[{"content":"Guard conditions in when in Kotlin 2.1.0 One of the new features in Kotlin 2.1.0 is the guard conditions on when expressions, this feature will bring some advantages like:\n Reduce nesting Avoid boilerplate Improve readability  Enable the feature This feature is in preview state, for this you need to enable it starting on Kotlin 2.1.0. In the file build.gradle.kts we should add the new piece of code inside the kotlin block:\n1 2 3 4 5  kotlin { compilerOptions { freeCompilerArgs.add(\u0026#34;-Xwhen-guards\u0026#34;) } }   Use guard conditions on when expression branches For this example we will use a sealed interface to handle the responses from a remote service:\n1 2 3 4 5  sealed interface Response\u0026lt;out T\u0026gt; { data object Loading : Response\u0026lt;Nothing\u0026gt; data class Content \u0026lt;out T\u0026gt; (val data: T?) : Response\u0026lt;T\u0026gt; data class Error(val error: Exception) : Response\u0026lt;Nothing\u0026gt; }   Loading, Content and Error implement the Response interface to manage the different states of the response.\nBefore new feature 1 2 3 4 5 6 7 8 9 10 11 12 13  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handleOld() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content -\u0026gt; if (data != null) { println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } is Response.Error -\u0026gt; if (error is IllegalStateException) { println(\u0026#34;Handled error\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } }   Here you can see how the code to print the Unknown error needs to be in both branches, also it adds nested complexity that reduces the code readability.\nUsing new Guard conditions You must add if statement after the primary condition inside the when branch, see below:\n1 2 3 4 5 6  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled error\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   This way the print statement with the text Unkwon error is used just once, also we remove the nested complexity.\nIf we need to check different conditions on the else branch, we can use an else if in case our response doesn\u0026rsquo;t satisfy the previous conditions.\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) else if this is Response.Error \u0026amp;\u0026amp; this.error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   This example can be simplified using to branches with the same primary condition is Response.Error, in my opinion keeps the code more readable and simple:\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) is Response.Error if error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   Conclusion With this new feature we can add new conditions without repeating code and will allow more concise when expressions. It\u0026rsquo;s in preview state starting from Kotlin 2.1.0 but seems like it will become stable soon.\nHere is the link to the documentation where you can find what\u0026rsquo;s new in Kotlin 2.1.0 included the guard conditions in when expressions kotlinlang\n","description":"New feature since Kotlin 2.1.0, guard conditions in when expressions","id":0,"section":"posts","tags":["kotlin","android","kmp"],"title":"Guard conditions in `when` starting in Kotlin 2.1.0.","uri":"https://carrion.dev/en/posts/kotlin-guard-conditions-in-when/"},{"content":"Inject runtime parameters with Dagger-Hilt Since Hilt appeared to make it easier the dependency injection in Android, it was impossible to inject runtime parameters without using third party libraries. Since Dagger version 2.31, exists the @AssistedInject annotation. With this annotation we can instruct Dagger-Hilt what dependencies need to be created at runtime and delay the injection of this parameters until we can provide those values.\nThis is necessary to inject parameters into ViewModel constructor and be able to execute some code in the init function. It can be an external API call or some query to our local database.\nIn this post we will learn how to use @AssistedInject from Dagger to inject runtime parameters to ViewModels with Hilt.\nInstallation In the root project build.gradle file, we will include the Hilt classpath:\n1  classpath \u0026#39;com.google.dagger:hilt-android-gradle-plugin:2.31.2-alpha\u0026#39;   Once we have Hilt classpath we will add Hilt plugin to build.gradle file from app module.\n1  apply plugin: \u0026#39;dagger.hilt.android.plugin\u0026#39;   And the next lines to our dependencies block:\n1 2  implementation \u0026#39;com.google.dagger:hilt-android:2.31.2-alpha\u0026#39; kapt \u0026#39;com.google.dagger:hilt-android-compiler:2.31.2-alpha\u0026#39;    We should keep in mind that we need kapt plugin on our build.gradle. For this we will add this line with the rest of plugins in our build.gradle from app module:\n 1  apply plugin: \u0026#39;kotlin-kapt\u0026#39;   Those were the needed dependencies to make Hilt work in our project. In this post we will use libraries that are not defined here.\nIn this link you can see the complete build.gradle file: app/build.gradle\nImplementation For this example we will be using a repository class with a function which receives a name and returns a welcome message. To acomplish this we will create the interface below:\n1 2 3  interface UserRepository { fun getMessage(name: String): String }   And it\u0026rsquo;s implementation:\n1 2 3 4 5  class UserRepositoryImpl @Inject constructor() : UserRepository { override fun getMessage(name: String): String { return \u0026#34;Hi $name\u0026#34; } }   We should annotate the constructor with @Inject so we can declare a @Binds annotation in the Hilt module to be able to inject the implementation when we call an interface of type UserRepository.\nNext we will create our ViewModel, this class will receive the user name from the Activity or Fragment and call the repository to get the welcome message:\n1 2 3 4 5 6 7 8 9  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { ... }   In this ViewModel we can see how we should annotate the constructor with @AssistedInject so Dagger-Hilt knows this class has dependencies that will be injected at runtime. This runtime dependencies will be annotated with @Assisted.\nTo be able to create our ViewModel with the extension by viewModels() from AndroidX library, we should create the Factory class wich will be provided to the extension:\n1 2 3 4 5 6 7 8  class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } }   You can see we need an interface called UserViewModelAssistedFactory. This interface will handle the runtime parameters injected to the ViewModel:\n1 2 3 4 5 6  @AssistedFactory interface UserViewModelAssistedFactory { fun create(name: String): UserViewModel }   It\u0026rsquo;s an interface with a create function. This function receive all the runtime parameters we want to inject in our ViewModel. In this example we only need a name parameter, but in case we need more parameters injected at runtime, they will be provided to this function.\nWith this we are able to complete our ViewModel with the logic to get the answer from the repository and expose it to the Fragment or Activity through a StateFlow.\nThe complete ViewModel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } } private val _message: MutableStateFlow\u0026lt;String\u0026gt; = MutableStateFlow(\u0026#34;\u0026#34;) val message: StateFlow\u0026lt;String\u0026gt; get() = _message init { viewModelScope.launch(dispatcher) { _message.emit(repository.getMessage(name)) } } }   Related to Hilt we only have to create the module to handle the creation of dependencies. For this example we will be using this module:\n1 2 3 4 5 6 7 8 9 10 11 12 13  @Module @InstallIn(ActivityComponent::class) abstract class MainModule { companion object { @Provides @Named(\u0026#34;UserDispatcher\u0026#34;) fun provideUserDispatcher(): CoroutineDispatcher = Dispatchers.IO } @Binds abstract fun provideUserRepository(repositoryImpl: UserRepositoryImpl): UserRepository }   In this module we declare a function to provide a Dispatcher so it will be easier to test this ViewModel in a future. We declare a @Binds function so when we inject a UserRepository interface Hilt provides its implementation UserRepositoryImpl.\nNow we can user our ViewModel in Activities or Fragments:\n1 2 3 4 5 6 7 8  private val navArgs: UserFragmentArgs by navArgs() @Inject lateinit var assistedFactory: UserViewModelAssistedFactory private val userViewModel: UserViewModel by viewModels { UserViewModel.Factory(assistedFactory, navArgs.name) }   We need to @Inject the AssistedFactory and use the UserViewModel.Factory to create our ViewModel.\nFrom this step we only need to observe changes in the ViewModel StateFlow to be able to update our UI. This can be done in Fragments observing from the onViewCreated.\n1 2 3 4 5 6 7 8  override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycleScope.launchWhenStarted { userViewModel.message.collect { binding.name.text = it } } }    Remember you need a class extending Application annotated with @HiltAndroidApp and each Activity or Fragment that uses injection with Hilt need to be annotated with @AndroidEntryPoint.\n Conclusion Now we can inject Runtime values with Dagger @AssistedInject in a simple way and we can keep using navArgs from AndroidX.\nYou can see the complete example in this repository: HiltAssistedInject\n","description":"Inject parameters to ViewModels at Runtime in Android.","id":1,"section":"posts","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Hilt: Inject Runtime parameters to ViewModels.","uri":"https://carrion.dev/en/posts/hilt-inject-parameters-runtime/"},{"content":"Welcome to Carrion.dev Hi droid!\nWelcome to my new Kotlin and Android programming blog. I am Ignacio Carrión and I\u0026rsquo;m an Android developer. I love Kotlin because it boost my Android development eficiency and because it has infinite posibilities outside of Android ecosystem (backend, web, native, multiplatform\u0026hellip;).\nIn this blog I hope I can publish interesting topics about Kotlin and Android at least twice a month. If you want to keep up to date you can subscribe to our newsletter.\nIf you have any question, idea about some topic for the blog or you just want to contact with me, I\u0026rsquo;m available through my email: ignacio@carrion.dev.\nI hope we can learn together!!\n","description":"First post in my new Kotlin and Android development blog","id":2,"section":"posts","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Welcome to my new Kotlin and Android development blog","uri":"https://carrion.dev/en/posts/welcome-to-my-new-kotlin-and-android-development-blog/"},{"content":"About. I\u0026rsquo;m Ignacio Carrión, I live in Valencia (Spain) and the one who appears on the avatar is my dog Wilfred. I like anything related to IT and videogames. At the moment I\u0026rsquo;m working as Android Engineer for Tkww. Before that I worked as Android Developer for other companies and I worked as a programming teacher. While I was working as a teacher, I realized that I love learning and helping others to learn with me. From this motivation arises the idea of this blog, Carrion.dev.\nI hope I can publish something interesting about Kotlin or Android ecosystem at least twice a month. Constructive criticism or ideas about posts will be welcomed. Below you can see the links to my social networks where you can find and contact me.\nContact Portfolio\nGithub\n","description":"Hugo, the world’s fastest framework for building websites","id":6,"section":"","tags":null,"title":"About","uri":"https://carrion.dev/en/about/"}]