[{"content":"Inject runtime parameters with Dagger-Hilt Since Hilt appeared to make it easier the dependency injection in Android, it was impossible to inject runtime parameters without using third party libraries. Since Dagger version 2.31, exists the @AssistedInject annotation. With this annotation we can instruct Dagger-Hilt what dependencies need to be created at runtime and delay the injection of this parameters until we can provide those values.\nThis is necessary to inject parameters into ViewModel constructor and be able to execute some code in the init function. It can be an external API call or some query to our local database.\nIn this post we will learn how to use @AssistedInject from Dagger to inject runtime parameters to ViewModels with Hilt.\nInstallation In the root project build.gradle file, we will include the Hilt classpath:\n1  classpath \u0026#39;com.google.dagger:hilt-android-gradle-plugin:2.31.2-alpha\u0026#39;   Once we have Hilt classpath we will add Hilt plugin to build.gradle file from app module.\n1  apply plugin: \u0026#39;dagger.hilt.android.plugin\u0026#39;   And the next lines to our dependencies block:\n1 2  implementation \u0026#39;com.google.dagger:hilt-android:2.31.2-alpha\u0026#39; kapt \u0026#39;com.google.dagger:hilt-android-compiler:2.31.2-alpha\u0026#39;    We should keep in mind that we need kapt plugin on our build.gradle. For this we will add this line with the rest of plugins in our build.gradle from app module:\n 1  apply plugin: \u0026#39;kotlin-kapt\u0026#39;   Those were the needed dependencies to make Hilt work in our project. In this post we will use libraries that are not defined here.\nIn this link you can see the complete build.gradle file: app/build.gradle\nImplementation For this example we will be using a repository class with a function which receives a name and returns a welcome message. To acomplish this we will create the interface below:\n1 2 3  interface UserRepository { fun getMessage(name: String): String }   And it\u0026rsquo;s implementation:\n1 2 3 4 5  class UserRepositoryImpl @Inject constructor() : UserRepository { override fun getMessage(name: String): String { return \u0026#34;Hi $name\u0026#34; } }   We should annotate the constructor with @Inject so we can declare a @Binds annotation in the Hilt module to be able to inject the implementation when we call an interface of type UserRepository.\nNext we will create our ViewModel, this class will receive the user name from the Activity or Fragment and call the repository to get the welcome message:\n1 2 3 4 5 6 7 8 9  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { ... }   In this ViewModel we can see how we should annotate the constructor with @AssistedInject so Dagger-Hilt knows this class has dependencies that will be injected at runtime. This runtime dependencies will be annotated with @Assisted.\nTo be able to create our ViewModel with the extension by viewModels() from AndroidX library, we should create the Factory class wich will be provided to the extension:\n1 2 3 4 5 6 7 8  class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } }   You can see we need an interface called UserViewModelAssistedFactory. This interface will handle the runtime parameters injected to the ViewModel:\n1 2 3 4 5 6  @AssistedFactory interface UserViewModelAssistedFactory { fun create(name: String): UserViewModel }   It\u0026rsquo;s an interface with a create function. This function receive all the runtime parameters we want to inject in our ViewModel. In this example we only need a name parameter, but in case we need more parameters injected at runtime, they will be provided to this function.\nWith this we are able to complete our ViewModel with the logic to get the answer from the repository and expose it to the Fragment or Activity through a StateFlow.\nThe complete ViewModel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } } private val _message: MutableStateFlow\u0026lt;String\u0026gt; = MutableStateFlow(\u0026#34;\u0026#34;) val message: StateFlow\u0026lt;String\u0026gt; get() = _message init { viewModelScope.launch(dispatcher) { _message.emit(repository.getMessage(name)) } } }   Related to Hilt we only have to create the module to handle the creation of dependencies. For this example we will be using this module:\n1 2 3 4 5 6 7 8 9 10 11 12 13  @Module @InstallIn(ActivityComponent::class) abstract class MainModule { companion object { @Provides @Named(\u0026#34;UserDispatcher\u0026#34;) fun provideUserDispatcher(): CoroutineDispatcher = Dispatchers.IO } @Binds abstract fun provideUserRepository(repositoryImpl: UserRepositoryImpl): UserRepository }   In this module we declare a function to provide a Dispatcher so it will be easier to test this ViewModel in a future. We declare a @Binds function so when we inject a UserRepository interface Hilt provides its implementation UserRepositoryImpl.\nNow we can user our ViewModel in Activities or Fragments:\n1 2 3 4 5 6 7 8  private val navArgs: UserFragmentArgs by navArgs() @Inject lateinit var assistedFactory: UserViewModelAssistedFactory private val userViewModel: UserViewModel by viewModels { UserViewModel.Factory(assistedFactory, navArgs.name) }   We need to @Inject the AssistedFactory and use the UserViewModel.Factory to create our ViewModel.\nFrom this step we only need to observe changes in the ViewModel StateFlow to be able to update our UI. This can be done in Fragments observing from the onViewCreated.\n1 2 3 4 5 6 7 8  override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycleScope.launchWhenStarted { userViewModel.message.collect { binding.name.text = it } } }    Remember you need a class extending Application annotated with @HiltAndroidApp and each Activity or Fragment that uses injection with Hilt need to be annotated with @AndroidEntryPoint.\n Conclusion Now we can inject Runtime values with Dagger @AssistedInject in a simple way and we can keep using navArgs from AndroidX.\nYou can see the complete example in this repository: HiltAssistedInject\n","description":"Inject parameters to ViewModels at Runtime in Android.","id":0,"section":"posts","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Hilt: Inject Runtime parameters to ViewModels.","uri":"https://carrion.dev/en/posts/hilt-inject-parameters-runtime/"},{"content":"Welcome to Carrion.dev Hi droid!\nWelcome to my new Kotlin and Android programming blog. I am Ignacio Carrión and I\u0026rsquo;m an Android developer. I love Kotlin because it boost my Android development eficiency and because it has infinite posibilities outside of Android ecosystem (backend, web, native, multiplatform\u0026hellip;).\nIn this blog I hope I can publish interesting topics about Kotlin and Android at least twice a month. If you want to keep up to date you can subscribe to our newsletter.\nIf you have any question, idea about some topic for the blog or you just want to contact with me, I\u0026rsquo;m available through my email: ignacio@carrion.dev.\nI hope we can learn together!!\n","description":"First post in my new Kotlin and Android development blog","id":1,"section":"posts","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Welcome to my new Kotlin and Android development blog","uri":"https://carrion.dev/en/posts/welcome-to-my-new-kotlin-and-android-development-blog/"},{"content":"About. I\u0026rsquo;m Ignacio Carrión, I live in Valencia (Spain) and the one who appears on the avatar is my dog Wilfred. I like anything related to IT and videogames. At the moment I\u0026rsquo;m working as Android Engineer for Tacter. Before that I worked as Android Developer for other companies and I worked as a programming teacher. While I was working as a teacher, I realized that I love learning and helping others to learn with me. From this motivation arrises the idea of this blog, Carrion.dev.\nI hope I can publish something interesting about Kotlin or Android ecosystem at least twice a month. Constructive criticism or ideas about posts will be welcomed. Below you can see the links to my social networks where you can find and contact me.\nContact Portfolio\nGithub\n","description":"Hugo, the world’s fastest framework for building websites","id":5,"section":"","tags":null,"title":"About","uri":"https://carrion.dev/en/about/"}]