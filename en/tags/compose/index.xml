<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>compose on Carrion.dev</title><link>https://carrion.dev/en/tags/compose/</link><description>Recent content in compose on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Thu, 30 Jan 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/en/tags/compose/index.xml" rel="self" type="application/rss+xml"/><item><title>Exploring Kotlin’s Immutable Collections Library</title><link>https://carrion.dev/en/posts/immutable_collections/</link><pubDate>Thu, 30 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 30 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/immutable_collections/</guid><description>Exploring Kotlin’s Immutable Collections Library Kotlin&amp;rsquo;s standard collections (List, Set, Map) are mutable by default, which can lead to unintended modifications. To enforce immutability at the API level, JetBrains introduced the Kotlin Immutable Collections library. This library provides a set of truly immutable collection types that prevent accidental modifications and enhance safety in concurrent or multi-threaded environments.
Why Use Immutable Collections? While Kotlin already has listOf(), setOf(), and mapOf() for read-only collections, they are not truly immutable.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/readonly-list.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>collections</category><category>compose</category></item><item><title>Using Koin in Compose Multiplatform</title><link>https://carrion.dev/en/posts/koin-cmp/</link><pubDate>Thu, 02 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 02 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/koin-cmp/</guid><description>Using Koin in Compose Multiplatform Dependency injection is a must-have for scalable applications, and Koin makes it straightforward, even in Compose Multiplatform projects. With the new KoinApplication composable function, you can initialize Koin directly from commonMain code, reducing boilerplate while maintaining platform-specific flexibility. Let’s walk through an example.
Project Setup Start by creating a Compose Multiplatform project using the KMP Wizard, selecting Android, iOS, Desktop, and Web targets. For this example, we won’t include a server target.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-cmp.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>multiplatform</category><category>cmp</category><category>compose</category><category>koin</category></item></channel></rss>