<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>compose on Carrion.dev</title><link>https://carrion.dev/en/tags/compose/</link><description>Recent content in compose on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Fri, 04 Apr 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/en/tags/compose/index.xml" rel="self" type="application/rss+xml"/><item><title>Custom Animations and Transitions in Jetpack Compose</title><link>https://carrion.dev/en/posts/custom-animations-transitions-compose/</link><pubDate>Fri, 04 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 04 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/custom-animations-transitions-compose/</guid><description>Custom Animations and Transitions in Jetpack Compose Creating smooth, meaningful animations is crucial for delivering a polished user experience. This article explores how to create custom animations and transitions in Jetpack Compose, from basic animations to complex custom implementations.
Creating Custom Animations Custom animations allow for more complex and unique visual effects:
Custom Animation Specs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Composable fun CustomAnimatedButton( onClick: () -&amp;gt; Unit, content: @Composable () -&amp;gt; Unit ) { var isPressed by remember { mutableStateOf(false) } val scope = rememberCoroutineScope() val scale by animateFloatAsState( targetValue = if (isPressed) 0.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/pulsating-dot.gif" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>animation</category><category>transitions</category></item><item><title>Advanced State Management in Compose: Effects and Flows</title><link>https://carrion.dev/en/posts/advanced-state-management-compose/</link><pubDate>Tue, 01 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 01 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/advanced-state-management-compose/</guid><description>Advanced State Management in Compose: Effects and Flows This article explores advanced state management patterns in Jetpack Compose, focusing on Effects and Flow integration. For fundamental concepts like mutableStateOf and state hoisting, check out our companion article Basic State Management in Jetpack Compose.
Understanding Compose Effects Effects in Compose are tools to handle side effects and lifecycle events in a composable-friendly way. Let&amp;rsquo;s explore the different types of effects and their use cases:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/state-management-compose-advanced.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>state</category><category>flows</category><category>effects</category></item><item><title>State Management Patterns in Jetpack Compose</title><link>https://carrion.dev/en/posts/state-management-patterns-compose/</link><pubDate>Fri, 28 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 28 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/state-management-patterns-compose/</guid><description>State Management Patterns in Jetpack Compose State management is a crucial aspect of building robust and maintainable Jetpack Compose applications. This article explores essential patterns and best practices for managing state effectively in your Compose UI, including immutable state, event-based updates, and testing strategies.
Understanding State Management Patterns Effective state management in Compose requires understanding how to structure and handle state changes in a way that&amp;rsquo;s maintainable, testable, and scalable. This involves several key patterns:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/state-management-compose.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>patterns</category><category>state</category></item><item><title>Kotlin Multiplatform Architecture Best Practices for Mobile Apps</title><link>https://carrion.dev/en/posts/kmp-architecture/</link><pubDate>Tue, 11 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 11 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kmp-architecture/</guid><description>Kotlin Multiplatform Architecture Best Practices for Mobile Apps Kotlin Multiplatform (KMP) allows developers to share business logic between Android and iOS while keeping platform-specific implementations where necessary. Structuring a KMP project efficiently is key to maintaining scalability, testability, and clean architecture. In this guide, we’ll explore best practices for architecting a KMP mobile application with Compose Multiplatform and Clean Architecture.
1. Project Structure A well-organized project structure improves maintainability and separation of concerns.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/expect-actual.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>compose</category><category>cmp</category><category>multiplatform</category><category>cleancode</category><category>architecture</category></item><item><title>Testing in Compose Multiplatform (CMP) from Common Code</title><link>https://carrion.dev/en/posts/cmp-ui-testing/</link><pubDate>Mon, 03 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 03 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/cmp-ui-testing/</guid><description>Testing in Compose Multiplatform (CMP) from Common Code Compose Multiplatform (CMP) enables building UI for multiple platforms using Jetpack Compose. Fortunately, CMP also supports writing and running UI tests in the common code, making testing more efficient across platforms. In this post, we’ll explore how to test CMP applications using compose.uiTest and run them on Android, Desktop, and iOS.
1. Setting Up Common UI Testing CMP provides compose.uiTest, allowing UI tests to be written in the shared module without platform-specific dependencies.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/compose-test.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>compose</category><category>cmp</category><category>multiplatform</category></item><item><title>Exploring Kotlin’s Immutable Collections Library</title><link>https://carrion.dev/en/posts/immutable-collections/</link><pubDate>Thu, 30 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 30 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/immutable-collections/</guid><description>Exploring Kotlin’s Immutable Collections Library Kotlin&amp;rsquo;s standard collections (List, Set, Map) are mutable by default, which can lead to unintended modifications. To enforce immutability at the API level, JetBrains introduced the Kotlin Immutable Collections library. This library provides a set of truly immutable collection types that prevent accidental modifications and enhance safety in concurrent or multi-threaded environments.
Why Use Immutable Collections? While Kotlin already has listOf(), setOf(), and mapOf() for read-only collections, they are not truly immutable.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/readonly-list.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>collections</category><category>compose</category></item><item><title>Using Koin in Compose Multiplatform</title><link>https://carrion.dev/en/posts/koin-cmp/</link><pubDate>Thu, 02 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 02 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/koin-cmp/</guid><description>Using Koin in Compose Multiplatform Dependency injection is a must-have for scalable applications, and Koin makes it straightforward, even in Compose Multiplatform projects. With the new KoinApplication composable function, you can initialize Koin directly from commonMain code, reducing boilerplate while maintaining platform-specific flexibility. Let’s walk through an example.
Project Setup Start by creating a Compose Multiplatform project using the KMP Wizard, selecting Android, iOS, Desktop, and Web targets. For this example, we won’t include a server target.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-cmp.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>multiplatform</category><category>cmp</category><category>compose</category><category>koin</category></item><item><title>Performance Optimization in Jetpack Compose</title><link>https://carrion.dev/en/posts/performance-optimization-compose/</link><pubDate>Mon, 08 Apr 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 08 Apr 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/performance-optimization-compose/</guid><description>Performance Optimization in Jetpack Compose Performance optimization is crucial for delivering a smooth user experience in Jetpack Compose applications. This article explores key techniques and best practices to ensure your composable functions are efficient and performant.
Understanding Composition and Recomposition One of the fundamental aspects of performance in Compose is understanding how composition and recomposition work:
Smart Recomposition Compose uses smart recomposition to update only the parts of the UI that need to change.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/remember-optimization.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>performance</category><category>optimization</category></item></channel></rss>