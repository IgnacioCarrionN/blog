<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>design-patterns on Carrion.dev</title><link>https://carrion.dev/en/tags/design-patterns/</link><description>Recent content in design-patterns on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Tue, 25 Mar 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/en/tags/design-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Building Type-safe DSLs with Kotlin: From Basics to Advanced Patterns</title><link>https://carrion.dev/en/posts/building-type-safe-dsls/</link><pubDate>Tue, 25 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 25 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/building-type-safe-dsls/</guid><description>Building Type-safe DSLs with Kotlin: From Basics to Advanced Patterns Domain-Specific Languages (DSLs) in Kotlin allow you to create expressive, readable, and type-safe APIs. This article explores how to build effective DSLs using Kotlin&amp;rsquo;s powerful features, focusing on scope control with @DslMarker to prevent common mistakes in nested DSLs.
By the end of this article, you&amp;rsquo;ll understand:
How to design clean and intuitive DSL APIs When and how to use @DslMarker for better scope control Best practices for maintaining type safety throughout your DSL Common pitfalls and how to avoid them Basic DSL Concepts Let&amp;rsquo;s explore the fundamental concepts of Kotlin DSLs by building a simple HTML builder:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/type-safe-dsls.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>dsl</category><category>type-safety</category><category>design-patterns</category></item><item><title>Kotlin Design Patterns - Part 3</title><link>https://carrion.dev/en/posts/design-patterns-3/</link><pubDate>Mon, 13 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 13 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/design-patterns-3/</guid><description>Exploring More Design Patterns in Kotlin: Part 3 Design Patterns Series Part 1 Part 2 Part 3 In this third installment, we’ll cover Memento, Command, Visitor, Chain of Responsibility, and Mediator patterns. These patterns address construction, behavioral, and structural challenges, showcasing Kotlin&amp;rsquo;s expressive syntax and modern features.
1. Memento Pattern The Memento Pattern captures and restores an object&amp;rsquo;s state without exposing its internal details.
When to Use To implement undo/redo functionality.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/memento-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item><item><title>Kotlin Design Patterns - Part 2</title><link>https://carrion.dev/en/posts/design-patterns-2/</link><pubDate>Mon, 06 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 06 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/design-patterns-2/</guid><description>Exploring Design Patterns in Kotlin: Part 2 Design Patterns Series Part 1 Part 2 Part 3 After the overwhelming response to our first post on Kotlin design patterns, we’re back with more! In this second part, we’ll dive into Prototype, Composite, Proxy, Observer, and Strategy patterns. These patterns solve a variety of design challenges and demonstrate Kotlin’s expressive capabilities.
1. Prototype Pattern The Prototype Pattern is used to create new objects by copying an existing object, ensuring efficient object creation.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/proxy-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item><item><title>Kotlin Design Patterns - Part 1</title><link>https://carrion.dev/en/posts/design-patterns-1/</link><pubDate>Mon, 30 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 30 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/design-patterns-1/</guid><description>Exploring Design Patterns in Kotlin - Part 1 Design Patterns Series Part 1 Part 2 Part 3 Design patterns are proven solutions to common problems in software design. With Kotlin’s expressive syntax and modern features, implementing these patterns often becomes cleaner and more concise. In this post, we’ll explore Singleton, Factory Method, Builder, Adapter and Decorator patterns, delving into their purpose, use cases, and Kotlin implementations.
1. Singleton Pattern The Singleton Pattern ensures that a class has only one instance and provides a global access point to it.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/singleton-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item></channel></rss>