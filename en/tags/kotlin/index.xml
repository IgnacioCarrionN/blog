<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>kotlin on Carrion.dev</title><link>https://carrion.dev/en/tags/kotlin/</link><description>Recent content in kotlin on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Tue, 04 Mar 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/en/tags/kotlin/index.xml" rel="self" type="application/rss+xml"/><item><title>Achieving Compile-Time Safety in Koin: A Comprehensive Guide</title><link>https://carrion.dev/en/posts/koin-compile-safety/</link><pubDate>Tue, 04 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 04 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/koin-compile-safety/</guid><description>Achieving Compile-Time Safety in Koin: A Comprehensive Guide Dependency injection is a fundamental pattern in modern Android development, but how can we ensure our DI configuration is correct before running the app? In this post, we&amp;rsquo;ll explore two powerful approaches to achieve compile-time safety with Koin: using the DSL&amp;rsquo;s verify() function and leveraging Koin Annotations with KSP.
The Problem: Runtime vs. Compile-Time Validation Traditional dependency injection often reveals configuration issues only at runtime:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-ksp-config.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>koin</category></item><item><title>Reliable Timekeeping with the TrustedTime API in Android</title><link>https://carrion.dev/en/posts/trusted-time-api/</link><pubDate>Wed, 19 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 19 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/trusted-time-api/</guid><description>Reliable Timekeeping with the TrustedTime API in Android Accurate timekeeping is crucial for many app functionalities, including scheduling, transaction logging, and security. However, relying on a device&amp;rsquo;s system clock can be problematic since users can alter their device’s time settings. To address this, Google has introduced the TrustedTime API, providing a reliable and tamper-resistant time source for Android apps.
Understanding the TrustedTime API The TrustedTime API leverages Google&amp;rsquo;s secure infrastructure to offer a trustworthy timestamp, independent of the device&amp;rsquo;s local time settings.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/trusted-time-api.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>google</category></item><item><title>Kotlin Multiplatform Architecture Best Practices for Mobile Apps</title><link>https://carrion.dev/en/posts/kmp-architecture/</link><pubDate>Tue, 11 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 11 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kmp-architecture/</guid><description>Kotlin Multiplatform Architecture Best Practices for Mobile Apps Kotlin Multiplatform (KMP) allows developers to share business logic between Android and iOS while keeping platform-specific implementations where necessary. Structuring a KMP project efficiently is key to maintaining scalability, testability, and clean architecture. In this guide, we’ll explore best practices for architecting a KMP mobile application with Compose Multiplatform and Clean Architecture.
1. Project Structure A well-organized project structure improves maintainability and separation of concerns.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/expect-actual.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>compose</category><category>cmp</category><category>multiplatform</category><category>cleancode</category><category>architecture</category></item><item><title>Mocks, Fakes, and More</title><link>https://carrion.dev/en/posts/test-doubles/</link><pubDate>Thu, 06 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 06 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/test-doubles/</guid><description>Mocks, Fakes, and More: Understanding Test Doubles in Kotlin When writing tests in Kotlin, especially for Android development, we often need to replace real dependencies with test doubles. However, not all test doubles are the same—terms like mocks, fakes, stubs, spies, and dummies often come up. In this post, we’ll break down their differences with Kotlin examples using only plain Kotlin (no third-party libraries).
1. Understanding Test Doubles Test doubles are objects that stand in for real dependencies in tests.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/mock.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>testing</category><category>mock</category><category>tdd</category></item><item><title>Testing in Compose Multiplatform (CMP) from Common Code</title><link>https://carrion.dev/en/posts/cmp-ui-testing/</link><pubDate>Mon, 03 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 03 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/cmp-ui-testing/</guid><description>Testing in Compose Multiplatform (CMP) from Common Code Compose Multiplatform (CMP) enables building UI for multiple platforms using Jetpack Compose. Fortunately, CMP also supports writing and running UI tests in the common code, making testing more efficient across platforms. In this post, we’ll explore how to test CMP applications using compose.uiTest and run them on Android, Desktop, and iOS.
1. Setting Up Common UI Testing CMP provides compose.uiTest, allowing UI tests to be written in the shared module without platform-specific dependencies.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/compose-test.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>compose</category><category>cmp</category><category>multiplatform</category></item><item><title>Exploring Kotlin’s Immutable Collections Library</title><link>https://carrion.dev/en/posts/immutable-collections/</link><pubDate>Thu, 30 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 30 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/immutable-collections/</guid><description>Exploring Kotlin’s Immutable Collections Library Kotlin&amp;rsquo;s standard collections (List, Set, Map) are mutable by default, which can lead to unintended modifications. To enforce immutability at the API level, JetBrains introduced the Kotlin Immutable Collections library. This library provides a set of truly immutable collection types that prevent accidental modifications and enhance safety in concurrent or multi-threaded environments.
Why Use Immutable Collections? While Kotlin already has listOf(), setOf(), and mapOf() for read-only collections, they are not truly immutable.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/readonly-list.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>collections</category><category>compose</category></item><item><title>Boosting Android App Performance with Baseline Profiles</title><link>https://carrion.dev/en/posts/baseline-profiles/</link><pubDate>Mon, 27 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 27 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/baseline-profiles/</guid><description>Boosting Android App Performance with Baseline Profiles Introduction In today’s fast-paced mobile world, users expect apps to launch instantly and run smoothly. Performance optimization is crucial, especially concerning app startup time and runtime execution.
Android’s Baseline Profiles offer an effective way to speed up app startup and improve runtime performance by precompiling critical code paths. Google Play even recommends using Baseline Profiles to enhance the user experience, particularly for apps with complex UI rendering or heavy dependencies.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/baseline-profile.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Modularization in Gradle Projects with Kotlin</title><link>https://carrion.dev/en/posts/gradle-modularization/</link><pubDate>Thu, 23 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 23 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/gradle-modularization/</guid><description>Modularization in Gradle Projects with Kotlin: A Comprehensive Guide Introduction As projects grow in complexity, maintaining a monolithic codebase becomes challenging. Modularization is a software design technique that breaks down an application into smaller, independent modules, making the project more scalable, maintainable, and efficient.
In this guide, we’ll explore why modularization is essential, different types of modules, and best practices for setting up a modular Gradle project using Kotlin.
Why Modularization?</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/folder-structure.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Test-Driven Development (TDD) in Kotlin for Android</title><link>https://carrion.dev/en/posts/tdd-kotlin/</link><pubDate>Mon, 20 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 20 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/tdd-kotlin/</guid><description>Test-Driven Development (TDD) in Kotlin for Android Test-Driven Development (TDD) is a software development practice that emphasizes writing tests before implementing functionality. It follows a Red-Green-Refactor cycle: first, you write a failing test (Red), then implement just enough code to make it pass (Green), and finally, refactor the code while keeping the test green (Refactor). In this post, we&amp;rsquo;ll explore how to apply TDD in Kotlin for Android development using JUnit, MockK, and Coroutines with a real-world example.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/tdd-cycle.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category><category>TDD</category><category>testing</category></item><item><title>Clean Architecture in Kotlin &amp; Android</title><link>https://carrion.dev/en/posts/clean-architecture/</link><pubDate>Sat, 18 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Sat, 18 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/clean-architecture/</guid><description>Clean Architecture in Kotlin &amp;amp; Android Introduction When building Android applications, maintaining scalability and readability is crucial. Without a clear architectural approach, projects can become difficult to maintain as they grow. This is where Clean Architecture, introduced by Uncle Bob (Robert C. Martin), becomes invaluable. It emphasizes separation of concerns, making code more modular, testable, and maintainable.
Understanding Clean Architecture Clean Architecture is structured into three main layers, each with a specific role:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/domain-layer.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Exploring App Architectures in Kotlin</title><link>https://carrion.dev/en/posts/app-architecture/</link><pubDate>Wed, 15 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 15 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/app-architecture/</guid><description>Exploring App Architectures in Kotlin: MVC, MVP, MVVM, and MVI Introduction In modern app development, choosing the right architecture is essential for creating maintainable and scalable applications. Architectures define how your codebase is organized and how different components interact. In this post, we’ll explore four popular app architectures: Model-View-Controller (MVC), Model-View-Presenter (MVP), Model-View-ViewModel (MVVM), and Model-View-Intent (MVI). We’ll look at their structure, pros, cons, and practical examples in Kotlin.
1. Model-View-Controller (MVC) Definition:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/mvvm.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Kotlin Design Patterns - Part 3</title><link>https://carrion.dev/en/posts/design-patterns-3/</link><pubDate>Mon, 13 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 13 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/design-patterns-3/</guid><description>Exploring More Design Patterns in Kotlin: Part 3 Design Patterns Series Part 1 Part 2 Part 3 In this third installment, we’ll cover Memento, Command, Visitor, Chain of Responsibility, and Mediator patterns. These patterns address construction, behavioral, and structural challenges, showcasing Kotlin&amp;rsquo;s expressive syntax and modern features.
1. Memento Pattern The Memento Pattern captures and restores an object&amp;rsquo;s state without exposing its internal details.
When to Use To implement undo/redo functionality.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/memento-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item><item><title>Understanding SOLID Principles with Kotlin Examples</title><link>https://carrion.dev/en/posts/solid-kotlin/</link><pubDate>Wed, 08 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 08 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/solid-kotlin/</guid><description>Understanding SOLID Principles with Kotlin Examples The SOLID principles are a set of design principles that make software designs more understandable, flexible, and maintainable. Introduced by Robert C. Martin, these principles are a cornerstone of object-oriented programming and are especially relevant when building complex systems. In this blog post, we’ll explore each principle with examples written in Kotlin, a language that brings modern syntax and powerful features to the table.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/di-fix.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>solid</category><category>architecture</category></item><item><title>Kotlin Design Patterns - Part 2</title><link>https://carrion.dev/en/posts/design-patterns-2/</link><pubDate>Mon, 06 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 06 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/design-patterns-2/</guid><description>Exploring Design Patterns in Kotlin: Part 2 Design Patterns Series Part 1 Part 2 Part 3 After the overwhelming response to our first post on Kotlin design patterns, we’re back with more! In this second part, we’ll dive into Prototype, Composite, Proxy, Observer, and Strategy patterns. These patterns solve a variety of design challenges and demonstrate Kotlin’s expressive capabilities.
1. Prototype Pattern The Prototype Pattern is used to create new objects by copying an existing object, ensuring efficient object creation.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/proxy-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item><item><title>Using Koin in Compose Multiplatform</title><link>https://carrion.dev/en/posts/koin-cmp/</link><pubDate>Thu, 02 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 02 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/koin-cmp/</guid><description>Using Koin in Compose Multiplatform Dependency injection is a must-have for scalable applications, and Koin makes it straightforward, even in Compose Multiplatform projects. With the new KoinApplication composable function, you can initialize Koin directly from commonMain code, reducing boilerplate while maintaining platform-specific flexibility. Let’s walk through an example.
Project Setup Start by creating a Compose Multiplatform project using the KMP Wizard, selecting Android, iOS, Desktop, and Web targets. For this example, we won’t include a server target.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-cmp.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>multiplatform</category><category>cmp</category><category>compose</category><category>koin</category></item><item><title>Kotlin Design Patterns - Part 1</title><link>https://carrion.dev/en/posts/design-patterns-1/</link><pubDate>Mon, 30 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 30 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/design-patterns-1/</guid><description>Exploring Design Patterns in Kotlin - Part 1 Design Patterns Series Part 1 Part 2 Part 3 Design patterns are proven solutions to common problems in software design. With Kotlin’s expressive syntax and modern features, implementing these patterns often becomes cleaner and more concise. In this post, we’ll explore Singleton, Factory Method, Builder, Adapter and Decorator patterns, delving into their purpose, use cases, and Kotlin implementations.
1. Singleton Pattern The Singleton Pattern ensures that a class has only one instance and provides a global access point to it.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/singleton-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item><item><title>A deep dive into Kotlin KSP</title><link>https://carrion.dev/en/posts/kotlin-ksp/</link><pubDate>Fri, 27 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 27 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-ksp/</guid><description>A Deep Dive into Kotlin Symbol Processing (KSP) with Practical Examples Kotlin Symbol Processing (KSP) is a powerful tool introduced to streamline annotation processing in Kotlin. Compared to kapt (Kotlin Annotation Processing Tool), KSP is faster, offers better integration with Kotlin, and reduces build times significantly. In this post, we’ll explore the fundamentals of KSP, discuss how it works, and demonstrate its use with popular libraries like Koin and Room.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-annotations.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Kotlin Infix functions</title><link>https://carrion.dev/en/posts/kotlin-infix/</link><pubDate>Thu, 26 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 26 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-infix/</guid><description>Exploring Kotlin Infix Functions: A Deep Dive Kotlin, as a modern programming language, is packed with features that make code expressive and concise. One of these features is infix functions, which allow you to write cleaner and more readable code. In this blog post, we&amp;rsquo;ll explore what infix functions are, how to use them, and some practical use cases.
What Are Infix Functions? Infix functions in Kotlin are a special kind of function that can be called without using parentheses or the dot operator.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-infix.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Kotlin Delegates</title><link>https://carrion.dev/en/posts/kotlin-delegates/</link><pubDate>Mon, 23 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 23 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-delegates/</guid><description>✨ Understanding Kotlin Delegates: The Magic Behind Cleaner Code ✨ Kotlin delegates are a powerful feature that lets you delegate the behavior of a property or even an interface implementation to another object. Instead of writing repetitive logic or managing state directly, you can delegate this responsibility to reusable and specialized classes.
How Delegates Work Delegates in Kotlin work by using the by keyword, which redirects the behavior of a property or an interface to a delegate object.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-delegate.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Kotlin contracts</title><link>https://carrion.dev/en/posts/kotlin-contracts/</link><pubDate>Fri, 20 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 20 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-contracts/</guid><description>Mastering Kotlin Contracts: Unlocking Smarter Code Analysis Kotlin never ceases to amaze with its features that combine elegance and power. One advanced yet often underutilized tool in Kotlin&amp;rsquo;s arsenal is Contracts. Contracts let you guide the Kotlin compiler to make smarter decisions about your code—resulting in better null safety, optimized performance, and fewer runtime errors.
What Are Kotlin Contracts? Kotlin Contracts allow you to define rules about how your functions behave, helping the compiler perform advanced static analysis.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/kotlin-contract.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Swift export in KMP</title><link>https://carrion.dev/en/posts/swift-export/</link><pubDate>Wed, 18 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 18 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/swift-export/</guid><description>Swift export in Kmp Starting from version 2.1.0 we can start testing the Swift export in Kotlin. This feature allows you to export the Kotlin shared modules to Swift without the use of Objective-C. This will improve the iOS developers experience when using KMP modules.
At the moment basic support includes:
Export multiple Gradle modules to Swift. Define the Swift module names. Flatten package structure Enable the feature To start testing this functionality you should enable it on gradle.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/swift-export.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>kmp</category></item><item><title>Guard conditions in when starting in Kotlin 2.1.0.</title><link>https://carrion.dev/en/posts/kotlin-guard-conditions-in-when/</link><pubDate>Tue, 17 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 17 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-guard-conditions-in-when/</guid><description>Guard conditions in when in Kotlin 2.1.0 One of the new features in Kotlin 2.1.0 is the guard conditions on when expressions, this feature will bring some advantages like:
Reduce nesting Avoid boilerplate Improve readability Enable the feature This feature is in preview state, for this you need to enable it starting on Kotlin 2.1.0. In the file build.gradle.kts we should add the new piece of code inside the kotlin block:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/guard-when-new.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>kmp</category></item><item><title>Hilt: Inject Runtime parameters to ViewModels.</title><link>https://carrion.dev/en/posts/hilt-inject-parameters-runtime/</link><pubDate>Wed, 24 Feb 2021 07:00:06 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 24 Feb 2021 07:00:06 +0100</atom:modified><guid>https://carrion.dev/en/posts/hilt-inject-parameters-runtime/</guid><description>Inject runtime parameters with Dagger-Hilt Since Hilt appeared to make it easier the dependency injection in Android, it was impossible to inject runtime parameters without using third party libraries. Since Dagger version 2.31, exists the @AssistedInject annotation. With this annotation we can instruct Dagger-Hilt what dependencies need to be created at runtime and delay the injection of this parameters until we can provide those values.
This is necessary to inject parameters into ViewModel constructor and be able to execute some code in the init function.</description><dc:creator>Ignacio</dc:creator><media:content url="https://carrion.dev/images/kotlin/kotlin-logo.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>jetpack</category><category>coroutines</category><category>androidx</category></item><item><title>Welcome to my new Kotlin and Android development blog</title><link>https://carrion.dev/en/posts/welcome-to-my-new-kotlin-and-android-development-blog/</link><pubDate>Tue, 23 Feb 2021 10:00:06 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 23 Feb 2021 10:00:06 +0100</atom:modified><guid>https://carrion.dev/en/posts/welcome-to-my-new-kotlin-and-android-development-blog/</guid><description>Welcome to Carrion.dev Hi droid!
Welcome to my new Kotlin and Android programming blog. I am Ignacio Carrión and I&amp;rsquo;m an Android developer. I love Kotlin because it boost my Android development eficiency and because it has infinite posibilities outside of Android ecosystem (backend, web, native, multiplatform&amp;hellip;).
In this blog I hope I can publish interesting topics about Kotlin and Android at least twice a month. If you want to keep up to date you can subscribe to our newsletter.</description><dc:creator>Ignacio</dc:creator><category>kotlin</category><category>android</category><category>jetpack</category><category>coroutines</category><category>androidx</category></item></channel></rss>