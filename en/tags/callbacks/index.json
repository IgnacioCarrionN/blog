[{"content":"Leveraging expect/actual in Kotlin Multiplatform for Native Implementations Kotlin Multiplatform (KMP) has emerged as a powerful solution for sharing code across different platforms while still allowing for platform-specific implementations when needed. At the heart of this capability is the expect/actual mechanism, which enables developers to define a common API in shared code and provide platform-specific implementations. This blog post explores how to effectively use expect/actual to create robust multiplatform applications with native implementations.\nUnderstanding expect/actual in Kotlin Multiplatform The expect/actual mechanism is Kotlin\u0026rsquo;s approach to handling platform-specific code in a multiplatform project. It consists of two key components:\n expect declarations: Define what functionality is required in the common code actual implementations: Provide platform-specific implementations of that functionality  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // In common code expect class PlatformDateFormatter() { fun format(date: Long): String } // In Android-specific code actual class PlatformDateFormatter { actual fun format(date: Long): String { val dateFormat = SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;, Locale.getDefault()) return dateFormat.format(Date(date)) } } // In iOS-specific code actual class PlatformDateFormatter { actual fun format(date: Long): String { val dateFormatter = NSDateFormatter() dateFormatter.dateFormat = \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34; return dateFormatter.stringFromDate(NSDate(timeIntervalSince1970 = date / 1000.0)) } }   The expect declaration serves as a contract that must be fulfilled by each platform-specific implementation. This ensures that the common code can rely on certain functionality being available, regardless of the platform.\nAdvantages of Using expect/actual in KMP The expect/actual mechanism offers several significant benefits for multiplatform development:\n  Code Sharing with Platform-Specific Optimizations\n Share business logic, models, and algorithms across platforms Implement platform-specific optimizations where needed Leverage platform-native APIs for better performance and user experience    Type Safety Across Platforms\n The compiler ensures that all expected declarations have corresponding actual implementations Type checking works across platform boundaries Refactoring is safer as changes to expect declarations must be reflected in all actual implementations    Better Developer Experience\n Clear separation between shared interfaces and platform-specific implementations IDE support for navigating between expect and actual declarations Easier maintenance as the common API is defined in one place    Gradual Adoption Path\n Start with platform-specific code and gradually move to shared implementations Selectively choose which components to share and which to keep platform-specific Integrate with existing codebases without complete rewrites    Practical Examples of expect/actual in Action Let\u0026rsquo;s explore some practical examples of how expect/actual can be used in real-world applications.\nExample 1: Platform-Specific Storage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // In commonMain expect class LocalStorage { fun saveString(key: String, value: String) fun getString(key: String): String? fun clear() } // In androidMain actual class LocalStorage { private val sharedPreferences = context.getSharedPreferences(\u0026#34;app_prefs\u0026#34;, Context.MODE_PRIVATE) actual fun saveString(key: String, value: String) { sharedPreferences.edit().putString(key, value).apply() } actual fun getString(key: String): String? { return sharedPreferences.getString(key, null) } actual fun clear() { sharedPreferences.edit().clear().apply() } } // In iosMain actual class LocalStorage { private val userDefaults = NSUserDefaults.standardUserDefaults actual fun saveString(key: String, value: String) { userDefaults.setObject(value, key) } actual fun getString(key: String): String? { return userDefaults.stringForKey(key) } actual fun clear() { userDefaults.dictionaryRepresentation().keys.forEach { userDefaults.removeObjectForKey(it) } } }   This example demonstrates how to create a common storage interface while leveraging platform-specific storage mechanisms (SharedPreferences on Android and NSUserDefaults on iOS).\nExample 2: Network Connectivity Monitoring 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  // In commonMain expect class NetworkMonitor() { fun startMonitoring(onConnectivityChange: (Boolean) -\u0026gt; Unit) fun stopMonitoring() } // In androidMain actual class NetworkMonitor { private var connectivityManager: ConnectivityManager? = null private var networkCallback: ConnectivityManager.NetworkCallback? = null actual fun startMonitoring(onConnectivityChange: (Boolean) -\u0026gt; Unit) { connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager networkCallback = object : ConnectivityManager.NetworkCallback() { override fun onAvailable(network: Network) { onConnectivityChange(true) } override fun onLost(network: Network) { onConnectivityChange(false) } } val networkRequest = NetworkRequest.Builder().build() connectivityManager?.registerNetworkCallback(networkRequest, networkCallback!!) } actual fun stopMonitoring() { networkCallback?.let { callback -\u0026gt; connectivityManager?.unregisterNetworkCallback(callback) } } } // In iosMain actual class NetworkMonitor { private var reachability: SCNetworkReachability? = null actual fun startMonitoring(onConnectivityChange: (Boolean) -\u0026gt; Unit) { reachability = SCNetworkReachabilityCreateWithName(null, \u0026#34;www.apple.com\u0026#34;) SCNetworkReachabilitySetCallback(reachability) { _, flags, _ -\u0026gt; val isReachable = flags.contains(SCNetworkReachabilityFlags.Reachable) onConnectivityChange(isReachable) } SCNetworkReachabilityScheduleWithRunLoop(reachability, CFRunLoopGetMain(), kCFRunLoopCommonModes) } actual fun stopMonitoring() { reachability?.let { reach -\u0026gt; SCNetworkReachabilityUnscheduleFromRunLoop(reach, CFRunLoopGetMain(), kCFRunLoopCommonModes) } } }   This example shows how to monitor network connectivity using platform-specific APIs while maintaining a consistent interface in shared code.\nBest Practices for Using expect/actual To get the most out of the expect/actual mechanism, consider these best practices:\n  Keep expect declarations minimal\n Define only what\u0026rsquo;s necessary for the common code to function Avoid exposing platform-specific details in the expect declaration Use interfaces when possible to define behavior rather than implementation    Use expect/actual strategically\n Not everything needs to be an expect/actual declaration Consider alternatives like interface implementations for simpler cases Reserve expect/actual for cases where you need deep platform integration    Organize your code effectively\n Follow the standard KMP source set structure (commonMain, androidMain, iosMain, etc.) Group related expect/actual declarations together Consider using separate files for complex expect/actual implementations    Handle platform-specific features gracefully\n Use expect/actual to provide fallbacks for features not available on all platforms Consider optional functionality that degrades gracefully Document platform-specific limitations clearly    Test both common and platform-specific code\n Write tests for the common interface in commonTest Create platform-specific tests for actual implementations Use mocks or test doubles when appropriate    Advanced Patterns with expect/actual As you become more comfortable with expect/actual, you can leverage more advanced patterns:\nDelegating to Platform-Specific Libraries 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // In commonMain expect class JsonParser() { fun parse(jsonString: String): Map\u0026lt;String, Any?\u0026gt; fun stringify(map: Map\u0026lt;String, Any?\u0026gt;): String } // In androidMain actual class JsonParser { private val gson = Gson() actual fun parse(jsonString: String): Map\u0026lt;String, Any?\u0026gt; { val type = object : TypeToken\u0026lt;Map\u0026lt;String, Any?\u0026gt;\u0026gt;() {}.type return gson.fromJson(jsonString, type) } actual fun stringify(map: Map\u0026lt;String, Any?\u0026gt;): String { return gson.toJson(map) } } // In iosMain actual class JsonParser { actual fun parse(jsonString: String): Map\u0026lt;String, Any?\u0026gt; { val nsString = NSString.create(string = jsonString) val data = nsString.dataUsingEncoding(NSUTF8StringEncoding) val nsObject = NSJSONSerialization.JSONObjectWithData(data!!, 0, null) return nsObject as Map\u0026lt;String, Any?\u0026gt; } actual fun stringify(map: Map\u0026lt;String, Any?\u0026gt;): String { val nsData = NSJSONSerialization.dataWithJSONObject(map, 0, null) return NSString.create(data = nsData!!, encoding = NSUTF8StringEncoding) as String } }   This pattern allows you to leverage platform-specific libraries (Gson for Android and NSJSONSerialization for iOS) while maintaining a consistent API.\nConclusion The expect/actual mechanism is a cornerstone of Kotlin Multiplatform development, enabling developers to write shared code while still leveraging platform-specific capabilities. By defining a common interface with expect declarations and providing platform-specific implementations with actual declarations, you can create applications that share business logic while taking advantage of native platform features.\nAs you build multiplatform applications, remember that expect/actual is just one tool in your KMP toolkit. Use it judiciously, alongside other approaches like interfaces and abstract classes, to create the right balance of code sharing and platform-specific optimization.\nWith the right approach to expect/actual, you can significantly reduce code duplication, improve maintainability, and deliver high-quality applications across multiple platforms without sacrificing the native experience that users expect.\n","description":"How to use Kotlin Multiplatform's expect/actual mechanism to create platform-specific implementations with shared interfaces.","id":0,"section":"posts","tags":["kotlin","multiplatform","kmp"],"title":"Leveraging expect/actual in Kotlin Multiplatform for Native Implementations","uri":"https://carrion.dev/en/posts/expect-actual-kmp/"},{"content":"Leveraging Sealed Classes and Interfaces for Better Domain Modeling Domain modeling is a crucial aspect of software development, representing the core business concepts and rules in your application. Kotlin provides powerful language features that can help create more expressive, type-safe, and maintainable domain models. Among these features, sealed classes and interfaces stand out as particularly valuable tools. This blog post explores how to leverage these Kotlin features to build better domain models.\nUnderstanding Sealed Classes and Interfaces Sealed classes and interfaces in Kotlin are special constructs that restrict the hierarchy of a type. When a class or interface is marked as sealed, all of its subclasses must be defined within the same file (or, since Kotlin 1.5, within the same module as direct subclasses).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  sealed class Result\u0026lt;out T\u0026gt; { data class Success\u0026lt;T\u0026gt;(val data: T) : Result\u0026lt;T\u0026gt;() data class Error(val message: String, val cause: Exception? = null) : Result\u0026lt;Nothing\u0026gt;() object Loading : Result\u0026lt;Nothing\u0026gt;() } fun main() { val result: Result\u0026lt;String\u0026gt; = Result.Success(\u0026#34;Data loaded successfully\u0026#34;) val message = when (result) { is Result.Success -\u0026gt; \u0026#34;Success: ${result.data}\u0026#34; is Result.Error -\u0026gt; \u0026#34;Error: ${result.message}\u0026#34; is Result.Loading -\u0026gt; \u0026#34;Loading...\u0026#34; } println(message) // Outputs: Success: Data loaded successfully }   The key benefits of sealed classes include:\n Exhaustive when expressions: The compiler ensures that all possible subclasses are handled in a when expression Restricted hierarchy: All subclasses must be known at compile time Type safety: The compiler can verify that all cases are handled Expressiveness: They clearly communicate that a type has a limited set of subtypes  Domain Modeling with Sealed Classes Let\u0026rsquo;s explore how sealed classes can improve domain modeling through practical examples.\nExample 1: Modeling Payment Methods Consider an e-commerce application that needs to handle different payment methods:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  sealed class PaymentMethod { data class CreditCard( val cardNumber: String, val expiryDate: String, val cvv: String ) : PaymentMethod() data class PayPal(val email: String) : PaymentMethod() data class BankTransfer( val accountNumber: String, val bankCode: String ) : PaymentMethod() object Cash : PaymentMethod() } class PaymentProcessor { fun process(payment: Payment) { val message = when (payment.method) { is PaymentMethod.CreditCard -\u0026gt; { val card = payment.method \u0026#34;Processing credit card payment with card ending with ${card.cardNumber.takeLast(4)}\u0026#34; } is PaymentMethod.PayPal -\u0026gt; { \u0026#34;Processing PayPal payment for ${payment.method.email}\u0026#34; } is PaymentMethod.BankTransfer -\u0026gt; { \u0026#34;Processing bank transfer from account ${payment.method.accountNumber}\u0026#34; } PaymentMethod.Cash -\u0026gt; { \u0026#34;Processing cash payment\u0026#34; } } println(message) } } data class Payment( val amount: Double, val currency: String, val method: PaymentMethod )   This approach offers several advantages:\n Type safety: The compiler ensures we handle all payment methods Self-documenting code: The sealed class clearly shows all possible payment methods Extensibility: Adding a new payment method is as simple as adding a new subclass Pattern matching: The when expression provides a clean way to handle different payment methods  Example 2: Modeling API Responses Sealed classes are particularly useful for modeling API responses:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  sealed class ApiResponse\u0026lt;out T\u0026gt; { data class Success\u0026lt;T\u0026gt;(val data: T) : ApiResponse\u0026lt;T\u0026gt;() data class Error(val code: Int, val message: String) : ApiResponse\u0026lt;Nothing\u0026gt;() object Loading : ApiResponse\u0026lt;Nothing\u0026gt;() object Empty : ApiResponse\u0026lt;Nothing\u0026gt;() } class UserRepository { fun getUser(id: String): ApiResponse\u0026lt;User\u0026gt; { return try { // Simulate API call  if (id == \u0026#34;123\u0026#34;) { ApiResponse.Success(User(\u0026#34;123\u0026#34;, \u0026#34;John Doe\u0026#34;)) } else { ApiResponse.Error(404, \u0026#34;User not found\u0026#34;) } } catch (e: Exception) { ApiResponse.Error(500, e.message ?: \u0026#34;Unknown error\u0026#34;) } } } data class User(val id: String, val name: String) fun main() { val repository = UserRepository() val response = repository.getUser(\u0026#34;123\u0026#34;) val result = when (response) { is ApiResponse.Success -\u0026gt; \u0026#34;User found: ${response.data.name}\u0026#34; is ApiResponse.Error -\u0026gt; \u0026#34;Error: ${response.message}(${response.code})\u0026#34; ApiResponse.Loading -\u0026gt; \u0026#34;Loading...\u0026#34; ApiResponse.Empty -\u0026gt; \u0026#34;No user data available\u0026#34; } println(result) // Outputs: User found: John Doe }   This pattern is widely used in Android development with architectures like MVI (Model-View-Intent) and helps create a clear separation between different states of data.\nSealed Interfaces for More Flexible Hierarchies Kotlin 1.5 introduced sealed interfaces, which provide more flexibility than sealed classes because a class can implement multiple interfaces:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  sealed interface Error { val message: String } sealed interface NetworkError : Error data class ServerError(override val message: String) : NetworkError data class ConnectionError(override val message: String) : NetworkError sealed interface DatabaseError : Error data class QueryError(override val message: String) : DatabaseError data class TransactionError(override val message: String) : DatabaseError class ErrorHandler { fun handle(error: Error) { val action = when (error) { is ServerError -\u0026gt; \u0026#34;Retry server request\u0026#34; is ConnectionError -\u0026gt; \u0026#34;Check internet connection\u0026#34; is QueryError -\u0026gt; \u0026#34;Fix database query\u0026#34; is TransactionError -\u0026gt; \u0026#34;Rollback transaction\u0026#34; } println(\u0026#34;Error: ${error.message}. Action: $action\u0026#34;) } }   Sealed interfaces allow for more complex hierarchies while maintaining the benefits of exhaustiveness and type safety.\nAdvanced Domain Modeling Patterns Let\u0026rsquo;s explore some advanced patterns using sealed classes and interfaces.\nState Machines with Sealed Classes Sealed classes are excellent for implementing state machines:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  sealed class OrderState { object Created : OrderState() data class Processing(val startTime: Long) : OrderState() data class Shipped(val trackingNumber: String) : OrderState() data class Delivered(val deliveryTime: Long) : OrderState() data class Cancelled(val reason: String) : OrderState() } class OrderStateMachine { fun transition(currentState: OrderState, event: OrderEvent): OrderState { return when (currentState) { is OrderState.Created -\u0026gt; handleCreatedState(event) is OrderState.Processing -\u0026gt; handleProcessingState(event) is OrderState.Shipped -\u0026gt; handleShippedState(event) is OrderState.Delivered -\u0026gt; currentState // Terminal state  is OrderState.Cancelled -\u0026gt; currentState // Terminal state  } } private fun handleCreatedState(event: OrderEvent): OrderState { return when (event) { is OrderEvent.StartProcessing -\u0026gt; OrderState.Processing(System.currentTimeMillis()) is OrderEvent.CancelOrder -\u0026gt; OrderState.Cancelled(event.reason) else -\u0026gt; throw IllegalStateException(\u0026#34;Invalid event $eventfor state Created\u0026#34;) } } private fun handleProcessingState(event: OrderEvent): OrderState { return when (event) { is OrderEvent.ShipOrder -\u0026gt; OrderState.Shipped(event.trackingNumber) is OrderEvent.CancelOrder -\u0026gt; OrderState.Cancelled(event.reason) else -\u0026gt; throw IllegalStateException(\u0026#34;Invalid event $eventfor state Processing\u0026#34;) } } private fun handleShippedState(event: OrderEvent): OrderState { return when (event) { is OrderEvent.DeliverOrder -\u0026gt; OrderState.Delivered(System.currentTimeMillis()) else -\u0026gt; throw IllegalStateException(\u0026#34;Invalid event $eventfor state Shipped\u0026#34;) } } } sealed class OrderEvent { object StartProcessing : OrderEvent() data class ShipOrder(val trackingNumber: String) : OrderEvent() object DeliverOrder : OrderEvent() data class CancelOrder(val reason: String) : OrderEvent() }   This pattern ensures that:\n All possible states are explicitly defined State transitions are controlled and validated The compiler helps ensure all states are handled The code is self-documenting regarding possible states and transitions  Best Practices for Using Sealed Classes in Domain Modeling   Use sealed classes for representing finite sets of possibilities\n API responses (Success, Error, Loading) State machines (Created, Processing, Completed) Command patterns (Add, Remove, Update)    Prefer sealed interfaces when classes need to implement multiple interfaces\n Error hierarchies Feature capabilities Cross-cutting concerns    Combine with data classes for immutable value objects\n Makes your domain model more predictable Provides equals(), hashCode(), and toString() implementations Enables destructuring declarations    Leverage exhaustive when expressions\n Let the compiler ensure all cases are handled Use the when statement without an else branch to force handling all cases    Keep the hierarchy shallow\n Deep hierarchies can become difficult to understand Consider composition over inheritance for complex behaviors    Use nested sealed classes for related concepts\n Helps organize code and maintain context Reduces namespace pollution    Conclusion Sealed classes and interfaces are powerful tools for domain modeling in Kotlin. They provide type safety, exhaustiveness checking, and clear expression of business concepts. By leveraging these features, you can create more robust, maintainable, and self-documenting domain models.\nRemember that good domain modeling is about clearly expressing the business concepts and rules in your code. Sealed classes and interfaces help achieve this goal by providing a way to model finite sets of possibilities in a type-safe manner. Whether you\u0026rsquo;re building an e-commerce platform, a content management system, or a mobile app, these Kotlin features can significantly improve the quality of your domain model.\nAs with any tool, the key is knowing when and how to apply it. Use sealed classes and interfaces when you need to represent a closed set of possibilities, and combine them with other Kotlin features like data classes and extension functions to create expressive and maintainable domain models.\n","description":"How to use Kotlin's sealed classes and interfaces to create more robust and type-safe domain models.","id":1,"section":"posts","tags":["kotlin","architecture","domain modeling","type safety"],"title":"Leveraging Sealed Classes and Interfaces for Better Domain Modeling","uri":"https://carrion.dev/en/posts/sealed-classes-domain-modeling/"},{"content":"Composition Over Inheritance: A Kotlin Perspective In object-oriented programming, there are two primary ways to reuse code and establish relationships between classes: inheritance and composition. While both approaches have their place, the principle of \u0026ldquo;composition over inheritance\u0026rdquo; has gained significant traction in modern software design. This blog post explores both approaches, their trade-offs, and why composition is often the preferred choice, with examples in Kotlin.\nUnderstanding Inheritance Inheritance is a mechanism where a class (subclass) can inherit properties and behaviors from another class (superclass). It establishes an \u0026ldquo;is-a\u0026rdquo; relationship between classes.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // Base class open class Animal { open fun makeSound() { println(\u0026#34;Some generic animal sound\u0026#34;) } fun eat() { println(\u0026#34;Eating...\u0026#34;) } } // Derived class class Dog : Animal() { override fun makeSound() { println(\u0026#34;Woof!\u0026#34;) } fun fetch() { println(\u0026#34;Fetching...\u0026#34;) } } fun main() { val dog = Dog() dog.makeSound() // Outputs: Woof!  dog.eat() // Outputs: Eating...  dog.fetch() // Outputs: Fetching... }   In this example, Dog inherits from Animal and can use its methods while also adding its own behavior.\nAdvantages of Inheritance:\n Code reuse - Subclasses automatically inherit methods and properties Method overriding - Allows customization of inherited behavior Polymorphism - Enables treating objects of different subclasses as objects of the superclass  Disadvantages of Inheritance:\n Tight coupling - Changes in the superclass can break subclasses Fragile base class problem - Modifications to the base class can have unexpected effects Inflexibility - The inheritance hierarchy is fixed at compile time Limited to single inheritance in many languages (including Kotlin)  Understanding Composition Composition is a design principle where classes achieve polymorphic behavior and code reuse by containing instances of other classes rather than inheriting from them. It establishes a \u0026ldquo;has-a\u0026rdquo; relationship.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  interface SoundBehavior { fun makeSound() } class BarkSound : SoundBehavior { override fun makeSound() { println(\u0026#34;Woof!\u0026#34;) } } class MeowSound : SoundBehavior { override fun makeSound() { println(\u0026#34;Meow!\u0026#34;) } } class EatingBehavior { fun eat() { println(\u0026#34;Eating...\u0026#34;) } } class Dog( private val soundBehavior: SoundBehavior, private val eatingBehavior: EatingBehavior ) { fun makeSound() { soundBehavior.makeSound() } fun eat() { eatingBehavior.eat() } fun fetch() { println(\u0026#34;Fetching...\u0026#34;) } } class Cat( private val soundBehavior: SoundBehavior, private val eatingBehavior: EatingBehavior ) { fun makeSound() { soundBehavior.makeSound() } fun eat() { eatingBehavior.eat() } fun purr() { println(\u0026#34;Purring...\u0026#34;) } } fun main() { val eatingBehavior = EatingBehavior() val dog = Dog(BarkSound(), eatingBehavior) val cat = Cat(MeowSound(), eatingBehavior) dog.makeSound() // Outputs: Woof!  cat.makeSound() // Outputs: Meow! }   In this example, instead of inheriting behavior, the Dog and Cat classes compose their behavior by containing instances of SoundBehavior and EatingBehavior.\nAdvantages of Composition:\n Flexibility - Behaviors can be changed at runtime Decoupling - Classes are less dependent on each other No fragile base class problem - Changes to one component don\u0026rsquo;t affect others Multiple behaviors - Can incorporate multiple behaviors without multiple inheritance  The Diamond Problem and Why It Matters One of the classic problems with inheritance is the \u0026ldquo;diamond problem,\u0026rdquo; which occurs in multiple inheritance scenarios:\n A / \\ B C \\ / D If both B and C override a method from A, which version should D inherit?\nWhile Kotlin doesn\u0026rsquo;t support multiple inheritance of classes, it does support multiple interface implementation, which can lead to similar issues:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  interface A { fun doSomething() { println(\u0026#34;A\u0026#39;s implementation\u0026#34;) } } interface B : A { override fun doSomething() { println(\u0026#34;B\u0026#39;s implementation\u0026#34;) } } interface C : A { override fun doSomething() { println(\u0026#34;C\u0026#39;s implementation\u0026#34;) } } // This won\u0026#39;t compile without explicitly overriding doSomething class D : B, C { override fun doSomething() { super\u0026lt;B\u0026gt;.doSomething() // We must choose which one to call  } }   Composition avoids this problem entirely by making the relationships explicit:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class ComponentA { fun doSomething() { println(\u0026#34;A\u0026#39;s implementation\u0026#34;) } } class ComponentB { fun doSomething() { println(\u0026#34;B\u0026#39;s implementation\u0026#34;) } } class ComponentC { fun doSomething() { println(\u0026#34;C\u0026#39;s implementation\u0026#34;) } } class D( private val componentB: ComponentB, private val componentC: ComponentC ) { fun doSomethingB() { componentB.doSomething() } fun doSomethingC() { componentC.doSomething() } }   Real-World Example: UI Components Let\u0026rsquo;s look at a more practical example involving UI components:\nInheritance Approach:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  open class UIComponent { open fun render() { println(\u0026#34;Rendering component\u0026#34;) } open fun handleClick() { println(\u0026#34;Component clicked\u0026#34;) } } open class Button : UIComponent() { override fun render() { println(\u0026#34;Rendering button\u0026#34;) } override fun handleClick() { println(\u0026#34;Button clicked\u0026#34;) } } class AnimatedButton : Button() { override fun render() { println(\u0026#34;Rendering animated button\u0026#34;) } }   Composition Approach:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  interface Renderer { fun render() } interface ClickHandler { fun handleClick() } class StandardRenderer : Renderer { override fun render() { println(\u0026#34;Standard rendering\u0026#34;) } } class AnimatedRenderer : Renderer { override fun render() { println(\u0026#34;Animated rendering\u0026#34;) } } class StandardClickHandler : ClickHandler { override fun handleClick() { println(\u0026#34;Standard click handling\u0026#34;) } } class UIComponent( private val renderer: Renderer, private val clickHandler: ClickHandler ) { fun render() { renderer.render() } fun handleClick() { clickHandler.handleClick() } } // Usage fun main() { val standardButton = UIComponent(StandardRenderer(), StandardClickHandler()) val animatedButton = UIComponent(AnimatedRenderer(), StandardClickHandler()) standardButton.render() // Outputs: Standard rendering  animatedButton.render() // Outputs: Animated rendering }   With composition, we can mix and match behaviors without creating a complex inheritance hierarchy. We can even change behaviors at runtime:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class DynamicButton( private var renderer: Renderer, private var clickHandler: ClickHandler ) { fun render() { renderer.render() } fun handleClick() { clickHandler.handleClick() } fun setRenderer(newRenderer: Renderer) { renderer = newRenderer } fun setClickHandler(newClickHandler: ClickHandler) { clickHandler = newClickHandler } }   When to Use Inheritance Despite the advantages of composition, inheritance still has its place:\n When there\u0026rsquo;s a clear \u0026ldquo;is-a\u0026rdquo; relationship that\u0026rsquo;s unlikely to change When you want to leverage polymorphism in a straightforward way When the base class is stable and unlikely to change frequently For framework design where extension points are well-defined  For example, in Kotlin\u0026rsquo;s standard library, ArrayList inherits from AbstractList, which makes sense because an ArrayList is fundamentally a list and this relationship won\u0026rsquo;t change.\nBest Practices  Favor composition over inheritance as a general rule Use inheritance when there\u0026rsquo;s a true \u0026ldquo;is-a\u0026rdquo; relationship that\u0026rsquo;s stable Design for composition by creating small, focused interfaces and classes Consider delegation as a middle ground (Kotlin has built-in support with the by keyword) Avoid deep inheritance hierarchies as they become difficult to understand and maintain Program to interfaces, not implementations to make composition easier  Kotlin\u0026rsquo;s delegation feature provides a convenient way to implement composition:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface SoundMaker { fun makeSound() } class Barker : SoundMaker { override fun makeSound() = println(\u0026#34;Woof!\u0026#34;) } // Using delegation with \u0026#39;by\u0026#39; keyword class Dog(soundMaker: SoundMaker) : SoundMaker by soundMaker { // Additional dog-specific methods  fun fetch() = println(\u0026#34;Fetching...\u0026#34;) } fun main() { val dog = Dog(Barker()) dog.makeSound() // Outputs: Woof!  dog.fetch() // Outputs: Fetching... }   Conclusion While inheritance is a powerful feature of object-oriented programming, composition often provides a more flexible and maintainable approach to code reuse and class relationships. By understanding the trade-offs between these approaches, you can make better design decisions in your Kotlin projects.\nRemember that good design isn\u0026rsquo;t about dogmatically following rules but about choosing the right tool for the job. In many cases, that tool will be composition, but there are still valid use cases for inheritance. The key is to understand the implications of your choice and to design your code to be as flexible and maintainable as possible.\n","description":"Understanding the advantages of composition over inheritance with practical Kotlin examples.","id":2,"section":"posts","tags":["kotlin","architecture","design patterns","object-oriented programming"],"title":"Composition Over Inheritance: A Kotlin Perspective","uri":"https://carrion.dev/en/posts/composition-over-inheritance/"},{"content":"Performance Optimization in Jetpack Compose Performance optimization is crucial for delivering a smooth user experience in Jetpack Compose applications. This article explores key techniques and best practices to ensure your composable functions are efficient and performant.\nUnderstanding Composition and Recomposition One of the fundamental aspects of performance in Compose is understanding how composition and recomposition work:\nSmart Recomposition Compose uses smart recomposition to update only the parts of the UI that need to change. Understanding what triggers recomposition and how to minimize its scope is crucial for performance optimization.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  @Composable fun ExpensiveCalculation(numbers: List\u0026lt;Int\u0026gt;) { // Bad: Expensive operation performed on every recomposition  val average = numbers.takeIf { it.isNotEmpty() } ?.average() ?: 0.0 // Good: Expensive operation cached and only recalculated when input changes  val cachedAverage = remember(numbers) { numbers.takeIf { it.isNotEmpty() } ?.average() ?: 0.0 } Column { // This will recalculate on every recomposition  Text(\u0026#34;Current Average: ${\u0026#34;%.2f\u0026#34;.format(average)}\u0026#34;) // This will use the cached value  Text(\u0026#34;Cached Average: ${\u0026#34;%.2f\u0026#34;.format(cachedAverage)}\u0026#34;) } }   Stable Types and Immutability Stable types are crucial for Compose\u0026rsquo;s smart recomposition system. A type is considered stable when Compose can guarantee that its equals() method is consistent with its properties and that the properties themselves won\u0026rsquo;t change without triggering a recomposition.\n1 2 3 4 5 6 7 8 9 10 11 12  // Bad: Unstable type - mutable properties can change without notifying Compose data class UserState( var name: String, // Mutable property can change silently  var age: Int // Changes won\u0026#39;t trigger recomposition ) // Good: Stable type - immutable properties and explicit stability @Stable // Tells Compose this type has a predictable equality data class UserState( val name: String, // Immutable property  val age: Int // Changes require creating a new instance )   Using stable types provides several benefits:\n More efficient recomposition - Compose can skip recomposing parts of the UI when it knows the data hasn\u0026rsquo;t changed Predictable behavior - Changes to the data always trigger proper UI updates Thread safety - Immutable data is safe to share across coroutines  Key Performance Optimizations 1. State Management with remember and derivedStateOf The remember and derivedStateOf functions serve different purposes in state management:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  @Composable fun UserProfile(user: User, items: List\u0026lt;Item\u0026gt;) { // Bad: Recalculating on every recomposition  val filteredItems = items.filter { it.userId == user.id } // Good: Caching calculation with remember  val cachedItems = remember(items, user.id) { items.filter { it.userId == user.id } } // Better: Using derivedStateOf for reactive computations  val reactiveItems by remember(items) { derivedStateOf { items.filter { it.userId == user.id } } } // reactiveItems will automatically update when items changes  // and only trigger recomposition when the filtered result changes  LazyColumn { itemsIndexed( items = reactiveItems, key = { _: Int, item: Item -\u0026gt; item.id } ) { _: Int, item: Item -\u0026gt; ItemRow(item) } } }   2. Composition Local Usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  // Bad: Each child component accesses CompositionLocal @Composable fun DeepNestedContent() { val theme = LocalTheme.current // Accessed directly  val strings = LocalStrings.current // Multiple CompositionLocal accesses  val dimensions = LocalDimensions.current Column { Text( text = strings.title, style = theme.textStyle, modifier = Modifier.padding(dimensions.padding) ) // More nested content with repeated CompositionLocal access  } } // Good: Hoisting CompositionLocal values to minimize lookups @Composable fun ParentContent() { // Single access to CompositionLocal values  val theme = LocalTheme.current val strings = LocalStrings.current val dimensions = LocalDimensions.current DeepNestedContent( theme = theme, strings = strings, dimensions = dimensions ) } @Composable fun DeepNestedContent( theme: Theme, strings: Strings, dimensions: Dimensions ) { // Use passed parameters instead of looking up CompositionLocal values  Column { Text( text = strings.title, style = theme.textStyle, modifier = Modifier.padding(dimensions.padding) ) // More nested content using passed parameters  } }   3. LazyList Optimizations Efficient list rendering is crucial for smooth scrolling performance. Here are key optimizations for LazyList components:\n1 2 3 4 5 6 7 8 9 10 11 12  @Composable fun \u0026lt;T : Any\u0026gt; OptimizedList(items: List\u0026lt;T\u0026gt;) { LazyColumn { itemsIndexed( items = items, // Stable keys help Compose track items across updates  key = { _: Int, item: T -\u0026gt; item.hashCode() } ) { _: Int, item: T -\u0026gt; // Content for each item  } } }   Key optimizations for LazyList:\n Provide stable keys to help Compose track items across updates Use fixed sizes when possible to avoid remeasurement Keep item composables lightweight Avoid unnecessary allocations in item content Use remember to cache expensive computations per item  Measuring and Monitoring Performance Layout Inspector and Composition Traces The Layout Inspector in Android Studio is a powerful tool for debugging Compose UI performance. It provides insights into your app\u0026rsquo;s view hierarchy, recomposition counts, and modifiers applied to each composable.\nTo use Layout Inspector with Compose:\n Run your app in debug mode In the Running Devices windows you will find a button to Toggle Layout inspector Inspect the Compose hierarchy:  View component tree Check recomposition counts Analyze modifier chains Inspect composable parameters    Key metrics to monitor in Layout Inspector:\n Recomposition counts - High numbers indicate potential optimization opportunities Skipping counts - Check that your Composables are skipping recomposition when they should Modifier chain complexity - Long chains might affect measure/layout performance  Performance Testing 1 2 3 4 5 6 7 8 9 10 11 12  @Test fun performanceTest() { benchmarkRule.measureRepeated( packageName = \u0026#34;com.example.app\u0026#34;, metrics = listOf(FrameTimingMetric()), iterations = 5 ) { composeTestRule.setContent { YourComposable() } } }   Best Practices Summary  Use stable types and immutable data structures Hoist expensive computations with remember Implement proper keys in lazy lists Minimize the scope of recomposition Profile and measure performance regularly  Following these optimization techniques will help ensure your Compose UI remains responsive and efficient, providing a better user experience for your applications.\n","description":"Learn essential techniques and best practices for optimizing performance in Jetpack Compose applications, including composition optimization, recomposition control, and memory management","id":3,"section":"posts","tags":["android","compose","performance","optimization"],"title":"Performance Optimization in Jetpack Compose","uri":"https://carrion.dev/en/posts/performance-optimization-compose/"},{"content":"Custom Animations and Transitions in Jetpack Compose Creating smooth, meaningful animations is crucial for delivering a polished user experience. This article explores how to create custom animations and transitions in Jetpack Compose, from basic animations to complex custom implementations.\nCreating Custom Animations Custom animations allow for more complex and unique visual effects:\nCustom Animation Specs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  @Composable fun CustomAnimatedButton( onClick: () -\u0026gt; Unit, content: @Composable () -\u0026gt; Unit ) { var isPressed by remember { mutableStateOf(false) } val scope = rememberCoroutineScope() val scale by animateFloatAsState( targetValue = if (isPressed) 0.95f else 1f, animationSpec = spring( dampingRatio = 0.4f, stiffness = Spring.StiffnessLow ) ) Box( modifier = Modifier .scale(scale) .clickable( interactionSource = remember { MutableInteractionSource() }, indication = null ) { isPressed = true onClick() // Reset after animation using lifecycle-aware scope  scope.launch { delay(100) isPressed = false } } ) { content() } }   Infinite Animations For continuous animations like loading indicators:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  @Composable fun PulsatingDot( color: Color, size: Dp = 20.dp ) { val infiniteTransition = rememberInfiniteTransition(label = \u0026#34;pulsating\u0026#34;) val scale by infiniteTransition.animateFloat( initialValue = 0.6f, targetValue = 1f, animationSpec = infiniteRepeatable( animation = tween(1000), repeatMode = RepeatMode.Reverse ), label = \u0026#34;scale\u0026#34; ) Box( modifier = Modifier .size(size) .scale(scale) .background(color, CircleShape) ) }   Implementing Custom Transitions Transitions help create smooth state changes between different UI states:\nContent Transitions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @Composable fun AnimatedContent( content: @Composable () -\u0026gt; Unit, modifier: Modifier = Modifier ) { AnimatedVisibility( visible = true, enter = fadeIn() + expandVertically(), exit = fadeOut() + shrinkVertically() ) { Box(modifier = modifier) { content() } } }   Custom Transition Specs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  @Composable fun CustomTransitionCard( expanded: Boolean, modifier: Modifier = Modifier, content: @Composable () -\u0026gt; Unit ) { val transition = updateTransition( targetState = expanded, label = \u0026#34;card_transition\u0026#34; ) val cardElevation by transition.animateDp( label = \u0026#34;elevation\u0026#34;, targetValueByState = { isExpanded: Boolean -\u0026gt; if (isExpanded) 8.dp else 2.dp } ) val cardRoundedCorners by transition.animateDp( label = \u0026#34;corner_radius\u0026#34;, targetValueByState = { isExpanded: Boolean -\u0026gt; if (isExpanded) 0.dp else 16.dp } ) Card( modifier = modifier, elevation = CardDefaults.cardElevation(defaultElevation = cardElevation), shape = RoundedCornerShape(cardRoundedCorners) ) { content() } }   Best Practices and Performance Optimization When implementing custom animations, keep these best practices in mind:\n1. Animation State Management Keep animation state close to where it\u0026rsquo;s used:\n1 2 3 4 5 6 7 8 9 10 11  @Composable fun OptimizedAnimation() { // ❌ Don\u0026#39;t store animation values at composable level  // var scale by remember { mutableStateOf(1f) }  // ✅ Use AnimationState or animate* APIs  val scale by animateFloatAsState( targetValue = 1f, label = \u0026#34;scale\u0026#34; ) }   2. Performance Considerations  Use remember for expensive calculations Avoid animating layout parameters when possible Consider using LaunchedEffect for complex animations  Conclusion Custom animations and transitions in Jetpack Compose provide powerful tools for creating engaging user experiences. By understanding the core concepts and following best practices, you can create smooth, performant animations that enhance your app\u0026rsquo;s user interface.\nRemember to:\n Start with simple animations and gradually add complexity Test animations on different devices and screen sizes Consider accessibility implications Monitor performance impact Use animation principles to create meaningful transitions  For more advanced topics, check out our other articles on Compose performance optimization and state management.\nYou can find all the examples from this post in this GitHub repository: ComposeAnimations\n","description":"Deep dive into creating custom animations and transitions in Jetpack Compose, covering animation APIs, custom transitions, and performance optimization","id":4,"section":"posts","tags":["android","compose","animation","transitions"],"title":"Custom Animations and Transitions in Jetpack Compose","uri":"https://carrion.dev/en/posts/custom-animations-transitions-compose/"},{"content":"Advanced State Management in Compose: Effects and Flows This article explores advanced state management patterns in Jetpack Compose, focusing on Effects and Flow integration. For fundamental concepts like mutableStateOf and state hoisting, check out our companion article Basic State Management in Jetpack Compose.\nUnderstanding Compose Effects Effects in Compose are tools to handle side effects and lifecycle events in a composable-friendly way. Let\u0026rsquo;s explore the different types of effects and their use cases:\nLaunchedEffect: Coroutine-based Side Effects LaunchedEffect launches a coroutine that is automatically cancelled when the composable leaves the composition:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @Composable fun AutoRefreshingList(viewModel: ListViewModel) { // Starts a coroutine that refreshes data every 30 seconds  LaunchedEffect(Unit) { while(true) { viewModel.refreshData() delay(30_000) } } // The key parameter controls when the effect should restart  LaunchedEffect(viewModel.searchQuery) { viewModel.performSearch() } }   SideEffect: Synchronizing with Non-Compose Code SideEffect is called on every successful recomposition to sync Compose state with non-Compose code:\n1 2 3 4 5 6 7  @Composable fun AnalyticsScreen(screenName: String) { SideEffect { // Called after every successful recomposition  AnalyticsTracker.trackScreen(screenName) } }   DisposableEffect: Cleanup Operations DisposableEffect handles cleanup when a composable leaves the composition:\n1 2 3 4 5 6 7 8 9 10 11  @Composable fun NetworkMonitor(onConnectionChange: (Boolean) -\u0026gt; Unit) { DisposableEffect(Unit) { val listener = NetworkListener(onConnectionChange) listener.register() onDispose { listener.unregister() } } }   derivedStateOf: Computed State derivedStateOf creates a state that\u0026rsquo;s automatically updated when its dependencies change. It\u0026rsquo;s particularly useful for threshold-based computations and UI state derivations that shouldn\u0026rsquo;t trigger recompositions on every small change:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  import androidx.compose.foundation.lazy.LazyListState import androidx.compose.foundation.lazy.rememberLazyListState import androidx.compose.runtime.getValue import androidx.compose.runtime.remember import androidx.compose.runtime.derivedStateOf // Example showing how derivedStateOf helps prevent unnecessary // recompositions when working with scroll state @Composable fun ScrollableNewsScreen() { val listState = rememberLazyListState() // ❌ Without derivedStateOf  // These properties would recompute on every scroll pixel change,  // causing unnecessary recompositions of any composable that reads them  // val showScrollToTop = listState.firstVisibleItemIndex \u0026gt; 0  // val isScrollInProgress = listState.isScrollInProgress  // ✅ With derivedStateOf  // These computations only trigger when crossing specific thresholds,  // significantly reducing unnecessary recompositions  val showScrollToTop by remember { derivedStateOf { // Only show button when scrolled past first item  listState.firstVisibleItemIndex \u0026gt; 0 } } val shouldLoadMore by remember { derivedStateOf { val lastVisibleItem = listState.layoutInfo.visibleItemsInfo.lastOrNull() // Trigger pagination when user is close to the end  lastVisibleItem?.index != null \u0026amp;\u0026amp; lastVisibleItem.index \u0026gt;= listState.layoutInfo.totalItemsCount - 3 } } val isScrollingUp by remember { derivedStateOf { // Track scroll direction based on first visible item  listState.firstVisibleItemScrollOffset \u0026lt; 100 } } // Use these derived states to control UI elements like:  // - Scroll to top button visibility (showScrollToTop)  // - Pagination loading (shouldLoadMore)  // - Collapsing/Expanding top bar (isScrollingUp)  NewsScreenContent( showScrollButton = showScrollToTop, isScrollingUp = isScrollingUp, shouldLoadMore = shouldLoadMore ) } // Note: Implementation of NewsScreenContent and other UI components omitted for brevity   produceState: Converting Non-Compose State to State produceState converts non-Compose state sources into Compose state:\n1 2 3 4 5 6 7 8 9 10  @Composable fun UserProfile(userId: String) { val user by produceState\u0026lt;User?\u0026gt;(initialValue = null, userId) { value = userRepository.fetchUser(userId) awaitDispose { // Cleanup if needed  } } }   Flow Integration with Compose When working with Flows in Compose, we need to convert them into Compose state. Jetpack Compose provides two main functions for this purpose: collectAsState and collectAsStateWithLifecycle.\ncollectAsState: Basic Flow Collection collectAsState converts a Flow into a Compose State:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @Composable fun UserProfile(viewModel: UserViewModel) { // Basic collection  val name by viewModel.nameFlow.collectAsState() // With initial value  val count by viewModel.countFlow.collectAsState(initial = 0) // Handling nullable flows  val user by viewModel.userFlow.collectAsState(initial = null) Text(\u0026#34;Name: $name\u0026#34;) Text(\u0026#34;Count: $count\u0026#34;) user?.let { Text(\u0026#34;User: ${it.name}\u0026#34;) } }   collectAsStateWithLifecycle: Lifecycle-Aware Collection collectAsStateWithLifecycle is the recommended way to collect flows in Compose as it respects the lifecycle of the composable. It provides several benefits over collectAsState:\n Automatically stops collection when the composable is not visible Resumes collection when the composable becomes visible again Reduces unnecessary processing and battery consumption Prevents memory leaks by properly cleaning up resources Allows fine-grained control over when collection should occur  Here\u0026rsquo;s how to use it:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // Data types for the example data class UserUpdate( val id: String, val message: String, val timestamp: Long ) @Composable fun UserUpdates(viewModel: UserViewModel) { // Basic lifecycle-aware collection  val updates by viewModel.userUpdatesFlow .collectAsStateWithLifecycle(initialValue = emptyList()) // Custom lifecycle state  val notifications by viewModel.notificationsFlow .collectAsStateWithLifecycle( initialValue = emptyList(), lifecycle = lifecycle, minActiveState = Lifecycle.State.RESUMED // Only collect when RESUMED  ) LazyColumn { items(updates) { update: UserUpdate -\u0026gt; UpdateItem(update) } } }   Conclusion Advanced state management in Compose requires understanding both Effects and Flow integration. Effects help you handle side effects and lifecycle events, while proper Flow integration ensures efficient state collection that respects the Android lifecycle.\nRemember to:\n Choose the appropriate Effect for your use case Use collectAsStateWithLifecycle for Flow integration when collecting from flows Test your state management implementation thoroughly  For fundamental state management concepts, check out our companion article Basic State Management in Jetpack Compose.\n","description":"Deep dive into advanced state management in Jetpack Compose, including Effects, Flow integration, and lifecycle-aware state collection","id":5,"section":"posts","tags":["android","compose","state","flows","effects"],"title":"Advanced State Management in Compose: Effects and Flows","uri":"https://carrion.dev/en/posts/advanced-state-management-compose/"},{"content":"State Management Patterns in Jetpack Compose State management is a crucial aspect of building robust and maintainable Jetpack Compose applications. This article explores essential patterns and best practices for managing state effectively in your Compose UI, including immutable state, event-based updates, and testing strategies.\nUnderstanding State Management Patterns Effective state management in Compose requires understanding how to structure and handle state changes in a way that\u0026rsquo;s maintainable, testable, and scalable. This involves several key patterns:\n Immutable State Classes: Define clear state boundaries and prevent unintended modifications Event-Based Updates: Centralize state modifications through well-defined events Predictable State Flow: Ensure state changes follow a consistent pattern Testable Architecture: Structure code to facilitate thorough testing  Let\u0026rsquo;s explore each of these patterns in detail.\n1. Single Source of Truth The foundation of effective state management is maintaining a single source of truth for your application state. This pattern helps prevent inconsistencies and makes state changes more predictable.\nThe Single Source of Truth pattern involves using a sealed interface/class to represent all possible states of your UI. This approach provides several benefits:\n Type-safe: The compiler ensures you handle all possible states Consistent: All UI state comes from one authoritative source Predictable: State transitions are explicit and traceable Maintainable: Each state is a complete snapshot of the UI Testable: State changes can be easily verified  Here\u0026rsquo;s how to implement this pattern:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // Example of Single Source of Truth pattern sealed interface UserUiState { object Loading : UserUiState data class Error(val message: String) : UserUiState data class Success(val user: User) : UserUiState } class UserViewModel : ViewModel() { private val _uiState = MutableStateFlow\u0026lt;UserUiState\u0026gt;(UserUiState.Loading) val uiState: StateFlow\u0026lt;UserUiState\u0026gt; = _uiState.asStateFlow() fun loadUser(userId: String) { viewModelScope.launch { _uiState.emit(UserUiState.Loading) try { val user = userRepository.getUser(userId) _uiState.emit(UserUiState.Success(user)) } catch (e: Exception) { _uiState.emit(UserUiState.Error(e.message ?: \u0026#34;Unknown error\u0026#34;)) } } } } // The Composable can easily handle all states in one place @Composable fun UserScreen(viewModel: UserViewModel) { val uiState by viewModel.uiState.collectAsStateWithLifecycle() when (val state = uiState) { is UserUiState.Loading -\u0026gt; LoadingSpinner() is UserUiState.Error -\u0026gt; ErrorMessage(state.message) is UserUiState.Success -\u0026gt; { UserContent(state.user) } } }   2. State Immutability The second key pattern is maintaining immutable state objects. This approach is crucial for:\n Preventing race conditions in concurrent operations Making state changes explicit and traceable Enabling efficient change detection in Compose Simplifying debugging and testing  Here\u0026rsquo;s how to implement immutable state management:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  // Define an immutable state class that represents all possible states // Benefits: // 1. Type-safe: Compiler ensures all properties are properly initialized // 2. Thread-safe: Immutable objects are safe to share across threads // 3. Predictable: State changes only happen through explicit copy operations // 4. Debuggable: Each state change creates a new object, making it easy to track changes data class SearchState( val query: String = \u0026#34;\u0026#34;, val results: List\u0026lt;SearchResult\u0026gt; = emptyList(), val selectedResult: SearchResult? = null, val isLoading: Boolean = false ) data class SearchResult( val id: String, val title: String, val description: String ) class SearchViewModel : ViewModel() { // Encapsulate MutableStateFlow to ensure state updates only happen through defined methods  private val _uiState = MutableStateFlow(SearchState()) // Expose immutable StateFlow to prevent unauthorized modifications  val uiState: StateFlow\u0026lt;SearchState\u0026gt; = _uiState.asStateFlow() // State updates are atomic and always create a new state object  fun onQueryChange(query: String) { _uiState.update { it.copy( query = query, isLoading = query.isNotEmpty() ) } searchResults(query) } fun onResultSelected(result: SearchResult) { _uiState.update { it.copy(selectedResult = result) } } // Handle asynchronous operations and error cases while maintaining state consistency  private fun searchResults(query: String) { viewModelScope.launch { try { val results = searchRepository.search(query) // Success: update results and reset loading state  _uiState.update { it.copy( results = results, isLoading = false ) } } catch (e: Exception) { // Error: clear results and reset loading state  _uiState.update { it.copy( results = emptyList(), isLoading = false ) } } } } } @Composable fun SearchScreen(viewModel: SearchViewModel) { // Collect state in a lifecycle-aware manner  // The Composable automatically recomposes when state changes  val state by viewModel.uiState.collectAsStateWithLifecycle() // Declarative UI pattern:  // 1. UI is a function of state  // 2. State changes trigger recomposition  // 3. UI automatically reflects the current state  Column(modifier = Modifier.padding(16.dp)) { // Input: Current query and callback for changes  SearchBar( query = state.query, onQueryChange = viewModel::onQueryChange ) // Conditional rendering based on loading state  if (state.isLoading) { CircularProgressIndicator() } else { // List rendering with stable keys for efficient updates  LazyColumn { items( items = state.results, key = { it.id } ) { result: SearchResult -\u0026gt; SearchResultItem( result = result, isSelected = result == state.selectedResult, onClick = { viewModel.onResultSelected(result) } ) } } } } }   3. Event-Based Updates The third key pattern is using events to make state updates predictable. This approach helps to:\n Centralize state modification logic Make state transitions explicit and traceable Ensure all state updates follow a consistent pattern Simplify testing by verifying event handling  Here\u0026rsquo;s how to implement event-based state updates:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147  // Events represent all possible ways to modify the state // Benefits of using events: // 1. Type-safe: Compiler ensures all events are handled // 2. Centralized: All state modifications go through a single point // 3. Traceable: Easy to log and debug state changes // 4. Testable: Events can be easily mocked and verified sealed interface ProfileEvent { object LoadProfile : ProfileEvent data class UpdateBio(val newBio: String) : ProfileEvent data class UpdateName(val newName: String) : ProfileEvent object SaveProfile : ProfileEvent } // Immutable state for the profile screen data class ProfileState( val name: String = \u0026#34;\u0026#34;, val bio: String = \u0026#34;\u0026#34;, val isLoading: Boolean = false, val isSaving: Boolean = false, val error: String? = null ) class ProfileViewModel : ViewModel() { private val _uiState = MutableStateFlow(ProfileState()) val uiState: StateFlow\u0026lt;ProfileState\u0026gt; = _uiState.asStateFlow() // Single entry point for all state modifications  // This ensures that:  // 1. All state changes are handled consistently  // 2. State modifications are easy to track  // 3. Side effects are properly managed  fun onEvent(event: ProfileEvent) { when (event) { is ProfileEvent.LoadProfile -\u0026gt; loadProfile() is ProfileEvent.UpdateBio -\u0026gt; updateBio(event.newBio) is ProfileEvent.UpdateName -\u0026gt; updateName(event.newName) is ProfileEvent.SaveProfile -\u0026gt; saveProfile() } } // Each event handler follows the same pattern:  // 1. Update state to show operation in progress  // 2. Perform the operation  // 3. Update state with the result or error  private fun loadProfile() { viewModelScope.launch { _uiState.update { it.copy(isLoading = true, error = null) } try { val profile = profileRepository.getProfile() _uiState.update { it.copy( name = profile.name, bio = profile.bio, isLoading = false ) } } catch (e: Exception) { _uiState.update { it.copy( isLoading = false, error = e.message ) } } } } private fun updateBio(newBio: String) { _uiState.update { it.copy(bio = newBio) } } private fun updateName(newName: String) { _uiState.update { it.copy(name = newName) } } // For async operations, we handle loading states and errors consistently  private fun saveProfile() { viewModelScope.launch { _uiState.update { it.copy(isSaving = true, error = null) } try { profileRepository.saveProfile( name = uiState.value.name, bio = uiState.value.bio ) _uiState.update { it.copy(isSaving = false) } } catch (e: Exception) { _uiState.update { it.copy( isSaving = false, error = e.message ) } } } } } @Composable fun ProfileScreen(viewModel: ProfileViewModel) { // UI layer only needs to:  // 1. Observe state changes  // 2. Send events to the ViewModel  // This creates a clear separation of concerns  val state by viewModel.uiState.collectAsStateWithLifecycle() // Load profile when screen is first displayed  LaunchedEffect(Unit) { viewModel.onEvent(ProfileEvent.LoadProfile) } Column(modifier = Modifier.padding(16.dp)) { // Name field  OutlinedTextField( value = state.name, onValueChange = { viewModel.onEvent(ProfileEvent.UpdateName(it)) }, label = { Text(\u0026#34;Name\u0026#34;) } ) // Bio field  OutlinedTextField( value = state.bio, onValueChange = { viewModel.onEvent(ProfileEvent.UpdateBio(it)) }, label = { Text(\u0026#34;Bio\u0026#34;) } ) // Save button  Button( onClick = { viewModel.onEvent(ProfileEvent.SaveProfile) }, enabled = !state.isLoading \u0026amp;\u0026amp; !state.isSaving ) { Text(\u0026#34;Save Profile\u0026#34;) } // Error message  state.error?.let { error: String -\u0026gt; Text( text = error, color = MaterialTheme.colorScheme.error ) } // Loading indicators  if (state.isLoading) { CircularProgressIndicator(Modifier.align(Alignment.CenterHorizontally)) } } } // This event-based pattern makes testing straightforward: // 1. Create ViewModel with test dependencies // 2. Send events // 3. Verify state updates // See the testing section below for detailed examples   4. Testing Strategy The fourth key pattern is implementing a comprehensive testing strategy. Testing state management in Compose involves three main aspects:\n Testing ViewModel state updates and transitions Verifying event handling and side effects Ensuring UI correctly reflects state changes  Here\u0026rsquo;s how to implement a complete testing strategy:\nFor ViewModel tests:\n Initial state is correct Events produce expected state updates Async operations handle loading and error states State updates are atomic and consistent  For UI tests:\n Components reflect the current state User interactions trigger correct events Loading and error states are properly displayed  Here\u0026rsquo;s a complete example showing these testing patterns:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98  // Test class demonstrates: // 1. Proper test setup with dependencies // 2. Testing different flows (success, error, immediate updates) // 3. Verifying state transitions class ProfileViewModelTest { private lateinit var viewModel: ProfileViewModel private lateinit var testRepository: TestProfileRepository @Before fun setup() { testRepository = TestProfileRepository() viewModel = ProfileViewModel(testRepository) } @Test fun `load profile - success flow`() = runTest { // Given  val testProfile = Profile(name = \u0026#34;Test User\u0026#34;, bio = \u0026#34;Test Bio\u0026#34;) testRepository.setProfile(testProfile) // Initial state  assertThat(viewModel.uiState.value) .isEqualTo(ProfileState()) // When  viewModel.onEvent(ProfileEvent.LoadProfile) // Then - Loading state  assertThat(viewModel.uiState.value.isLoading).isTrue() assertThat(viewModel.uiState.value.error).isNull() // Complete async work  advanceUntilIdle() // Then - Success state  with(viewModel.uiState.value) { assertThat(isLoading).isFalse() assertThat(name).isEqualTo(testProfile.name) assertThat(bio).isEqualTo(testProfile.bio) assertThat(error).isNull() } } @Test fun `load profile - error flow`() = runTest { // Given  testRepository.setShouldError(true) // When  viewModel.onEvent(ProfileEvent.LoadProfile) advanceUntilIdle() // Then  with(viewModel.uiState.value) { assertThat(isLoading).isFalse() assertThat(error).isNotNull() } } @Test fun `update name updates state immediately`() = runTest { // When  viewModel.onEvent(ProfileEvent.UpdateName(\u0026#34;New Name\u0026#34;)) // Then  assertThat(viewModel.uiState.value.name).isEqualTo(\u0026#34;New Name\u0026#34;) } } // UI tests verify the complete flow: // 1. Initial state rendering // 2. State updates reflection in UI // 3. User interaction handling @Test fun `profile screen shows loading indicator and then content`() { // Create test rule  composeTestRule.setContent { ProfileScreen(viewModel = viewModel) } // Verify initial loading state  composeTestRule.onNode(hasTestTag(\u0026#34;loading\u0026#34;)).assertIsDisplayed() // Complete loading  runTest { advanceUntilIdle() } // Verify content  composeTestRule.onNode(hasText(\u0026#34;Test User\u0026#34;)).assertIsDisplayed() composeTestRule.onNode(hasText(\u0026#34;Test Bio\u0026#34;)).assertIsDisplayed() // Test interaction  composeTestRule.onNode(hasText(\u0026#34;Save Profile\u0026#34;)).performClick() // Verify save event was handled  verify(viewModel).onEvent(ProfileEvent.SaveProfile) }   The combination of event-based state management and immutable states makes testing straightforward:\n Events provide clear entry points for testing state changes Immutable states make assertions simple and reliable State transitions are easy to verify UI tests can focus on state reflection and user interactions  Conclusion Effective state management in Jetpack Compose requires a combination of patterns and best practices:\n  Single Source of Truth\n Use immutable state classes to represent all possible states Keep state management centralized and predictable Make state changes explicit and traceable    State Immutability\n Prevent unintended modifications with immutable state Use data classes with copy for state updates Maintain thread safety and predictability    Event-Based Updates\n Define clear events for all state modifications Centralize state update logic Make state transitions explicit and testable    Testing Strategy\n Test state transitions thoroughly Verify UI updates reflect state changes Ensure proper event handling    By following these patterns, you\u0026rsquo;ll build Compose applications that are:\n More maintainable and easier to debug Less prone to state-related bugs Easier to test and verify More scalable as complexity grows  ","description":"Learn essential patterns for managing state in Jetpack Compose applications, including immutable state, event-based updates, and testing strategies","id":6,"section":"posts","tags":["android","compose","patterns","state"],"title":"State Management Patterns in Jetpack Compose","uri":"https://carrion.dev/en/posts/state-management-patterns-compose/"},{"content":"Building Type-safe DSLs with Kotlin: From Basics to Advanced Patterns Domain-Specific Languages (DSLs) in Kotlin allow you to create expressive, readable, and type-safe APIs. This article explores how to build effective DSLs using Kotlin\u0026rsquo;s powerful features, focusing on scope control with @DslMarker to prevent common mistakes in nested DSLs.\nBy the end of this article, you\u0026rsquo;ll understand:\n How to design clean and intuitive DSL APIs When and how to use @DslMarker for better scope control Best practices for maintaining type safety throughout your DSL Common pitfalls and how to avoid them  Basic DSL Concepts Let\u0026rsquo;s explore the fundamental concepts of Kotlin DSLs by building a simple HTML builder:\nHTML Builder DSL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  // Traditional way: manual string building val sb = StringBuilder() sb.append(\u0026#34;\u0026lt;div\u0026gt;\u0026#34;) sb.append(\u0026#34;\u0026lt;span\u0026gt;Hello\u0026lt;/span\u0026gt;\u0026#34;) sb.append(\u0026#34;\u0026lt;div\u0026gt;\u0026#34;) // Easy to make mistakes sb.append(\u0026#34;\u0026lt;span\u0026gt;Nested content\u0026lt;/span\u0026gt;\u0026#34;) sb.append(\u0026#34;\u0026lt;/div\u0026gt;\u0026#34;) // Which div are we closing? sb.append(\u0026#34;\u0026lt;/div\u0026gt;\u0026#34;) // Is the nesting correct?  // Using a DSL: structure mirrors HTML\u0026#39;s natural nesting val html = buildHtml { div { span { +\u0026#34;Hello\u0026#34; } div { span { +\u0026#34;Nested content\u0026#34; } } // Nesting is clear and enforced by the compiler  } } // The DSL implementation using Kotlin\u0026#39;s features class HtmlBuilder { private val content = StringBuilder() // Extension function with receiver: creates div { } blocks  fun div(block: HtmlBuilder.() -\u0026gt; Unit) { content.append(\u0026#34;\u0026lt;div\u0026gt;\u0026#34;) this.block() // \u0026#39;this\u0026#39; is the receiver (HtmlBuilder)  content.append(\u0026#34;\u0026lt;/div\u0026gt;\u0026#34;) } // Similar to div, creates span { } blocks  fun span(block: HtmlBuilder.() -\u0026gt; Unit) { content.append(\u0026#34;\u0026lt;span\u0026gt;\u0026#34;) this.block() content.append(\u0026#34;\u0026lt;/span\u0026gt;\u0026#34;) } // Operator overloading: allows +\u0026#34;text\u0026#34; syntax  operator fun String.unaryPlus() { content.append(this) } override fun toString() = content.toString() } // Entry point function that creates the DSL context fun buildHtml(block: HtmlBuilder.() -\u0026gt; Unit): String = HtmlBuilder().apply(block).toString()   This HTML builder demonstrates the fundamental concepts that make Kotlin DSLs powerful:\n Extension functions create a natural, fluent syntax Lambda receivers provide clear scoping and context Operator overloading enables convenient syntactic sugar Type safety prevents common mistakes at compile time  Scope Safety with @DslMarker When building DSLs with nested scopes, we need to ensure that method calls are unambiguous. Without proper scope control, it can be unclear which method is being called in nested contexts. Here\u0026rsquo;s an example of this problem:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class MenuDsl { fun item(text: String) { println(\u0026#34;Menu item: $text\u0026#34;) } fun submenu(block: MenuDsl.() -\u0026gt; Unit) { println(\u0026#34;Submenu start\u0026#34;) MenuDsl().block() println(\u0026#34;Submenu end\u0026#34;) } } fun menu(block: MenuDsl.() -\u0026gt; Unit) = MenuDsl().apply(block) // This code is ambiguous: menu { item(\u0026#34;Home\u0026#34;) submenu { item(\u0026#34;Settings\u0026#34;) // Which item() is this calling?  // Could be from either the outer or inner MenuDsl!  } }   Kotlin provides the @DslMarker annotation to solve this problem:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  @DslMarker annotation class MenuMarker @MenuMarker class MenuDsl { fun item(text: String) { println(\u0026#34;Menu item: $text\u0026#34;) } fun submenu(block: MenuDsl.() -\u0026gt; Unit) { println(\u0026#34;Submenu start\u0026#34;) MenuDsl().block() println(\u0026#34;Submenu end\u0026#34;) } } // Now the code is unambiguous: menu { item(\u0026#34;Home\u0026#34;) // Calls outer scope\u0026#39;s item()  submenu { item(\u0026#34;Settings\u0026#34;) // Calls inner scope\u0026#39;s item()  // Outer scope\u0026#39;s item() is not accessible here  } }   The @DslMarker annotation is a powerful tool that helps us build safer DSLs by preventing scope-related ambiguity. Now that we understand the basic concepts and safety features, let\u0026rsquo;s see how they\u0026rsquo;re applied in practice.\nReal-World Examples Kotlin\u0026rsquo;s ecosystem provides excellent examples of how DSLs can simplify complex APIs while maintaining type and scope safety. Let\u0026rsquo;s look at two different approaches:\nKotlin\u0026rsquo;s buildString Function The standard library starts with the basics: string manipulation. While a simple task, buildString shows how a well-designed DSL can make even common operations more elegant and less error-prone:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // Without DSL: explicit StringBuilder management val sb = StringBuilder() sb.append(\u0026#34;Hello, \u0026#34;) sb.appendLine(\u0026#34;World!\u0026#34;) sb.append(\u0026#34;The time is \u0026#34;) sb.append(System.currentTimeMillis()) val message = sb.toString() // With DSL: StringBuilder methods available directly val messageDsl = buildString { append(\u0026#34;Hello, \u0026#34;) appendLine(\u0026#34;World!\u0026#34;) append(\u0026#34;The time is \u0026#34;) append(System.currentTimeMillis()) }   The DSL is enabled by this simple yet powerful function in the standard library:\n1 2 3 4 5 6 7  // The actual implementation from Kotlin\u0026#39;s standard library public inline fun buildString(builderAction: StringBuilder.() -\u0026gt; Unit): String { contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) } return StringBuilder().apply(builderAction).toString() } // The contract helps the compiler ensure type safety in the DSL // by guaranteeing the builder action is called exactly once   Finally, let\u0026rsquo;s look at how these DSL concepts can be applied to complex real-world problems. Jetpack Compose\u0026rsquo;s LazyColumn is an excellent example of how a well-designed DSL can transform a complex UI component into an intuitive, declarative API:\nJetpack Compose LazyColumn While our previous examples dealt with text manipulation, LazyColumn tackles a more challenging problem: efficient scrolling lists with complex layouts and recycling. Despite this complexity, the DSL makes it remarkably simple to use:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  // The actual LazyColumn signature shows its complexity @Composable fun LazyColumn( modifier: Modifier = Modifier, state: LazyListState = rememberLazyListState(), contentPadding: PaddingValues = PaddingValues(0.dp), reverseLayout: Boolean = false, verticalArrangement: Arrangement.Vertical = if (!reverseLayout) Arrangement.Top else Arrangement.Bottom, horizontalAlignment: Alignment.Horizontal = Alignment.Start, flingBehavior: FlingBehavior = ScrollableDefaults.flingBehavior(), userScrollEnabled: Boolean = true, content: LazyListScope.() -\u0026gt; Unit // But the DSL makes it easy to use! ) { // Complex implementation with recycling, layout, animations... } // ...but the DSL makes it simple through this interface interface LazyListScope { // Add a single item to the list  fun item( key: Any? = null, contentType: Any? = null, content: @Composable () -\u0026gt; Unit ) // Add multiple items from a list  fun \u0026lt;T\u0026gt; items( items: List\u0026lt;T\u0026gt;, key: ((item: T) -\u0026gt; Any)? = null, contentType: (item: T) -\u0026gt; Any? = { null }, itemContent: @Composable (item: T) -\u0026gt; Unit ) } // Example: Using the DSL to create a complex list @Composable fun CategoryList(categories: List\u0026lt;String\u0026gt;) { LazyColumn { // Header section  item { Text(\u0026#34;Categories\u0026#34;) } // Dynamic items with custom keys  items\u0026lt;String\u0026gt;( items = categories, key = { category: String -\u0026gt; category } // Stable identity for animations  ) { category: String -\u0026gt; Text(\u0026#34;Category: $category\u0026#34;) } // Footer section  item { Text(\u0026#34;End of list\u0026#34;) } } } // The LazyColumn DSL demonstrates how Kotlin can: // - Hide complex configuration behind sensible defaults // - Transform verbose APIs into simple, focused interfaces // - Make powerful features (recycling, animations) easy to use // - Turn implementation complexity into developer-friendly APIs   Conclusion Building DSLs in Kotlin allows you to create powerful, expressive APIs that are both safe and intuitive to use. As we\u0026rsquo;ve seen through our examples, from a simple HTML builder to Jetpack Compose\u0026rsquo;s sophisticated UI components, well-designed DSLs can:\n  Improve Code Quality\n Transform verbose imperative code into clear, declarative expressions Make common patterns more readable and maintainable Hide implementation complexity behind intuitive interfaces    Ensure Safety\n Leverage Kotlin\u0026rsquo;s type system to prevent errors at compile time Use @DslMarker to prevent scope ambiguity Make invalid states and unsafe operations impossible    Scale with Complexity\n Start simple with basic builders like buildString Handle complex scenarios like LazyColumn\u0026rsquo;s recycling Maintain clarity even as functionality grows    The success of DSLs in Kotlin shows their versatility across different domains:\n Basic utilities (buildString) UI frameworks (Compose) Configuration systems Any API where clarity and safety matter  By understanding these patterns and tools, from extension functions to @DslMarker, you can create APIs that are not only powerful and safe but also a pleasure to use.\n","description":"Learn how to create type-safe Domain-Specific Languages (DSLs) in Kotlin using @DslMarker for better scope control","id":7,"section":"posts","tags":["kotlin","dsl","type-safety","design-patterns"],"title":"Building Type-safe DSLs with Kotlin: From Basics to Advanced Patterns","uri":"https://carrion.dev/en/posts/building-type-safe-dsls/"},{"content":"Advanced Generics and Variance in Kotlin: A Comprehensive Guide Understanding advanced generics and variance in Kotlin is crucial for writing type-safe, reusable code. This article explores these concepts in depth, providing practical examples and real-world applications.\nUnderstanding Variance Variance in Kotlin determines how generic types with different type arguments relate to each other. Understanding variance is easier when thinking in terms of producers and consumers:\n Producer: Only produces/provides values of type T (output) Consumer: Only consumes/accepts values of type T (input)  This producer/consumer relationship directly maps to the two types of variance:\n Covariance (out): Used for producers - only outputs values Contravariance (in): Used for consumers - only inputs values  Here\u0026rsquo;s how producers and consumers work with types:\nType Hierarchy: Producer\u0026lt;T\u0026gt; Consumer\u0026lt;T\u0026gt; Any ▲ can produce ▼ can consume └── Number │ more specific │ more general └── Int │ types │ types For producers (covariant, out): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  interface Producer\u0026lt;out T\u0026gt; { fun get(): T // OK: Producing/returning T  // fun set(item: T) {} // Error: Can\u0026#39;t consume T } // Simple producer implementation class IntProducer(private val value: Int) : Producer\u0026lt;Int\u0026gt; { override fun get(): Int = value } // Type safety with covariance: // 1. IntProducer.get() returns Int // 2. Int is a subtype of Number // 3. Therefore, it\u0026#39;s safe to use Producer\u0026lt;Int\u0026gt; as Producer\u0026lt;Number\u0026gt; val intProducer: Producer\u0026lt;Int\u0026gt; = IntProducer(42) val numberProducer: Producer\u0026lt;Number\u0026gt; = intProducer // Safe: Int is always a Number  // Without \u0026#39;out\u0026#39; modifier, this wouldn\u0026#39;t compile: // class RegularBox\u0026lt;T\u0026gt;(val item: T) // invariant // val intBox: RegularBox\u0026lt;Int\u0026gt; = RegularBox(42) // val numBox: RegularBox\u0026lt;Number\u0026gt; = intBox // Error: Type mismatch  // We can use the numberProducer wherever a Number is expected fun printNumber(producer: Producer\u0026lt;Number\u0026gt;) { println(\u0026#34;Number: ${producer.get()}\u0026#34;) // Safe: we know we\u0026#39;ll get a Number } printNumber(intProducer) // Works because Producer is covariant (out)   For consumers (contravariant, in): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  interface Consumer\u0026lt;in T\u0026gt; { fun set(item: T) // OK: Consuming/accepting T  // fun get(): T {} // Error: Can\u0026#39;t produce T } // Simple consumer implementation class NumberProcessor : Consumer\u0026lt;Number\u0026gt; { override fun set(item: Number) { println(\u0026#34;Processing number: ${item.toDouble()}\u0026#34;) } } // Type safety with contravariance: // 1. NumberProcessor.set() accepts any Number // 2. Int is a subtype of Number // 3. Therefore, it\u0026#39;s safe to use Consumer\u0026lt;Number\u0026gt; as Consumer\u0026lt;Int\u0026gt; val numberConsumer: Consumer\u0026lt;Number\u0026gt; = NumberProcessor() val intConsumer: Consumer\u0026lt;Int\u0026gt; = numberConsumer // Safe: anything that can handle Number can handle Int  // Without \u0026#39;in\u0026#39; modifier, this wouldn\u0026#39;t compile: // class Processor\u0026lt;T\u0026gt;(val process: (T) -\u0026gt; Unit) // invariant // val numProcessor: Processor\u0026lt;Number\u0026gt; = Processor { println(it) } // val intProcessor: Processor\u0026lt;Int\u0026gt; = numProcessor // Error: Type mismatch  // We can use the intConsumer with Int values fun processInt(consumer: Consumer\u0026lt;Int\u0026gt;) { consumer.set(42) // Safe: we know the consumer can handle any Number, including Int } processInt(numberConsumer) // Works because Consumer is contravariant (in)   The restrictions make sense because:\n A producer of Ints can safely produce them where Numbers are needed (every Int is a Number) A consumer of Numbers can safely consume Ints (it knows how to handle any Number)  Here\u0026rsquo;s a simple way to remember it:\n If a class only produces/returns T, make it covariant with out T (can use more specific types) If a class only consumes/accepts T, make it contravariant with in T (can use more general types) If a class both produces and consumes T, it should remain invariant (type must match exactly)  Invariance (Default) By default, generic types in Kotlin are invariant, meaning there\u0026rsquo;s no subtype relationship between different instantiations of the generic type.\n1 2 3 4 5 6  class Box\u0026lt;T\u0026gt;(var value: T) fun main() { val stringBox = Box(\u0026#34;Hello\u0026#34;) // val anyBox: Box\u0026lt;Any\u0026gt; = stringBox // This won\u0026#39;t compile }   Declaration-site vs Use-site Variance Kotlin supports two ways to specify variance: declaration-site variance (using in or out on the class/interface declaration) and use-site variance (using type projections). Each approach has its own use cases and benefits.\nDeclaration-site Variance Declaration-site variance is specified at the type parameter declaration of a class or interface. This approach is preferred when a class can only use the type parameter in one way throughout its entire implementation.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Declaration-site variance example interface Producer\u0026lt;out T\u0026gt; { fun produce(): T // Can only produce/return T  // fun consume(item: T) {} // Error: Can\u0026#39;t consume T in an out position } interface Consumer\u0026lt;in T\u0026gt; { fun consume(item: T) // Can only consume T  // fun produce(): T {} // Error: Can\u0026#39;t produce T in an in position } // Usage is straightforward - variance is handled automatically class StringProducer : Producer\u0026lt;String\u0026gt; { override fun produce(): String = \u0026#34;Hello\u0026#34; } val producer: Producer\u0026lt;Any\u0026gt; = StringProducer() // OK: String is more specific than Any   Use-site Variance Use-site variance (also known as type projection) is specified at the point of usage. This is useful when a type can be used both as a producer and consumer, but in a specific usage, you want to restrict it to one role.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // Class with invariant type parameter class Box\u0026lt;T\u0026gt;(var value: T) { fun get(): T = value fun set(value: T) { this.value = value } } // Use-site variance examples fun copyOut(from: Box\u0026lt;out Number\u0026gt;, to: MutableList\u0026lt;Number\u0026gt;) { // \u0026#39;from\u0026#39; is projected to be covariant (producer)  // Can only call methods that return Number  to.add(from.get()) // OK  // from.set(42) // Error: Can\u0026#39;t call set on projected type } fun copyIn(to: Box\u0026lt;in Number\u0026gt;, from: List\u0026lt;Int\u0026gt;) { // \u0026#39;to\u0026#39; is projected to be contravariant (consumer)  // Can only call methods that accept Number  to.set(from.first()) // OK  // val x: Number = to.get() // Error: Return type is projected to Nothing }   When to Use Each Approach   Use Declaration-site Variance When:\n The class can only use the type parameter in one way (only produce or only consume) You want to enforce the usage pattern across all usages of the class The API design is clear about its variance requirements    Use Use-site Variance When:\n The class needs to both produce and consume the type in general You want to restrict variance at specific usage points You need flexibility in how the type is used in different contexts    Generic Constraints Kotlin allows you to specify upper bounds for type parameters, restricting what types can be used.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  interface Drawable { fun draw() } class Canvas\u0026lt;T : Drawable\u0026gt; { fun drawAll(elements: List\u0026lt;T\u0026gt;) { elements.forEach { it.draw() } } } class Circle : Drawable { override fun draw() = println(\u0026#34;Drawing Circle\u0026#34;) } val canvas = Canvas\u0026lt;Circle\u0026gt;() canvas.drawAll(listOf(Circle(), Circle()))   Multiple Constraints You can specify multiple constraints using where clause:\n1 2 3 4 5 6 7 8 9  fun \u0026lt;T\u0026gt; copyWhenBothValid( source: T, destination: T ) where T : Drawable, T : Comparable\u0026lt;T\u0026gt; { if (source \u0026gt; destination) { destination.draw() } }   Best Practices and Guidelines  Use out when your class only produces values of type T Use in when your class only consumes values of type T Use invariance when your class both produces and consumes values of type T Prefer declaration-site variance (out/in on the class) over use-site variance when possible  Conclusion Advanced generics and variance in Kotlin provide powerful tools for building type-safe, reusable abstractions. By understanding these concepts and applying them appropriately, you can write more robust and maintainable code. Remember to:\n Use variance modifiers (out/in) when appropriate Apply generic constraints to ensure type safety Consider both declaration-site and use-site variance Be mindful of type erasure and nullability  The proper use of these features leads to more elegant and safer code, reducing the likelihood of runtime errors and making your codebase more maintainable.\n","description":"Master Kotlin's advanced generic types and variance concepts with practical examples and real-world applications","id":8,"section":"posts","tags":["kotlin","generics","variance","type-safety"],"title":"Advanced Generics and Variance in Kotlin: A Comprehensive Guide","uri":"https://carrion.dev/en/posts/advanced-kotlin-generics/"},{"content":"Flow Composition Patterns: Combining Multiple Flows Effectively When working with Kotlin Flows in real-world applications, you often need to combine multiple data streams to create more complex workflows. This article explores various Flow composition patterns and best practices for effectively combining multiple Flows.\nUnderstanding Flow Composition Flow composition is the process of combining multiple Flows to create a new Flow that represents a more complex data stream. Kotlin provides several operators for Flow composition, each serving different use cases.\nBasic Flow Composition Operators Let\u0026rsquo;s start with the fundamental Flow composition operators:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Sample data sources val priceUpdates = flow { emit(10.0) delay(100) emit(11.0) } val quantityUpdates = flow { emit(5) delay(200) emit(6) } // Combining latest values from both flows val totalValueFlow = combine(priceUpdates, quantityUpdates) { price: Double, quantity: Int -\u0026gt; price * quantity }   Output:\n50.0 // 10.0 * 5 66.0 // 11.0 * 6 Zip vs Combine The zip and combine operators serve different purposes and have distinct behaviors when working with multiple flows:\nZip Operator  Pairs values strictly one-to-one from each flow Waits for all flows to emit before producing a result If one flow emits slower, it creates back-pressure Useful when you need to match corresponding values from different flows If one flow completes, the resulting flow also completes  Combine Operator  Uses the latest value from each flow to produce results Emits whenever any flow produces a new value No back-pressure - uses the most recent value from other flows Useful for real-time updates where you need the latest state Continues until all flows complete  Here\u0026rsquo;s a practical example showing the difference:\n1 2 3 4 5 6 7 8 9  // zip: Pairs corresponding values (one-to-one) val zippedFlow = priceUpdates.zip(quantityUpdates) { price: Double, quantity: Int -\u0026gt; \u0026#34;Price: $price, Quantity: $quantity\u0026#34; } // combine: Emits when either flow emits (using latest values) val combinedFlow = combine(priceUpdates, quantityUpdates) { price: Double, quantity: Int -\u0026gt; \u0026#34;Latest Price: $price, Latest Quantity: $quantity\u0026#34; }   Let\u0026rsquo;s see how they behave with different timing:\n1 2 3 4 5 6 7 8 9 10 11 12 13  val prices = flow { emit(10.0) // t=0ms  delay(100) emit(11.0) // t=100ms  delay(100) emit(12.0) // t=200ms } val quantities = flow { emit(5) // t=0ms  delay(150) emit(6) // t=150ms }   Output for zippedFlow (pairs values in order):\n\u0026quot;Price: 10.0, Quantity: 5\u0026quot; // First pair \u0026quot;Price: 11.0, Quantity: 6\u0026quot; // Second pair // 12.0 is never emitted because quantities has no more values Output for combinedFlow (reacts to each change):\n\u0026quot;Latest Price: 10.0, Latest Quantity: 5\u0026quot; // Initial values \u0026quot;Latest Price: 11.0, Latest Quantity: 5\u0026quot; // Price updated at t=100ms \u0026quot;Latest Price: 11.0, Latest Quantity: 6\u0026quot; // Quantity updated at t=150ms \u0026quot;Latest Price: 12.0, Latest Quantity: 6\u0026quot; // Price updated at t=200ms This example shows how:\n zip matches values in sequence and requires both flows to emit combine reacts to changes in either flow and uses the latest available values zip might skip values if flows emit at different rates combine ensures you always work with the most recent data  Advanced Composition Patterns Merging Multiple Flows The merge operator combines multiple flows into a single flow, preserving the relative timing of emissions from each source. Unlike zip or combine, merge simply forwards values as they arrive, without attempting to pair or combine them.\nKey Characteristics of Merge  Emits values as soon as they arrive from any source flow Maintains the order of emissions within each source flow Doesn\u0026rsquo;t wait for or combine values from different flows Completes only when all source flows complete Useful for handling independent events from multiple sources  Here\u0026rsquo;s how merge works with multiple event sources:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  val userActions = merge( buttonClicks, menuSelections, gestureEvents ) // Alternative using Flow builder val mergedFlow = flow { coroutineScope { launch { buttonClicks.collect { emit(it) } } launch { menuSelections.collect { emit(it) } } launch { gestureEvents.collect { emit(it) } } } }   Let\u0026rsquo;s see how merge handles events with different timing:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  val clickEvents = flow { emit(\u0026#34;Click 1\u0026#34;) // t=0ms  delay(100) emit(\u0026#34;Click 2\u0026#34;) // t=100ms } val keyEvents = flow { delay(50) emit(\u0026#34;Key A\u0026#34;) // t=50ms  delay(100) emit(\u0026#34;Key B\u0026#34;) // t=150ms } val gestureEvents = flow { delay(75) emit(\u0026#34;Swipe\u0026#34;) // t=75ms } val allEvents = merge(clickEvents, keyEvents, gestureEvents)   Output (events in order of arrival):\n\u0026quot;Click 1\u0026quot; // t=0ms (from clickEvents) \u0026quot;Key A\u0026quot; // t=50ms (from keyEvents) \u0026quot;Swipe\u0026quot; // t=75ms (from gestureEvents) \u0026quot;Click 2\u0026quot; // t=100ms (from clickEvents) \u0026quot;Key B\u0026quot; // t=150ms (from keyEvents) Common Use Cases for Merge:\n Event Handling: Combining user interactions from different sources Multi-source Updates: Monitoring changes from multiple independent data sources Parallel Processing: Collecting results from parallel operations System Monitoring: Aggregating logs or metrics from multiple components  The alternative implementation using a Flow builder shows how merge works internally:\nError Handling in Composed Flows When working with composed flows, error handling becomes particularly important as errors can propagate through the flow chain and affect multiple data sources. There are several strategies for handling errors in composed flows:\n1. Individual Flow Error Handling Each flow can handle its own errors before composition:\n1 2 3 4 5 6 7 8 9 10 11  val safeFlow1 = flow1.catch { error: Throwable -\u0026gt; emit(fallbackValue) // or  emit(Result.failure\u0026lt;String\u0026gt;(error)) } val safeFlow2 = flow2.catch { error: Throwable -\u0026gt; // Log error and emit default value  logger.error(\u0026#34;Flow 2 failed\u0026#34;, error) emit(defaultValue) }   2. Error Transformation in Composed Flows Transform errors into domain-specific results:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  sealed class DataResult\u0026lt;T\u0026gt; { data class Success\u0026lt;T\u0026gt;(val data: T) : DataResult\u0026lt;T\u0026gt;() data class Error\u0026lt;T\u0026gt;(val error: Throwable) : DataResult\u0026lt;T\u0026gt;() } fun \u0026lt;T\u0026gt; Flow\u0026lt;T\u0026gt;.asResult(): Flow\u0026lt;DataResult\u0026lt;T\u0026gt;\u0026gt; = map { value: T -\u0026gt; DataResult.Success(value) }.catch { e: Throwable -\u0026gt; emit(DataResult.Error\u0026lt;T\u0026gt;(e)) } // Usage in composition val combinedFlow = combine( flow1.asResult(), flow2.asResult() ) { result1: DataResult\u0026lt;Data1\u0026gt;, result2: DataResult\u0026lt;Data2\u0026gt; -\u0026gt; when { result1 is DataResult.Error\u0026lt;Data1\u0026gt; -\u0026gt; result1 as DataResult\u0026lt;CombinedData\u0026gt; result2 is DataResult.Error\u0026lt;Data2\u0026gt; -\u0026gt; result2 as DataResult\u0026lt;CombinedData\u0026gt; else -\u0026gt; DataResult.Success( combineData( (result1 as DataResult.Success\u0026lt;Data1\u0026gt;).data, (result2 as DataResult.Success\u0026lt;Data2\u0026gt;).data ) ) } }   3. Using Result Type for Error Handling A common pattern using Kotlin\u0026rsquo;s Result type:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  fun combineDataSources(): Flow\u0026lt;Result\u0026lt;CombinedData\u0026gt;\u0026gt; = combine( source1.catch { emit(Result.failure(it)) }, source2.catch { emit(Result.failure(it)) } ) { result1: Result\u0026lt;Data1\u0026gt;, result2: Result\u0026lt;Data2\u0026gt; -\u0026gt; when { result1.isFailure -\u0026gt; result1 as Result\u0026lt;CombinedData\u0026gt; result2.isFailure -\u0026gt; result2 as Result\u0026lt;CombinedData\u0026gt; else -\u0026gt; Result.success( CombinedData( result1.getOrNull()!!, result2.getOrNull()!! ) ) } }   4. Retry Strategies Implement retry logic for transient failures:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  fun \u0026lt;T\u0026gt; Flow\u0026lt;T\u0026gt;.retryWithBackoff( maxAttempts: Int = 3, initialDelay: Long = 100, maxDelay: Long = 1000, factor: Double = 2.0 ): Flow\u0026lt;T\u0026gt; = retry { cause: Throwable, attempt: Long -\u0026gt; if (attempt \u0026lt; maxAttempts) { delay( (initialDelay * factor.pow(attempt.toDouble())) .toLong().coerceAtMost(maxDelay) ) true } else false } // Usage in composed flows val resilientFlow = combine( flow1.retryWithBackoff(), flow2.retryWithBackoff() ) { value1: Data1, value2: Data2 -\u0026gt; // Process values  CombinedData(value1, value2) }   Best Practices for Error Handling in Composed Flows:   Handle Errors Close to Source:\n Catch errors in individual flows before composition Transform errors into domain-specific results Provide fallback values when appropriate    Error Recovery Strategies:\n Implement retry logic for transient failures Use backoff strategies to avoid overwhelming systems Consider providing default or cached values    Error Propagation:\n Decide whether to propagate or handle errors locally Use structured error types (sealed classes, Result type) Maintain error context through the flow chain    Monitoring and Debugging:\n Log errors with appropriate context Track error rates and patterns Implement proper error reporting    Performance Considerations When combining Flows, consider these performance optimization techniques:\n Buffer Management:  1 2 3 4 5  val optimizedFlow = flow1 .buffer(Channel.BUFFERED) .combine(flow2.buffer(Channel.BUFFERED)) { value1: T1, value2: T2 -\u0026gt; // Process values  }   Conflation for Latest Values:  1 2 3 4 5  val conflatedFlow = flow1 .conflate() .combine(flow2.conflate()) { value1: T1, value2: T2 -\u0026gt; // Process only latest values  }   Conclusion Flow composition is a powerful feature that allows you to build complex reactive streams in Kotlin. By understanding these patterns and best practices, you can effectively combine multiple Flows while maintaining clean, maintainable, and performant code. Remember to:\n Choose the right composition operator for your use case Handle errors appropriately at each level Consider performance implications Implement proper cancellation handling  These patterns will help you build robust applications that can handle complex data flows effectively.\n","description":"Learn how to effectively combine multiple Kotlin Flows using various composition patterns and best practices for building complex flow pipelines","id":9,"section":"posts","tags":["kotlin","coroutines","flows","patterns"],"title":"Flow Composition Patterns: Combining Multiple Flows Effectively","uri":"https://carrion.dev/en/posts/flow-composition-patterns/"},{"content":"Understanding Flow Operators: Buffer, Conflate, Debounce, and Sample When working with Kotlin Flows, especially in scenarios involving fast-emitting producers and slow collectors, it\u0026rsquo;s crucial to understand how to manage the flow of data effectively. This post explores four essential Flow operators that help handle such scenarios: buffer, conflate, debounce, and sample.\nThe Problem: Slow Collectors Before diving into the operators, let\u0026rsquo;s understand the problem they solve. Consider this scenario:\n1 2 3 4 5 6 7 8 9  flow { for (i in 1..100) { emit(i) delay(100) // Emit every 100ms  } }.collect { value: Int -\u0026gt; delay(300) // Process for 300ms  println(\u0026#34;Processed $value\u0026#34;) }   In this case, the collector is slower than the producer, which can lead to backpressure issues. Each operator we\u0026rsquo;ll discuss provides a different strategy to handle this situation.\nBuffer Operator The buffer operator creates a channel of specified capacity to store emissions while the collector processes previous values.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  flow { for (i in 1..5) { emit(i) println(\u0026#34;Emitting $i\u0026#34;) delay(100) } }.buffer(2) // Buffer capacity of 2  .collect { value: Int -\u0026gt; println(\u0026#34;Collecting $value\u0026#34;) delay(300) // Slow collector } // Output: // Emitting 1 // Emitting 2 // Emitting 3 // Collecting 1 (t=300ms) // Collecting 2 (t=600ms) // Emitting 4 // Emitting 5 // Collecting 3 (t=900ms) // Collecting 4 (t=1200ms) // Collecting 5 (t=1500ms)   When to Use Buffer  When you want to store a specific number of emissions When you need to process all values but want to decouple producer and collector speeds When order of processing is important  Conflate Operator The conflate operator keeps only the latest value, dropping intermediate ones if the collector can\u0026rsquo;t keep up.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  flow { for (i in 1..5) { emit(i) println(\u0026#34;Emitting $i\u0026#34;) delay(100) } }.conflate() .collect { value: Int -\u0026gt; println(\u0026#34;Collecting $value\u0026#34;) delay(300) // Slow collector } // Output: // Emitting 1 // Emitting 2 // Collecting 1 (t=300ms) // Emitting 3 // Emitting 4 // Collecting 4 (t=600ms) // Emitting 5 // Collecting 5 (t=900ms)   When to Use Conflate  When you only care about the most recent value In UI scenarios where showing intermediate states isn\u0026rsquo;t necessary When processing every value isn\u0026rsquo;t critical  Debounce Operator The debounce operator emits a value only after a specified time has passed without new emissions.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  flow { emit(1) delay(90) emit(2) // Will be dropped  delay(90) emit(3) // Will be dropped  delay(150) // Longer than debounce timeout  emit(4) // Will be emitted }.debounce(100) .collect { value: Int -\u0026gt; println(\u0026#34;Collecting $value\u0026#34;) } // Output: // Collecting 1 (t=100ms) // Collecting 4 (t=430ms) // (Values 2 and 3 are dropped because new values arrived before debounce timeout)   When to Use Debounce  For search-as-you-type functionality When handling rapid UI events When you want to wait for \u0026ldquo;quiet periods\u0026rdquo; before processing  Sample Operator The sample operator periodically samples the most recent value from the flow at specified intervals.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  flow { var i = 0 while (i \u0026lt; 10) { emit(i++) delay(50) // Emit every 50ms  } }.sample(100) // Sample every 100ms  .collect { value: Int -\u0026gt; println(\u0026#34;Sampled value: $value\u0026#34;) } // Output: // Sampled value: 1 (t=100ms) // Sampled value: 3 (t=200ms) // Sampled value: 5 (t=300ms) // Sampled value: 7 (t=400ms) // Sampled value: 9 (t=500ms) // (Only captures the latest value every 100ms)   When to Use Sample  When you need regular updates at fixed intervals For displaying real-time data where intermediate values aren\u0026rsquo;t crucial When you want to limit the rate of processing regardless of emission rate  Comparison and Best Practices Here\u0026rsquo;s a quick comparison of these operators:\n   Operator Behavior Use Case     buffer Stores emissions Process all values, maintain order   conflate Keeps latest only UI updates, latest-value-only scenarios   debounce Waits for quiet period Search-as-you-type, rapid event handling   sample Takes periodic snapshots Regular updates, rate limiting    Conclusion Understanding these Flow operators is crucial for building efficient reactive applications:\n Use buffer when you need to process all values and control memory usage Use conflate when only the latest value matters Use debounce when handling rapid events that need \u0026ldquo;settling time\u0026rdquo; Use sample when you need regular updates at fixed intervals  Choose the appropriate operator based on your specific use case and requirements regarding data completeness, order, and processing rate.\nRemember that these operators can be combined to create more sophisticated data processing pipelines, but be careful not to over-complicate your flows. Always consider the trade-offs between data completeness, memory usage, and processing efficiency.\n","description":"Deep dive into Kotlin Flow operators: buffer, conflate, debounce, and sample. Learn when and how to use each operator with practical examples.","id":10,"section":"posts","tags":["kotlin","flows","coroutines"],"title":"Understanding Flow Operators: Buffer, Conflate, Debounce, and Sample","uri":"https://carrion.dev/en/posts/flow-operators-buffer-conflate/"},{"content":"Converting Callbacks to Coroutines and Flows in Kotlin Callback-based APIs have been a common pattern in asynchronous programming for many years. However, with Kotlin\u0026rsquo;s coroutines and flows, we can transform these callbacks into more modern, sequential code that\u0026rsquo;s easier to read and maintain. In this article, we\u0026rsquo;ll explore how to use suspendCoroutine and callbackFlow to convert callback-based APIs into coroutines and flows.\nUnderstanding suspendCoroutine The suspendCoroutine function is a powerful tool that allows you to wrap callback-based APIs into suspend functions. This transformation makes asynchronous code more sequential and easier to handle.\nBasic Usage of suspendCoroutine Here\u0026rsquo;s a simple example of converting a callback-based function to a suspend function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // Traditional callback-based API interface LocationCallback { fun onLocationFound(location: Location) fun onError(error: Exception) } class LocationService { fun getCurrentLocation(callback: LocationCallback) { // Simulating async location fetch  // Implementation details...  } } // Converted to suspend function suspend fun LocationService.getLocationSuspend(): Location { return suspendCoroutine\u0026lt;Location\u0026gt; { continuation: Continuation\u0026lt;Location\u0026gt; -\u0026gt; getCurrentLocation(object : LocationCallback { override fun onLocationFound(location: Location) { continuation.resume(location) } override fun onError(error: Exception) { continuation.resumeWithException(error) } }) } } // Usage suspend fun fetchLocation() { try { val location = locationService.getLocationSuspend() println(\u0026#34;Location received: $location\u0026#34;) } catch (e: Exception) { println(\u0026#34;Error getting location: ${e.message}\u0026#34;) } }   Handling Cancellation When working with suspendCoroutine, it\u0026rsquo;s important to handle cancellation properly:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  suspend fun LocationService.getLocationSuspendWithCancellation(): Location { return suspendCancellableCoroutine\u0026lt;Location\u0026gt; { continuation: CancellableContinuation\u0026lt;Location\u0026gt; -\u0026gt; val callback = object : LocationCallback { override fun onLocationFound(location: Location) { continuation.resume(location) } override fun onError(error: Exception) { continuation.resumeWithException(error) } } getCurrentLocation(callback) continuation.invokeOnCancellation { // Cleanup resources, remove callbacks, etc.  removeLocationUpdates(callback) } } }   Converting to Flows with callbackFlow While suspendCoroutine is great for one-shot operations, callbackFlow is perfect for handling streams of data or events. It allows you to convert callback-based APIs that emit multiple values into Kotlin Flows.\nBasic callbackFlow Example Here\u0026rsquo;s how to convert a location updates API to a Flow:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  interface LocationUpdatesCallback { fun onLocationUpdate(location: Location) fun onError(error: Exception) } class LocationService { fun startLocationUpdates(callback: LocationUpdatesCallback) { // Implementation details...  } fun stopLocationUpdates(callback: LocationUpdatesCallback) { // Implementation details...  } } fun LocationService.locationUpdatesFlow(): Flow\u0026lt;Location\u0026gt; = callbackFlow { val callback = object : LocationUpdatesCallback { override fun onLocationUpdate(location: Location) { trySend(location) } override fun onError(error: Exception) { close(error) } } startLocationUpdates(callback) // Clean up when the flow is cancelled  awaitClose { stopLocationUpdates(callback) } } // Usage suspend fun trackLocation() { locationService.locationUpdatesFlow() .catch { error: Throwable -\u0026gt; println(\u0026#34;Error in location updates: ${error.message}\u0026#34;) } .collect { location: Location -\u0026gt; println(\u0026#34;New location: $location\u0026#34;) } }   Handling Backpressure When dealing with frequent updates, it\u0026rsquo;s important to handle backpressure properly:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  fun SensorService.sensorUpdatesFlow(): Flow\u0026lt;SensorData\u0026gt; = callbackFlow { val callback = object : SensorCallback { override fun onSensorUpdate(data: SensorData) { // Use trySend instead of send to handle backpressure  if (!trySend(data).isSuccess) { // Handle unsuccessful send  println(\u0026#34;Buffer full, dropping sensor update\u0026#34;) } } } registerSensorCallback(callback) awaitClose { unregisterSensorCallback(callback) } }.buffer(Channel.CONFLATED) // Keep only the latest value   Best Practices   Error Handling\n Always handle errors appropriately in both suspendCoroutine and callbackFlow Use try-catch blocks for suspendCoroutine Use catch operator for flows    Resource Management\n Clean up resources in awaitClose for callbackFlow Use suspendCancellableCoroutine when cancellation handling is needed    Backpressure Considerations\n Choose appropriate buffer strategies for your use case Consider using conflated or buffered channels based on your needs    Testing\n Write tests for both success and error scenarios Test cancellation behavior Verify resource cleanup    Common Patterns and Examples Timeout Handling 1 2 3 4 5 6 7 8 9 10 11 12 13 14  suspend fun apiCallWithTimeout(): Result\u0026lt;String\u0026gt; = withTimeout(5000L) { suspendCoroutine\u0026lt;Result\u0026lt;String\u0026gt;\u0026gt; { continuation: Continuation\u0026lt;Result\u0026lt;String\u0026gt;\u0026gt; -\u0026gt; api.call(object : ApiCallback { override fun onSuccess(result: Result\u0026lt;String\u0026gt;) { continuation.resume(result) } override fun onError(error: Exception) { continuation.resumeWithException(error) } }) } }   Combining Multiple Callbacks 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  fun MultipleSourceService.combinedUpdatesFlow(): Flow\u0026lt;Update\u0026gt; = callbackFlow { val callback1 = object : SourceCallback { override fun onUpdate(data: Update) { trySend(data) } } val callback2 = object : SourceCallback { override fun onUpdate(data: Update) { trySend(data) } } registerCallbacks(callback1, callback2) awaitClose { unregisterCallbacks(callback1, callback2) } }.buffer(Channel.BUFFERED)   Conclusion Converting callback-based APIs to coroutines and flows can significantly improve code readability and maintainability. By using suspendCoroutine for one-shot operations and callbackFlow for streams of data, you can modernize legacy code and take full advantage of Kotlin\u0026rsquo;s powerful concurrency features.\nRemember to always handle errors appropriately, manage resources properly, and consider backpressure when dealing with high-frequency updates. With these tools and patterns, you can effectively bridge the gap between callback-based APIs and modern Kotlin concurrency.\n","description":"Learn how to transform callback-based APIs into modern Kotlin coroutines and flows using suspendCoroutine and callbackFlow","id":11,"section":"posts","tags":["kotlin","coroutines","flows","callbacks"],"title":"Converting Callbacks to Coroutines and Flows in Kotlin","uri":"https://carrion.dev/en/posts/callback-to-flow-conversion/"},{"content":"Understanding Hot and Cold Flows in Kotlin Kotlin Flow is a powerful feature for handling reactive streams of data. One of the fundamental concepts to understand when working with flows is the distinction between hot and cold flows. This article will explain the differences and provide practical examples of both types.\nCold Flows: The Default Behavior Cold flows are the default type in Kotlin Flow. They start producing values only when a collector starts collecting from them. Each collector gets its own independent stream of values from scratch.\nCharacteristics of Cold Flows:  Start producing values only when collected Each collector receives all values from the beginning Values are produced independently for each collector Resources are not shared between collectors  Here\u0026rsquo;s an example of a cold flow:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  fun numbers(): Flow\u0026lt;Int\u0026gt; = flow { println(\u0026#34;Flow started\u0026#34;) for (i in 1..3) { delay(100) emit(i) } } suspend fun main() { val numbersFlow = numbers() // First collector  println(\u0026#34;First collector starting\u0026#34;) numbersFlow.collect { value: Int -\u0026gt; println(\u0026#34;Collector 1: $value\u0026#34;) } // Second collector  println(\u0026#34;Second collector starting\u0026#34;) numbersFlow.collect { value: Int -\u0026gt; println(\u0026#34;Collector 2: $value\u0026#34;) } }   Output:\nFirst collector starting Flow started Collector 1: 1 Collector 1: 2 Collector 1: 3 Second collector starting Flow started Collector 2: 1 Collector 2: 2 Collector 2: 3 Hot Flows: Shared State and Events Hot flows, on the other hand, may start producing values regardless of collectors and can share the same stream of values between multiple collectors. They\u0026rsquo;re useful for representing real-time events or shared state.\nTypes of Hot Flows:  StateFlow: For representing state SharedFlow: For representing events  StateFlow Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class TemperatureSensor { private val _temperature = MutableStateFlow(20.0) // Initial temperature  val temperature: StateFlow\u0026lt;Double\u0026gt; = _temperature.asStateFlow() fun updateTemperature(newTemp: Double) { _temperature.update { newTemp } } } suspend fun main() { val sensor = TemperatureSensor() // First collector  launch { sensor.temperature.collect { temp: Double -\u0026gt; println(\u0026#34;Display 1: $temp°C\u0026#34;) } } delay(100) println(\u0026#34;Updating temperature to 22.5°C\u0026#34;) sensor.updateTemperature(22.5) delay(100) // Late collector - will only see the current value (22.5) and future updates  launch { println(\u0026#34;Display 2 starting collection...\u0026#34;) sensor.temperature.collect { temp: Double -\u0026gt; println(\u0026#34;Display 2: $temp°C\u0026#34;) } } delay(100) println(\u0026#34;Updating temperature to 23.0°C\u0026#34;) sensor.updateTemperature(23.0) }   Output:\nDisplay 1: 20.0°C Updating temperature to 22.5°C Display 1: 22.5°C Display 2 starting collection... Display 2: 22.5°C Updating temperature to 23.0°C Display 1: 23.0°C Display 2: 23.0°C SharedFlow Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class EventBus { private val _events = MutableSharedFlow\u0026lt;String\u0026gt;() val events = _events.asSharedFlow() suspend fun emit(event: String) { _events.emit(event) } } suspend fun main() { val eventBus = EventBus() // First subscriber  launch { eventBus.events.collect { event: String -\u0026gt; println(\u0026#34;Subscriber 1: $event\u0026#34;) } } delay(100) println(\u0026#34;Emitting first event\u0026#34;) eventBus.emit(\u0026#34;User logged in\u0026#34;) delay(100) // Late subscriber - will miss the \u0026#34;User logged in\u0026#34; event  launch { println(\u0026#34;Subscriber 2 starting collection...\u0026#34;) eventBus.events.collect { event: String -\u0026gt; println(\u0026#34;Subscriber 2: $event\u0026#34;) } } delay(100) println(\u0026#34;Emitting second event\u0026#34;) eventBus.emit(\u0026#34;Data updated\u0026#34;) }   Output:\nSubscriber 1: User logged in Subscriber 2 starting collection... Emitting second event Subscriber 1: Data updated Subscriber 2: Data updated Key Differences Between Hot and Cold Flows   Execution Timing\n Cold: Executes per collector Hot: Can execute independently of collectors    Value Sharing\n Cold: Each collector gets its own stream Hot: Multiple collectors share the same stream    Resource Usage\n Cold: Resources allocated per collector Hot: Resources shared between collectors    Use Cases\n Cold: Data transformations, database queries Hot: UI states, real-time events, broadcasts    When to Use Each Type Use Cold Flows When:  Each collector needs its own independent stream You\u0026rsquo;re performing resource-intensive operations You need to restart the stream from the beginning for each collector  Use Hot Flows When:  Multiple parts of your app need the same data stream You\u0026rsquo;re dealing with UI state management You need to broadcast events to multiple subscribers You want to share resources between collectors  Best Practices   Cold Flows\n Use for operations that should be executed independently Consider using buffer() for performance optimization Clean up resources in onCompletion    Hot Flows\n Use StateFlow for state management Use SharedFlow for events Consider replay and buffer sizes carefully Handle backpressure appropriately    By understanding these differences, you can choose the right type of flow for your specific use case and create more efficient and maintainable reactive streams in your Kotlin applications.\n","description":"A comprehensive guide to understanding the differences between hot and cold flows in Kotlin, with practical examples","id":12,"section":"posts","tags":["kotlin","coroutines","flows"],"title":"Understanding Hot and Cold Flows in Kotlin","uri":"https://carrion.dev/en/posts/kotlin-flows-hot-cold/"},{"content":"Achieving Compile-Time Safety in Koin: A Comprehensive Guide Dependency injection is a fundamental pattern in modern Android development, but how can we ensure our DI configuration is correct before running the app? In this post, we\u0026rsquo;ll explore two powerful approaches to achieve compile-time safety with Koin: using the DSL\u0026rsquo;s verify() function and leveraging Koin Annotations with KSP.\nThe Problem: Runtime vs. Compile-Time Validation Traditional dependency injection often reveals configuration issues only at runtime:\n Missing dependencies cause crashes Circular dependencies aren\u0026rsquo;t detected until runtime Type mismatches surface when the app is running Wrong scoping leads to unexpected behavior  These issues can be particularly problematic in large applications where dependency graphs are complex and not all paths are covered by tests.\nSolution 1: Koin DSL with verify() The first approach uses Koin\u0026rsquo;s built-in verify() function to check module configurations during the compilation phase.\nHow It Works 1 2 3 4 5 6 7 8 9 10 11 12  val appModule = module { single\u0026lt;Repository\u0026gt; { DefaultRepository() } factory { UseCase(get()) } viewModel { MainViewModel(get()) } } class ModuleCheck { @Test fun verifyKoinModules() { appModule.verify() } }   By creating a unit test that calls verify() on your modules and making it part of your build process, you can catch common issues early.\nAdvantages  Simple to implement No additional dependencies required Works with existing Koin DSL code Can be integrated into CI/CD pipelines  Limitations  Requires explicit test execution Less IDE support No direct compilation errors Can\u0026rsquo;t catch all potential issues  Solution 2: Koin Annotations with KSP The second approach uses Kotlin Symbol Processing (KSP) and Koin\u0026rsquo;s annotation system to validate dependency graphs during compilation.\nSetup 1 2 3 4 5 6 7 8 9 10 11 12 13  // build.gradle.kts plugins { id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;2.1.10-1.0.31\u0026#34; } dependencies { implementation(\u0026#34;io.insert-koin:koin-annotations:2.0.0-RC5\u0026#34;) ksp(\u0026#34;io.insert-koin:koin-ksp-compiler:2.0.0-RC5\u0026#34;) } ksp { arg(\u0026#34;KOIN_CONFIG_CHECK\u0026#34;, \u0026#34;true\u0026#34;) }   How It Works Instead of using the DSL, you define dependencies using annotations:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  @SingleOf(binds = [Repository::class]) class DefaultRepository : Repository { // Implementation } @Module class AppModule { @Factory fun provideUseCase(repository: Repository): UseCase { return UseCase(repository) } } @Module class ViewModelModule { @KoinViewModel fun provideMainViewModel( useCase: UseCase ): MainViewModel = MainViewModel(useCase) }   KSP processes these annotations during compilation and:\n Generates type-safe dependency definitions Validates the dependency graph Ensures all dependencies can be resolved Checks for circular dependencies Verifies scope consistency  Advantages  True compile-time validation Better IDE support More explicit dependency declarations Catches issues during compilation Type-safe by design  Limitations  Requires additional setup More verbose than DSL Requires migration from DSL-based code  Comparing the Approaches    Feature DSL + verify() Annotations + KSP     Setup Complexity Low Medium   Validation Timing Build-time (via tests) Compile-time   IDE Support Limited Good   Migration Effort Low Medium   Type Safety Good Excellent   Error Messages Test failures Compilation errors   Learning Curve Gentle Moderate    Which Approach Should You Choose? Choose DSL + verify() if:  You have an existing Koin DSL codebase You want a simple solution You prefer more flexible configuration You\u0026rsquo;re comfortable with test-based validation  Choose Annotations + KSP if:  You\u0026rsquo;re starting a new project You want true compile-time safety You prefer explicit dependency declarations You value IDE support and type safety  Best Practices Regardless of the approach you choose:\n  Make validation part of your build process\n For DSL: Include verification tests in your build For Annotations: Enable KSP validation    Document your dependency graph\n Keep a clear structure of modules Document scope decisions Maintain a clean architecture    Monitor build times\n Both approaches can impact build times KSP processing adds to compilation time Test execution adds to build time    Consider gradual migration\n You can mix both approaches Migrate gradually from DSL to annotations Start with new features using your chosen approach    Conclusion Both approaches offer valuable ways to achieve compile-time safety in your Koin dependency injection. The DSL with verify() provides a simpler, test-based approach, while annotations with KSP offer stronger compile-time guarantees with better tooling support.\nChoose the approach that best fits your project\u0026rsquo;s needs, considering factors like existing codebase, team expertise, and desired level of type safety. Remember that both approaches are significantly better than relying solely on runtime validation.\nResources  Koin Documentation Koin Annotations Guide KSP Documentation Sample Project  ","description":"Dependency injection is a fundamental pattern in modern Android development, but how can we ensure our DI configuration is correct before running the app? In this post, we'll explore two powerful approaches to achieve compile-time safety with Koin: using the DSL's `verify()` function and leveraging Koin Annotations with KSP.","id":13,"section":"posts","tags":["kotlin","android","koin"],"title":"Achieving Compile-Time Safety in Koin: A Comprehensive Guide","uri":"https://carrion.dev/en/posts/koin-compile-safety/"},{"content":"Reliable Timekeeping with the TrustedTime API in Android Accurate timekeeping is crucial for many app functionalities, including scheduling, transaction logging, and security. However, relying on a device\u0026rsquo;s system clock can be problematic since users can alter their device’s time settings. To address this, Google has introduced the TrustedTime API, providing a reliable and tamper-resistant time source for Android apps.\nUnderstanding the TrustedTime API The TrustedTime API leverages Google\u0026rsquo;s secure infrastructure to offer a trustworthy timestamp, independent of the device\u0026rsquo;s local time settings. It periodically syncs with Google\u0026rsquo;s accurate time servers, reducing the need for frequent network requests. The API also accounts for clock drift, alerting developers when time accuracy may degrade between synchronizations.\nWhy Reliable Timekeeping Matters Relying solely on a device’s clock can cause issues such as:\n Data Inconsistency: Apps that depend on event ordering can face data corruption if users manipulate device time. Security Risks: Time-based security measures, like OTPs and access controls, require an accurate clock. Unreliable Scheduling: Reminders and scheduled events may malfunction if the device clock is incorrect. Clock Drift: Internal clocks can drift due to factors like temperature changes and battery levels. Multi-Device Synchronization Issues: Inconsistent time settings across devices can disrupt data sync. Excessive Battery \u0026amp; Data Usage: Constantly querying network time servers drains resources, which TrustedTime helps optimize.  Practical Applications of TrustedTime The TrustedTime API enhances security and reliability in various scenarios:\n Financial Apps: Ensures accurate timestamps for transactions. Gaming: Prevents time-based exploits. E-Commerce: Tracks order processing and delivery accurately. Limited-Time Offers: Ensures promotions expire correctly. IoT Devices: Synchronizes clocks across multiple devices. Productivity Apps: Maintains accurate timestamps for cloud document edits.  Integrating TrustedTime into Your Android App 1. Add the Dependency Include the TrustedTime API in your build.gradle file:\n1  implementation \u0026#39;com.google.android.gms:play-services-time:16.0.1\u0026#39;   2. Initialize TrustedTimeClient 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class MyApp : Application() { var trustedTimeClient: TrustedTimeClient? = null private set override fun onCreate() { super.onCreate() TrustedTime.createClient(this).addOnCompleteListener { task -\u0026gt; if (task.isSuccessful) { trustedTimeClient = task.result } else { // Handle error  } } } }   3. Using TrustedTime in an Activity or Fragment To retrieve the trusted time within an Activity or Fragment, we can access the TrustedTimeClient from the application class:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class MainActivity : AppCompatActivity() { private val trustedTimeClient: TrustedTimeClient? get() = (application as MyApp).trustedTimeClient override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) getTrustedTime() } private fun getTrustedTime() { val currentTimeMillis = trustedTimeClient?.computeCurrentUnixEpochMillis() ?: System.currentTimeMillis() Log.d(\u0026#34;TrustedTime\u0026#34;, \u0026#34;Trusted current time: $currentTimeMillis\u0026#34;) } }   By retrieving trustedTimeClient from MyApp, we avoid redundant initialization and ensure a single trusted source of time throughout the app.\nConsiderations \u0026amp; Limitations  Requires Internet Access: TrustedTime needs an internet connection after boot to function correctly. Clock Drift: While the API estimates error, it cannot entirely prevent clock drift. Tampering Protection: It reduces, but does not completely eliminate, time manipulation risks. TrustedTime API Availability and Limitations: The TrustedTime API is available on all devices running Google Play services on Android 5 (Lollipop) and above.  By integrating the TrustedTime API, developers can improve the accuracy and security of time-dependent app functionalities, ensuring a consistent and reliable experience for users.\n","description":"The TrustedTime API leverages Google's secure infrastructure to offer a trustworthy timestamp","id":14,"section":"posts","tags":["kotlin","android","google"],"title":"Reliable Timekeeping with the TrustedTime API in Android","uri":"https://carrion.dev/en/posts/trusted-time-api/"},{"content":"Kotlin Multiplatform Architecture Best Practices for Mobile Apps Kotlin Multiplatform (KMP) allows developers to share business logic between Android and iOS while keeping platform-specific implementations where necessary. Structuring a KMP project efficiently is key to maintaining scalability, testability, and clean architecture. In this guide, we’ll explore best practices for architecting a KMP mobile application with Compose Multiplatform and Clean Architecture.\n1. Project Structure A well-organized project structure improves maintainability and separation of concerns. A common approach is to follow a multi-module structure, either with a single shared module or with multiple feature-based modules:\nproject-root/ ├── core/ │ ├── network/ # Network shared logic │ │ ├── src/commonMain/ # Shared networking │ │ ├── src/androidMain/ # Android-specific implementations │ │ ├── src/iosMain/ # iOS-specific implementations ├── features/ # Feature-based modules │ ├── feature1/ # Example feature module │ │ ├── domain/ # Domain layer (Use cases, repositories interfaces) │ │ ├── data/ # Data layer (Implementations, APIs, Database) │ │ ├── presentation/ # UI and ViewModels for Compose Multiplatform ├── composeApp/ # Application module integrating all features │ ├── src/commonMain/ # Can contain shared UI and navigation logic │ ├── src/androidMain/ # Android-specific implementations if needed │ ├── src/iosMain/ # iOS-specific implementations if needed ├── androidApp/ # Android application module ├── iosApp/ # iOS application module  Feature Modules: Instead of a single shared module, you can have feature-specific shared modules to improve modularity and scalability. These can be further split into domain, data, and presentation layers for better separation of concerns. Core Modules: Contains shared utilities like networking, logging, and common domain logic. ComposeApp Module: Acts as the main application module, integrating all feature modules and handling navigation, similar to an app module in an Android project.  In most Compose Multiplatform projects, a composeApp module is used to assemble all features, manage navigation, and handle other app-wide concerns, similar to the app module in a standard Android project.\n2. Applying Clean Architecture in KMP Following Clean Architecture helps in maintaining separation of concerns and improving testability. The architecture can be structured into the following layers:\nDomain Layer (commonMain)  Contains business logic (Use Cases, Interactors). Defines repository interfaces for data access. Does not depend on any platform-specific implementation.  1 2 3  interface UserRepository { suspend fun getUser(): User }   Data Layer (commonMain, platform-specific)  Implements repository interfaces. Uses expect/actual for platform-specific APIs like networking, databases, etc. Fetches and processes raw data before exposing it to the domain layer.  Example expect/actual for HTTP client:\n1 2 3  expect class HttpClientProvider { fun getClient(): HttpClient }   Android-specific implementation:\n1 2 3  actual class HttpClientProvider { actual fun getClient() = HttpClient(Android) {} }   iOS-specific implementation:\n1 2 3  actual class HttpClientProvider { actual fun getClient() = HttpClient(Ios) {} }   Presentation Layer (Compose Multiplatform) With Compose Multiplatform, we can share UI components across platforms while leveraging native rendering. The composeApp module integrates all feature modules and handles navigation and app-wide logic.\n1 2 3 4 5 6 7 8 9 10  @Composable fun UserScreen(viewModel: UserViewModel) { val user by viewModel.userState.collectAsState() Column(modifier = Modifier.padding(16.dp)) { Text( \u0026#34;Hello, ${user?.name ?: \u0026#34;Guest\u0026#34;}\u0026#34;, style = MaterialTheme.typography.h6 ) } }   On Android, this is rendered using Jetpack Compose, and on iOS, it is rendered using Compose for iOS.\n3. State Management in KMP State management in a KMP project can be handled efficiently using StateFlow.\n1 2 3 4 5 6 7 8 9 10  class UserViewModel(private val repository: UserRepository) { private val _userState = MutableStateFlow\u0026lt;User?\u0026gt;(null) val userState: StateFlow\u0026lt;User?\u0026gt; = _userState fun loadUser() { viewModelScope.launch { _userState.value = repository.getUser() } } }   Since Compose Multiplatform supports collectAsState(), we can observe and render state changes directly in the UI.\n4. Testing in KMP  **Unit Tests in **commonTest using kotlin.test. Platform-specific Tests in androidTest and iosTest.  Example shared unit test:\n1 2 3 4 5  @Test fun testUserRepository() = runTest { val repository = FakeUserRepository() assertNotNull(repository.getUser()) }   Conclusion By following these best practices, you can build scalable and maintainable KMP applications:\n Use a modularized project structure with either a shared module or feature-based modules. Follow Clean Architecture for maintainability. Leverage Compose Multiplatform for UI, using a composeApp module to integrate feature modules and manage navigation. Feature modules can be further divided into domain, data, and presentation layers to improve separation of concerns. Manage state efficiently using StateFlow. Write comprehensive tests across shared and platform-specific code.  KMP enables efficient code sharing while preserving platform-specific optimizations, making it a powerful choice for mobile app development.\nWould you like a sample GitHub repository demonstrating this setup? 🚀\n","description":"Architecture tips for KMP projects using clean architecture","id":15,"section":"posts","tags":["kotlin","compose","cmp","multiplatform","cleancode","architecture"],"title":"Kotlin Multiplatform Architecture Best Practices for Mobile Apps","uri":"https://carrion.dev/en/posts/kmp-architecture/"},{"content":"Mocks, Fakes, and More: Understanding Test Doubles in Kotlin When writing tests in Kotlin, especially for Android development, we often need to replace real dependencies with test doubles. However, not all test doubles are the same—terms like mocks, fakes, stubs, spies, and dummies often come up. In this post, we’ll break down their differences with Kotlin examples using only plain Kotlin (no third-party libraries).\n1. Understanding Test Doubles Test doubles are objects that stand in for real dependencies in tests. They help us isolate the system under test (SUT) and make tests more reliable. Here are the main types:\n Dummy – A placeholder object that is never actually used. Stub – Provides predefined responses but doesn’t contain logic. Fake – A lightweight implementation with in-memory logic. Mock – A test double that verifies interactions. Spy – Wraps a real object while allowing selective behavior modification.  2. Dummy Objects A dummy is an object that exists only to satisfy a method signature but is never actually used.\nExample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  interface EmailSender { fun sendEmail(email: String, message: String) } class UserService(private val emailSender: EmailSender) { fun registerUser(user: User) { // User is registered, but we don\u0026#39;t actually send an email  } } data class User(val name: String, val email: String) // Test fun testRegisterUser() { val dummyEmailSender = object : EmailSender { override fun sendEmail(email: String, message: String) { // This will never be called in the test  } } val userService = UserService(dummyEmailSender) userService.registerUser(User(\u0026#34;John Doe\u0026#34;, \u0026#34;john@example.com\u0026#34;)) }   3. Stubs A stub returns predefined responses to method calls but doesn’t track interactions.\nExample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  interface UserRepository { fun getUser(id: Int): User? } class StubUserRepository : UserRepository { override fun getUser(id: Int): User? { return if (id == 1) User(\u0026#34;John Doe\u0026#34;, \u0026#34;john@example.com\u0026#34;) else null } } // Test fun testGetUser() { val stubRepo = StubUserRepository() val user = stubRepo.getUser(1) assert(user?.name == \u0026#34;John Doe\u0026#34;) }   4. Fakes A fake is a simplified but functional version of a real class, often using in-memory storage.\nExample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class FakeUserRepository : UserRepository { private val users = mutableMapOf\u0026lt;Int, User\u0026gt;() override fun getUser(id: Int): User? = users[id] fun addUser(id: Int, user: User) { users[id] = user } } // Test fun testFakeUserRepository() { val fakeRepo = FakeUserRepository() fakeRepo.addUser(1, User(\u0026#34;Jane Doe\u0026#34;, \u0026#34;jane@example.com\u0026#34;)) assert(fakeRepo.getUser(1)?.name == \u0026#34;Jane Doe\u0026#34;) }   5. Mocks A mock is a test double that verifies interactions. Without a mocking framework, we must manually track calls.\nExample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class MockEmailSender : EmailSender { var wasSendEmailCalled = false var sentTo: String? = null var sentMessage: String? = null override fun sendEmail(email: String, message: String) { wasSendEmailCalled = true sentTo = email sentMessage = message } } // Test fun testSendWelcomeEmail() { val mockEmailSender = MockEmailSender() val service = NotificationService(mockEmailSender) service.sendWelcomeEmail(User(\u0026#34;test@example.com\u0026#34;, \u0026#34;test@example.com\u0026#34;)) assert(mockEmailSender.wasSendEmailCalled) assert(mockEmailSender.sentTo == \u0026#34;test@example.com\u0026#34;) assert(mockEmailSender.sentMessage == \u0026#34;Welcome!\u0026#34;) } class NotificationService(private val emailSender: EmailSender) { fun sendWelcomeEmail(user: User) { emailSender.sendEmail(user.email, \u0026#34;Welcome!\u0026#34;) } }   6. Spies A spy wraps a real object while allowing selective behavior modification. Without a library, we must extend the real class and override specific behavior.\nExample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  open class MathService { open fun add(a: Int, b: Int) = a + b } class SpyMathService : MathService() { var wasAddCalled = false var lastA: Int? = null var lastB: Int? = null override fun add(a: Int, b: Int): Int { wasAddCalled = true lastA = a lastB = b return super.add(a, b) // Calls real implementation  } }   7. Using MockK for Mocks and Spies While manually creating mocks and spies is possible, using a library like MockK simplifies the process.\nExample using MockK: 1 2 3 4 5 6 7 8 9 10 11  import io.mockk.* fun testMockKExample() { val mockEmailSender = mockk\u0026lt;EmailSender\u0026gt;() every { mockEmailSender.sendEmail(any(), any()) } just Runs val service = NotificationService(mockEmailSender) service.sendWelcomeEmail(User(\u0026#34;test@example.com\u0026#34;, \u0026#34;test@example.com\u0026#34;)) verify { mockEmailSender.sendEmail(\u0026#34;test@example.com\u0026#34;, \u0026#34;Welcome!\u0026#34;) } }   MockK provides powerful features like automatic spies, relaxed mocks, and argument capturing, making testing easier and more maintainable.\nConclusion Understanding test doubles helps you write better tests by isolating dependencies. Use:\n✅ Dummies when an argument is required but unused.\n✅ Stubs for returning predefined values.\n✅ Fakes for lightweight implementations.\n✅ Mocks when verifying interactions.\n✅ Spies when you need partial mocking.\n✅ MockK for easier and more powerful mocking.\nBy choosing the right type, you can make your tests more reliable and maintainable.\n","description":"Mocks, Fakes, and More: Understanding Test Doubles in Kotlin","id":16,"section":"posts","tags":["kotlin","testing","mock","tdd"],"title":"Mocks, Fakes, and More","uri":"https://carrion.dev/en/posts/test-doubles/"},{"content":"Testing in Compose Multiplatform (CMP) from Common Code Compose Multiplatform (CMP) enables building UI for multiple platforms using Jetpack Compose. Fortunately, CMP also supports writing and running UI tests in the common code, making testing more efficient across platforms. In this post, we’ll explore how to test CMP applications using compose.uiTest and run them on Android, Desktop, and iOS.\n1. Setting Up Common UI Testing CMP provides compose.uiTest, allowing UI tests to be written in the shared module without platform-specific dependencies. This means you can write once and test everywhere.\nUpdating Build Configuration To enable testing, update your build.gradle.kts file in the shared module:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  kotlin { androidTarget { instrumentedTestVariant.sourceSetTree.set(KotlinSourceSetTree.test) } sourceSets { val commonTest by getting { dependencies { implementation(kotlin(\u0026#34;test\u0026#34;)) @OptIn(org.jetbrains.compose.ExperimentalComposeLibrary::class) implementation(compose.uiTest) // Common UI testing library  } } val desktopTest by getting { dependencies { implementation(compose.desktop.currentOs) } } } }   Declaring Android UI Test Dependencies At the root level of your build.gradle.kts file, add the necessary Android test dependencies:\n1 2 3 4  dependencies { androidTestImplementation(\u0026#34;androidx.compose.ui:ui-test-junit4-android:1.5.4\u0026#34;) debugImplementation(\u0026#34;androidx.compose.ui:ui-test-manifest:1.5.4\u0026#34;) }   Setting Up Android-Specific Test Configuration For Android instrumentation tests, add the following to your build.gradle.kts:\n1 2 3 4 5  android { defaultConfig { testInstrumentationRunner = \u0026#34;androidx.test.runner.AndroidJUnitRunner\u0026#34; } }   2. Implementing a Simple Counter UI Let’s create a CounterViewModel that will be tested:\n1 2 3 4 5 6 7 8 9 10 11 12  import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.asStateFlow class CounterViewModel { private val _count = MutableStateFlow(0) val count: StateFlow\u0026lt;Int\u0026gt; = _count.asStateFlow() fun increment() { _count.value += 1 } }   Now, let’s create the Composable UI that interacts with this ViewModel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  import androidx.compose.foundation.layout.* import androidx.compose.material.* import androidx.compose.runtime.* import androidx.compose.ui.Modifier import androidx.compose.ui.platform.testTag import androidx.compose.ui.unit.dp @Composable fun CounterScreen(viewModel: CounterViewModel) { val count by viewModel.count.collectAsState() Column( modifier = Modifier.padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally ) { Text( text = count.toString(), fontSize = 24.sp, modifier = Modifier.testTag(\u0026#34;counterText\u0026#34;) ) Spacer(modifier = Modifier.height(8.dp)) Button( onClick = { viewModel.increment() }, modifier = Modifier.testTag(\u0026#34;incrementButton\u0026#34;) ) { Text(\u0026#34;Increment\u0026#34;) } } }   3. Writing a Common UI Test in CMP Now, let’s write a UI test in commonTest to validate that clicking the button increments the counter:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import androidx.compose.ui.test.* import kotlin.test.Test import kotlin.test.assertEquals class CounterScreenTest { @OptIn(ExperimentalTestApi::class) @Test fun testButtonIncrementsCounter() = runComposeUiTest { val viewModel = CounterViewModel() setContent { CounterScreen(viewModel = viewModel) } onNodeWithTag(\u0026#34;counterText\u0026#34;).assertTextEquals(\u0026#34;0\u0026#34;) onNodeWithTag(\u0026#34;incrementButton\u0026#34;).performClick() onNodeWithTag(\u0026#34;counterText\u0026#34;).assertTextEquals(\u0026#34;1\u0026#34;) } }   4. Running the Tests on Multiple Platforms Now that we have our test written in common code, let’s execute it on Android, Desktop, and iOS.\nRun Tests on Android For Android instrumented tests, run:\n1  ./gradlew connectedAndroidTest   Run Tests on Desktop 1  ./gradlew desktopTest   Run Tests on iOS For iOS simulator tests, run:\n1  ./gradlew :composeApp:iosSimulatorArm64Test   5. Why Test CMP from Common Code? ✅ Write once, test everywhere: No need to duplicate tests across platforms.\n✅ Consistent behavior across platforms: Ensures UI elements function the same way.\n✅ Easier maintenance: Single test suite covering all targets.\nConclusion With Compose Multiplatform UI testing, we can validate UI behavior from shared code without requiring platform-specific test implementations. The compose.uiTest library allows us to test UI interactions like text verification and button clicks, ensuring UI consistency across Android, iOS, and Desktop.\n","description":"Learn how to write and run UI tests in Compose Multiplatform (CMP) from common code, ensuring cross-platform consistency for Android, iOS, and Desktop.","id":17,"section":"posts","tags":["kotlin","compose","cmp","multiplatform"],"title":"Testing in Compose Multiplatform (CMP) from Common Code","uri":"https://carrion.dev/en/posts/cmp-ui-testing/"},{"content":"Exploring Kotlin’s Immutable Collections Library Kotlin\u0026rsquo;s standard collections (List, Set, Map) are mutable by default, which can lead to unintended modifications. To enforce immutability at the API level, JetBrains introduced the Kotlin Immutable Collections library. This library provides a set of truly immutable collection types that prevent accidental modifications and enhance safety in concurrent or multi-threaded environments.\nWhy Use Immutable Collections? While Kotlin already has listOf(), setOf(), and mapOf() for read-only collections, they are not truly immutable. The underlying collection can still be modified if it\u0026rsquo;s referenced elsewhere. Example:\n1 2 3 4 5 6 7  val list = mutableListOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) val readOnlyList: List\u0026lt;String\u0026gt; = list list.add(\u0026#34;D\u0026#34;) // Modifies the original list println(readOnlyList) // Output: [A, B, C, D]  (readOnlyList as MutableList).add(\u0026#34;E\u0026#34;) println(readOnlyList) // Output: [A, B, C, D, E]   To solve this, the Immutable Collections library provides collections that guarantee immutability at runtime.\nKey Features  Truly Immutable – Once created, they cannot be changed. Safe for Multi-threading – Avoids unintended modifications in concurrent environments. Optimized for Performance – Uses structural sharing to prevent unnecessary copying.  How to Use Kotlin Immutable Collections 1. Add the Dependency inFirst, include the Immutable Collections dependency in your build.gradle.kts:\n1 2 3  dependencies { implementation(\u0026#34;org.jetbrains.kotlinx:kotlinx-collections-immutable:0.3.5\u0026#34;) }   2. Creating Immutable Collections The library provides persistentListOf(), persistentSetOf(), and persistentMapOf() to create immutable collections:\n1 2 3 4 5  import kotlinx.collections.immutable.* val immutableList = persistentListOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) val immutableSet = persistentSetOf(1, 2, 3) val immutableMap = persistentMapOf(\u0026#34;key1\u0026#34; to 100, \u0026#34;key2\u0026#34; to 200)   3. Adding and Removing Elements Since these collections are immutable, modifying operations return a new modified copy instead of changing the original collection:\n1 2 3 4 5  val newList = immutableList.add(\u0026#34;D\u0026#34;) // Creates a new list println(newList) // Output: [A, B, C, D]  val newMap = immutableMap.put(\u0026#34;key3\u0026#34;, 300) println(newMap) // Output: {key1=100, key2=200, key3=300}   The original immutableList and immutableMap remain unchanged!\nPerformance Considerations Unlike regular immutable collections (which require full copies for modifications), persistent collections use structural sharing. This means that modifications create a new collection while reusing unchanged parts of the original, improving performance and memory efficiency.\nFor example, adding an item to a persistent list does not create a full copy but instead reuses most of the existing structure:\nOriginal: [A, B, C] New List: [A, B, C, D] (Only \u0026quot;D\u0026quot; is newly allocated) This makes immutable collections efficient even for large datasets.\nBenefits in Jetpack Compose Immutable collections are particularly useful in Jetpack Compose because they optimize state management and recompositions. Here’s why they matter in Compose applications:\n1. Avoid Unnecessary Recompositions  Compose tracks state changes to decide when to recompose UI elements. Mutable lists, sets, or maps might trigger unnecessary recompositions even when data hasn’t changed. Immutable collections ensure that state remains stable, preventing redundant recompositions.  Example:\n1 2 3 4 5 6 7 8  @Composable fun MyListScreen(items: List\u0026lt;String\u0026gt;) { LazyColumn { items(items) { item -\u0026gt; Text(text = item) } } }   If items is a mutable list, even reassigning the same values triggers recomposition. Using an immutable collection like PersistentList ensures that Compose recognizes when data is unchanged:\n1 2  val items = remember { persistentListOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) } MyListScreen(items)   2. State Stability for Performance  Compose optimizes rendering by skipping recompositions when state objects are stable. Immutable collections use structural sharing, meaning that modifications only affect the changed part while reusing the rest. This leads to better performance in large lists or complex UI hierarchies.  3. Predictable UI Behavior  Since immutable collections cannot be modified after creation, they prevent accidental mutations that might lead to unpredictable UI updates. This is especially useful in state-driven architectures (MVI, Redux, etc.), ensuring UI updates only when necessary.  4. Thread Safety  In Compose apps using coroutines (Flows, LiveData, etc.), immutable collections prevent race conditions when multiple threads update state. They ensure safe data flow between ViewModels, repositories, and UI components.  When to Use Immutable Collections? ✅ Functional Programming – Encourages immutability for safer data transformations.\n✅ Thread Safety – Prevents unintended modifications in multi-threaded environments.\n✅ Prevent Bugs – Reduces unexpected side effects due to accidental mutation.\n✅ State Management in Compose – Helps optimize recompositions and improve UI performance.\nConclusion The Kotlin Immutable Collections library provides truly immutable, efficient, and safe collections, making them a great choice for functional programming, concurrent applications, and Jetpack Compose development. By leveraging persistent collections, you can write safer and more predictable Kotlin code.\n🚀 Would you use immutable collections in your projects?\n","description":"Exploring Kotlin’s Immutable Collections Library, use it in Compose to improve performance.","id":18,"section":"posts","tags":["kotlin","collections","compose"],"title":"Exploring Kotlin’s Immutable Collections Library","uri":"https://carrion.dev/en/posts/immutable-collections/"},{"content":"Boosting Android App Performance with Baseline Profiles Introduction In today’s fast-paced mobile world, users expect apps to launch instantly and run smoothly. Performance optimization is crucial, especially concerning app startup time and runtime execution.\nAndroid’s Baseline Profiles offer an effective way to speed up app startup and improve runtime performance by precompiling critical code paths. Google Play even recommends using Baseline Profiles to enhance the user experience, particularly for apps with complex UI rendering or heavy dependencies.\nIn this guide, we\u0026rsquo;ll explore what Baseline Profiles are, how they work, and how to integrate them into your Android app using a dedicated Baseline Profile module to achieve faster startup times and improved runtime performance.\nWhat Are Baseline Profiles? Android apps use the Android Runtime (ART) to execute code, employing Just-In-Time (JIT) and Ahead-Of-Time (AOT) compilation.\nHowever, JIT compilation can introduce delays during app startup since code isn\u0026rsquo;t fully optimized initially. Baseline Profiles solve this problem by allowing developers to specify critical code paths that should be precompiled before the app runs.\nHow Do Baseline Profiles Work?  Precompilation: They contain method and class definitions that are precompiled and optimized before execution. Installation: These profiles are installed on the user’s device upon the app’s first launch. Optimization: ART utilizes them to enhance execution speed, especially during cold starts.  When Should You Use Baseline Profiles? Baseline Profiles are particularly beneficial in the following scenarios:\n✅ Optimizing App Startup – Reducing cold start time by precompiling launch sequences.\n✅ Improving Scroll Performance – Ensuring smoother UI rendering.\n✅ Enhancing Frequently Used Features – Precompiling logic that users interact with often.\nSetting Up Baseline Profiles in a Separate Module Step 1: Create the Baseline Profile Module   Open Android Studio:\n Navigate to File → New → New Module. Select the Baseline Profile Generator template.    Configure the Module:\n Target Application: Choose the app module for which the Baseline Profile will be generated. Module Name: Assign a name, e.g., baselineprofile. Package Name: Define the package name for the module. Language: Select Kotlin or Java. Build Configuration Language: Choose between Kotlin Script (KTS) or Groovy.    Finish: Click Finish to create the module.\n  This process sets up a new module containing the necessary configurations and code to generate and benchmark Baseline Profiles.\nStep 2: Define the Baseline Profile Generator Jetpack Compose-Based Baseline Profile Generator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  @RunWith(AndroidJUnit4::class) @LargeTest class BaselineProfileGenerator { @get:Rule val baselineProfileRule = BaselineProfileRule() @get:Rule val composeTestRule = createAndroidComposeRule\u0026lt;MainActivity\u0026gt;() @Test fun baselineProfile() = baselineProfileRule.collect( packageName = \u0026#34;com.example.app\u0026#34;, includeInStartupProfile = true, profileBlock = { // 1. **App Cold Start**  startActivityAndWait() // 2. **Navigate to Main Screen**  composeTestRule.onNodeWithText(\u0026#34;Get Started\u0026#34;) .performClick() composeTestRule.waitForIdle() // 3. **Scroll Through a LazyColumn List**  composeTestRule.onNodeWithTag(\u0026#34;itemList\u0026#34;) .performScrollToIndex(10) composeTestRule.waitForIdle() // 4. **Open a Detail Screen**  composeTestRule.onNodeWithTag(\u0026#34;item_0\u0026#34;) .performClick() composeTestRule.waitForIdle() // 5. **Perform a Search**  composeTestRule.onNodeWithTag(\u0026#34;searchInput\u0026#34;) .performTextInput(\u0026#34;Kotlin\u0026#34;) composeTestRule.waitForIdle() // 6. **Back Navigation**  composeTestRule.onNodeWithContentDescription(\u0026#34;Back\u0026#34;) .performClick() composeTestRule.waitForIdle() } ) }   Step 3: Generate and Integrate the Baseline Profile   Generate the Baseline Profile:\n  Run the Generate Baseline Profile configuration created by the template.\n  Alternatively, execute the following Gradle task:\n1  ./gradlew :app:generateBaselineProfile     This generates the Baseline Profile and copies it to the appropriate directory in your app module.\n  Integrate the Baseline Profile:\n  The generated profile is automatically included in your app module’s assets.\n  Ensure that your app\u0026rsquo;s build.gradle includes the necessary dependencies:\n1 2 3 4  dependencies { implementation(\u0026#34;androidx.profileinstaller:profileinstaller:1.3.0\u0026#34;) baselineProfile(project(\u0026#34;:baselineprofile\u0026#34;)) }     The profileinstaller library installs the Baseline Profile on user devices, and the baselineProfile dependency links the generated profile to your app.\n  Conclusion Baseline Profiles are a powerful tool for improving app startup time and runtime performance without increasing APK size. By precompiling critical code paths, your app launches faster, providing a smoother and more responsive experience for users.\nBy integrating Baseline Profiles using a dedicated module, you ensure a modular, maintainable, and scalable approach to performance optimization.\nIf you haven’t already, start using Baseline Profiles today and measure their impact on your app’s performance!\n","description":"Boosting Android App Performance with Baseline Profiles with real world example","id":19,"section":"posts","tags":["kotlin","architecture"],"title":"Boosting Android App Performance with Baseline Profiles","uri":"https://carrion.dev/en/posts/baseline-profiles/"},{"content":"Modularization in Gradle Projects with Kotlin: A Comprehensive Guide Introduction As projects grow in complexity, maintaining a monolithic codebase becomes challenging. Modularization is a software design technique that breaks down an application into smaller, independent modules, making the project more scalable, maintainable, and efficient.\nIn this guide, we’ll explore why modularization is essential, different types of modules, and best practices for setting up a modular Gradle project using Kotlin.\nWhy Modularization? Before implementing modularization, it’s important to understand its key benefits:\n Faster Build Times – Gradle compiles independent modules in parallel, reducing build times. Scalability – Easier to manage and extend large projects. Encapsulation – Each module has a well-defined responsibility, improving separation of concerns. Team Collaboration – Teams can work independently on different modules, reducing merge conflicts. Reusability – Common functionality can be extracted into reusable modules.  Example Scenario Imagine an Android app where all features and dependencies reside in a single app module. This setup leads to long build times, tightly coupled code, and difficulties in testing. With modularization, features and shared functionalities can be isolated into separate modules, improving efficiency.\nTypes of Modules in a Gradle Project ✅ Feature Modules Contain independent features of the app, such as:\n feature-auth (Authentication screens) feature-dashboard (Home screen, user data) Can be dynamically loaded using Dynamic Feature Modules in Android.  ✅ Library Modules Reusable components shared across the app, such as:\n ui-components (Custom buttons, toolbars) networking (API calls, Retrofit setup) analytics (Logging, Firebase events)  ✅ Core Modules Contains shared utilities, such as:\n core-utils (Common utilities, extensions)  Gradle Setup for Modularization After defining module types, configuring dependencies correctly is crucial.\nUsing api, implementation, and compileOnly  implementation – Dependency is only visible within the module. api – Dependency is exposed to other modules. compileOnly – Used for compile-time dependencies.  Example:\n1 2 3 4 5  // In feature-auth/build.gradle.kts dependencies { implementation(project(\u0026#34;:core-utils\u0026#34;)) // Only visible in this module  compileOnly(\u0026#34;androidx.annotation:annotation:1.3.0\u0026#34;) }   Dependency Management in Gradle Managing dependencies across multiple modules can be simplified using Version Catalogs, which is the recommended approach in modern Gradle projects.\n✅ Using Version Catalogs (libs.versions.toml) (Recommended) Gradle’s Version Catalogs allow defining dependencies in a .toml file, ensuring consistency and easy updates across modules. This method is now the preferred way to manage dependencies in Gradle.\nStep 1: Define Dependencies in libs.versions.toml Create or update the gradle/libs.versions.toml file:\n1 2 3 4 5 6 7  [versions] retrofit = \u0026#34;2.9.0\u0026#34; coroutines = \u0026#34;1.6.4\u0026#34; [libraries] retrofit = { module = \u0026#34;com.squareup.retrofit2:retrofit\u0026#34;, version.ref = \u0026#34;retrofit\u0026#34; } coroutines = { module = \u0026#34;org.jetbrains.kotlinx:kotlinx-coroutines-core\u0026#34;, version.ref = \u0026#34;coroutines\u0026#34; }   Step 2: Use Version Catalog in build.gradle.kts 1 2 3 4  dependencies { implementation(libs.retrofit) implementation(libs.coroutines) }   This approach provides:\n Centralized Dependency Management – All versions are stored in one place. Safer Updates – Easy bulk updates and compatibility checks. Better Maintainability – Reduces duplication across multiple build.gradle.kts files.  If your project is still using buildSrc, consider migrating to Version Catalogs, as Gradle actively recommends this approach.\nExample Modular Architecture in Kotlin Folder Structure of a Modular Project my-app/ │── app/ # Main application module │── core/ │ ├── core-utils/ # Common utilities │── features/ │ ├── feature-auth/ # Login, signup │ ├── feature-dashboard/ # Dashboard, home screen │── libraries/ │ ├── ui-components/ # Shared UI elements │ ├── networking/ # Retrofit setup, API client Dependency Flow  feature-auth → depends on core-utils and networking app → depends on all feature modules (feature-auth, feature-dashboard)  Best Practices for Modularization ✅ Avoid Cyclic Dependencies\n Feature modules should not depend on each other directly. Use event-based communication (e.g., LiveData, Flow).  ✅ Use Dependency Injection (DI)\n Libraries like Koin help manage dependencies.  ✅ Optimize Gradle Build Speed\n Enable Gradle’s configuration cache:  org.gradle.parallel=true org.gradle.caching=true Conclusion By implementing modularization in Gradle projects, you achieve:\n✔️ Faster build times\n✔️ Better maintainability\n✔️ Scalability for large teams\n✔️ Reusable components\nWould you like to explore a sample Kotlin project showcasing modularization? 🚀\n","description":"Modularization in Gradle Projects with Kotlin: A Comprehensive Guide","id":20,"section":"posts","tags":["kotlin","architecture"],"title":"Modularization in Gradle Projects with Kotlin","uri":"https://carrion.dev/en/posts/gradle-modularization/"},{"content":"Test-Driven Development (TDD) in Kotlin for Android Test-Driven Development (TDD) is a software development practice that emphasizes writing tests before implementing functionality. It follows a Red-Green-Refactor cycle: first, you write a failing test (Red), then implement just enough code to make it pass (Green), and finally, refactor the code while keeping the test green (Refactor). In this post, we\u0026rsquo;ll explore how to apply TDD in Kotlin for Android development using JUnit, MockK, and Coroutines with a real-world example.\nWhy Use TDD in Android Development?  Better Code Quality: Writing tests first ensures better design decisions and maintainability. Faster Debugging: Bugs are caught early before they become complex. Refactoring Confidence: Tests act as a safety net when modifying code. Improved Productivity: Although writing tests first might seem slower initially, it speeds up development in the long run.  Setting Up the Test Environment Before we begin, let\u0026rsquo;s add the necessary dependencies to our Gradle file:\n1 2 3 4  // Unit Testing testImplementation(\u0026#34;junit:junit:4.13.2\u0026#34;) testImplementation(\u0026#34;org.jetbrains.kotlinx:kotlinx-coroutines-test:1.10.1\u0026#34;) testImplementation(\u0026#34;io.mockk:mockk:1.13.16\u0026#34;)   Now, let\u0026rsquo;s create a real-world example demonstrating TDD.\nReal-World Example: Fetching Data in a UseCase We\u0026rsquo;ll implement a UseCase that fetches data from a Repository and runs it on the IO Dispatcher. We\u0026rsquo;ll follow the TDD approach.\nStep 1: Write a Failing Test (Red) First, let\u0026rsquo;s define a test for our FetchUserUseCase. This use case fetches user details from a repository.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  import io.mockk.* import kotlinx.coroutines.CoroutineDispatcher import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.ExperimentalCoroutinesApi import kotlinx.coroutines.test.* import kotlinx.coroutines.runBlocking import org.junit.Before import org.junit.Test import kotlin.test.assertEquals @ExperimentalCoroutinesApi class FetchUserUseCaseTest { private val repository: UserRepository = mockk() private lateinit var useCase: FetchUserUseCase private val testDispatcher = StandardTestDispatcher() @Before fun setup() { useCase = FetchUserUseCase(repository, testDispatcher) // Inject test dispatcher  } @Test fun `fetch user returns expected user`() = runTest { // Given  val expectedUser = User(id = 1, name = \u0026#34;John Doe\u0026#34;) coEvery { repository.getUser(1) } returns expectedUser // When  val result = useCase(1) // Then  assertEquals(expectedUser, result) coVerify { repository.getUser(1) } } }   Understanding Given-When-Then   Given – Set up the initial conditions or dependencies required for the test.\n1 2  val expectedUser = User(id = 1, name = \u0026#34;John Doe\u0026#34;) coEvery { repository.getUser(1) } returns expectedUser    This prepares a mock response for repository.getUser(1) so that it returns expectedUser.    When – Execute the actual function or use case being tested.\n1  val result = useCase(1)    This calls the FetchUserUseCase with a user ID of 1, triggering the behavior we want to test.    Then – Verify that the expected outcome matches the actual outcome.\n1 2  assertEquals(expectedUser, result) coVerify { repository.getUser(1) }    This checks that the function returned the expected user and that the repository’s getUser method was called.    Step 2: Implement Minimal Code to Pass the Test (Green) Now, let\u0026rsquo;s implement the FetchUserUseCase class.\n1 2 3 4 5 6 7 8 9 10 11 12 13  import kotlinx.coroutines.CoroutineDispatcher import kotlinx.coroutines.withContext class FetchUserUseCase( private val repository: UserRepository, private val dispatcher: CoroutineDispatcher = Dispatchers.IO // Injected dispatcher ) { suspend operator fun invoke(userId: Int): User { return withContext(dispatcher) { repository.getUser(userId) } } }   Step 3: Refactor Since our test is passing, we can clean up or improve our implementation if necessary. Here, the implementation is already clean, so no major refactoring is needed.\nUnderstanding Key Parts 1. Mocking with MockK We use MockK to mock our repository:\n1  coEvery { repository.getUser(1) } returns expectedUser   This simulates a function call returning a predefined value.\n2. Using Coroutines with Test Dispatchers We replace Dispatchers.IO with a Test Dispatcher to control coroutine execution.\n3. Verifying Function Calls We ensure that our repository function was called:\n1  coVerify { repository.getUser(1) }   This confirms our code behaves as expected.\nBest Practices for TDD in Kotlin  Write Small, Focused Tests: Each test should verify one thing. Use Mocks Wisely: Avoid over-mocking; only mock dependencies. Prefer Deterministic Tests: Avoid flaky or time-dependent tests. Leverage Coroutines Test Utilities: Use StandardTestDispatcher and runTest. Keep Tests Fast: Unit tests should run in milliseconds.  Conclusion TDD improves code quality and development efficiency. By writing tests first, we ensure reliable and maintainable code. In this post, we built a UseCase that fetches data from a repository while running on the IO Dispatcher, following TDD principles. With MockK and Coroutines, we created a robust testing setup.\nStart applying TDD in your Kotlin projects today and see the benefits firsthand!\n","description":"Test-Driven Development (TDD) in Kotlin for Android with real-world examples using JUnit, MockK, and Coroutines","id":21,"section":"posts","tags":["kotlin","architecture","TDD","testing"],"title":"Test-Driven Development (TDD) in Kotlin for Android","uri":"https://carrion.dev/en/posts/tdd-kotlin/"},{"content":"Clean Architecture in Kotlin \u0026amp; Android Introduction When building Android applications, maintaining scalability and readability is crucial. Without a clear architectural approach, projects can become difficult to maintain as they grow. This is where Clean Architecture, introduced by Uncle Bob (Robert C. Martin), becomes invaluable. It emphasizes separation of concerns, making code more modular, testable, and maintainable.\nUnderstanding Clean Architecture Clean Architecture is structured into three main layers, each with a specific role:\n Presentation Layer: Handles UI and user interactions. Domain Layer: Contains business logic, use cases, and repository interfaces. Data Layer: Implements repositories, manages API calls, and handles database operations.  The core principle of Clean Architecture is dependency direction—each layer should only depend on the layers closer to the core (domain). This ensures flexibility and scalability.\nProject Structure A Clean Architecture project in Kotlin typically follows this structure:\ncom.example.app │── presentation (ViewModels, UI, State) │── domain (UseCases, Repository Interfaces, Models) │── data (Repository Implementations, Data Sources, APIs, DB) Each layer should be in a separate module or package, ensuring proper separation of concerns.\nModularization To further enhance maintainability and scalability, consider structuring your project into separate Gradle modules. This ensures clear separation between different layers and promotes reusability.\nA modularized Clean Architecture project could follow this structure:\ncom.example.app │── app (Main application module) │── feature-user │ │── domain (UseCases, Repository Interfaces, Models) │ │── data (Repository Implementations, Data Sources, APIs, DB) │ │── presentation (UI and ViewModels for user features) │── core (Common utilities, networking, database helpers) Benefits of modularization:\n Faster build times due to isolated module compilation. Improved code encapsulation and separation of concerns. Easier feature development and maintenance. Better testability by allowing independent testing of modules.  Implementing Clean Architecture with Kotlin 1. Domain Layer (Core Business Logic) The domain layer defines the business logic and use cases. It does not depend on any framework or external library, making it the most stable part of the application.\nExample: Defining a Repository Interface 1 2 3  interface UserRepository { suspend fun getUserById(id: String): User }   Example: Use Case 1 2 3 4 5  class GetUserByIdUseCase(private val userRepository: UserRepository) { suspend operator fun invoke(id: String): User { return userRepository.getUserById(id) } }   2. Data Layer (Implementing Repositories and Data Sources) The data layer provides concrete implementations of the repository interfaces. It interacts with APIs, databases, or local storage.\nExample: Data Source 1 2 3 4 5 6 7 8 9  interface UserRemoteDataSource { suspend fun fetchUserById(id: String): User } class UserRemoteDataSourceImpl(private val api: UserApi) : UserRemoteDataSource { override suspend fun fetchUserById(id: String): User { return api.fetchUserById(id) } }   Example: Repository Implementation 1 2 3 4 5  class UserRepositoryImpl(private val remoteDataSource: UserRemoteDataSource) : UserRepository { override suspend fun getUserById(id: String): User { return remoteDataSource.fetchUserById(id) } }   3. Presentation Layer (UI \u0026amp; ViewModel) The presentation layer is responsible for UI logic and state management. It depends on the domain layer but does not interact directly with the data layer.\nExample: ViewModel 1 2 3 4 5 6 7 8 9 10 11  class UserViewModel(private val getUserByIdUseCase: GetUserByIdUseCase) : ViewModel() { private val _user = MutableStateFlow\u0026lt;User?\u0026gt;(null) val user: StateFlow\u0026lt;User?\u0026gt; get() = _user.asStateFlow() fun loadUser(id: String) { viewModelScope.launch { _user.value = getUserByIdUseCase(id) } } }   Best Practices  Keep the Domain Layer Pure: It should have no dependencies on Android frameworks. Use Dependency Injection: Koin helps in managing dependencies cleanly. Follow the Dependency Rule: The inner layers should not depend on the outer layers. Separate Repository Interfaces and Implementations: Interfaces go in the domain layer, and implementations stay in the data layer. Use Data Sources: Encapsulate API and database calls in dedicated data source classes. Modularize Your Code: Use Gradle modules to separate concerns and improve build times.  Conclusion Clean Architecture provides a robust way to structure Android applications. By separating concerns and enforcing clear dependencies, it makes code more testable and scalable. Using Koin for dependency injection further enhances maintainability. Adopting this architecture, along with modularization, will result in a more modular and resilient codebase for your Kotlin projects.\n","description":"Clean Architecture in Kotlin \u0026 Android with practical examples","id":22,"section":"posts","tags":["kotlin","architecture"],"title":"Clean Architecture in Kotlin \u0026 Android","uri":"https://carrion.dev/en/posts/clean-architecture/"},{"content":"Exploring App Architectures in Kotlin: MVC, MVP, MVVM, and MVI Introduction In modern app development, choosing the right architecture is essential for creating maintainable and scalable applications. Architectures define how your codebase is organized and how different components interact. In this post, we’ll explore four popular app architectures: Model-View-Controller (MVC), Model-View-Presenter (MVP), Model-View-ViewModel (MVVM), and Model-View-Intent (MVI). We’ll look at their structure, pros, cons, and practical examples in Kotlin.\n1. Model-View-Controller (MVC) Definition:\nMVC divides an app into three components:\n Model: Manages the data and business logic. View: Displays data to the user, directly accessing the Model for updates. Controller: Handles user input and updates the Model.  Pros:\n Simple to implement and understand. Effective for small apps or prototypes.  Cons:\n Tight coupling between View and Model. Limited separation of concerns; scaling can be challenging.  Kotlin Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // Model data class User(var name: String, var age: Int) // View class UserView { fun displayUser(user: User) { println(\u0026#34;Name: ${user.name}, Age: ${user.age}\u0026#34;) } } // Controller class UserController(private val model: User, private val view: UserView) { fun handleUserInput() { println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; model.name = newName // Directly updates the model  view.displayUser(model) } } fun main() { val user = User(\u0026#34;Alice\u0026#34;, 30) val view = UserView() val controller = UserController(user, view) view.displayUser(user) controller.handleUserInput() }   2. Model-View-Presenter (MVP) Definition:\nIn MVP, the Presenter mediates between the Model and View. Unlike MVC, the View is passive and delegates all interaction logic to the Presenter, which retrieves data from the Model and updates the View.\nPros:\n Better separation of concerns compared to MVC. Easier to test since the Presenter handles all logic.  Cons:\n Presenter classes can become large (\u0026ldquo;God classes\u0026rdquo;). Managing lifecycle events can be challenging.  Kotlin Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // Model data class User(val name: String, val age: Int) // View Interface interface UserView { fun displayUser(name: String, age: Int) } // Presenter class UserPresenter(private val view: UserView) { private var user = User(\u0026#34;Bob\u0026#34;, 25) fun loadUser() { view.displayUser(user.name, user.age) } fun updateUser() { println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; user = user.copy(name = newName) view.displayUser(user.name, user.age) } } // View Implementation class ConsoleUserView : UserView { override fun displayUser(name: String, age: Int) { println(\u0026#34;Name: $name, Age: $age\u0026#34;) } } fun main() { val view = ConsoleUserView() val presenter = UserPresenter(view) presenter.loadUser() presenter.updateUser() }   3. Model-View-ViewModel (MVVM) Definition:\nMVVM promotes a reactive approach. The ViewModel provides data to the View and reacts to changes in the Model. It often uses LiveData or Kotlin’s StateFlow.\nPros:\n Encourages clean separation of concerns. Excellent for reactive programming using coroutines or flows.  Cons:\n Requires familiarity with reactive paradigms. Data binding or state management can add complexity.  Kotlin Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // Model data class User(val name: String, val age: Int) // ViewModel class UserViewModel { private val _user = MutableStateFlow(User(\u0026#34;Charlie\u0026#34;, 28)) val user = _user.asStateFlow() fun updateUser(name: String) { _user.value = _user.value.copy(name = name) } } // View class UserView(private val viewModel: UserViewModel) { fun render() { viewModel.user.collect { user -\u0026gt; println(\u0026#34;Name: ${user.name}, Age: ${user.age}\u0026#34;) } } fun getUserInput(): String { println(\u0026#34;Enter new name for the user:\u0026#34;) return readLine() ?: \u0026#34;\u0026#34; } fun updateUserName() { val newName = getUserInput() viewModel.updateUser(newName) } } fun main() = runBlocking { val viewModel = UserViewModel() val view = UserView(viewModel) view.render() view.updateUserName() }   4. Model-View-Intent (MVI) Definition:\nMVI uses unidirectional data flow. The View sends user intents, the Model processes them, and the state is updated and rendered by the View.\nPros:\n Predictable state management. Encourages immutability and clear data flow.  Cons:\n Steeper learning curve. Overhead for simple apps.  Kotlin Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  // Model data class UserState(val name: String = \u0026#34;\u0026#34;, val age: Int = 0) // Intent sealed class UserIntent { object LoadUser : UserIntent() data class UpdateUser(val name: String) : UserIntent() } // Reducer fun userReducer(currentState: UserState, intent: UserIntent): UserState { return when (intent) { is UserIntent.LoadUser -\u0026gt; UserState(name = \u0026#34;Dave\u0026#34;, age = 40) is UserIntent.UpdateUser -\u0026gt; currentState.copy(name = intent.name) } } // ViewModel class UserViewModel { private val _state = MutableStateFlow(UserState()) val state: StateFlow\u0026lt;UserState\u0026gt; = _state fun processIntent(intent: UserIntent) { _state.update { currentState -\u0026gt; userReducer(currentState, intent) } } } // View class UserView(private val viewModel: UserViewModel) { fun render() { viewModel.state.collect { state -\u0026gt; println(\u0026#34;Name: ${state.name}, Age: ${state.age}\u0026#34;) } } fun sendIntent(intent: UserIntent) { viewModel.processIntent(intent) } } fun main() = runBlocking { val viewModel = UserViewModel() val view = UserView(viewModel) view.sendIntent(UserIntent.LoadUser) view.render() println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; view.sendIntent(UserIntent.UpdateUser(newName)) }   Conclusion Each architecture has its strengths and trade-offs:\n MVC: Best for small, simple apps. MVP: Balances structure and simplicity. MVVM: Ideal for reactive programming. MVI: Great for predictable and scalable state management.  Consider your project’s complexity and requirements when choosing an architecture. Which one do you prefer?\n","description":"Exploring App Architectures in Kotlin: MVC, MVP, MVVM, and MVI","id":23,"section":"posts","tags":["kotlin","architecture"],"title":"Exploring App Architectures in Kotlin","uri":"https://carrion.dev/en/posts/app-architecture/"},{"content":"Exploring More Design Patterns in Kotlin: Part 3 Design Patterns Series  Part 1 Part 2 Part 3  In this third installment, we’ll cover Memento, Command, Visitor, Chain of Responsibility, and Mediator patterns. These patterns address construction, behavioral, and structural challenges, showcasing Kotlin\u0026rsquo;s expressive syntax and modern features.\n1. Memento Pattern The Memento Pattern captures and restores an object\u0026rsquo;s state without exposing its internal details.\nWhen to Use  To implement undo/redo functionality.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  class Editor { var content: String = \u0026#34;\u0026#34; fun createMemento(): Memento = Memento(content) fun restore(memento: Memento) { content = memento.state } data class Memento(val state: String) } class History { private val mementos = mutableListOf\u0026lt;Editor.Memento\u0026gt;() fun save(memento: Editor.Memento) { mementos.add(memento) } fun pop(): Editor.Memento? { if (mementos.isNotEmpty()) { return mementos.removeAt(mementos.lastIndex) } return null } } fun main() { val editor = Editor() val history = History() editor.content = \u0026#34;First Version\u0026#34; history.push(editor.save()) editor.content = \u0026#34;Second Version\u0026#34; history.push(editor.save()) editor.content = \u0026#34;Third Version\u0026#34; println(\u0026#34;Current Content: ${editor.content}\u0026#34;) editor.restore(history.pop()!!) println(\u0026#34;Restored Content: ${editor.content}\u0026#34;) editor.restore(history.pop()!!) println(\u0026#34;Restored Content: ${editor.content}\u0026#34;) }   Why Kotlin? Kotlin’s concise syntax makes state capture and restoration easy to implement.\n2. Command Pattern The Command Pattern encapsulates a request as an object, allowing for parameterization and queuing.\nWhen to Use  To implement undoable operations or command queues.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  interface Command { fun execute() } class Light { fun on() = println(\u0026#34;Light is ON\u0026#34;) fun off() = println(\u0026#34;Light is OFF\u0026#34;) } class LightOnCommand(private val light: Light) : Command { override fun execute() = light.on() } class LightOffCommand(private val light: Light) : Command { override fun execute() = light.off() } fun main() { val light = Light() val commands = listOf(LightOnCommand(light), LightOffCommand(light)) commands.forEach { it.execute() } }   Why Kotlin? Kotlin’s functional approach can further simplify command execution.\n3. Visitor Pattern The Visitor Pattern separates an algorithm from the object structure it operates on by moving the algorithm into a visitor object.\nWhen to Use  When you need to perform operations across a set of objects with varying types.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  interface Shape { fun accept(visitor: ShapeVisitor) } class Circle(val radius: Double) : Shape { override fun accept(visitor: ShapeVisitor) { visitor.visit(this) } } class Rectangle(val width: Double, val height: Double) : Shape { override fun accept(visitor: ShapeVisitor) { visitor.visit(this) } } fun interface ShapeVisitor { fun visit(shape: Shape) } fun main() { val shapes: List\u0026lt;Shape\u0026gt; = listOf(Circle(5.0), Rectangle(4.0, 6.0)) val visitor = ShapeVisitor { shape -\u0026gt; when (shape) { is Circle -\u0026gt; println(\u0026#34;Circle with radius ${shape.radius}\u0026#34;) is Rectangle -\u0026gt; println(\u0026#34;Rectangle with width ${shape.width}and height ${shape.height}\u0026#34;) } } shapes.forEach { it.accept(visitor) } }   Why Kotlin? Kotlin’s fun interface and sealed classes streamline the visitor implementation.\n4. Chain of Responsibility Pattern The Chain of Responsibility Pattern passes a request along a chain of handlers until one processes it.\nWhen to Use  When multiple objects can handle a request, and the handler isn’t determined until runtime.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  interface Handler { fun handle(request: String): Boolean } class AuthHandler(private val next: Handler?) : Handler { override fun handle(request: String): Boolean { println(\u0026#34;AuthHandler processing...\u0026#34;) return next?.handle(request) ?: true } } class LoggingHandler(private val next: Handler?) : Handler { override fun handle(request: String): Boolean { println(\u0026#34;LoggingHandler processing...\u0026#34;) return next?.handle(request) ?: true } } fun main() { val chain = AuthHandler(LoggingHandler(null)) chain.handle(\u0026#34;Request\u0026#34;) }   Why Kotlin? Kotlin’s nullable types and concise delegation simplify chaining handlers.\n5. Mediator Pattern The Mediator Pattern centralizes complex communication between multiple objects by having them communicate through a mediator.\nWhen to Use  When objects interact in complex ways, leading to tangled dependencies.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class Mediator { private val colleagues = mutableListOf\u0026lt;Colleague\u0026gt;() fun addColleague(colleague: Colleague) { colleagues.add(colleague) } fun broadcast(sender: Colleague, message: String) { colleagues.filter { it != sender } .forEach { it.receive(message) } } } interface Colleague { fun send(message: String) fun receive(message: String) } class ConcreteColleague(private val mediator: Mediator) : Colleague { override fun send(message: String) { println(\u0026#34;Sending message: $message\u0026#34;) mediator.broadcast(this, message) } override fun receive(message: String) { println(\u0026#34;Received message: $message\u0026#34;) } } fun main() { val mediator = Mediator() val colleague1 = ConcreteColleague(mediator) val colleague2 = ConcreteColleague(mediator) mediator.addColleague(colleague1) mediator.addColleague(colleague2) colleague1.send(\u0026#34;Hello from Colleague 1\u0026#34;) }   Why Kotlin? Kotlin’s first-class functions and collections simplify broadcasting and interaction.\nConclusion These patterns—Memento, Command, Visitor, Chain of Responsibility, and Mediator—demonstrate Kotlin\u0026rsquo;s ability to enhance classic design patterns with modern features.\nWhich of these patterns do you find most interesting? Let me know! 🚀\n","description":"Kotlin Design Patterns - Part 3","id":24,"section":"posts","tags":["kotlin","design-patterns","architecture"],"title":"Kotlin Design Patterns - Part 3","uri":"https://carrion.dev/en/posts/design-patterns-3/"},{"content":"Understanding SOLID Principles with Kotlin Examples The SOLID principles are a set of design principles that make software designs more understandable, flexible, and maintainable. Introduced by Robert C. Martin, these principles are a cornerstone of object-oriented programming and are especially relevant when building complex systems. In this blog post, we’ll explore each principle with examples written in Kotlin, a language that brings modern syntax and powerful features to the table.\n1. Single Responsibility Principle (SRP) A class should have one, and only one, reason to change.\nThis principle ensures that a class has a single responsibility, making it easier to maintain and less prone to bugs.\nBreaking SRP:\n1 2 3 4 5 6 7 8 9 10 11  class ReportManager { fun generateReport(data: String): String { // Logic to generate report  return \u0026#34;Report: $data\u0026#34; } fun saveReport(report: String) { // Logic to save report  println(\u0026#34;Report saved: $report\u0026#34;) } }   In this example, the ReportManager class violates SRP because it has two responsibilities: generating and saving reports. Any change in report generation logic or saving logic would require modifying the same class.\nFixing SRP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class ReportGenerator { fun generateReport(data: String): String { // Logic to generate report  return \u0026#34;Report: $data\u0026#34; } } class ReportSaver { fun saveReport(report: String) { // Logic to save report  println(\u0026#34;Report saved: $report\u0026#34;) } } fun main() { val generator = ReportGenerator() val saver = ReportSaver() val report = generator.generateReport(\u0026#34;Sales Data\u0026#34;) saver.saveReport(report) }   By separating responsibilities, we make each class focused and easier to test independently.\n2. Open/Closed Principle (OCP) Software entities should be open for extension but closed for modification.\nYou can add new functionality by extending classes without changing the existing code.\nBreaking OCP:\n1 2 3 4 5 6 7 8 9  class Discount { fun calculate(price: Double, type: String): Double { return when (type) { \u0026#34;none\u0026#34; -\u0026gt; price \u0026#34;percentage\u0026#34; -\u0026gt; price * 0.9 else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unknown discount type\u0026#34;) } } }   Here, adding a new discount type requires modifying the calculate method, which violates OCP.\nFixing OCP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  interface DiscountStrategy { fun calculate(price: Double): Double } class NoDiscount : DiscountStrategy { override fun calculate(price: Double): Double = price } class PercentageDiscount(private val percentage: Double) : DiscountStrategy { override fun calculate(price: Double): Double = price * (1 - percentage / 100) } class DiscountCalculator(private val strategy: DiscountStrategy) { fun calculate(price: Double): Double = strategy.calculate(price) } fun main() { val noDiscount = DiscountCalculator(NoDiscount()) println(\u0026#34;Price after no discount: ${noDiscount.calculate(100.0)}\u0026#34;) val percentageDiscount = DiscountCalculator(PercentageDiscount(10.0)) println(\u0026#34;Price after 10% discount: ${percentageDiscount.calculate(100.0)}\u0026#34;) }   By using interfaces and composition, we achieve a design that is open to extension (new discount strategies) and closed to modification (no changes to existing classes).\n3. Liskov Substitution Principle (LSP) Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.\nThis principle ensures that derived classes honor the expectations set by their base class.\nBreaking LSP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  open class Bird { open fun fly() { println(\u0026#34;Flying\u0026#34;) } } class Sparrow : Bird() class Penguin : Bird() { override fun fly() { throw UnsupportedOperationException(\u0026#34;Penguins can\u0026#39;t fly\u0026#34;) } } fun main() { val birds: List\u0026lt;Bird\u0026gt; = listOf(Sparrow(), Penguin()) for (bird in birds) { bird.fly() // This will fail for Penguin  } }   In this example, Penguin violates LSP because it cannot fulfill the contract of Bird. A better approach is to refactor the design:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  interface Flyable { fun fly() } class Sparrow : Flyable { override fun fly() { println(\u0026#34;Flying\u0026#34;) } } class Penguin { fun swim() { println(\u0026#34;Swimming\u0026#34;) } }   Now, behaviors are segregated, and LSP is upheld.\n4. Interface Segregation Principle (ISP) Clients should not be forced to depend on methods they do not use.\nThis principle promotes creating specific interfaces rather than a bloated one.\nBreaking ISP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Machine { fun print() fun scan() fun fax() } class OldPrinter : Machine { override fun print() { println(\u0026#34;Printing\u0026#34;) } override fun scan() { throw UnsupportedOperationException(\u0026#34;Scan not supported\u0026#34;) } override fun fax() { throw UnsupportedOperationException(\u0026#34;Fax not supported\u0026#34;) } }   This implementation forces OldPrinter to implement methods it doesn’t support, violating ISP.\nFixing ISP:\n1 2 3 4 5 6 7 8 9 10 11 12 13  interface Printer { fun print() } interface Scanner { fun scan() } class SimplePrinter : Printer { override fun print() { println(\u0026#34;Printing\u0026#34;) } }   By splitting the functionalities into separate interfaces, we allow devices to implement only what they need.\n5. Dependency Inversion Principle (DIP) High-level modules should not depend on low-level modules. Both should depend on abstractions.\nThis principle reduces the coupling between high-level and low-level modules by introducing abstractions.\nBreaking DIP:\n1 2 3 4 5 6 7 8 9 10 11 12 13  class EmailService { fun sendEmail(message: String) { println(\u0026#34;Sending Email: $message\u0026#34;) } } class NotificationSender { private val emailService = EmailService() fun notifyUser(message: String) { emailService.sendEmail(message) } }   Here, NotificationSender is tightly coupled to EmailService, making it difficult to switch to a different notification service.\nFixing DIP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  interface NotificationService { fun sendNotification(message: String) } class EmailService : NotificationService { override fun sendNotification(message: String) { println(\u0026#34;Sending Email: $message\u0026#34;) } } class SMSService : NotificationService { override fun sendNotification(message: String) { println(\u0026#34;Sending SMS: $message\u0026#34;) } } class NotificationSender(private val service: NotificationService) { fun notifyUser(message: String) { service.sendNotification(message) } } fun main() { val emailSender = NotificationSender(EmailService()) emailSender.notifyUser(\u0026#34;Hello via Email\u0026#34;) val smsSender = NotificationSender(SMSService()) smsSender.notifyUser(\u0026#34;Hello via SMS\u0026#34;) }   Here, NotificationSender depends on the NotificationService abstraction, making it flexible to work with any notification type.\nConclusion The SOLID principles form the foundation for building robust and scalable software. Kotlin, with its expressive syntax and modern features, allows developers to implement these principles elegantly. By adhering to these principles, you can create code that is easier to maintain, extend, and adapt to changing requirements.\n","description":"SOLID Principles explained with Kotlin Examples.","id":25,"section":"posts","tags":["kotlin","solid","architecture"],"title":"Understanding SOLID Principles with Kotlin Examples","uri":"https://carrion.dev/en/posts/solid-kotlin/"},{"content":"Exploring Design Patterns in Kotlin: Part 2 Design Patterns Series  Part 1 Part 2 Part 3  After the overwhelming response to our first post on Kotlin design patterns, we’re back with more! In this second part, we’ll dive into Prototype, Composite, Proxy, Observer, and Strategy patterns. These patterns solve a variety of design challenges and demonstrate Kotlin’s expressive capabilities.\n1. Prototype Pattern The Prototype Pattern is used to create new objects by copying an existing object, ensuring efficient object creation.\nWhen to Use  When creating a new instance is costly or complex. To avoid creating instances of subclasses repeatedly.  Kotlin Implementation Using Kotlin’s data class and its built-in copy function simplifies this pattern.\n1 2 3 4 5 6 7 8 9  data class Document(var title: String, var content: String, var author: String) fun main() { val original = Document(\u0026#34;Design Patterns\u0026#34;, \u0026#34;Content about patterns\u0026#34;, \u0026#34;John Doe\u0026#34;) val copy = original.copy(title = \u0026#34;Prototype Pattern\u0026#34;) println(\u0026#34;Original: $original\u0026#34;) println(\u0026#34;Copy: $copy\u0026#34;) }   Why Kotlin? Kotlin’s data classes inherently support copying with minimal boilerplate, making the Prototype Pattern a breeze to implement.\n2. Composite Pattern The Composite Pattern is used to treat individual objects and groups of objects uniformly.\nWhen to Use  When you have a tree structure and want to manipulate it in a consistent way.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  interface Logger { fun log(message: String) } class ConsoleLogger : Logger { override fun log(message: String) { println(message) } } class FileLogger(private val filePath: String) : Logger { override fun log(message: String) { // Implementation for writing logs to a file  } } class RootLogger(private val loggers: List\u0026lt;Logger\u0026gt;) : Logger { override fun log(message: String) { loggers.forEach { it.log(message) } } } fun main() { val consoleLogger = ConsoleLogger() val fileLogger = FileLogger(\u0026#34;/path/to/log.txt\u0026#34;) val rootLogger = RootLogger(listOf(consoleLogger, fileLogger)) rootLogger.log(\u0026#34;Composite Pattern Example\u0026#34;) }   3. Proxy Pattern The Proxy Pattern provides a surrogate or placeholder to control access to another object.\nWhen to Use  To control access to a resource. To add functionality without modifying the actual object.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Service { fun fetchData(): String } class RealService : Service { override fun fetchData() = \u0026#34;Data from Real Service\u0026#34; } class ProxyService(private val realService: RealService) : Service { override fun fetchData(): String { println(\u0026#34;Proxy: Checking access before delegating.\u0026#34;) return realService.fetchData() } } fun main() { val proxy = ProxyService(RealService()) println(proxy.fetchData()) }   4. Observer Pattern The Observer Pattern defines a one-to-many dependency, so when one object changes state, all its dependents are notified.\nWhen to Use  For event-driven systems. When multiple components need to react to state changes.  Kotlin Implementation Using Kotlin\u0026rsquo;s fun interface makes defining listeners more concise.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  fun interface StateChangeListener { fun onStateChanged(oldState: String, newState: String) } class Subject { private val listeners = mutableListOf\u0026lt;StateChangeListener\u0026gt;() var state: String by Delegates.observable(\u0026#34;Initial State\u0026#34;) { _, old, new -\u0026gt; listeners.forEach { it.onStateChanged(old, new) } } fun addListener(listener: StateChangeListener) { listeners.add(listener) } } fun main() { val subject = Subject() subject.addListener { oldState, newState -\u0026gt; println(\u0026#34;Listener 1: State changed from \u0026#39;$oldState\u0026#39; to \u0026#39;$newState\u0026#39;\u0026#34;) } subject.addListener { oldState, newState -\u0026gt; println(\u0026#34;Listener 2: State changed from \u0026#39;$oldState\u0026#39; to \u0026#39;$newState\u0026#39;\u0026#34;) } subject.state = \u0026#34;State 1\u0026#34; subject.state = \u0026#34;State 2\u0026#34; }   Why Kotlin? Using fun interface simplifies the implementation of single-method interfaces and reduces boilerplate for listeners. Additionally, Kotlin\u0026rsquo;s Delegates.observable makes observing state changes straightforward and powerful, further enhancing the implementation of the Observer Pattern.\n5. Strategy Pattern The Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable.\nWhen to Use  When you need multiple algorithms for a specific task. To avoid hardcoding algorithm logic.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  interface PaymentStrategy { fun pay(amount: Double) } class CreditCardPayment : PaymentStrategy { override fun pay(amount: Double) = println(\u0026#34;Paid $$amountusing Credit Card.\u0026#34;) } class PayPalPayment : PaymentStrategy { override fun pay(amount: Double) = println(\u0026#34;Paid $$amountusing PayPal.\u0026#34;) } class PaymentContext(private var strategy: PaymentStrategy) { fun setStrategy(strategy: PaymentStrategy) { this.strategy = strategy } fun executePayment(amount: Double) = strategy.pay(amount) } fun main() { val context = PaymentContext(CreditCardPayment()) context.executePayment(100.0) context.setStrategy(PayPalPayment()) context.executePayment(200.0) }   Conclusion With Kotlin, design patterns like Prototype, Composite, Proxy, Observer, and Strategy become more intuitive and powerful. These patterns are not just tools—they\u0026rsquo;re stepping stones to cleaner and more maintainable code.\n","description":"Kotlin Design Patterns - Part 2","id":26,"section":"posts","tags":["kotlin","design-patterns","architecture"],"title":"Kotlin Design Patterns - Part 2","uri":"https://carrion.dev/en/posts/design-patterns-2/"},{"content":"Using Koin in Compose Multiplatform Dependency injection is a must-have for scalable applications, and Koin makes it straightforward, even in Compose Multiplatform projects. With the new KoinApplication composable function, you can initialize Koin directly from commonMain code, reducing boilerplate while maintaining platform-specific flexibility. Let’s walk through an example.\nProject Setup Start by creating a Compose Multiplatform project using the KMP Wizard, selecting Android, iOS, Desktop, and Web targets. For this example, we won’t include a server target.\nAdding Dependencies Use Gradle’s version catalog to include the necessary Koin dependencies in libs.versions.toml:\n1 2 3 4 5 6 7 8 9  [versions] koin-bom = \u0026#34;4.1.0-Beta1\u0026#34; [libraries] koin-bom = { module = \u0026#34;io.insert-koin:koin-bom\u0026#34;, version.ref = \u0026#34;koin-bom\u0026#34; } koin-core = { module = \u0026#34;io.insert-koin:koin-core\u0026#34; } koin-android = { module = \u0026#34;io.insert-koin:koin-android\u0026#34; } koin-compose = { module = \u0026#34;io.insert-koin:koin-compose\u0026#34; } koin-compose-viewModel = { module = \u0026#34;io.insert-koin:koin-compose-viewmodel\u0026#34; }   Defining Koin Modules We’ll create two Koin modules: appModule and platformModule. The platformModule defines platform-specific dependencies.\nShared Code Modules 1 2 3 4 5 6 7 8 9 10 11 12  val appModule = module { viewModelOf(::MainViewModel) factoryOf(::GetJokeUseCase) singleOf(::DefaultJokeRepository) bind JokeRepository::class singleOf(::JokeJsonDataSource) bind JokeDataSource::class single { Json { ignoreUnknownKeys = true } } } val Module.localPreferencesDefinition get() = singleOf(::InMemoryLocalPreferences) bind LocalPreferences::class expect val platformModule: Module   Platform-Specific Modules For Android we will use an implementation to the LocalPreferences interface that depends on Android Context so we need a different module declaration:\n1 2 3 4  actual val platformModule: Module get() = module { singleOf(::AndroidPreferences) bind LocalPreferences::class }   For iOS, Desktop, and Web, we reuse the localPreferencesDefinition:\n1 2 3 4  actual val platformModule: Module get() = module { localPreferencesDefinition }   Configuring the App In App.kt, we’ll use the KoinApplication composable function to initialize Koin. Adding KoinAppDeclaration as optional parameter and default to null.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Composable @Preview fun App(koinAppDeclaration: KoinAppDeclaration? = null) { KoinApplication( application = { koinAppDeclaration?.invoke(this) modules(appModule, platformModule) } ) { MaterialTheme { MainScreen() } } }   On Android, we pass a lambda to provide the context and enable logging:\n1 2 3 4 5 6 7 8 9 10 11  class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { App { androidLogger(Level.DEBUG) androidContext(this@MainActivity) } } } }   This flexibility ensures platform-specific setups, like injecting the Android context, without affecting other targets.\nRun the app Run the app on each platform. You can test that all is working fine and each platform gets the configuration needed to run.\nConclusion The new KoinApplication composable simplifies dependency injection in Compose Multiplatform by allowing shared initialization with platform-specific tweaks. This approach reduces boilerplate and enhances code reusability across targets.\nCheck out the complete example on GitHub.\nAlso if you need more info about the different options to declare dependencies on Koin you can refer to a post I made on LinkedIn: Koin DSL\n","description":"Using Koin in Compose Multiplatform from common code with the possibility of configuring each platform.","id":27,"section":"posts","tags":["kotlin","multiplatform","cmp","compose","koin"],"title":"Using Koin in Compose Multiplatform","uri":"https://carrion.dev/en/posts/koin-cmp/"},{"content":"Exploring Design Patterns in Kotlin - Part 1 Design Patterns Series  Part 1 Part 2 Part 3  Design patterns are proven solutions to common problems in software design. With Kotlin’s expressive syntax and modern features, implementing these patterns often becomes cleaner and more concise. In this post, we’ll explore Singleton, Factory Method, Builder, Adapter and Decorator patterns, delving into their purpose, use cases, and Kotlin implementations.\n1. Singleton Pattern The Singleton Pattern ensures that a class has only one instance and provides a global access point to it.\nWhen to Use  Managing shared resources like database connections, logging, or configuration settings.  Kotlin Implementation Kotlin’s object keyword provides a straightforward way to create a Singleton.\n1 2 3 4 5  object DatabaseConnection { fun connect() { println(\u0026#34;Connecting to database...\u0026#34;) } }   Usage 1 2 3  fun main() { DatabaseConnection.connect() }   Advantages in Kotlin  Thread-safe by default. Requires minimal boilerplate compared to traditional implementations in other languages.  2. Factory Method Pattern The Factory Method Pattern delegates the creation of objects to subclasses or helper functions, providing flexibility in object instantiation.\nWhen to Use  When creating objects involves logic or complexity. To decouple object creation from client code.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Shape { fun draw() } class Circle : Shape { override fun draw() = println(\u0026#34;Drawing a Circle\u0026#34;) } class Rectangle : Shape { override fun draw() = println(\u0026#34;Drawing a Rectangle\u0026#34;) } object ShapeFactory { fun createShape(type: String): Shape = when (type) { \u0026#34;Circle\u0026#34; -\u0026gt; Circle() \u0026#34;Rectangle\u0026#34; -\u0026gt; Rectangle() else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unknown shape type\u0026#34;) } }   Usage 1 2 3 4  fun main() { val shape = ShapeFactory.createShape(\u0026#34;Circle\u0026#34;) shape.draw() }   3. Builder Pattern The Builder Pattern is used to construct complex objects step by step. It’s especially useful when an object has many optional parameters or configurations.\nWhen to Use  To avoid constructors with numerous parameters. When the construction process is complex or involves multiple steps.  Kotlin Implementation Kotlin’s apply and DSL capabilities simplify the Builder Pattern.\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Car(val make: String, val model: String, val year: Int) { class Builder { private var make = \u0026#34;\u0026#34; private var model = \u0026#34;\u0026#34; private var year = 0 fun make(make: String) = apply { this.make = make } fun model(model: String) = apply { this.model = model } fun year(year: Int) = apply { this.year = year } fun build() = Car(make, model, year) } }   Usage 1 2 3 4 5 6 7 8 9  fun main() { val car = Car.Builder() .make(\u0026#34;Toyota\u0026#34;) .model(\u0026#34;Corolla\u0026#34;) .year(2022) .build() println(\u0026#34;${car.make}${car.model}, ${car.year}\u0026#34;) }   Why Kotlin? Chaining methods with apply allows a concise and expressive syntax for constructing objects.\n4. Adapter Pattern The Adapter Pattern is used to bridge the gap between incompatible interfaces by translating one interface to another.\nWhen to Use  Integrating with legacy code or external libraries. When two systems or components need to work together but have incompatible interfaces.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // Existing integer provider interface interface OldProvider { fun provide(): Int } class RandomIntProvider : OldProvider { override fun provide(): Int = (1..100).random() } // Target string provider interface interface NewProvider { fun provide(): String } // Adapter class class OldToNewProviderAdapter(private val intProvider: OldProvider) : NewProvider { override fun provide(): String = \u0026#34;Provided number: ${intProvider.provide()}\u0026#34; }   Usage 1 2 3 4 5 6  fun main() { val intProvider = RandomIntProvider() val stringProvider: NewProvider = OldToNewProviderAdapter(intProvider) println(stringProvider.provideString()) }   Why Kotlin? Kotlin’s primary constructors and concise class syntax simplify the implementation of wrapper classes.\n5. Decorator Pattern The Decorator Pattern dynamically adds behavior to objects without altering their structure.\nWhen to Use  To extend functionality of a class at runtime. When subclassing would lead to a bloated hierarchy.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14  interface Coffee { fun cost(): Double fun description(): String } class SimpleCoffee : Coffee { override fun cost() = 5.0 override fun description() = \u0026#34;Simple Coffee\u0026#34; } class MilkDecorator(private val coffee: Coffee) : Coffee { override fun cost() = coffee.cost() + 1.5 override fun description() = coffee.description() + \u0026#34;, Milk\u0026#34; }   Usage 1 2 3 4 5 6  fun main() { val coffee = SimpleCoffee() val coffeeWithMilk = MilkDecorator(coffee) println(\u0026#34;${coffeeWithMilk.description()}costs \\$${coffeeWithMilk.cost()}\u0026#34;) }   Conclusion Kotlin’s modern features like object, when, and apply make implementing traditional design patterns easier and more expressive. These patterns not only solve common design challenges but also demonstrate how Kotlin enhances their implementation.\nAre there other patterns you’d like me to cover in future posts?\n","description":"Kotlin Design Patterns - Part 1","id":28,"section":"posts","tags":["kotlin","design-patterns","architecture"],"title":"Kotlin Design Patterns - Part 1","uri":"https://carrion.dev/en/posts/design-patterns-1/"},{"content":"A Deep Dive into Kotlin Symbol Processing (KSP) with Practical Examples Kotlin Symbol Processing (KSP) is a powerful tool introduced to streamline annotation processing in Kotlin. Compared to kapt (Kotlin Annotation Processing Tool), KSP is faster, offers better integration with Kotlin, and reduces build times significantly. In this post, we’ll explore the fundamentals of KSP, discuss how it works, and demonstrate its use with popular libraries like Koin and Room.\nWhat is KSP? KSP is a lightweight and efficient API for processing Kotlin source code. It allows you to build annotation processors that work directly with Kotlin\u0026rsquo;s syntax tree rather than relying on Java-based tools. This makes it a perfect fit for Kotlin-first projects.\nBenefits of KSP:  Speed: Processes Kotlin code faster than kapt. Kotlin-First: Works directly with Kotlin language constructs, avoiding Java-based abstractions. Lightweight: Reduces boilerplate and integrates seamlessly with Gradle. Compatibility: Many popular libraries now support KSP natively.  Setting Up KSP in Your Project Add the KSP plugin to your project:\nGradle Configuration 1 2 3 4 5 6 7 8 9 10 11 12 13  plugins { kotlin(\u0026#34;jvm\u0026#34;) version \u0026#34;\u0026lt;latest-kotlin-version\u0026gt;\u0026#34; id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;\u0026lt;latest-ksp-version\u0026gt;\u0026#34; } repositories { mavenCentral() } dependencies { implementation(kotlin(\u0026#34;stdlib\u0026#34;)) ksp(\u0026#34;\u0026lt;ksp-processor-library\u0026gt;\u0026#34;) }   Replace \u0026lt;ksp-processor-library\u0026gt; with the library-specific processor dependency, as shown in the examples below.\nExample 1: KSP with Koin Dependency Injection Koin, starting from version 3.4.0, provides annotations to define dependencies, which are processed using KSP to generate Koin modules.\nSetup Koin with KSP Add the following dependencies:\n1 2 3 4 5  dependencies { implementation(\u0026#34;io.insert-koin:koin-core:\u0026lt;version\u0026gt;\u0026#34;) implementation(\u0026#34;io.insert-koin:koin-annotations:\u0026lt;version\u0026gt;\u0026#34;) ksp(\u0026#34;io.insert-koin:koin-ksp-compiler:\u0026lt;version\u0026gt;\u0026#34;) }   Annotate Classes Use Koin annotations to define your dependency graph:\n1 2 3 4 5 6 7 8 9  @Module @ComponentScan class AppModule @Single class UserRepository @Factory class UserUseCase(private val userRepository: UserRepository)   Generated Module The KSP processor automatically generates a Koin module for you. You can include it in your application setup:\n1 2 3 4 5  fun main() { startKoin { modules(AppModuleModule().module) } }   This eliminates the need to manually write the Koin module, saving time and reducing boilerplate.\nExample 2: KSP with Room Database Room is a widely-used ORM for Android. With KSP, Room processes annotations faster, reducing build times significantly.\nSetup Room with KSP Add the following dependencies:\n1 2 3 4  dependencies { implementation(\u0026#34;androidx.room:room-runtime:\u0026lt;version\u0026gt;\u0026#34;) ksp(\u0026#34;androidx.room:room-compiler:\u0026lt;version\u0026gt;\u0026#34;) }   Annotate Entities 1 2 3 4 5  @Entity data class User( @PrimaryKey val id: Int, val name: String )   Generate DAO and Database 1 2 3 4 5 6 7 8 9 10  @Dao interface UserDao { @Query(\u0026#34;SELECT * FROM User\u0026#34;) fun getAllUsers(): List\u0026lt;User\u0026gt; } @Database(entities = [User::class], version = 1) abstract class AppDatabase : RoomDatabase() { abstract fun userDao(): UserDao }   Using KSP, Room generates the necessary code behind the scenes, reducing boilerplate.\nHow to Create a Custom KSP Processor Let’s build a custom KSP processor that generates a Builder class for data classes annotated with @GenerateBuilder. This is a practical and commonly useful feature for many projects.\nCreate the Module First, you should create a module with the API for KSP.\n1 2 3  dependencies { implementation(\u0026#34;com.google.devtools.ksp:symbol-processing-api:\u0026lt;version\u0026gt;\u0026#34;) }   Define the Annotation 1 2 3  @Target(AnnotationTarget.CLASS) @Retention(AnnotationRetention.SOURCE) annotation class GenerateBuilder   KSP Processor Logic The processor can dynamically generate a Builder class based on the properties of the annotated data class. You need to create a class extending SymbolProcessor where all the work will be done in the process function, and a class extending SymbolProcessorProvider, which will provide the implementation of the SymbolProcessor.\nHere is the SymbolProcessor implementation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  class KspBuilderProcessor( private val codeGenerator: CodeGenerator ) : SymbolProcessor { override fun process(resolver: Resolver): List\u0026lt;KSAnnotated\u0026gt; { val symbols = resolver.getSymbolsWithAnnotation(GenerateBuilder::class.qualifiedName.toString()) .filterIsInstance\u0026lt;KSClassDeclaration\u0026gt;() symbols.forEach { symbol -\u0026gt; val className = symbol.simpleName.asString() val packageName = symbol.packageName.asString() val generatedClassName = \u0026#34;${className}Builder\u0026#34; val file = codeGenerator.createNewFile( dependencies = Dependencies(false, symbol.containingFile!!), packageName = packageName, fileName = generatedClassName ) val properties = symbol.getAllProperties() val builderProperties = mutableListOf\u0026lt;String\u0026gt;() val setters = mutableListOf\u0026lt;String\u0026gt;() val buildMethodParams = mutableListOf\u0026lt;String\u0026gt;() properties.forEach { property -\u0026gt; val propName = property.simpleName.asString() val propType = property.type.resolve().declaration.simpleName.asString() .let { if (property.type.resolve().isMarkedNullable) \u0026#34;$it?\u0026#34; else it } val defaultValue = getDefaultValueFromProperty(property) builderProperties.add(\u0026#34; private var $propName: $propType= $defaultValue\u0026#34;) setters.add(\u0026#34; fun set${propName.replaceFirstChar { it.uppercase() }}($propName: $propType) = apply { this.$propName= $propName}\u0026#34;) buildMethodParams.add(\u0026#34; $propName= this.$propName\u0026#34;) } val builderClass = buildString { appendLine(\u0026#34;package $packageName\u0026#34;) appendLine() appendLine(\u0026#34;class $generatedClassName{\u0026#34;) builderProperties.forEach { property -\u0026gt; appendLine(property) } appendLine() setters.forEach { setter -\u0026gt; appendLine(setter) } appendLine() appendLine(\u0026#34; fun build(): $className{\u0026#34;) appendLine(\u0026#34; return $className(\u0026#34;) buildMethodParams.forEach { methodParam -\u0026gt; appendLine(methodParam) } appendLine(\u0026#34; )\u0026#34;) appendLine(\u0026#34; }\u0026#34;) appendLine(\u0026#34;}\u0026#34;) appendLine() appendLine(\u0026#34;fun ${generatedClassName.replaceFirstChar { it.lowercase() }}(block: $generatedClassName.() -\u0026gt; Unit): $className{\u0026#34;) appendLine(\u0026#34; return $generatedClassName().apply(block).build()\u0026#34;) appendLine(\u0026#34;}\u0026#34;) } file.write(builderClass.toByteArray()) file.close() } return symbols.filterNot { it.validate() }.toList() } private fun getDefaultValueFromProperty(property: KSPropertyDeclaration): String { val propType = property.type.resolve().declaration.qualifiedName?.asString() ?: \u0026#34;Any\u0026#34; val isNullable = property.type.resolve().isMarkedNullable return if (isNullable) \u0026#34;null\u0026#34; else when (propType) { \u0026#34;kotlin.String\u0026#34; -\u0026gt; \u0026#34;\\\u0026#34;\\\u0026#34;\u0026#34; \u0026#34;kotlin.Int\u0026#34;, \u0026#34;kotlin.Long\u0026#34;, \u0026#34;kotlin.Short\u0026#34;, \u0026#34;kotlin.Byte\u0026#34; -\u0026gt; \u0026#34;0\u0026#34; \u0026#34;kotlin.Double\u0026#34;, \u0026#34;kotlin.Float\u0026#34; -\u0026gt; \u0026#34;0.0\u0026#34; \u0026#34;kotlin.Boolean\u0026#34; -\u0026gt; \u0026#34;false\u0026#34; else -\u0026gt; throw IllegalArgumentException(\u0026#34;Non-nullable type $propTyperequires a default value\u0026#34;) } } }   And here is the SymbolProcessorProvider:\n1 2 3 4 5  class KspBuilderProvider : SymbolProcessorProvider { override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor { return KspBuilderProcessor(environment.codeGenerator) } }   With these two classes created, you need to create a file with the path src/main/resources/META-INF/services and name com.google.devtools.ksp.processing.SymbolProcessorProvider. Its content will be the full name of the SymbolProcessorProvider class you just created. In this case, it is:\ncom.example.kspbuilder.KspBuilderProvider Use the Custom KSP Processor Add Custom Processor Add the KSP plugin to the build.gradle.kts file on the module where you want to use the annotation:\n1 2 3 4 5 6 7 8  plugins { id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;\u0026lt;version\u0026gt;\u0026#34; } dependencies { implementation(project(\u0026#34;:KspBuilder\u0026#34;)) ksp(project(\u0026#34;:KspBuilder\u0026#34;)) }   Annotate a Class Create a data class with the custom annotation:\n1 2 3 4 5  @GenerateBuilder class Person(val id: Int, val name: String, val age: Int, val address: Address?) @GenerateBuilder class Address(val id: Int, val name: String, val country: String)   Generated Output After building the project, the generated code with KSP will be located under the build/generated/ksp folder.\nFor the Person data class, the generated builder class would look like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class PersonBuilder { private var id: Int = 0 private var name: String = \u0026#34;\u0026#34; private var age: Int = 0 private var address: Address? = null fun setId(id: Int) = apply { this.id = id } fun setName(name: String) = apply { this.name = name } fun setAge(age: Int) = apply { this.age = age } fun setAddress(address: Address?) = apply { this.address = address } fun build(): Person { return Person( id = this.id, name = this.name, age = this.age, address = this.address ) } } fun personBuilder(block: PersonBuilder.() -\u0026gt; Unit): Person { return PersonBuilder().apply(block).build() }   For the Address data class, the generated builder class would look like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class AddressBuilder { private var id: Int = 0 private var name: String = \u0026#34;\u0026#34; private var country: String = \u0026#34;\u0026#34; fun setId(id: Int) = apply { this.id = id } fun setName(name: String) = apply { this.name = name } fun setCountry(country: String) = apply { this.country = country } fun build(): Address { return Address( id = this.id, name = this.name, country = this.country ) } } fun addressBuilder(block: AddressBuilder.() -\u0026gt; Unit): Address { return AddressBuilder().apply(block).build() }   Usage Example 1 2 3 4 5 6 7 8 9 10 11 12  val person = personBuilder { setId(10) setName(\u0026#34;Test\u0026#34;) setAge(100) setAddress( addressBuilder { setId(10) setName(\u0026#34;AddressTest\u0026#34;) setCountry(\u0026#34;Spain\u0026#34;) } ) }   Conclusion Kotlin Symbol Processing is a game-changer for Kotlin developers. Its lightweight and Kotlin-first design makes it a perfect replacement for kapt, and its ability to generate code dynamically opens up new possibilities. Whether you’re using KSP with established libraries like Koin and Room or building custom processors for your use case, KSP provides the tools you need to take your development to the next level.\nTry integrating KSP into your project and see the performance benefits firsthand!\nHere is the repository with the code for the custom KSP processor Github Repo\n","description":"Advanced Kotlin - Kotlin Symbol Processing (KSP)","id":29,"section":"posts","tags":["kotlin","android","advanced"],"title":"A deep dive into Kotlin KSP","uri":"https://carrion.dev/en/posts/kotlin-ksp/"},{"content":"Exploring Kotlin Infix Functions: A Deep Dive Kotlin, as a modern programming language, is packed with features that make code expressive and concise. One of these features is infix functions, which allow you to write cleaner and more readable code. In this blog post, we\u0026rsquo;ll explore what infix functions are, how to use them, and some practical use cases.\nWhat Are Infix Functions? Infix functions in Kotlin are a special kind of function that can be called without using parentheses or the dot operator. This can make certain code patterns more natural and readable, resembling traditional mathematical or DSL (Domain Specific Language) syntax.\nHere’s an example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Point(val x: Int, val y: Int) { infix fun moveBy(offset: Point): Point { return Point(this.x + offset.x, this.y + offset.y) } } fun main() { val point1 = Point(2, 3) val offset = Point(1, 1) // Using the infix notation  val newPoint = point1 moveBy offset println(\u0026#34;New Point: (\\${newPoint.x}, \\${newPoint.y})\u0026#34;) }   In this example, the moveBy function is called using infix notation, improving readability.\nRules and Syntax Here are a few key points about infix functions:\n Single Parameter: The function must take exactly one parameter. Class Member or Extension Function: It must be defined as a member function or an extension function. No Varargs or Default Arguments: The parameter cannot have default values or be a vararg.  Example of an extension function:\n1 2 3 4 5 6 7 8  infix fun String.concatWith(other: String): String { return this + other } fun main() { val result = \u0026#34;Hello\u0026#34; concatWith \u0026#34; World\u0026#34; println(result) // Outputs: Hello World }   Practical Use Cases Infix functions are commonly used in Kotlin to make code more concise and readable. They shine in scenarios where intuitive operations are necessary, such as working with collections, ranges, or creating expressive testing frameworks. Below are some examples of how infix functions can simplify everyday coding tasks:\n  Mapping Keys to Values: The to function in Kotlin\u0026rsquo;s standard library is an infix function that helps in creating pairs, often used in maps.\n1 2 3 4  fun main() { val map = mapOf(\u0026#34;key1\u0026#34; to \u0026#34;value1\u0026#34;, \u0026#34;key2\u0026#34; to 42) println(map) // Outputs: {key1=value1, key2=42} }     Defining Ranges: The until function is an infix function used to define ranges that exclude the upper bound.\n1 2 3 4 5  fun main() { for (i in 1 until 5) { println(i) // Outputs: 1, 2, 3, 4  } }     Mocking in Tests: Libraries like MockK use infix functions to create expressive and readable test setups.\n1 2 3 4 5 6 7 8 9 10  class Calculator { fun add(a: Int, b: Int): Int = a + b } fun test() { val calculator = mockk\u0026lt;Calculator\u0026gt;() every { calculator.add(1, 2) } returns 3 println(calculator.add(1, 2)) // Outputs: 3 }     Dependency Injection with Koin: Koin, a dependency injection framework for Kotlin, uses the bind infix function to define bindings in a clean and readable way.\n1 2 3 4 5 6  interface MyInterface class MyImplementation : MyInterface val appModule = module { single { MyImplementation() } bind MyInterface::class }   The bind infix function enhances readability when declaring that a specific implementation should be used for an interface.\n  When to Use Infix Functions While infix functions can make code cleaner, they should be used judiciously. Use them when:\n The operation is intuitive and widely understood. They enhance readability and flow. They fit naturally into a DSL.  Avoid using infix functions when:\n It could lead to ambiguous or confusing syntax. The function\u0026rsquo;s purpose isn\u0026rsquo;t clear from its name or usage.  Conclusion Kotlin\u0026rsquo;s infix functions are a powerful tool for creating expressive and readable code. Whether you’re defining a DSL, simplifying mathematical operations, or enhancing logical expressions, infix functions can make your code more elegant. However, as with any feature, they should be used thoughtfully to maintain code clarity and avoid overcomplication.\nTry incorporating infix functions in your next Kotlin project and see how they transform your code! What are your favorite infix functions or creative ways to use them? Share your experiences in the comments!\n","description":"Advanced Kotlin - Infix functions","id":30,"section":"posts","tags":["kotlin","android","advanced"],"title":"Kotlin Infix functions","uri":"https://carrion.dev/en/posts/kotlin-infix/"},{"content":"✨ Understanding Kotlin Delegates: The Magic Behind Cleaner Code ✨ Kotlin delegates are a powerful feature that lets you delegate the behavior of a property or even an interface implementation to another object. Instead of writing repetitive logic or managing state directly, you can delegate this responsibility to reusable and specialized classes.\nHow Delegates Work Delegates in Kotlin work by using the by keyword, which redirects the behavior of a property or an interface to a delegate object. For properties, the delegate object provides custom implementations for the get and/or set methods. For interface delegation, the class implementation is forwarded to the provided delegate.\nHere’s an example of property delegation using a custom delegate:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class StringDelegate { private var value: String = \u0026#34;\u0026#34; operator fun getValue(thisRef: Any?, property: kotlin.reflect.KProperty\u0026lt;*\u0026gt;): String { println(\u0026#34;Getting value for \\${property.name}\u0026#34;) return value } operator fun setValue(thisRef: Any?, property: kotlin.reflect.KProperty\u0026lt;*\u0026gt;, newValue: String) { println(\u0026#34;Setting value for \\${property.name} to \\$newValue\u0026#34;) value = newValue } } class Example { var text: String by StringDelegate() } fun main() { val example = Example() example.text = \u0026#34;Hello, Kotlin!\u0026#34; println(example.text) }   Output Setting value for text to Hello, Kotlin! Getting value for text Hello, Kotlin! In this example:\n The StringDelegate class defines custom behavior for property access using the getValue and setValue operators. The text property in the Example class delegates its behavior to an instance of StringDelegate.  Real-World Applications of Delegates 1️⃣ Dependency Injection with Koin In #Koin, you can use the by inject() delegate to inject dependencies directly into your classes. This eliminates the need for manual instantiation:\n1 2 3 4 5 6 7 8 9 10  class DelegatesFragment : Fragment() { private val tracker: AnalyticsTracker by inject() } inline fun \u0026lt;reified T : Any\u0026gt; KoinComponent.inject( qualifier: Qualifier? = null, mode: LazyThreadSafetyMode = KoinPlatformTools.defaultLazyMode(), noinline parameters: ParametersDefinition? = null, ): Lazy\u0026lt;T\u0026gt; = lazy(mode) { get\u0026lt;T\u0026gt;(qualifier, parameters) }   The by inject() delegate automatically resolves the dependency using Koin’s container. It abstracts the boilerplate, resulting in cleaner, testable code.\n2️⃣ State Management in Jetpack Compose In Jetpack Compose, the remember function with mutableStateOf is a great example of delegation. It helps you manage state efficiently within your composables:\n1 2 3 4 5 6 7 8 9 10 11  @Composable fun Counter() { var count by remember { mutableStateOf(0) } Column { Text(\u0026#34;Count: $count\u0026#34;) Button(onClick = { count++ }) { Text(\u0026#34;Increment\u0026#34;) } } }   3️⃣ Lazy Initialization The lazy delegate is perfect for properties that need to be initialized only when accessed for the first time:\n1 2 3 4 5 6 7 8 9  val greeting: String by lazy { println(\u0026#34;Initializing...\u0026#34;) \u0026#34;Hello, Kotlin!\u0026#34; } fun main() { println(greeting) // Initializes here  println(greeting) // Uses cached value }   Output Initializing... Hello, Kotlin! Hello, Kotlin! 4️⃣ Interface Delegation in Constructor Kotlin allows you to delegate the implementation of an interface to another object.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  interface Logger { fun log(message: String) } class ConsoleLogger : Logger { override fun log(message: String) { println(\u0026#34;Log: $message\u0026#34;) } } class FileLogger : Logger { override fun log(message: String) { println(\u0026#34;Writing log to file: $message\u0026#34;) } } class Application(logger: Logger) : Logger by logger fun main() { val consoleApp = Application(ConsoleLogger()) consoleApp.log(\u0026#34;Starting console application\u0026#34;) val fileApp = Application(FileLogger()) fileApp.log(\u0026#34;Starting file application\u0026#34;) }   Output Log: Starting console application Writing log to file: Starting file application Here’s what’s happening:\n The Application class doesn’t implement the Logger methods directly. Instead, it delegates the Logger implementation to the object passed to its constructor using by. This makes it easy to swap implementations without changing the Application class.  Why Use Kotlin Delegates? Delegates encapsulate logic that would otherwise clutter your classes. They help:\n Simplify code by reusing logic (e.g., lazy initialization). Abstract repetitive patterns (e.g., dependency injection). Enhance state management (e.g., Jetpack Compose’s remember). Provide modular and reusable interface implementations (e.g., constructor delegation).  Conclusion Kotlin’s delegate mechanism is a prime example of how the language combines simplicity and power. Delegates are everywhere in Kotlin development. Are you using them in other cases in your projects?\n","description":"Advanced Kotlin - Delegates","id":31,"section":"posts","tags":["kotlin","android","advanced"],"title":"Kotlin Delegates","uri":"https://carrion.dev/en/posts/kotlin-delegates/"},{"content":"Mastering Kotlin Contracts: Unlocking Smarter Code Analysis Kotlin never ceases to amaze with its features that combine elegance and power. One advanced yet often underutilized tool in Kotlin\u0026rsquo;s arsenal is Contracts. Contracts let you guide the Kotlin compiler to make smarter decisions about your code—resulting in better null safety, optimized performance, and fewer runtime errors.\nWhat Are Kotlin Contracts? Kotlin Contracts allow you to define rules about how your functions behave, helping the compiler perform advanced static analysis. They enable features like smart-casts and context-aware checks beyond Kotlin’s default capabilities.\nWhy Use Contracts?  Improve Null Safety: Eliminate redundant null checks by telling the compiler when something is guaranteed to be non-null. Optimize Smart-Casts: Make the compiler aware of variable types in custom scenarios. Reduce Boilerplate: Write cleaner, more intuitive code by offloading repetitive checks to the compiler.  Examples of Kotlin Contracts in Action 1. Simplify Null Checks Let’s create a custom utility to validate non-null values:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @OptIn(ExperimentalContracts::class) inline fun \u0026lt;T\u0026gt; requireNotNull(value: T?, message: String): T { contract { returns() implies (value != null) } if (value == null) { throw IllegalArgumentException(message) } return value } fun processName(name: String?) { val nonNullName = requireNotNull(name, \u0026#34;Name cannot be null\u0026#34;) // No need for additional null checks; compiler knows \u0026#39;nonNullName\u0026#39; is not null!  println(\u0026#34;Processing name: $nonNullName\u0026#34;) } fun main() { processName(\u0026#34;John\u0026#34;) // Works fine  // processName(null) // Throws an IllegalArgumentException }   Something similar is implemented in the functions require and requireNotNull from the Kotlin standard lib:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  /** * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false. * * @sample samples.misc.Preconditions.failRequireWithLazyMessage */ @kotlin.internal.InlineOnly public inline fun require(value: Boolean, lazyMessage: () -\u0026gt; Any): Unit { contract { returns() implies value } if (!value) { val message = lazyMessage() throw IllegalArgumentException(message.toString()) } } /** * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise * returns the not null value. * * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage */ @kotlin.internal.InlineOnly public inline fun \u0026lt;T : Any\u0026gt; requireNotNull(value: T?, lazyMessage: () -\u0026gt; Any): T { contract { returns() implies (value != null) } if (value == null) { val message = lazyMessage() throw IllegalArgumentException(message.toString()) } else { return value } }   How Contracts Help Here  The returns() implies (value != null) contract tells the compiler:  If the function returns successfully, then value is guaranteed to be non-null.\n  This enables smart-casts, so you don’t need manual null checks after the function call.  2. Custom Assertions Here’s how contracts can be used to define custom assertion functions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @OptIn(ExperimentalContracts::class) fun assertValidState(condition: Boolean, message: String) { contract { returns() implies condition } if (!condition) { throw IllegalStateException(message) } } fun performOperation(state: Boolean) { val state: Any? = \u0026#34;Hello\u0026#34; assertValidState(state is String, \u0026#34;Is String\u0026#34;) // Here the compiler knows that the state val is of type String so no need to other cast checks  println(\u0026#34;String length: ${assertion.length}\u0026#34;) } fun main() { performOperation(true) // Prints success  // performOperation(false) // Throws IllegalStateException }   3. Smart-Casts with Custom Conditions Let’s create a utility function that checks if a value matches a specific type. This will demonstrate how contracts enable smarter casting:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  @OptIn(ExperimentalContracts::class) inline fun \u0026lt;reified T\u0026gt; isOfType(value: Any?): Boolean { contract { returns(true) implies (value is T) } return value is T } fun main() { val input: Any? = \u0026#34;Hello, Kotlin!\u0026#34; if (isOfType\u0026lt;String\u0026gt;(input)) { println(\u0026#34;String length: ${input.length}\u0026#34;) } val inputInt: Any? = 10 if (isOfType\u0026lt;Int\u0026gt;(inputInt)) { println(\u0026#34;The value is an integer ${input.toUInt()}\u0026#34;) } }   With this implementation, the compiler knows that within the if block, input is a String, thanks to the contract defined in isOfType. Also the compilers knows that inputInt is an Int so you don\u0026rsquo;t need to cast it.\n4. Optimizing Flow Control Contracts can simplify flow control by enabling the compiler to understand loop invariants or conditions. Here’s an example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  inline fun isNotEmpty(list: List\u0026lt;*\u0026gt;?): Boolean { contract { returns(true) implies (list != null \u0026amp;\u0026amp; list.isNotEmpty()) } return list != null \u0026amp;\u0026amp; list.isNotEmpty() } fun processItems(items: List\u0026lt;String\u0026gt;?) { if (isNotEmpty(items)) { // Compiler knows items is non-null and not empty  println(\u0026#34;Processing ${items.size}items\u0026#34;) } else { println(\u0026#34;No items to process\u0026#34;) } } fun main() { processItems(listOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;)) processItems(null) processItems(emptyList()) }   Output Processing 3 items No items to process No items to process When to Use Contracts Contracts are ideal for:\n Library Development: Safeguard public APIs by enforcing preconditions. DSLs and Frameworks: Simplify type-checking and state validations in Kotlin DSLs. Performance Optimization: Reduce runtime checks by letting the compiler infer conditions at compile time.  Conclusion Kotlin Contracts are a hidden gem that can elevate your code by improving safety, reducing boilerplate, and enabling smarter compiler analysis. Whether you\u0026rsquo;re building libraries, writing complex DSLs, or just optimizing everyday code, contracts provide a powerful tool to guide the Kotlin compiler and ensure code correctness.\nAlso keep in mind that contracts are annotated as experimental feature but they are in Kotlin since 1.3 version and are being used in the standard library so they are stable enough to use them.\n","description":"Advanced Kotlin - Contracts","id":32,"section":"posts","tags":["kotlin","android","advanced"],"title":"Kotlin contracts","uri":"https://carrion.dev/en/posts/kotlin-contracts/"},{"content":"Swift export in Kmp Starting from version 2.1.0 we can start testing the Swift export in Kotlin. This feature allows you to export the Kotlin shared modules to Swift without the use of Objective-C. This will improve the iOS developers experience when using KMP modules.\nAt the moment basic support includes:\n Export multiple Gradle modules to Swift. Define the Swift module names. Flatten package structure  Enable the feature To start testing this functionality you should enable it on gradle.properties file:\nkotlin.experimental.swift-export.enabled=true Configuration After adding the line above you need to add this configuration to the build.gradle.kts file:\n1 2 3 4 5 6 7 8 9 10 11  kotlin { iosX64() iosArm64() iosSimulatorArm64() @OptIn(ExperimentalSwiftExportDsl::class) swiftExport { moduleName = \u0026#34;shared\u0026#34; flattenPackage = \u0026#34;dev.carrion.kmpswiftexport\u0026#34; } }   Next step is configuring xcode to launch the new task embedSwiftExportForXcode instead of embedAndSignAppleFrameworkForXcode. You can do it from xcode build phases configuration of the iosApp or from Android Studio modifying the project.pbxproj file.\nYou should change this line:\nshellScript = \u0026quot;cd \\\u0026quot;$SRCROOT/..\\\u0026quot;\\n./gradlew :shared:embedAndSignAppleFrameworkForXcode\\n\u0026quot;; With this one:\nshellScript = \u0026quot;cd \\\u0026quot;$SRCROOT/..\\\u0026quot;\\n./gradlew :shared:embedSwiftExportForXcode\\n\u0026quot;; After this changes you should be able to launch the app from Android Studio or xcode without any problems.\nBefore enabling the feature If you try to jump to the definition of a kotlin function from xcode in a swift file, you will be prompted with the Objective-C code exported from the kotlin shared module. This file is huge given the complexity of the project used for this example.\nI will show you just a little piece of the 175 lines file generated from the Kotlin source code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;Greeting\u0026#34;))) @interface SharedGreeting : SharedBase - (instancetype)init __attribute__((swift_name(\u0026#34;init()\u0026#34;))) __attribute__((objc_designated_initializer)); + (instancetype)new __attribute__((availability(swift, unavailable, message=\u0026#34;use object initializers instead\u0026#34;))); - (NSString *)greet __attribute__((swift_name(\u0026#34;greet()\u0026#34;))); @end __attribute__((swift_name(\u0026#34;Platform\u0026#34;))) @protocol SharedPlatform @required @property (readonly) NSString *name __attribute__((swift_name(\u0026#34;name\u0026#34;))); @end __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;IOSPlatform\u0026#34;))) @interface SharedIOSPlatform : SharedBase \u0026lt;SharedPlatform\u0026gt; - (instancetype)init __attribute__((swift_name(\u0026#34;init()\u0026#34;))) __attribute__((objc_designated_initializer)); + (instancetype)new __attribute__((availability(swift, unavailable, message=\u0026#34;use object initializers instead\u0026#34;))); @property (readonly) NSString *name __attribute__((swift_name(\u0026#34;name\u0026#34;))); @end __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;Platform_iosKt\u0026#34;))) @interface SharedPlatform_iosKt : SharedBase + (id\u0026lt;SharedPlatform\u0026gt;)getPlatform __attribute__((swift_name(\u0026#34;getPlatform()\u0026#34;))); @end #pragma pop_macro(\u0026#34;_Nullable_result\u0026#34;) #pragma clang diagnostic pop NS_ASSUME_NONNULL_END   After enabling the feature When you enable the feature and build the project, trying to go to the definition of a function from the Kotlin code, xcode will show you the exported Swift code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  @_exported import ExportedKotlinPackages @_implementationOnly import SharedBridge_shared import KotlinRuntime public typealias Greeting = ExportedKotlinPackages.dev.carrion.kmpswiftexport.Greeting public func getPlatform() -\u0026gt; Swift.Never { ExportedKotlinPackages.dev.carrion.kmpswiftexport.getPlatform() } public extension ExportedKotlinPackages.dev.carrion.kmpswiftexport { public final class Greeting : KotlinRuntime.KotlinBase { public override init() { let __kt = dev_carrion_kmpswiftexport_Greeting_init_allocate() super.init(__externalRCRef: __kt) dev_carrion_kmpswiftexport_Greeting_init_initialize__TypesOfArguments__Swift_UInt__(__kt) } public override init( __externalRCRef: Swift.UInt ) { super.init(__externalRCRef: __externalRCRef) } public func greet() -\u0026gt; Swift.String { return dev_carrion_kmpswiftexport_Greeting_greet(self.__externalRCRef()) } } public static func getPlatform() -\u0026gt; Swift.Never { fatalError() } }   The code above this lines is the complete file with 28 lines, a huge difference with the 175 lines from the Objective-C exported code. Also it\u0026rsquo;s important to mention the lower complexity and higher readability on the Swift example.\nConclusion After testing this new feature, I\u0026rsquo;m really amazed with the improvement it brings to the iOS development in KMP projects. Also impressed with the difference in code between Objective-C and Swift exported codes. I\u0026rsquo;m sure this feature will improve in next versions and it will close the bridge between the native and multiplatform development experiences.\nYou can find the repository with the code from this example in SwiftExport, with two branches, main, where it\u0026rsquo;s the usual iOS framework configuration, and swift-export branch which has the new feature enabled.\n","description":"New feature in Kotlin 2.1.0, basic swift export from Kotlin","id":33,"section":"posts","tags":["kotlin","android","kmp"],"title":"Swift export in KMP","uri":"https://carrion.dev/en/posts/swift-export/"},{"content":"Guard conditions in when in Kotlin 2.1.0 One of the new features in Kotlin 2.1.0 is the guard conditions on when expressions, this feature will bring some advantages like:\n Reduce nesting Avoid boilerplate Improve readability  Enable the feature This feature is in preview state, for this you need to enable it starting on Kotlin 2.1.0. In the file build.gradle.kts we should add the new piece of code inside the kotlin block:\n1 2 3 4 5  kotlin { compilerOptions { freeCompilerArgs.add(\u0026#34;-Xwhen-guards\u0026#34;) } }   Use guard conditions on when expression branches For this example we will use a sealed interface to handle the responses from a remote service:\n1 2 3 4 5  sealed interface Response\u0026lt;out T\u0026gt; { data object Loading : Response\u0026lt;Nothing\u0026gt; data class Content \u0026lt;out T\u0026gt; (val data: T?) : Response\u0026lt;T\u0026gt; data class Error(val error: Exception) : Response\u0026lt;Nothing\u0026gt; }   Loading, Content and Error implement the Response interface to manage the different states of the response.\nBefore new feature 1 2 3 4 5 6 7 8 9 10 11 12 13  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handleOld() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content -\u0026gt; if (data != null) { println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } is Response.Error -\u0026gt; if (error is IllegalStateException) { println(\u0026#34;Handled error\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } }   Here you can see how the code to print the Unknown error needs to be in both branches, also it adds nested complexity that reduces the code readability.\nUsing new Guard conditions You must add if statement after the primary condition inside the when branch, see below:\n1 2 3 4 5 6  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled error\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   This way the print statement with the text Unkwon error is used just once, also we remove the nested complexity.\nIf we need to check different conditions on the else branch, we can use an else if in case our response doesn\u0026rsquo;t satisfy the previous conditions.\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) else if this is Response.Error \u0026amp;\u0026amp; this.error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   This example can be simplified using to branches with the same primary condition is Response.Error, in my opinion keeps the code more readable and simple:\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) is Response.Error if error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   Conclusion With this new feature we can add new conditions without repeating code and will allow more concise when expressions. It\u0026rsquo;s in preview state starting from Kotlin 2.1.0 but seems like it will become stable soon.\nHere is the link to the documentation where you can find what\u0026rsquo;s new in Kotlin 2.1.0 included the guard conditions in when expressions kotlinlang\n","description":"New feature since Kotlin 2.1.0, guard conditions in when expressions","id":34,"section":"posts","tags":["kotlin","android","kmp"],"title":"Guard conditions in when starting in Kotlin 2.1.0.","uri":"https://carrion.dev/en/posts/kotlin-guard-conditions-in-when/"},{"content":"Inject runtime parameters with Dagger-Hilt Since Hilt appeared to make it easier the dependency injection in Android, it was impossible to inject runtime parameters without using third party libraries. Since Dagger version 2.31, exists the @AssistedInject annotation. With this annotation we can instruct Dagger-Hilt what dependencies need to be created at runtime and delay the injection of this parameters until we can provide those values.\nThis is necessary to inject parameters into ViewModel constructor and be able to execute some code in the init function. It can be an external API call or some query to our local database.\nIn this post we will learn how to use @AssistedInject from Dagger to inject runtime parameters to ViewModels with Hilt.\nInstallation In the root project build.gradle file, we will include the Hilt classpath:\n1  classpath \u0026#39;com.google.dagger:hilt-android-gradle-plugin:2.31.2-alpha\u0026#39;   Once we have Hilt classpath we will add Hilt plugin to build.gradle file from app module.\n1  apply plugin: \u0026#39;dagger.hilt.android.plugin\u0026#39;   And the next lines to our dependencies block:\n1 2  implementation \u0026#39;com.google.dagger:hilt-android:2.31.2-alpha\u0026#39; kapt \u0026#39;com.google.dagger:hilt-android-compiler:2.31.2-alpha\u0026#39;    We should keep in mind that we need kapt plugin on our build.gradle. For this we will add this line with the rest of plugins in our build.gradle from app module:\n 1  apply plugin: \u0026#39;kotlin-kapt\u0026#39;   Those were the needed dependencies to make Hilt work in our project. In this post we will use libraries that are not defined here.\nIn this link you can see the complete build.gradle file: app/build.gradle\nImplementation For this example we will be using a repository class with a function which receives a name and returns a welcome message. To acomplish this we will create the interface below:\n1 2 3  interface UserRepository { fun getMessage(name: String): String }   And it\u0026rsquo;s implementation:\n1 2 3 4 5  class UserRepositoryImpl @Inject constructor() : UserRepository { override fun getMessage(name: String): String { return \u0026#34;Hi $name\u0026#34; } }   We should annotate the constructor with @Inject so we can declare a @Binds annotation in the Hilt module to be able to inject the implementation when we call an interface of type UserRepository.\nNext we will create our ViewModel, this class will receive the user name from the Activity or Fragment and call the repository to get the welcome message:\n1 2 3 4 5 6 7 8 9  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { ... }   In this ViewModel we can see how we should annotate the constructor with @AssistedInject so Dagger-Hilt knows this class has dependencies that will be injected at runtime. This runtime dependencies will be annotated with @Assisted.\nTo be able to create our ViewModel with the extension by viewModels() from AndroidX library, we should create the Factory class wich will be provided to the extension:\n1 2 3 4 5 6 7 8  class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } }   You can see we need an interface called UserViewModelAssistedFactory. This interface will handle the runtime parameters injected to the ViewModel:\n1 2 3 4 5 6  @AssistedFactory interface UserViewModelAssistedFactory { fun create(name: String): UserViewModel }   It\u0026rsquo;s an interface with a create function. This function receive all the runtime parameters we want to inject in our ViewModel. In this example we only need a name parameter, but in case we need more parameters injected at runtime, they will be provided to this function.\nWith this we are able to complete our ViewModel with the logic to get the answer from the repository and expose it to the Fragment or Activity through a StateFlow.\nThe complete ViewModel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } } private val _message: MutableStateFlow\u0026lt;String\u0026gt; = MutableStateFlow(\u0026#34;\u0026#34;) val message: StateFlow\u0026lt;String\u0026gt; get() = _message init { viewModelScope.launch(dispatcher) { _message.emit(repository.getMessage(name)) } } }   Related to Hilt we only have to create the module to handle the creation of dependencies. For this example we will be using this module:\n1 2 3 4 5 6 7 8 9 10 11 12 13  @Module @InstallIn(ActivityComponent::class) abstract class MainModule { companion object { @Provides @Named(\u0026#34;UserDispatcher\u0026#34;) fun provideUserDispatcher(): CoroutineDispatcher = Dispatchers.IO } @Binds abstract fun provideUserRepository(repositoryImpl: UserRepositoryImpl): UserRepository }   In this module we declare a function to provide a Dispatcher so it will be easier to test this ViewModel in a future. We declare a @Binds function so when we inject a UserRepository interface Hilt provides its implementation UserRepositoryImpl.\nNow we can user our ViewModel in Activities or Fragments:\n1 2 3 4 5 6 7 8  private val navArgs: UserFragmentArgs by navArgs() @Inject lateinit var assistedFactory: UserViewModelAssistedFactory private val userViewModel: UserViewModel by viewModels { UserViewModel.Factory(assistedFactory, navArgs.name) }   We need to @Inject the AssistedFactory and use the UserViewModel.Factory to create our ViewModel.\nFrom this step we only need to observe changes in the ViewModel StateFlow to be able to update our UI. This can be done in Fragments observing from the onViewCreated.\n1 2 3 4 5 6 7 8  override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycleScope.launchWhenStarted { userViewModel.message.collect { binding.name.text = it } } }    Remember you need a class extending Application annotated with @HiltAndroidApp and each Activity or Fragment that uses injection with Hilt need to be annotated with @AndroidEntryPoint.\n Conclusion Now we can inject Runtime values with Dagger @AssistedInject in a simple way and we can keep using navArgs from AndroidX.\nYou can see the complete example in this repository: HiltAssistedInject\n","description":"Inject parameters to ViewModels at Runtime in Android.","id":35,"section":"posts","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Hilt: Inject Runtime parameters to ViewModels.","uri":"https://carrion.dev/en/posts/hilt-inject-parameters-runtime/"},{"content":"Welcome to Carrion.dev Hi droid!\nWelcome to my new Kotlin and Android programming blog. I am Ignacio Carrión and I\u0026rsquo;m an Android developer. I love Kotlin because it boost my Android development eficiency and because it has infinite posibilities outside of Android ecosystem (backend, web, native, multiplatform\u0026hellip;).\nIn this blog I hope I can publish interesting topics about Kotlin and Android at least twice a month. If you want to keep up to date you can subscribe to our newsletter.\nIf you have any question, idea about some topic for the blog or you just want to contact with me, I\u0026rsquo;m available through my email: ignacio@carrion.dev.\nI hope we can learn together!!\n","description":"First post in my new Kotlin and Android development blog","id":36,"section":"posts","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Welcome to my new Kotlin and Android development blog","uri":"https://carrion.dev/en/posts/welcome-to-my-new-kotlin-and-android-development-blog/"},{"content":"About. I\u0026rsquo;m Ignacio Carrión, I live in Valencia (Spain) and the one who appears on the avatar is my dog Wilfred. I like anything related to IT and videogames. At the moment I\u0026rsquo;m working as Android Engineer for Tkww. Before that I worked as Android Developer for other companies and I worked as a programming teacher. While I was working as a teacher, I realized that I love learning and helping others to learn with me. From this motivation arises the idea of this blog, Carrion.dev.\nI hope I can publish something interesting about Kotlin or Android ecosystem at least twice a month. Constructive criticism or ideas about posts will be welcomed. Below you can see the links to my social networks where you can find and contact me.\nContact Portfolio\nGithub\n","description":"Hugo, the world’s fastest framework for building websites","id":41,"section":"","tags":null,"title":"About","uri":"https://carrion.dev/en/about/"}]