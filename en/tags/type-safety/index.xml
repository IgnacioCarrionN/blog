<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>type-safety on Carrion.dev</title><link>https://carrion.dev/en/tags/type-safety/</link><description>Recent content in type-safety on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Tue, 15 Apr 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/en/tags/type-safety/index.xml" rel="self" type="application/rss+xml"/><item><title>Leveraging Sealed Classes and Interfaces for Better Domain Modeling</title><link>https://carrion.dev/en/posts/sealed-classes-domain-modeling/</link><pubDate>Tue, 15 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 15 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/sealed-classes-domain-modeling/</guid><description>Leveraging Sealed Classes and Interfaces for Better Domain Modeling Domain modeling is a crucial aspect of software development, representing the core business concepts and rules in your application. Kotlin provides powerful language features that can help create more expressive, type-safe, and maintainable domain models. Among these features, sealed classes and interfaces stand out as particularly valuable tools. This blog post explores how to leverage these Kotlin features to build better domain models.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/sealed-classes.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category><category>domain modeling</category><category>type safety</category></item><item><title>Building Type-safe DSLs with Kotlin: From Basics to Advanced Patterns</title><link>https://carrion.dev/en/posts/building-type-safe-dsls/</link><pubDate>Tue, 25 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 25 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/building-type-safe-dsls/</guid><description>Building Type-safe DSLs with Kotlin: From Basics to Advanced Patterns Domain-Specific Languages (DSLs) in Kotlin allow you to create expressive, readable, and type-safe APIs. This article explores how to build effective DSLs using Kotlin&amp;rsquo;s powerful features, focusing on scope control with @DslMarker to prevent common mistakes in nested DSLs.
By the end of this article, you&amp;rsquo;ll understand:
How to design clean and intuitive DSL APIs When and how to use @DslMarker for better scope control Best practices for maintaining type safety throughout your DSL Common pitfalls and how to avoid them Basic DSL Concepts Let&amp;rsquo;s explore the fundamental concepts of Kotlin DSLs by building a simple HTML builder:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/type-safe-dsls.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>dsl</category><category>type-safety</category><category>design-patterns</category></item><item><title>Advanced Generics and Variance in Kotlin: A Comprehensive Guide</title><link>https://carrion.dev/en/posts/advanced-kotlin-generics/</link><pubDate>Fri, 21 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 21 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/advanced-kotlin-generics/</guid><description>Advanced Generics and Variance in Kotlin: A Comprehensive Guide Understanding advanced generics and variance in Kotlin is crucial for writing type-safe, reusable code. This article explores these concepts in depth, providing practical examples and real-world applications.
Understanding Variance Variance in Kotlin determines how generic types with different type arguments relate to each other. Understanding variance is easier when thinking in terms of producers and consumers:
Producer: Only produces/provides values of type T (output) Consumer: Only consumes/accepts values of type T (input) This producer/consumer relationship directly maps to the two types of variance:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/advanced-generics.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>generics</category><category>variance</category><category>type-safety</category></item></channel></rss>