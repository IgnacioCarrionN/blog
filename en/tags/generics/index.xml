<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>generics on Carrion.dev</title><link>https://carrion.dev/en/tags/generics/</link><description>Recent content in generics on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Fri, 24 Oct 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/en/tags/generics/index.xml" rel="self" type="application/rss+xml"/><item><title>Zero-Cost Abstractions in Kotlin: Inline Functions and Value Classes</title><link>https://carrion.dev/en/posts/kotlin-inline-functions-value-classes/</link><pubDate>Fri, 24 Oct 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 24 Oct 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-inline-functions-value-classes/</guid><description>Zero-Cost Abstractions in Kotlin: Inline Functions and Value Classes Kotlin gives you two powerful tools to write safer and faster code with zero or near-zero runtime overhead: inline functions and value classes. Used correctly, they help you avoid allocations, improve type safety, and keep APIs expressive.
This post explains what they are, how they work under the hood, practical use cases, trade-offs, and when not to use them.
TL;DR Inline functions remove call-site overhead for small higher-order utilities and enable reified type parameters.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/inline.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>inline</category><category>value-classes</category><category>performance</category><category>generics</category></item><item><title>Advanced Generics and Variance in Kotlin: A Comprehensive Guide</title><link>https://carrion.dev/en/posts/advanced-kotlin-generics/</link><pubDate>Fri, 21 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 21 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/advanced-kotlin-generics/</guid><description>Advanced Generics and Variance in Kotlin: A Comprehensive Guide Understanding advanced generics and variance in Kotlin is crucial for writing type-safe, reusable code. This article explores these concepts in depth, providing practical examples and real-world applications.
Understanding Variance Variance in Kotlin determines how generic types with different type arguments relate to each other. Understanding variance is easier when thinking in terms of producers and consumers:
Producer: Only produces/provides values of type T (output) Consumer: Only consumes/accepts values of type T (input) This producer/consumer relationship directly maps to the two types of variance:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/advanced-generics.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>generics</category><category>variance</category><category>type-safety</category></item></channel></rss>