<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>testing on Carrion.dev</title><link>https://carrion.dev/en/tags/testing/</link><description>Recent content in testing on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Fri, 22 Aug 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/en/tags/testing/index.xml" rel="self" type="application/rss+xml"/><item><title>Dependency Injection + Dependency Inversion: More Robust and Testable Code</title><link>https://carrion.dev/en/posts/dependency-injection-benefits/</link><pubDate>Fri, 22 Aug 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 22 Aug 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/dependency-injection-benefits/</guid><description>Dependency Injection + Dependency Inversion: More Robust and Testable Code Modern applications evolve quickly: features are added, platforms multiply, and teams scale. In this environment, tightly coupled code becomes a bottleneck for change and a source of fragile tests. Two key ideas help us fight this complexity:
Dependency Inversion Principle (DIP) from SOLID: high-level modules should not depend on low-level modules. Both should depend on abstractions. Dependency Injection (DI): a technique and set of tools to provide those dependencies from the outside instead of constructing them internally.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/dip.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>architecture</category><category>solid</category><category>dependency-injection</category><category>testing</category></item><item><title>Coroutine Testing Patterns: Effective Strategies for Testing Asynchronous Kotlin Code</title><link>https://carrion.dev/en/posts/coroutine-testing-patterns/</link><pubDate>Tue, 29 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 29 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/coroutine-testing-patterns/</guid><description>Coroutine Testing Patterns: Effective Strategies for Testing Asynchronous Kotlin Code Testing asynchronous code has always been challenging, and Kotlin&amp;rsquo;s coroutines and flows are no exception. However, the Kotlin team has provided powerful testing utilities that make this process more manageable and reliable. In this blog post, we&amp;rsquo;ll explore effective patterns for testing coroutines and flows, from basic unit tests to complex integration scenarios.
The Foundation: kotlinx-coroutines-test Before diving into specific patterns, let&amp;rsquo;s establish the foundation.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/coroutine-testing.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>coroutines</category><category>testing</category><category>flows</category></item><item><title>Mocks, Fakes, and More</title><link>https://carrion.dev/en/posts/test-doubles/</link><pubDate>Thu, 06 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 06 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/test-doubles/</guid><description>Mocks, Fakes, and More: Understanding Test Doubles in Kotlin When writing tests in Kotlin, especially for Android development, we often need to replace real dependencies with test doubles. However, not all test doubles are the same—terms like mocks, fakes, stubs, spies, and dummies often come up. In this post, we’ll break down their differences with Kotlin examples using only plain Kotlin (no third-party libraries).
1. Understanding Test Doubles Test doubles are objects that stand in for real dependencies in tests.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/mock.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>testing</category><category>mock</category><category>tdd</category></item><item><title>Test-Driven Development (TDD) in Kotlin for Android</title><link>https://carrion.dev/en/posts/tdd-kotlin/</link><pubDate>Mon, 20 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 20 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/tdd-kotlin/</guid><description>Test-Driven Development (TDD) in Kotlin for Android Test-Driven Development (TDD) is a software development practice that emphasizes writing tests before implementing functionality. It follows a Red-Green-Refactor cycle: first, you write a failing test (Red), then implement just enough code to make it pass (Green), and finally, refactor the code while keeping the test green (Refactor). In this post, we&amp;rsquo;ll explore how to apply TDD in Kotlin for Android development using JUnit, MockK, and Coroutines with a real-world example.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/tdd-cycle.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category><category>TDD</category><category>testing</category></item></channel></rss>