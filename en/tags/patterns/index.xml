<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>patterns on Carrion.dev</title><link>https://carrion.dev/en/tags/patterns/</link><description>Recent content in patterns on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Fri, 28 Mar 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/en/tags/patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>State Management Patterns in Jetpack Compose</title><link>https://carrion.dev/en/posts/state-management-patterns-compose/</link><pubDate>Fri, 28 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 28 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/state-management-patterns-compose/</guid><description>State Management Patterns in Jetpack Compose State management is a crucial aspect of building robust and maintainable Jetpack Compose applications. This article explores essential patterns and best practices for managing state effectively in your Compose UI, including immutable state, event-based updates, and testing strategies.
Understanding State Management Patterns Effective state management in Compose requires understanding how to structure and handle state changes in a way that&amp;rsquo;s maintainable, testable, and scalable. This involves several key patterns:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/state-management-compose.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>patterns</category><category>state</category></item><item><title>Flow Composition Patterns: Combining Multiple Flows Effectively</title><link>https://carrion.dev/en/posts/flow-composition-patterns/</link><pubDate>Tue, 18 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 18 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/flow-composition-patterns/</guid><description>Flow Composition Patterns: Combining Multiple Flows Effectively When working with Kotlin Flows in real-world applications, you often need to combine multiple data streams to create more complex workflows. This article explores various Flow composition patterns and best practices for effectively combining multiple Flows.
Understanding Flow Composition Flow composition is the process of combining multiple Flows to create a new Flow that represents a more complex data stream. Kotlin provides several operators for Flow composition, each serving different use cases.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/flow-composition.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>coroutines</category><category>flows</category><category>patterns</category></item></channel></rss>