<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>flows on Carrion.dev</title><link>https://carrion.dev/en/tags/flows/</link><description>Recent content in flows on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Fri, 14 Mar 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/en/tags/flows/index.xml" rel="self" type="application/rss+xml"/><item><title>Understanding Flow Operators: Buffer, Conflate, Debounce, and Sample</title><link>https://carrion.dev/en/posts/flow-operators-buffer-conflate/</link><pubDate>Fri, 14 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 14 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/flow-operators-buffer-conflate/</guid><description>Understanding Flow Operators: Buffer, Conflate, Debounce, and Sample When working with Kotlin Flows, especially in scenarios involving fast-emitting producers and slow collectors, it&amp;rsquo;s crucial to understand how to manage the flow of data effectively. This post explores four essential Flow operators that help handle such scenarios: buffer, conflate, debounce, and sample.
The Problem: Slow Collectors Before diving into the operators, let&amp;rsquo;s understand the problem they solve. Consider this scenario:
1 2 3 4 5 6 7 8 9 flow { for (i in 1.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev//images/kotlin/flow-operators.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>flows</category><category>coroutines</category></item><item><title>Converting Callbacks to Coroutines and Flows in Kotlin</title><link>https://carrion.dev/en/posts/callback-to-flow-conversion/</link><pubDate>Tue, 11 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 11 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/callback-to-flow-conversion/</guid><description>Converting Callbacks to Coroutines and Flows in Kotlin Callback-based APIs have been a common pattern in asynchronous programming for many years. However, with Kotlin&amp;rsquo;s coroutines and flows, we can transform these callbacks into more modern, sequential code that&amp;rsquo;s easier to read and maintain. In this article, we&amp;rsquo;ll explore how to use suspendCoroutine and callbackFlow to convert callback-based APIs into coroutines and flows.
Understanding suspendCoroutine The suspendCoroutine function is a powerful tool that allows you to wrap callback-based APIs into suspend functions.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/suspend-coroutine.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>coroutines</category><category>flows</category><category>callbacks</category></item><item><title>Understanding Hot and Cold Flows in Kotlin</title><link>https://carrion.dev/en/posts/kotlin-flows-hot-cold/</link><pubDate>Fri, 07 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 07 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-flows-hot-cold/</guid><description>Understanding Hot and Cold Flows in Kotlin Kotlin Flow is a powerful feature for handling reactive streams of data. One of the fundamental concepts to understand when working with flows is the distinction between hot and cold flows. This article will explain the differences and provide practical examples of both types.
Cold Flows: The Default Behavior Cold flows are the default type in Kotlin Flow. They start producing values only when a collector starts collecting from them.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/flows.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>coroutines</category><category>flows</category></item></channel></rss>