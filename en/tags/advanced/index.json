[{"content":"Mastering Kotlin Contracts: Unlocking Smarter Code Analysis Kotlin never ceases to amaze with its features that combine elegance and power. One advanced yet often underutilized tool in Kotlin\u0026rsquo;s arsenal is Contracts. Contracts let you guide the Kotlin compiler to make smarter decisions about your code—resulting in better null safety, optimized performance, and fewer runtime errors.\nWhat Are Kotlin Contracts? Kotlin Contracts allow you to define rules about how your functions behave, helping the compiler perform advanced static analysis. They enable features like smart-casts and context-aware checks beyond Kotlin’s default capabilities.\nWhy Use Contracts?  Improve Null Safety: Eliminate redundant null checks by telling the compiler when something is guaranteed to be non-null. Optimize Smart-Casts: Make the compiler aware of variable types in custom scenarios. Reduce Boilerplate: Write cleaner, more intuitive code by offloading repetitive checks to the compiler.  Examples of Kotlin Contracts in Action 1. Simplify Null Checks Let’s create a custom utility to validate non-null values:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @OptIn(ExperimentalContracts::class) inline fun \u0026lt;T\u0026gt; requireNotNull(value: T?, message: String): T { contract { returns() implies (value != null) } if (value == null) { throw IllegalArgumentException(message) } return value } fun processName(name: String?) { val nonNullName = requireNotNull(name, \u0026#34;Name cannot be null\u0026#34;) // No need for additional null checks; compiler knows \u0026#39;nonNullName\u0026#39; is not null!  println(\u0026#34;Processing name: $nonNullName\u0026#34;) } fun main() { processName(\u0026#34;John\u0026#34;) // Works fine  // processName(null) // Throws an IllegalArgumentException }   Something similar is implemented in the functions require and requireNotNull from the Kotlin standard lib:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  /** * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false. * * @sample samples.misc.Preconditions.failRequireWithLazyMessage */ @kotlin.internal.InlineOnly public inline fun require(value: Boolean, lazyMessage: () -\u0026gt; Any): Unit { contract { returns() implies value } if (!value) { val message = lazyMessage() throw IllegalArgumentException(message.toString()) } } /** * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise * returns the not null value. * * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage */ @kotlin.internal.InlineOnly public inline fun \u0026lt;T : Any\u0026gt; requireNotNull(value: T?, lazyMessage: () -\u0026gt; Any): T { contract { returns() implies (value != null) } if (value == null) { val message = lazyMessage() throw IllegalArgumentException(message.toString()) } else { return value } }   How Contracts Help Here  The returns() implies (value != null) contract tells the compiler:  If the function returns successfully, then value is guaranteed to be non-null.\n  This enables smart-casts, so you don’t need manual null checks after the function call.  2. Custom Assertions Here’s how contracts can be used to define custom assertion functions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @OptIn(ExperimentalContracts::class) fun assertValidState(condition: Boolean, message: String) { contract { returns() implies condition } if (!condition) { throw IllegalStateException(message) } } fun performOperation(state: Boolean) { val state: Any? = \u0026#34;Hello\u0026#34; assertValidState(state is String, \u0026#34;Is String\u0026#34;) // Here the compiler knows that the state val is of type String so no need to other cast checks  println(\u0026#34;String length: ${assertion.length}\u0026#34;) } fun main() { performOperation(true) // Prints success  // performOperation(false) // Throws IllegalStateException }   3. Smart-Casts with Custom Conditions Let’s create a utility function that checks if a value matches a specific type. This will demonstrate how contracts enable smarter casting:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  @OptIn(ExperimentalContracts::class) inline fun \u0026lt;reified T\u0026gt; isOfType(value: Any?): Boolean { contract { returns(true) implies (value is T) } return value is T } fun main() { val input: Any? = \u0026#34;Hello, Kotlin!\u0026#34; if (isOfType\u0026lt;String\u0026gt;(input)) { println(\u0026#34;String length: ${input.length}\u0026#34;) } val inputInt: Any? = 10 if (isOfType\u0026lt;Int\u0026gt;(inputInt)) { println(\u0026#34;The value is an integer ${input.toUInt()}\u0026#34;) } }   With this implementation, the compiler knows that within the if block, input is a String, thanks to the contract defined in isOfType. Also the compilers knows that inputInt is an Int so you don\u0026rsquo;t need to cast it.\n4. Optimizing Flow Control Contracts can simplify flow control by enabling the compiler to understand loop invariants or conditions. Here’s an example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  inline fun isNotEmpty(list: List\u0026lt;*\u0026gt;?): Boolean { contract { returns(true) implies (list != null \u0026amp;\u0026amp; list.isNotEmpty()) } return list != null \u0026amp;\u0026amp; list.isNotEmpty() } fun processItems(items: List\u0026lt;String\u0026gt;?) { if (isNotEmpty(items)) { // Compiler knows items is non-null and not empty  println(\u0026#34;Processing ${items.size}items\u0026#34;) } else { println(\u0026#34;No items to process\u0026#34;) } } fun main() { processItems(listOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;)) processItems(null) processItems(emptyList()) }   Output Processing 3 items No items to process No items to process When to Use Contracts Contracts are ideal for:\n Library Development: Safeguard public APIs by enforcing preconditions. DSLs and Frameworks: Simplify type-checking and state validations in Kotlin DSLs. Performance Optimization: Reduce runtime checks by letting the compiler infer conditions at compile time.  Conclusion Kotlin Contracts are a hidden gem that can elevate your code by improving safety, reducing boilerplate, and enabling smarter compiler analysis. Whether you\u0026rsquo;re building libraries, writing complex DSLs, or just optimizing everyday code, contracts provide a powerful tool to guide the Kotlin compiler and ensure code correctness.\nAlso keep in mind that contracts are annotated as experimental feature but they are in Kotlin since 1.3 version and are being used in the standard library so they are stable enough to use them.\n","description":"Advanced Kotlin - Contracts","id":0,"section":"posts","tags":["kotlin","android","advanced"],"title":"Kotlin contracts","uri":"https://carrion.dev/en/posts/kotlin-contracts/"},{"content":"Swift export in Kmp Starting from version 2.1.0 we can start testing the Swift export in Kotlin. This feature allows you to export the Kotlin shared modules to Swift without the use of Objective-C. This will improve the iOS developers experience when using KMP modules.\nAt the moment basic support includes:\n Export multiple Gradle modules to Swift. Define the Swift module names. Flatten package structure  Enable the feature To start testing this functionality you should enable it on gradle.properties file:\nkotlin.experimental.swift-export.enabled=true Configuration After adding the line above you need to add this configuration to the build.gradle.kts file:\n1 2 3 4 5 6 7 8 9 10 11  kotlin { iosX64() iosArm64() iosSimulatorArm64() @OptIn(ExperimentalSwiftExportDsl::class) swiftExport { moduleName = \u0026#34;shared\u0026#34; flattenPackage = \u0026#34;dev.carrion.kmpswiftexport\u0026#34; } }   Next step is configuring xcode to launch the new task embedSwiftExportForXcode instead of embedAndSignAppleFrameworkForXcode. You can do it from xcode build phases configuration of the iosApp or from Android Studio modifying the project.pbxproj file.\nYou should change this line:\nshellScript = \u0026quot;cd \\\u0026quot;$SRCROOT/..\\\u0026quot;\\n./gradlew :shared:embedAndSignAppleFrameworkForXcode\\n\u0026quot;; With this one:\nshellScript = \u0026quot;cd \\\u0026quot;$SRCROOT/..\\\u0026quot;\\n./gradlew :shared:embedSwiftExportForXcode\\n\u0026quot;; After this changes you should be able to launch the app from Android Studio or xcode without any problems.\nBefore enabling the feature If you try to jump to the definition of a kotlin function from xcode in a swift file, you will be prompted with the Objective-C code exported from the kotlin shared module. This file is huge given the complexity of the project used for this example.\nI will show you just a little piece of the 175 lines file generated from the Kotlin source code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;Greeting\u0026#34;))) @interface SharedGreeting : SharedBase - (instancetype)init __attribute__((swift_name(\u0026#34;init()\u0026#34;))) __attribute__((objc_designated_initializer)); + (instancetype)new __attribute__((availability(swift, unavailable, message=\u0026#34;use object initializers instead\u0026#34;))); - (NSString *)greet __attribute__((swift_name(\u0026#34;greet()\u0026#34;))); @end __attribute__((swift_name(\u0026#34;Platform\u0026#34;))) @protocol SharedPlatform @required @property (readonly) NSString *name __attribute__((swift_name(\u0026#34;name\u0026#34;))); @end __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;IOSPlatform\u0026#34;))) @interface SharedIOSPlatform : SharedBase \u0026lt;SharedPlatform\u0026gt; - (instancetype)init __attribute__((swift_name(\u0026#34;init()\u0026#34;))) __attribute__((objc_designated_initializer)); + (instancetype)new __attribute__((availability(swift, unavailable, message=\u0026#34;use object initializers instead\u0026#34;))); @property (readonly) NSString *name __attribute__((swift_name(\u0026#34;name\u0026#34;))); @end __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;Platform_iosKt\u0026#34;))) @interface SharedPlatform_iosKt : SharedBase + (id\u0026lt;SharedPlatform\u0026gt;)getPlatform __attribute__((swift_name(\u0026#34;getPlatform()\u0026#34;))); @end #pragma pop_macro(\u0026#34;_Nullable_result\u0026#34;) #pragma clang diagnostic pop NS_ASSUME_NONNULL_END   After enabling the feature When you enable the feature and build the project, trying to go to the definition of a function from the Kotlin code, xcode will show you the exported Swift code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  @_exported import ExportedKotlinPackages @_implementationOnly import SharedBridge_shared import KotlinRuntime public typealias Greeting = ExportedKotlinPackages.dev.carrion.kmpswiftexport.Greeting public func getPlatform() -\u0026gt; Swift.Never { ExportedKotlinPackages.dev.carrion.kmpswiftexport.getPlatform() } public extension ExportedKotlinPackages.dev.carrion.kmpswiftexport { public final class Greeting : KotlinRuntime.KotlinBase { public override init() { let __kt = dev_carrion_kmpswiftexport_Greeting_init_allocate() super.init(__externalRCRef: __kt) dev_carrion_kmpswiftexport_Greeting_init_initialize__TypesOfArguments__Swift_UInt__(__kt) } public override init( __externalRCRef: Swift.UInt ) { super.init(__externalRCRef: __externalRCRef) } public func greet() -\u0026gt; Swift.String { return dev_carrion_kmpswiftexport_Greeting_greet(self.__externalRCRef()) } } public static func getPlatform() -\u0026gt; Swift.Never { fatalError() } }   The code above this lines is the complete file with 28 lines, a huge difference with the 175 lines from the Objective-C exported code. Also it\u0026rsquo;s important to mention the lower complexity and higher readability on the Swift example.\nConclusion After testing this new feature, I\u0026rsquo;m really amazed with the improvement it brings to the iOS development in KMP projects. Also impressed with the difference in code between Objective-C and Swift exported codes. I\u0026rsquo;m sure this feature will improve in next versions and it will close the bridge between the native and multiplatform development experiences.\nYou can find the repository with the code from this example in SwiftExport, with two branches, main, where it\u0026rsquo;s the usual iOS framework configuration, and swift-export branch which has the new feature enabled.\n","description":"New feature in Kotlin 2.1.0, basic swift export from Kotlin","id":1,"section":"posts","tags":["kotlin","android","kmp"],"title":"Swift export in KMP","uri":"https://carrion.dev/en/posts/swift-export/"},{"content":"Guard conditions in when in Kotlin 2.1.0 One of the new features in Kotlin 2.1.0 is the guard conditions on when expressions, this feature will bring some advantages like:\n Reduce nesting Avoid boilerplate Improve readability  Enable the feature This feature is in preview state, for this you need to enable it starting on Kotlin 2.1.0. In the file build.gradle.kts we should add the new piece of code inside the kotlin block:\n1 2 3 4 5  kotlin { compilerOptions { freeCompilerArgs.add(\u0026#34;-Xwhen-guards\u0026#34;) } }   Use guard conditions on when expression branches For this example we will use a sealed interface to handle the responses from a remote service:\n1 2 3 4 5  sealed interface Response\u0026lt;out T\u0026gt; { data object Loading : Response\u0026lt;Nothing\u0026gt; data class Content \u0026lt;out T\u0026gt; (val data: T?) : Response\u0026lt;T\u0026gt; data class Error(val error: Exception) : Response\u0026lt;Nothing\u0026gt; }   Loading, Content and Error implement the Response interface to manage the different states of the response.\nBefore new feature 1 2 3 4 5 6 7 8 9 10 11 12 13  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handleOld() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content -\u0026gt; if (data != null) { println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } is Response.Error -\u0026gt; if (error is IllegalStateException) { println(\u0026#34;Handled error\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } }   Here you can see how the code to print the Unknown error needs to be in both branches, also it adds nested complexity that reduces the code readability.\nUsing new Guard conditions You must add if statement after the primary condition inside the when branch, see below:\n1 2 3 4 5 6  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled error\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   This way the print statement with the text Unkwon error is used just once, also we remove the nested complexity.\nIf we need to check different conditions on the else branch, we can use an else if in case our response doesn\u0026rsquo;t satisfy the previous conditions.\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) else if this is Response.Error \u0026amp;\u0026amp; this.error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   This example can be simplified using to branches with the same primary condition is Response.Error, in my opinion keeps the code more readable and simple:\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) is Response.Error if error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   Conclusion With this new feature we can add new conditions without repeating code and will allow more concise when expressions. It\u0026rsquo;s in preview state starting from Kotlin 2.1.0 but seems like it will become stable soon.\nHere is the link to the documentation where you can find what\u0026rsquo;s new in Kotlin 2.1.0 included the guard conditions in when expressions kotlinlang\n","description":"New feature since Kotlin 2.1.0, guard conditions in when expressions","id":2,"section":"posts","tags":["kotlin","android","kmp"],"title":"Guard conditions in when starting in Kotlin 2.1.0.","uri":"https://carrion.dev/en/posts/kotlin-guard-conditions-in-when/"},{"content":"Inject runtime parameters with Dagger-Hilt Since Hilt appeared to make it easier the dependency injection in Android, it was impossible to inject runtime parameters without using third party libraries. Since Dagger version 2.31, exists the @AssistedInject annotation. With this annotation we can instruct Dagger-Hilt what dependencies need to be created at runtime and delay the injection of this parameters until we can provide those values.\nThis is necessary to inject parameters into ViewModel constructor and be able to execute some code in the init function. It can be an external API call or some query to our local database.\nIn this post we will learn how to use @AssistedInject from Dagger to inject runtime parameters to ViewModels with Hilt.\nInstallation In the root project build.gradle file, we will include the Hilt classpath:\n1  classpath \u0026#39;com.google.dagger:hilt-android-gradle-plugin:2.31.2-alpha\u0026#39;   Once we have Hilt classpath we will add Hilt plugin to build.gradle file from app module.\n1  apply plugin: \u0026#39;dagger.hilt.android.plugin\u0026#39;   And the next lines to our dependencies block:\n1 2  implementation \u0026#39;com.google.dagger:hilt-android:2.31.2-alpha\u0026#39; kapt \u0026#39;com.google.dagger:hilt-android-compiler:2.31.2-alpha\u0026#39;    We should keep in mind that we need kapt plugin on our build.gradle. For this we will add this line with the rest of plugins in our build.gradle from app module:\n 1  apply plugin: \u0026#39;kotlin-kapt\u0026#39;   Those were the needed dependencies to make Hilt work in our project. In this post we will use libraries that are not defined here.\nIn this link you can see the complete build.gradle file: app/build.gradle\nImplementation For this example we will be using a repository class with a function which receives a name and returns a welcome message. To acomplish this we will create the interface below:\n1 2 3  interface UserRepository { fun getMessage(name: String): String }   And it\u0026rsquo;s implementation:\n1 2 3 4 5  class UserRepositoryImpl @Inject constructor() : UserRepository { override fun getMessage(name: String): String { return \u0026#34;Hi $name\u0026#34; } }   We should annotate the constructor with @Inject so we can declare a @Binds annotation in the Hilt module to be able to inject the implementation when we call an interface of type UserRepository.\nNext we will create our ViewModel, this class will receive the user name from the Activity or Fragment and call the repository to get the welcome message:\n1 2 3 4 5 6 7 8 9  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { ... }   In this ViewModel we can see how we should annotate the constructor with @AssistedInject so Dagger-Hilt knows this class has dependencies that will be injected at runtime. This runtime dependencies will be annotated with @Assisted.\nTo be able to create our ViewModel with the extension by viewModels() from AndroidX library, we should create the Factory class wich will be provided to the extension:\n1 2 3 4 5 6 7 8  class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } }   You can see we need an interface called UserViewModelAssistedFactory. This interface will handle the runtime parameters injected to the ViewModel:\n1 2 3 4 5 6  @AssistedFactory interface UserViewModelAssistedFactory { fun create(name: String): UserViewModel }   It\u0026rsquo;s an interface with a create function. This function receive all the runtime parameters we want to inject in our ViewModel. In this example we only need a name parameter, but in case we need more parameters injected at runtime, they will be provided to this function.\nWith this we are able to complete our ViewModel with the logic to get the answer from the repository and expose it to the Fragment or Activity through a StateFlow.\nThe complete ViewModel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } } private val _message: MutableStateFlow\u0026lt;String\u0026gt; = MutableStateFlow(\u0026#34;\u0026#34;) val message: StateFlow\u0026lt;String\u0026gt; get() = _message init { viewModelScope.launch(dispatcher) { _message.emit(repository.getMessage(name)) } } }   Related to Hilt we only have to create the module to handle the creation of dependencies. For this example we will be using this module:\n1 2 3 4 5 6 7 8 9 10 11 12 13  @Module @InstallIn(ActivityComponent::class) abstract class MainModule { companion object { @Provides @Named(\u0026#34;UserDispatcher\u0026#34;) fun provideUserDispatcher(): CoroutineDispatcher = Dispatchers.IO } @Binds abstract fun provideUserRepository(repositoryImpl: UserRepositoryImpl): UserRepository }   In this module we declare a function to provide a Dispatcher so it will be easier to test this ViewModel in a future. We declare a @Binds function so when we inject a UserRepository interface Hilt provides its implementation UserRepositoryImpl.\nNow we can user our ViewModel in Activities or Fragments:\n1 2 3 4 5 6 7 8  private val navArgs: UserFragmentArgs by navArgs() @Inject lateinit var assistedFactory: UserViewModelAssistedFactory private val userViewModel: UserViewModel by viewModels { UserViewModel.Factory(assistedFactory, navArgs.name) }   We need to @Inject the AssistedFactory and use the UserViewModel.Factory to create our ViewModel.\nFrom this step we only need to observe changes in the ViewModel StateFlow to be able to update our UI. This can be done in Fragments observing from the onViewCreated.\n1 2 3 4 5 6 7 8  override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycleScope.launchWhenStarted { userViewModel.message.collect { binding.name.text = it } } }    Remember you need a class extending Application annotated with @HiltAndroidApp and each Activity or Fragment that uses injection with Hilt need to be annotated with @AndroidEntryPoint.\n Conclusion Now we can inject Runtime values with Dagger @AssistedInject in a simple way and we can keep using navArgs from AndroidX.\nYou can see the complete example in this repository: HiltAssistedInject\n","description":"Inject parameters to ViewModels at Runtime in Android.","id":3,"section":"posts","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Hilt: Inject Runtime parameters to ViewModels.","uri":"https://carrion.dev/en/posts/hilt-inject-parameters-runtime/"},{"content":"Welcome to Carrion.dev Hi droid!\nWelcome to my new Kotlin and Android programming blog. I am Ignacio Carrión and I\u0026rsquo;m an Android developer. I love Kotlin because it boost my Android development eficiency and because it has infinite posibilities outside of Android ecosystem (backend, web, native, multiplatform\u0026hellip;).\nIn this blog I hope I can publish interesting topics about Kotlin and Android at least twice a month. If you want to keep up to date you can subscribe to our newsletter.\nIf you have any question, idea about some topic for the blog or you just want to contact with me, I\u0026rsquo;m available through my email: ignacio@carrion.dev.\nI hope we can learn together!!\n","description":"First post in my new Kotlin and Android development blog","id":4,"section":"posts","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Welcome to my new Kotlin and Android development blog","uri":"https://carrion.dev/en/posts/welcome-to-my-new-kotlin-and-android-development-blog/"},{"content":"About. I\u0026rsquo;m Ignacio Carrión, I live in Valencia (Spain) and the one who appears on the avatar is my dog Wilfred. I like anything related to IT and videogames. At the moment I\u0026rsquo;m working as Android Engineer for Tkww. Before that I worked as Android Developer for other companies and I worked as a programming teacher. While I was working as a teacher, I realized that I love learning and helping others to learn with me. From this motivation arises the idea of this blog, Carrion.dev.\nI hope I can publish something interesting about Kotlin or Android ecosystem at least twice a month. Constructive criticism or ideas about posts will be welcomed. Below you can see the links to my social networks where you can find and contact me.\nContact Portfolio\nGithub\n","description":"Hugo, the world’s fastest framework for building websites","id":9,"section":"","tags":null,"title":"About","uri":"https://carrion.dev/en/about/"}]