<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>android on Carrion.dev</title><link>https://carrion.dev/en/tags/android/</link><description>Recent content in android on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Fri, 04 Apr 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/en/tags/android/index.xml" rel="self" type="application/rss+xml"/><item><title>Custom Animations and Transitions in Jetpack Compose</title><link>https://carrion.dev/en/posts/custom-animations-transitions-compose/</link><pubDate>Fri, 04 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 04 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/custom-animations-transitions-compose/</guid><description>Custom Animations and Transitions in Jetpack Compose Creating smooth, meaningful animations is crucial for delivering a polished user experience. This article explores how to create custom animations and transitions in Jetpack Compose, from basic animations to complex custom implementations.
Creating Custom Animations Custom animations allow for more complex and unique visual effects:
Custom Animation Specs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Composable fun CustomAnimatedButton( onClick: () -&amp;gt; Unit, content: @Composable () -&amp;gt; Unit ) { var isPressed by remember { mutableStateOf(false) } val scope = rememberCoroutineScope() val scale by animateFloatAsState( targetValue = if (isPressed) 0.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/pulsating-dot.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>animation</category><category>transitions</category></item><item><title>Advanced State Management in Compose: Effects and Flows</title><link>https://carrion.dev/en/posts/advanced-state-management-compose/</link><pubDate>Tue, 01 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 01 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/advanced-state-management-compose/</guid><description>Advanced State Management in Compose: Effects and Flows This article explores advanced state management patterns in Jetpack Compose, focusing on Effects and Flow integration. For fundamental concepts like mutableStateOf and state hoisting, check out our companion article Basic State Management in Jetpack Compose.
Understanding Compose Effects Effects in Compose are tools to handle side effects and lifecycle events in a composable-friendly way. Let&amp;rsquo;s explore the different types of effects and their use cases:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/state-management-compose-advanced.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>state</category><category>flows</category><category>effects</category></item><item><title>State Management Patterns in Jetpack Compose</title><link>https://carrion.dev/en/posts/state-management-patterns-compose/</link><pubDate>Fri, 28 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 28 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/state-management-patterns-compose/</guid><description>State Management Patterns in Jetpack Compose State management is a crucial aspect of building robust and maintainable Jetpack Compose applications. This article explores essential patterns and best practices for managing state effectively in your Compose UI, including immutable state, event-based updates, and testing strategies.
Understanding State Management Patterns Effective state management in Compose requires understanding how to structure and handle state changes in a way that&amp;rsquo;s maintainable, testable, and scalable. This involves several key patterns:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/state-management-compose.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>patterns</category><category>state</category></item><item><title>Achieving Compile-Time Safety in Koin: A Comprehensive Guide</title><link>https://carrion.dev/en/posts/koin-compile-safety/</link><pubDate>Tue, 04 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 04 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/koin-compile-safety/</guid><description>Achieving Compile-Time Safety in Koin: A Comprehensive Guide Dependency injection is a fundamental pattern in modern Android development, but how can we ensure our DI configuration is correct before running the app? In this post, we&amp;rsquo;ll explore two powerful approaches to achieve compile-time safety with Koin: using the DSL&amp;rsquo;s verify() function and leveraging Koin Annotations with KSP.
The Problem: Runtime vs. Compile-Time Validation Traditional dependency injection often reveals configuration issues only at runtime:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-ksp-config.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>koin</category></item><item><title>Reliable Timekeeping with the TrustedTime API in Android</title><link>https://carrion.dev/en/posts/trusted-time-api/</link><pubDate>Wed, 19 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 19 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/trusted-time-api/</guid><description>Reliable Timekeeping with the TrustedTime API in Android Accurate timekeeping is crucial for many app functionalities, including scheduling, transaction logging, and security. However, relying on a device&amp;rsquo;s system clock can be problematic since users can alter their device’s time settings. To address this, Google has introduced the TrustedTime API, providing a reliable and tamper-resistant time source for Android apps.
Understanding the TrustedTime API The TrustedTime API leverages Google&amp;rsquo;s secure infrastructure to offer a trustworthy timestamp, independent of the device&amp;rsquo;s local time settings.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/trusted-time-api.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>google</category></item><item><title>A deep dive into Kotlin KSP</title><link>https://carrion.dev/en/posts/kotlin-ksp/</link><pubDate>Fri, 27 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 27 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-ksp/</guid><description>A Deep Dive into Kotlin Symbol Processing (KSP) with Practical Examples Kotlin Symbol Processing (KSP) is a powerful tool introduced to streamline annotation processing in Kotlin. Compared to kapt (Kotlin Annotation Processing Tool), KSP is faster, offers better integration with Kotlin, and reduces build times significantly. In this post, we’ll explore the fundamentals of KSP, discuss how it works, and demonstrate its use with popular libraries like Koin and Room.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-annotations.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Kotlin Infix functions</title><link>https://carrion.dev/en/posts/kotlin-infix/</link><pubDate>Thu, 26 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 26 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-infix/</guid><description>Exploring Kotlin Infix Functions: A Deep Dive Kotlin, as a modern programming language, is packed with features that make code expressive and concise. One of these features is infix functions, which allow you to write cleaner and more readable code. In this blog post, we&amp;rsquo;ll explore what infix functions are, how to use them, and some practical use cases.
What Are Infix Functions? Infix functions in Kotlin are a special kind of function that can be called without using parentheses or the dot operator.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-infix.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Kotlin Delegates</title><link>https://carrion.dev/en/posts/kotlin-delegates/</link><pubDate>Mon, 23 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 23 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-delegates/</guid><description>✨ Understanding Kotlin Delegates: The Magic Behind Cleaner Code ✨ Kotlin delegates are a powerful feature that lets you delegate the behavior of a property or even an interface implementation to another object. Instead of writing repetitive logic or managing state directly, you can delegate this responsibility to reusable and specialized classes.
How Delegates Work Delegates in Kotlin work by using the by keyword, which redirects the behavior of a property or an interface to a delegate object.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-delegate.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Kotlin contracts</title><link>https://carrion.dev/en/posts/kotlin-contracts/</link><pubDate>Fri, 20 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 20 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-contracts/</guid><description>Mastering Kotlin Contracts: Unlocking Smarter Code Analysis Kotlin never ceases to amaze with its features that combine elegance and power. One advanced yet often underutilized tool in Kotlin&amp;rsquo;s arsenal is Contracts. Contracts let you guide the Kotlin compiler to make smarter decisions about your code—resulting in better null safety, optimized performance, and fewer runtime errors.
What Are Kotlin Contracts? Kotlin Contracts allow you to define rules about how your functions behave, helping the compiler perform advanced static analysis.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/kotlin-contract.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Swift export in KMP</title><link>https://carrion.dev/en/posts/swift-export/</link><pubDate>Wed, 18 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 18 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/swift-export/</guid><description>Swift export in Kmp Starting from version 2.1.0 we can start testing the Swift export in Kotlin. This feature allows you to export the Kotlin shared modules to Swift without the use of Objective-C. This will improve the iOS developers experience when using KMP modules.
At the moment basic support includes:
Export multiple Gradle modules to Swift. Define the Swift module names. Flatten package structure Enable the feature To start testing this functionality you should enable it on gradle.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/swift-export.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>kmp</category></item><item><title>Guard conditions in when starting in Kotlin 2.1.0.</title><link>https://carrion.dev/en/posts/kotlin-guard-conditions-in-when/</link><pubDate>Tue, 17 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 17 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-guard-conditions-in-when/</guid><description>Guard conditions in when in Kotlin 2.1.0 One of the new features in Kotlin 2.1.0 is the guard conditions on when expressions, this feature will bring some advantages like:
Reduce nesting Avoid boilerplate Improve readability Enable the feature This feature is in preview state, for this you need to enable it starting on Kotlin 2.1.0. In the file build.gradle.kts we should add the new piece of code inside the kotlin block:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/guard-when-new.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>kmp</category></item><item><title>Hilt: Inject Runtime parameters to ViewModels.</title><link>https://carrion.dev/en/posts/hilt-inject-parameters-runtime/</link><pubDate>Wed, 24 Feb 2021 07:00:06 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 24 Feb 2021 07:00:06 +0100</atom:modified><guid>https://carrion.dev/en/posts/hilt-inject-parameters-runtime/</guid><description>Inject runtime parameters with Dagger-Hilt Since Hilt appeared to make it easier the dependency injection in Android, it was impossible to inject runtime parameters without using third party libraries. Since Dagger version 2.31, exists the @AssistedInject annotation. With this annotation we can instruct Dagger-Hilt what dependencies need to be created at runtime and delay the injection of this parameters until we can provide those values.
This is necessary to inject parameters into ViewModel constructor and be able to execute some code in the init function.</description><dc:creator>Ignacio</dc:creator><media:content url="https://carrion.dev/images/kotlin/kotlin-logo.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>jetpack</category><category>coroutines</category><category>androidx</category></item><item><title>Welcome to my new Kotlin and Android development blog</title><link>https://carrion.dev/en/posts/welcome-to-my-new-kotlin-and-android-development-blog/</link><pubDate>Tue, 23 Feb 2021 10:00:06 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 23 Feb 2021 10:00:06 +0100</atom:modified><guid>https://carrion.dev/en/posts/welcome-to-my-new-kotlin-and-android-development-blog/</guid><description>Welcome to Carrion.dev Hi droid!
Welcome to my new Kotlin and Android programming blog. I am Ignacio Carrión and I&amp;rsquo;m an Android developer. I love Kotlin because it boost my Android development eficiency and because it has infinite posibilities outside of Android ecosystem (backend, web, native, multiplatform&amp;hellip;).
In this blog I hope I can publish interesting topics about Kotlin and Android at least twice a month. If you want to keep up to date you can subscribe to our newsletter.</description><dc:creator>Ignacio</dc:creator><category>kotlin</category><category>android</category><category>jetpack</category><category>coroutines</category><category>androidx</category></item></channel></rss>