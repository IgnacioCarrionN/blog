<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>collections on Carrion.dev</title><link>https://carrion.dev/en/tags/collections/</link><description>Recent content in collections on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Fri, 05 Sep 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/en/tags/collections/index.xml" rel="self" type="application/rss+xml"/><item><title>Kotlin Data Structures: What to Use and When</title><link>https://carrion.dev/en/posts/kotlin-data-structures-guide/</link><pubDate>Fri, 05 Sep 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 05 Sep 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-data-structures-guide/</guid><description>Kotlin Data Structures: What to Use and When Choosing the right data structure is one of the most impactful performance decisions you can make. Kotlin gives you expressive, type‑safe APIs on top of the JVM’s mature collections — plus some Kotlin‑specific options like ArrayDeque and immutable collections via kotlinx.collections.immutable.
This guide focuses on practical choice making: what to use, when to use it, and what to expect in terms of time complexity.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/kotlin-data-structures.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>collections</category><category>data-structures</category><category>algorithms</category><category>complexity</category></item><item><title>Exploring Kotlin’s Immutable Collections Library</title><link>https://carrion.dev/en/posts/immutable-collections/</link><pubDate>Thu, 30 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 30 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/immutable-collections/</guid><description>Exploring Kotlin’s Immutable Collections Library Kotlin&amp;rsquo;s standard collections (List, Set, Map) are mutable by default, which can lead to unintended modifications. To enforce immutability at the API level, JetBrains introduced the Kotlin Immutable Collections library. This library provides a set of truly immutable collection types that prevent accidental modifications and enhance safety in concurrent or multi-threaded environments.
Why Use Immutable Collections? While Kotlin already has listOf(), setOf(), and mapOf() for read-only collections, they are not truly immutable.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/readonly-list.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>collections</category><category>compose</category></item></channel></rss>