<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>coroutines on Carrion.dev</title><link>https://carrion.dev/en/tags/coroutines/</link><description>Recent content in coroutines on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Fri, 07 Nov 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/en/tags/coroutines/index.xml" rel="self" type="application/rss+xml"/><item><title>Mastering Kotlin Coroutines: Dispatchers, Jobs, and Structured Concurrency</title><link>https://carrion.dev/en/posts/kotlin-coroutines-dispatchers-jobs/</link><pubDate>Fri, 07 Nov 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 07 Nov 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-coroutines-dispatchers-jobs/</guid><description>Mastering Kotlin Coroutines: Dispatchers, Jobs, and Structured Concurrency Kotlin Coroutines provide a lightweight, structured way to write asynchronous and concurrent code. This guide focuses on the three pillars you use every day: Dispatchers (where coroutines run), Jobs (what you are running and how it is supervised), and structured concurrency (the rules that keep your async code sane).
You’ll find mental models, small runnable snippets, gotchas, and production-ready patterns.
TL;DR Dispatcher: decides the thread or thread pool where a coroutine executes (Dispatchers.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/coroutines.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>coroutines</category><category>concurrency</category><category>async</category><category>structured-concurrency</category></item><item><title>Kotlin Mutex: Thread-Safe Concurrency for Coroutines</title><link>https://carrion.dev/en/posts/kotlin-mutex-concurrency-guide/</link><pubDate>Fri, 03 Oct 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 03 Oct 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-mutex-concurrency-guide/</guid><description>Kotlin Mutex: Thread-Safe Concurrency for Coroutines When building concurrent applications with Kotlin coroutines, protecting shared mutable state is essential. While traditional Java synchronization tools like synchronized blocks and ReentrantLock work, they block threads and don&amp;rsquo;t play well with coroutines' suspension model. Enter Mutex — a coroutine-friendly synchronization primitive that provides mutual exclusion without blocking threads.
This guide explores when to use Mutex, best practices, and how it compares to other concurrency control mechanisms.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/mutex.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>coroutines</category><category>concurrency</category><category>mutex</category><category>thread-safety</category></item><item><title>Coroutine Testing Patterns: Effective Strategies for Testing Asynchronous Kotlin Code</title><link>https://carrion.dev/en/posts/coroutine-testing-patterns/</link><pubDate>Tue, 29 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 29 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/coroutine-testing-patterns/</guid><description>Coroutine Testing Patterns: Effective Strategies for Testing Asynchronous Kotlin Code Testing asynchronous code has always been challenging, and Kotlin&amp;rsquo;s coroutines and flows are no exception. However, the Kotlin team has provided powerful testing utilities that make this process more manageable and reliable. In this blog post, we&amp;rsquo;ll explore effective patterns for testing coroutines and flows, from basic unit tests to complex integration scenarios.
The Foundation: kotlinx-coroutines-test Before diving into specific patterns, let&amp;rsquo;s establish the foundation.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/coroutine-testing.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>coroutines</category><category>testing</category><category>flows</category></item><item><title>Flow Composition Patterns: Combining Multiple Flows Effectively</title><link>https://carrion.dev/en/posts/flow-composition-patterns/</link><pubDate>Tue, 18 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 18 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/flow-composition-patterns/</guid><description>Flow Composition Patterns: Combining Multiple Flows Effectively When working with Kotlin Flows in real-world applications, you often need to combine multiple data streams to create more complex workflows. This article explores various Flow composition patterns and best practices for effectively combining multiple Flows.
Understanding Flow Composition Flow composition is the process of combining multiple Flows to create a new Flow that represents a more complex data stream. Kotlin provides several operators for Flow composition, each serving different use cases.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/flow-composition.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>coroutines</category><category>flows</category><category>patterns</category></item><item><title>Understanding Flow Operators: Buffer, Conflate, Debounce, and Sample</title><link>https://carrion.dev/en/posts/flow-operators-buffer-conflate/</link><pubDate>Fri, 14 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 14 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/flow-operators-buffer-conflate/</guid><description>Understanding Flow Operators: Buffer, Conflate, Debounce, and Sample When working with Kotlin Flows, especially in scenarios involving fast-emitting producers and slow collectors, it&amp;rsquo;s crucial to understand how to manage the flow of data effectively. This post explores four essential Flow operators that help handle such scenarios: buffer, conflate, debounce, and sample.
The Problem: Slow Collectors Before diving into the operators, let&amp;rsquo;s understand the problem they solve. Consider this scenario:
1 2 3 4 5 6 7 8 9 flow { for (i in 1.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev//images/kotlin/flow-operators.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>flows</category><category>coroutines</category></item><item><title>Converting Callbacks to Coroutines and Flows in Kotlin</title><link>https://carrion.dev/en/posts/callback-to-flow-conversion/</link><pubDate>Tue, 11 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 11 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/callback-to-flow-conversion/</guid><description>Converting Callbacks to Coroutines and Flows in Kotlin Callback-based APIs have been a common pattern in asynchronous programming for many years. However, with Kotlin&amp;rsquo;s coroutines and flows, we can transform these callbacks into more modern, sequential code that&amp;rsquo;s easier to read and maintain. In this article, we&amp;rsquo;ll explore how to use suspendCoroutine and callbackFlow to convert callback-based APIs into coroutines and flows.
Understanding suspendCoroutine The suspendCoroutine function is a powerful tool that allows you to wrap callback-based APIs into suspend functions.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/suspend-coroutine.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>coroutines</category><category>flows</category><category>callbacks</category></item><item><title>Understanding Hot and Cold Flows in Kotlin</title><link>https://carrion.dev/en/posts/kotlin-flows-hot-cold/</link><pubDate>Fri, 07 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 07 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-flows-hot-cold/</guid><description>Understanding Hot and Cold Flows in Kotlin Kotlin Flow is a powerful feature for handling reactive streams of data. One of the fundamental concepts to understand when working with flows is the distinction between hot and cold flows. This article will explain the differences and provide practical examples of both types.
Cold Flows: The Default Behavior Cold flows are the default type in Kotlin Flow. They start producing values only when a collector starts collecting from them.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/flows.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>coroutines</category><category>flows</category></item><item><title>Hilt: Inject Runtime parameters to ViewModels.</title><link>https://carrion.dev/en/posts/hilt-inject-parameters-runtime/</link><pubDate>Wed, 24 Feb 2021 07:00:06 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 24 Feb 2021 07:00:06 +0100</atom:modified><guid>https://carrion.dev/en/posts/hilt-inject-parameters-runtime/</guid><description>Inject runtime parameters with Dagger-Hilt Since Hilt appeared to make it easier the dependency injection in Android, it was impossible to inject runtime parameters without using third party libraries. Since Dagger version 2.31, exists the @AssistedInject annotation. With this annotation we can instruct Dagger-Hilt what dependencies need to be created at runtime and delay the injection of this parameters until we can provide those values.
This is necessary to inject parameters into ViewModel constructor and be able to execute some code in the init function.</description><dc:creator>Ignacio</dc:creator><media:content url="https://carrion.dev/images/kotlin/kotlin-logo.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>jetpack</category><category>coroutines</category><category>androidx</category></item><item><title>Welcome to my new Kotlin and Android development blog</title><link>https://carrion.dev/en/posts/welcome-to-my-new-kotlin-and-android-development-blog/</link><pubDate>Tue, 23 Feb 2021 10:00:06 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 23 Feb 2021 10:00:06 +0100</atom:modified><guid>https://carrion.dev/en/posts/welcome-to-my-new-kotlin-and-android-development-blog/</guid><description>Welcome to Carrion.dev Hi droid!
Welcome to my new Kotlin and Android programming blog. I am Ignacio Carrión and I&amp;rsquo;m an Android developer. I love Kotlin because it boost my Android development eficiency and because it has infinite posibilities outside of Android ecosystem (backend, web, native, multiplatform&amp;hellip;).
In this blog I hope I can publish interesting topics about Kotlin and Android at least twice a month. If you want to keep up to date you can subscribe to our newsletter.</description><dc:creator>Ignacio</dc:creator><category>kotlin</category><category>android</category><category>jetpack</category><category>coroutines</category><category>androidx</category></item></channel></rss>