[{"content":"Understanding Flow Operators: Buffer, Conflate, Debounce, and Sample When working with Kotlin Flows, especially in scenarios involving fast-emitting producers and slow collectors, it\u0026rsquo;s crucial to understand how to manage the flow of data effectively. This post explores four essential Flow operators that help handle such scenarios: buffer, conflate, debounce, and sample.\nThe Problem: Slow Collectors Before diving into the operators, let\u0026rsquo;s understand the problem they solve. Consider this scenario:\n1 2 3 4 5 6 7 8 9  flow { for (i in 1..100) { emit(i) delay(100) // Emit every 100ms  } }.collect { value: Int -\u0026gt; delay(300) // Process for 300ms  println(\u0026#34;Processed $value\u0026#34;) }   In this case, the collector is slower than the producer, which can lead to backpressure issues. Each operator we\u0026rsquo;ll discuss provides a different strategy to handle this situation.\nBuffer Operator The buffer operator creates a channel of specified capacity to store emissions while the collector processes previous values.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  flow { for (i in 1..5) { emit(i) println(\u0026#34;Emitting $i\u0026#34;) delay(100) } }.buffer(2) // Buffer capacity of 2  .collect { value: Int -\u0026gt; println(\u0026#34;Collecting $value\u0026#34;) delay(300) // Slow collector } // Output: // Emitting 1 // Emitting 2 // Emitting 3 // Collecting 1 (t=300ms) // Collecting 2 (t=600ms) // Emitting 4 // Emitting 5 // Collecting 3 (t=900ms) // Collecting 4 (t=1200ms) // Collecting 5 (t=1500ms)   When to Use Buffer  When you want to store a specific number of emissions When you need to process all values but want to decouple producer and collector speeds When order of processing is important  Conflate Operator The conflate operator keeps only the latest value, dropping intermediate ones if the collector can\u0026rsquo;t keep up.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  flow { for (i in 1..5) { emit(i) println(\u0026#34;Emitting $i\u0026#34;) delay(100) } }.conflate() .collect { value: Int -\u0026gt; println(\u0026#34;Collecting $value\u0026#34;) delay(300) // Slow collector } // Output: // Emitting 1 // Emitting 2 // Collecting 1 (t=300ms) // Emitting 3 // Emitting 4 // Collecting 4 (t=600ms) // Emitting 5 // Collecting 5 (t=900ms)   When to Use Conflate  When you only care about the most recent value In UI scenarios where showing intermediate states isn\u0026rsquo;t necessary When processing every value isn\u0026rsquo;t critical  Debounce Operator The debounce operator emits a value only after a specified time has passed without new emissions.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  flow { emit(1) delay(90) emit(2) // Will be dropped  delay(90) emit(3) // Will be dropped  delay(150) // Longer than debounce timeout  emit(4) // Will be emitted }.debounce(100) .collect { value: Int -\u0026gt; println(\u0026#34;Collecting $value\u0026#34;) } // Output: // Collecting 1 (t=100ms) // Collecting 4 (t=430ms) // (Values 2 and 3 are dropped because new values arrived before debounce timeout)   When to Use Debounce  For search-as-you-type functionality When handling rapid UI events When you want to wait for \u0026ldquo;quiet periods\u0026rdquo; before processing  Sample Operator The sample operator periodically samples the most recent value from the flow at specified intervals.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  flow { var i = 0 while (i \u0026lt; 10) { emit(i++) delay(50) // Emit every 50ms  } }.sample(100) // Sample every 100ms  .collect { value: Int -\u0026gt; println(\u0026#34;Sampled value: $value\u0026#34;) } // Output: // Sampled value: 1 (t=100ms) // Sampled value: 3 (t=200ms) // Sampled value: 5 (t=300ms) // Sampled value: 7 (t=400ms) // Sampled value: 9 (t=500ms) // (Only captures the latest value every 100ms)   When to Use Sample  When you need regular updates at fixed intervals For displaying real-time data where intermediate values aren\u0026rsquo;t crucial When you want to limit the rate of processing regardless of emission rate  Comparison and Best Practices Here\u0026rsquo;s a quick comparison of these operators:\n   Operator Behavior Use Case     buffer Stores emissions Process all values, maintain order   conflate Keeps latest only UI updates, latest-value-only scenarios   debounce Waits for quiet period Search-as-you-type, rapid event handling   sample Takes periodic snapshots Regular updates, rate limiting    Conclusion Understanding these Flow operators is crucial for building efficient reactive applications:\n Use buffer when you need to process all values and control memory usage Use conflate when only the latest value matters Use debounce when handling rapid events that need \u0026ldquo;settling time\u0026rdquo; Use sample when you need regular updates at fixed intervals  Choose the appropriate operator based on your specific use case and requirements regarding data completeness, order, and processing rate.\nRemember that these operators can be combined to create more sophisticated data processing pipelines, but be careful not to over-complicate your flows. Always consider the trade-offs between data completeness, memory usage, and processing efficiency.\n","description":"Deep dive into Kotlin Flow operators: buffer, conflate, debounce, and sample. Learn when and how to use each operator with practical examples.","id":0,"section":"posts","tags":["kotlin","flows","coroutines"],"title":"Understanding Flow Operators: Buffer, Conflate, Debounce, and Sample","uri":"https://carrion.dev/en/posts/flow-operators-buffer-conflate/"},{"content":"Converting Callbacks to Coroutines and Flows in Kotlin Callback-based APIs have been a common pattern in asynchronous programming for many years. However, with Kotlin\u0026rsquo;s coroutines and flows, we can transform these callbacks into more modern, sequential code that\u0026rsquo;s easier to read and maintain. In this article, we\u0026rsquo;ll explore how to use suspendCoroutine and callbackFlow to convert callback-based APIs into coroutines and flows.\nUnderstanding suspendCoroutine The suspendCoroutine function is a powerful tool that allows you to wrap callback-based APIs into suspend functions. This transformation makes asynchronous code more sequential and easier to handle.\nBasic Usage of suspendCoroutine Here\u0026rsquo;s a simple example of converting a callback-based function to a suspend function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // Traditional callback-based API interface LocationCallback { fun onLocationFound(location: Location) fun onError(error: Exception) } class LocationService { fun getCurrentLocation(callback: LocationCallback) { // Simulating async location fetch  // Implementation details...  } } // Converted to suspend function suspend fun LocationService.getLocationSuspend(): Location { return suspendCoroutine\u0026lt;Location\u0026gt; { continuation: Continuation\u0026lt;Location\u0026gt; -\u0026gt; getCurrentLocation(object : LocationCallback { override fun onLocationFound(location: Location) { continuation.resume(location) } override fun onError(error: Exception) { continuation.resumeWithException(error) } }) } } // Usage suspend fun fetchLocation() { try { val location = locationService.getLocationSuspend() println(\u0026#34;Location received: $location\u0026#34;) } catch (e: Exception) { println(\u0026#34;Error getting location: ${e.message}\u0026#34;) } }   Handling Cancellation When working with suspendCoroutine, it\u0026rsquo;s important to handle cancellation properly:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  suspend fun LocationService.getLocationSuspendWithCancellation(): Location { return suspendCancellableCoroutine\u0026lt;Location\u0026gt; { continuation: CancellableContinuation\u0026lt;Location\u0026gt; -\u0026gt; val callback = object : LocationCallback { override fun onLocationFound(location: Location) { continuation.resume(location) } override fun onError(error: Exception) { continuation.resumeWithException(error) } } getCurrentLocation(callback) continuation.invokeOnCancellation { // Cleanup resources, remove callbacks, etc.  removeLocationUpdates(callback) } } }   Converting to Flows with callbackFlow While suspendCoroutine is great for one-shot operations, callbackFlow is perfect for handling streams of data or events. It allows you to convert callback-based APIs that emit multiple values into Kotlin Flows.\nBasic callbackFlow Example Here\u0026rsquo;s how to convert a location updates API to a Flow:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  interface LocationUpdatesCallback { fun onLocationUpdate(location: Location) fun onError(error: Exception) } class LocationService { fun startLocationUpdates(callback: LocationUpdatesCallback) { // Implementation details...  } fun stopLocationUpdates(callback: LocationUpdatesCallback) { // Implementation details...  } } fun LocationService.locationUpdatesFlow(): Flow\u0026lt;Location\u0026gt; = callbackFlow { val callback = object : LocationUpdatesCallback { override fun onLocationUpdate(location: Location) { trySend(location) } override fun onError(error: Exception) { close(error) } } startLocationUpdates(callback) // Clean up when the flow is cancelled  awaitClose { stopLocationUpdates(callback) } } // Usage suspend fun trackLocation() { locationService.locationUpdatesFlow() .catch { error: Throwable -\u0026gt; println(\u0026#34;Error in location updates: ${error.message}\u0026#34;) } .collect { location: Location -\u0026gt; println(\u0026#34;New location: $location\u0026#34;) } }   Handling Backpressure When dealing with frequent updates, it\u0026rsquo;s important to handle backpressure properly:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  fun SensorService.sensorUpdatesFlow(): Flow\u0026lt;SensorData\u0026gt; = callbackFlow { val callback = object : SensorCallback { override fun onSensorUpdate(data: SensorData) { // Use trySend instead of send to handle backpressure  if (!trySend(data).isSuccess) { // Handle unsuccessful send  println(\u0026#34;Buffer full, dropping sensor update\u0026#34;) } } } registerSensorCallback(callback) awaitClose { unregisterSensorCallback(callback) } }.buffer(Channel.CONFLATED) // Keep only the latest value   Best Practices   Error Handling\n Always handle errors appropriately in both suspendCoroutine and callbackFlow Use try-catch blocks for suspendCoroutine Use catch operator for flows    Resource Management\n Clean up resources in awaitClose for callbackFlow Use suspendCancellableCoroutine when cancellation handling is needed    Backpressure Considerations\n Choose appropriate buffer strategies for your use case Consider using conflated or buffered channels based on your needs    Testing\n Write tests for both success and error scenarios Test cancellation behavior Verify resource cleanup    Common Patterns and Examples Timeout Handling 1 2 3 4 5 6 7 8 9 10 11 12 13 14  suspend fun apiCallWithTimeout(): Result\u0026lt;String\u0026gt; = withTimeout(5000L) { suspendCoroutine\u0026lt;Result\u0026lt;String\u0026gt;\u0026gt; { continuation: Continuation\u0026lt;Result\u0026lt;String\u0026gt;\u0026gt; -\u0026gt; api.call(object : ApiCallback { override fun onSuccess(result: Result\u0026lt;String\u0026gt;) { continuation.resume(result) } override fun onError(error: Exception) { continuation.resumeWithException(error) } }) } }   Combining Multiple Callbacks 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  fun MultipleSourceService.combinedUpdatesFlow(): Flow\u0026lt;Update\u0026gt; = callbackFlow { val callback1 = object : SourceCallback { override fun onUpdate(data: Update) { trySend(data) } } val callback2 = object : SourceCallback { override fun onUpdate(data: Update) { trySend(data) } } registerCallbacks(callback1, callback2) awaitClose { unregisterCallbacks(callback1, callback2) } }.buffer(Channel.BUFFERED)   Conclusion Converting callback-based APIs to coroutines and flows can significantly improve code readability and maintainability. By using suspendCoroutine for one-shot operations and callbackFlow for streams of data, you can modernize legacy code and take full advantage of Kotlin\u0026rsquo;s powerful concurrency features.\nRemember to always handle errors appropriately, manage resources properly, and consider backpressure when dealing with high-frequency updates. With these tools and patterns, you can effectively bridge the gap between callback-based APIs and modern Kotlin concurrency.\n","description":"Learn how to transform callback-based APIs into modern Kotlin coroutines and flows using suspendCoroutine and callbackFlow","id":1,"section":"posts","tags":["kotlin","coroutines","flows","callbacks"],"title":"Converting Callbacks to Coroutines and Flows in Kotlin","uri":"https://carrion.dev/en/posts/callback-to-flow-conversion/"},{"content":"Understanding Hot and Cold Flows in Kotlin Kotlin Flow is a powerful feature for handling reactive streams of data. One of the fundamental concepts to understand when working with flows is the distinction between hot and cold flows. This article will explain the differences and provide practical examples of both types.\nCold Flows: The Default Behavior Cold flows are the default type in Kotlin Flow. They start producing values only when a collector starts collecting from them. Each collector gets its own independent stream of values from scratch.\nCharacteristics of Cold Flows:  Start producing values only when collected Each collector receives all values from the beginning Values are produced independently for each collector Resources are not shared between collectors  Here\u0026rsquo;s an example of a cold flow:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  fun numbers(): Flow\u0026lt;Int\u0026gt; = flow { println(\u0026#34;Flow started\u0026#34;) for (i in 1..3) { delay(100) emit(i) } } suspend fun main() { val numbersFlow = numbers() // First collector  println(\u0026#34;First collector starting\u0026#34;) numbersFlow.collect { value: Int -\u0026gt; println(\u0026#34;Collector 1: $value\u0026#34;) } // Second collector  println(\u0026#34;Second collector starting\u0026#34;) numbersFlow.collect { value: Int -\u0026gt; println(\u0026#34;Collector 2: $value\u0026#34;) } }   Output:\nFirst collector starting Flow started Collector 1: 1 Collector 1: 2 Collector 1: 3 Second collector starting Flow started Collector 2: 1 Collector 2: 2 Collector 2: 3 Hot Flows: Shared State and Events Hot flows, on the other hand, may start producing values regardless of collectors and can share the same stream of values between multiple collectors. They\u0026rsquo;re useful for representing real-time events or shared state.\nTypes of Hot Flows:  StateFlow: For representing state SharedFlow: For representing events  StateFlow Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class TemperatureSensor { private val _temperature = MutableStateFlow(20.0) // Initial temperature  val temperature: StateFlow\u0026lt;Double\u0026gt; = _temperature.asStateFlow() fun updateTemperature(newTemp: Double) { _temperature.update { newTemp } } } suspend fun main() { val sensor = TemperatureSensor() // First collector  launch { sensor.temperature.collect { temp: Double -\u0026gt; println(\u0026#34;Display 1: $temp°C\u0026#34;) } } delay(100) println(\u0026#34;Updating temperature to 22.5°C\u0026#34;) sensor.updateTemperature(22.5) delay(100) // Late collector - will only see the current value (22.5) and future updates  launch { println(\u0026#34;Display 2 starting collection...\u0026#34;) sensor.temperature.collect { temp: Double -\u0026gt; println(\u0026#34;Display 2: $temp°C\u0026#34;) } } delay(100) println(\u0026#34;Updating temperature to 23.0°C\u0026#34;) sensor.updateTemperature(23.0) }   Output:\nDisplay 1: 20.0°C Updating temperature to 22.5°C Display 1: 22.5°C Display 2 starting collection... Display 2: 22.5°C Updating temperature to 23.0°C Display 1: 23.0°C Display 2: 23.0°C SharedFlow Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class EventBus { private val _events = MutableSharedFlow\u0026lt;String\u0026gt;() val events = _events.asSharedFlow() suspend fun emit(event: String) { _events.emit(event) } } suspend fun main() { val eventBus = EventBus() // First subscriber  launch { eventBus.events.collect { event: String -\u0026gt; println(\u0026#34;Subscriber 1: $event\u0026#34;) } } delay(100) println(\u0026#34;Emitting first event\u0026#34;) eventBus.emit(\u0026#34;User logged in\u0026#34;) delay(100) // Late subscriber - will miss the \u0026#34;User logged in\u0026#34; event  launch { println(\u0026#34;Subscriber 2 starting collection...\u0026#34;) eventBus.events.collect { event: String -\u0026gt; println(\u0026#34;Subscriber 2: $event\u0026#34;) } } delay(100) println(\u0026#34;Emitting second event\u0026#34;) eventBus.emit(\u0026#34;Data updated\u0026#34;) }   Output:\nSubscriber 1: User logged in Subscriber 2 starting collection... Emitting second event Subscriber 1: Data updated Subscriber 2: Data updated Key Differences Between Hot and Cold Flows   Execution Timing\n Cold: Executes per collector Hot: Can execute independently of collectors    Value Sharing\n Cold: Each collector gets its own stream Hot: Multiple collectors share the same stream    Resource Usage\n Cold: Resources allocated per collector Hot: Resources shared between collectors    Use Cases\n Cold: Data transformations, database queries Hot: UI states, real-time events, broadcasts    When to Use Each Type Use Cold Flows When:  Each collector needs its own independent stream You\u0026rsquo;re performing resource-intensive operations You need to restart the stream from the beginning for each collector  Use Hot Flows When:  Multiple parts of your app need the same data stream You\u0026rsquo;re dealing with UI state management You need to broadcast events to multiple subscribers You want to share resources between collectors  Best Practices   Cold Flows\n Use for operations that should be executed independently Consider using buffer() for performance optimization Clean up resources in onCompletion    Hot Flows\n Use StateFlow for state management Use SharedFlow for events Consider replay and buffer sizes carefully Handle backpressure appropriately    By understanding these differences, you can choose the right type of flow for your specific use case and create more efficient and maintainable reactive streams in your Kotlin applications.\n","description":"A comprehensive guide to understanding the differences between hot and cold flows in Kotlin, with practical examples","id":2,"section":"posts","tags":["kotlin","coroutines","flows"],"title":"Understanding Hot and Cold Flows in Kotlin","uri":"https://carrion.dev/en/posts/kotlin-flows-hot-cold/"},{"content":"Achieving Compile-Time Safety in Koin: A Comprehensive Guide Dependency injection is a fundamental pattern in modern Android development, but how can we ensure our DI configuration is correct before running the app? In this post, we\u0026rsquo;ll explore two powerful approaches to achieve compile-time safety with Koin: using the DSL\u0026rsquo;s verify() function and leveraging Koin Annotations with KSP.\nThe Problem: Runtime vs. Compile-Time Validation Traditional dependency injection often reveals configuration issues only at runtime:\n Missing dependencies cause crashes Circular dependencies aren\u0026rsquo;t detected until runtime Type mismatches surface when the app is running Wrong scoping leads to unexpected behavior  These issues can be particularly problematic in large applications where dependency graphs are complex and not all paths are covered by tests.\nSolution 1: Koin DSL with verify() The first approach uses Koin\u0026rsquo;s built-in verify() function to check module configurations during the compilation phase.\nHow It Works 1 2 3 4 5 6 7 8 9 10 11 12  val appModule = module { single\u0026lt;Repository\u0026gt; { DefaultRepository() } factory { UseCase(get()) } viewModel { MainViewModel(get()) } } class ModuleCheck { @Test fun verifyKoinModules() { appModule.verify() } }   By creating a unit test that calls verify() on your modules and making it part of your build process, you can catch common issues early.\nAdvantages  Simple to implement No additional dependencies required Works with existing Koin DSL code Can be integrated into CI/CD pipelines  Limitations  Requires explicit test execution Less IDE support No direct compilation errors Can\u0026rsquo;t catch all potential issues  Solution 2: Koin Annotations with KSP The second approach uses Kotlin Symbol Processing (KSP) and Koin\u0026rsquo;s annotation system to validate dependency graphs during compilation.\nSetup 1 2 3 4 5 6 7 8 9 10 11 12 13  // build.gradle.kts plugins { id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;2.1.10-1.0.31\u0026#34; } dependencies { implementation(\u0026#34;io.insert-koin:koin-annotations:2.0.0-RC5\u0026#34;) ksp(\u0026#34;io.insert-koin:koin-ksp-compiler:2.0.0-RC5\u0026#34;) } ksp { arg(\u0026#34;KOIN_CONFIG_CHECK\u0026#34;, \u0026#34;true\u0026#34;) }   How It Works Instead of using the DSL, you define dependencies using annotations:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  @SingleOf(binds = [Repository::class]) class DefaultRepository : Repository { // Implementation } @Module class AppModule { @Factory fun provideUseCase(repository: Repository): UseCase { return UseCase(repository) } } @Module class ViewModelModule { @KoinViewModel fun provideMainViewModel( useCase: UseCase ): MainViewModel = MainViewModel(useCase) }   KSP processes these annotations during compilation and:\n Generates type-safe dependency definitions Validates the dependency graph Ensures all dependencies can be resolved Checks for circular dependencies Verifies scope consistency  Advantages  True compile-time validation Better IDE support More explicit dependency declarations Catches issues during compilation Type-safe by design  Limitations  Requires additional setup More verbose than DSL Requires migration from DSL-based code  Comparing the Approaches    Feature DSL + verify() Annotations + KSP     Setup Complexity Low Medium   Validation Timing Build-time (via tests) Compile-time   IDE Support Limited Good   Migration Effort Low Medium   Type Safety Good Excellent   Error Messages Test failures Compilation errors   Learning Curve Gentle Moderate    Which Approach Should You Choose? Choose DSL + verify() if:  You have an existing Koin DSL codebase You want a simple solution You prefer more flexible configuration You\u0026rsquo;re comfortable with test-based validation  Choose Annotations + KSP if:  You\u0026rsquo;re starting a new project You want true compile-time safety You prefer explicit dependency declarations You value IDE support and type safety  Best Practices Regardless of the approach you choose:\n  Make validation part of your build process\n For DSL: Include verification tests in your build For Annotations: Enable KSP validation    Document your dependency graph\n Keep a clear structure of modules Document scope decisions Maintain a clean architecture    Monitor build times\n Both approaches can impact build times KSP processing adds to compilation time Test execution adds to build time    Consider gradual migration\n You can mix both approaches Migrate gradually from DSL to annotations Start with new features using your chosen approach    Conclusion Both approaches offer valuable ways to achieve compile-time safety in your Koin dependency injection. The DSL with verify() provides a simpler, test-based approach, while annotations with KSP offer stronger compile-time guarantees with better tooling support.\nChoose the approach that best fits your project\u0026rsquo;s needs, considering factors like existing codebase, team expertise, and desired level of type safety. Remember that both approaches are significantly better than relying solely on runtime validation.\nResources  Koin Documentation Koin Annotations Guide KSP Documentation Sample Project  ","description":"Dependency injection is a fundamental pattern in modern Android development, but how can we ensure our DI configuration is correct before running the app? In this post, we'll explore two powerful approaches to achieve compile-time safety with Koin: using the DSL's `verify()` function and leveraging Koin Annotations with KSP.","id":3,"section":"posts","tags":["kotlin","android","koin"],"title":"Achieving Compile-Time Safety in Koin: A Comprehensive Guide","uri":"https://carrion.dev/en/posts/koin-compile-safety/"},{"content":"Reliable Timekeeping with the TrustedTime API in Android Accurate timekeeping is crucial for many app functionalities, including scheduling, transaction logging, and security. However, relying on a device\u0026rsquo;s system clock can be problematic since users can alter their device’s time settings. To address this, Google has introduced the TrustedTime API, providing a reliable and tamper-resistant time source for Android apps.\nUnderstanding the TrustedTime API The TrustedTime API leverages Google\u0026rsquo;s secure infrastructure to offer a trustworthy timestamp, independent of the device\u0026rsquo;s local time settings. It periodically syncs with Google\u0026rsquo;s accurate time servers, reducing the need for frequent network requests. The API also accounts for clock drift, alerting developers when time accuracy may degrade between synchronizations.\nWhy Reliable Timekeeping Matters Relying solely on a device’s clock can cause issues such as:\n Data Inconsistency: Apps that depend on event ordering can face data corruption if users manipulate device time. Security Risks: Time-based security measures, like OTPs and access controls, require an accurate clock. Unreliable Scheduling: Reminders and scheduled events may malfunction if the device clock is incorrect. Clock Drift: Internal clocks can drift due to factors like temperature changes and battery levels. Multi-Device Synchronization Issues: Inconsistent time settings across devices can disrupt data sync. Excessive Battery \u0026amp; Data Usage: Constantly querying network time servers drains resources, which TrustedTime helps optimize.  Practical Applications of TrustedTime The TrustedTime API enhances security and reliability in various scenarios:\n Financial Apps: Ensures accurate timestamps for transactions. Gaming: Prevents time-based exploits. E-Commerce: Tracks order processing and delivery accurately. Limited-Time Offers: Ensures promotions expire correctly. IoT Devices: Synchronizes clocks across multiple devices. Productivity Apps: Maintains accurate timestamps for cloud document edits.  Integrating TrustedTime into Your Android App 1. Add the Dependency Include the TrustedTime API in your build.gradle file:\n1  implementation \u0026#39;com.google.android.gms:play-services-time:16.0.1\u0026#39;   2. Initialize TrustedTimeClient 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class MyApp : Application() { var trustedTimeClient: TrustedTimeClient? = null private set override fun onCreate() { super.onCreate() TrustedTime.createClient(this).addOnCompleteListener { task -\u0026gt; if (task.isSuccessful) { trustedTimeClient = task.result } else { // Handle error  } } } }   3. Using TrustedTime in an Activity or Fragment To retrieve the trusted time within an Activity or Fragment, we can access the TrustedTimeClient from the application class:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class MainActivity : AppCompatActivity() { private val trustedTimeClient: TrustedTimeClient? get() = (application as MyApp).trustedTimeClient override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) getTrustedTime() } private fun getTrustedTime() { val currentTimeMillis = trustedTimeClient?.computeCurrentUnixEpochMillis() ?: System.currentTimeMillis() Log.d(\u0026#34;TrustedTime\u0026#34;, \u0026#34;Trusted current time: $currentTimeMillis\u0026#34;) } }   By retrieving trustedTimeClient from MyApp, we avoid redundant initialization and ensure a single trusted source of time throughout the app.\nConsiderations \u0026amp; Limitations  Requires Internet Access: TrustedTime needs an internet connection after boot to function correctly. Clock Drift: While the API estimates error, it cannot entirely prevent clock drift. Tampering Protection: It reduces, but does not completely eliminate, time manipulation risks. TrustedTime API Availability and Limitations: The TrustedTime API is available on all devices running Google Play services on Android 5 (Lollipop) and above.  By integrating the TrustedTime API, developers can improve the accuracy and security of time-dependent app functionalities, ensuring a consistent and reliable experience for users.\n","description":"The TrustedTime API leverages Google's secure infrastructure to offer a trustworthy timestamp","id":4,"section":"posts","tags":["kotlin","android","google"],"title":"Reliable Timekeeping with the TrustedTime API in Android","uri":"https://carrion.dev/en/posts/trusted-time-api/"},{"content":"Kotlin Multiplatform Architecture Best Practices for Mobile Apps Kotlin Multiplatform (KMP) allows developers to share business logic between Android and iOS while keeping platform-specific implementations where necessary. Structuring a KMP project efficiently is key to maintaining scalability, testability, and clean architecture. In this guide, we’ll explore best practices for architecting a KMP mobile application with Compose Multiplatform and Clean Architecture.\n1. Project Structure A well-organized project structure improves maintainability and separation of concerns. A common approach is to follow a multi-module structure, either with a single shared module or with multiple feature-based modules:\nproject-root/ ├── core/ │ ├── network/ # Network shared logic │ │ ├── src/commonMain/ # Shared networking │ │ ├── src/androidMain/ # Android-specific implementations │ │ ├── src/iosMain/ # iOS-specific implementations ├── features/ # Feature-based modules │ ├── feature1/ # Example feature module │ │ ├── domain/ # Domain layer (Use cases, repositories interfaces) │ │ ├── data/ # Data layer (Implementations, APIs, Database) │ │ ├── presentation/ # UI and ViewModels for Compose Multiplatform ├── composeApp/ # Application module integrating all features │ ├── src/commonMain/ # Can contain shared UI and navigation logic │ ├── src/androidMain/ # Android-specific implementations if needed │ ├── src/iosMain/ # iOS-specific implementations if needed ├── androidApp/ # Android application module ├── iosApp/ # iOS application module  Feature Modules: Instead of a single shared module, you can have feature-specific shared modules to improve modularity and scalability. These can be further split into domain, data, and presentation layers for better separation of concerns. Core Modules: Contains shared utilities like networking, logging, and common domain logic. ComposeApp Module: Acts as the main application module, integrating all feature modules and handling navigation, similar to an app module in an Android project.  In most Compose Multiplatform projects, a composeApp module is used to assemble all features, manage navigation, and handle other app-wide concerns, similar to the app module in a standard Android project.\n2. Applying Clean Architecture in KMP Following Clean Architecture helps in maintaining separation of concerns and improving testability. The architecture can be structured into the following layers:\nDomain Layer (commonMain)  Contains business logic (Use Cases, Interactors). Defines repository interfaces for data access. Does not depend on any platform-specific implementation.  1 2 3  interface UserRepository { suspend fun getUser(): User }   Data Layer (commonMain, platform-specific)  Implements repository interfaces. Uses expect/actual for platform-specific APIs like networking, databases, etc. Fetches and processes raw data before exposing it to the domain layer.  Example expect/actual for HTTP client:\n1 2 3  expect class HttpClientProvider { fun getClient(): HttpClient }   Android-specific implementation:\n1 2 3  actual class HttpClientProvider { actual fun getClient() = HttpClient(Android) {} }   iOS-specific implementation:\n1 2 3  actual class HttpClientProvider { actual fun getClient() = HttpClient(Ios) {} }   Presentation Layer (Compose Multiplatform) With Compose Multiplatform, we can share UI components across platforms while leveraging native rendering. The composeApp module integrates all feature modules and handles navigation and app-wide logic.\n1 2 3 4 5 6 7 8 9 10  @Composable fun UserScreen(viewModel: UserViewModel) { val user by viewModel.userState.collectAsState() Column(modifier = Modifier.padding(16.dp)) { Text( \u0026#34;Hello, ${user?.name ?: \u0026#34;Guest\u0026#34;}\u0026#34;, style = MaterialTheme.typography.h6 ) } }   On Android, this is rendered using Jetpack Compose, and on iOS, it is rendered using Compose for iOS.\n3. State Management in KMP State management in a KMP project can be handled efficiently using StateFlow.\n1 2 3 4 5 6 7 8 9 10  class UserViewModel(private val repository: UserRepository) { private val _userState = MutableStateFlow\u0026lt;User?\u0026gt;(null) val userState: StateFlow\u0026lt;User?\u0026gt; = _userState fun loadUser() { viewModelScope.launch { _userState.value = repository.getUser() } } }   Since Compose Multiplatform supports collectAsState(), we can observe and render state changes directly in the UI.\n4. Testing in KMP  **Unit Tests in **commonTest using kotlin.test. Platform-specific Tests in androidTest and iosTest.  Example shared unit test:\n1 2 3 4 5  @Test fun testUserRepository() = runTest { val repository = FakeUserRepository() assertNotNull(repository.getUser()) }   Conclusion By following these best practices, you can build scalable and maintainable KMP applications:\n Use a modularized project structure with either a shared module or feature-based modules. Follow Clean Architecture for maintainability. Leverage Compose Multiplatform for UI, using a composeApp module to integrate feature modules and manage navigation. Feature modules can be further divided into domain, data, and presentation layers to improve separation of concerns. Manage state efficiently using StateFlow. Write comprehensive tests across shared and platform-specific code.  KMP enables efficient code sharing while preserving platform-specific optimizations, making it a powerful choice for mobile app development.\nWould you like a sample GitHub repository demonstrating this setup? 🚀\n","description":"Architecture tips for KMP projects using clean architecture","id":5,"section":"posts","tags":["kotlin","compose","cmp","multiplatform","cleancode","architecture"],"title":"Kotlin Multiplatform Architecture Best Practices for Mobile Apps","uri":"https://carrion.dev/en/posts/kmp-architecture/"},{"content":"Mocks, Fakes, and More: Understanding Test Doubles in Kotlin When writing tests in Kotlin, especially for Android development, we often need to replace real dependencies with test doubles. However, not all test doubles are the same—terms like mocks, fakes, stubs, spies, and dummies often come up. In this post, we’ll break down their differences with Kotlin examples using only plain Kotlin (no third-party libraries).\n1. Understanding Test Doubles Test doubles are objects that stand in for real dependencies in tests. They help us isolate the system under test (SUT) and make tests more reliable. Here are the main types:\n Dummy – A placeholder object that is never actually used. Stub – Provides predefined responses but doesn’t contain logic. Fake – A lightweight implementation with in-memory logic. Mock – A test double that verifies interactions. Spy – Wraps a real object while allowing selective behavior modification.  2. Dummy Objects A dummy is an object that exists only to satisfy a method signature but is never actually used.\nExample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  interface EmailSender { fun sendEmail(email: String, message: String) } class UserService(private val emailSender: EmailSender) { fun registerUser(user: User) { // User is registered, but we don\u0026#39;t actually send an email  } } data class User(val name: String, val email: String) // Test fun testRegisterUser() { val dummyEmailSender = object : EmailSender { override fun sendEmail(email: String, message: String) { // This will never be called in the test  } } val userService = UserService(dummyEmailSender) userService.registerUser(User(\u0026#34;John Doe\u0026#34;, \u0026#34;john@example.com\u0026#34;)) }   3. Stubs A stub returns predefined responses to method calls but doesn’t track interactions.\nExample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  interface UserRepository { fun getUser(id: Int): User? } class StubUserRepository : UserRepository { override fun getUser(id: Int): User? { return if (id == 1) User(\u0026#34;John Doe\u0026#34;, \u0026#34;john@example.com\u0026#34;) else null } } // Test fun testGetUser() { val stubRepo = StubUserRepository() val user = stubRepo.getUser(1) assert(user?.name == \u0026#34;John Doe\u0026#34;) }   4. Fakes A fake is a simplified but functional version of a real class, often using in-memory storage.\nExample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class FakeUserRepository : UserRepository { private val users = mutableMapOf\u0026lt;Int, User\u0026gt;() override fun getUser(id: Int): User? = users[id] fun addUser(id: Int, user: User) { users[id] = user } } // Test fun testFakeUserRepository() { val fakeRepo = FakeUserRepository() fakeRepo.addUser(1, User(\u0026#34;Jane Doe\u0026#34;, \u0026#34;jane@example.com\u0026#34;)) assert(fakeRepo.getUser(1)?.name == \u0026#34;Jane Doe\u0026#34;) }   5. Mocks A mock is a test double that verifies interactions. Without a mocking framework, we must manually track calls.\nExample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class MockEmailSender : EmailSender { var wasSendEmailCalled = false var sentTo: String? = null var sentMessage: String? = null override fun sendEmail(email: String, message: String) { wasSendEmailCalled = true sentTo = email sentMessage = message } } // Test fun testSendWelcomeEmail() { val mockEmailSender = MockEmailSender() val service = NotificationService(mockEmailSender) service.sendWelcomeEmail(User(\u0026#34;test@example.com\u0026#34;, \u0026#34;test@example.com\u0026#34;)) assert(mockEmailSender.wasSendEmailCalled) assert(mockEmailSender.sentTo == \u0026#34;test@example.com\u0026#34;) assert(mockEmailSender.sentMessage == \u0026#34;Welcome!\u0026#34;) } class NotificationService(private val emailSender: EmailSender) { fun sendWelcomeEmail(user: User) { emailSender.sendEmail(user.email, \u0026#34;Welcome!\u0026#34;) } }   6. Spies A spy wraps a real object while allowing selective behavior modification. Without a library, we must extend the real class and override specific behavior.\nExample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  open class MathService { open fun add(a: Int, b: Int) = a + b } class SpyMathService : MathService() { var wasAddCalled = false var lastA: Int? = null var lastB: Int? = null override fun add(a: Int, b: Int): Int { wasAddCalled = true lastA = a lastB = b return super.add(a, b) // Calls real implementation  } }   7. Using MockK for Mocks and Spies While manually creating mocks and spies is possible, using a library like MockK simplifies the process.\nExample using MockK: 1 2 3 4 5 6 7 8 9 10 11  import io.mockk.* fun testMockKExample() { val mockEmailSender = mockk\u0026lt;EmailSender\u0026gt;() every { mockEmailSender.sendEmail(any(), any()) } just Runs val service = NotificationService(mockEmailSender) service.sendWelcomeEmail(User(\u0026#34;test@example.com\u0026#34;, \u0026#34;test@example.com\u0026#34;)) verify { mockEmailSender.sendEmail(\u0026#34;test@example.com\u0026#34;, \u0026#34;Welcome!\u0026#34;) } }   MockK provides powerful features like automatic spies, relaxed mocks, and argument capturing, making testing easier and more maintainable.\nConclusion Understanding test doubles helps you write better tests by isolating dependencies. Use:\n✅ Dummies when an argument is required but unused.\n✅ Stubs for returning predefined values.\n✅ Fakes for lightweight implementations.\n✅ Mocks when verifying interactions.\n✅ Spies when you need partial mocking.\n✅ MockK for easier and more powerful mocking.\nBy choosing the right type, you can make your tests more reliable and maintainable.\n","description":"Mocks, Fakes, and More: Understanding Test Doubles in Kotlin","id":6,"section":"posts","tags":["kotlin","testing","mock","tdd"],"title":"Mocks, Fakes, and More","uri":"https://carrion.dev/en/posts/test-doubles/"},{"content":"Testing in Compose Multiplatform (CMP) from Common Code Compose Multiplatform (CMP) enables building UI for multiple platforms using Jetpack Compose. Fortunately, CMP also supports writing and running UI tests in the common code, making testing more efficient across platforms. In this post, we’ll explore how to test CMP applications using compose.uiTest and run them on Android, Desktop, and iOS.\n1. Setting Up Common UI Testing CMP provides compose.uiTest, allowing UI tests to be written in the shared module without platform-specific dependencies. This means you can write once and test everywhere.\nUpdating Build Configuration To enable testing, update your build.gradle.kts file in the shared module:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  kotlin { androidTarget { instrumentedTestVariant.sourceSetTree.set(KotlinSourceSetTree.test) } sourceSets { val commonTest by getting { dependencies { implementation(kotlin(\u0026#34;test\u0026#34;)) @OptIn(org.jetbrains.compose.ExperimentalComposeLibrary::class) implementation(compose.uiTest) // Common UI testing library  } } val desktopTest by getting { dependencies { implementation(compose.desktop.currentOs) } } } }   Declaring Android UI Test Dependencies At the root level of your build.gradle.kts file, add the necessary Android test dependencies:\n1 2 3 4  dependencies { androidTestImplementation(\u0026#34;androidx.compose.ui:ui-test-junit4-android:1.5.4\u0026#34;) debugImplementation(\u0026#34;androidx.compose.ui:ui-test-manifest:1.5.4\u0026#34;) }   Setting Up Android-Specific Test Configuration For Android instrumentation tests, add the following to your build.gradle.kts:\n1 2 3 4 5  android { defaultConfig { testInstrumentationRunner = \u0026#34;androidx.test.runner.AndroidJUnitRunner\u0026#34; } }   2. Implementing a Simple Counter UI Let’s create a CounterViewModel that will be tested:\n1 2 3 4 5 6 7 8 9 10 11 12  import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.asStateFlow class CounterViewModel { private val _count = MutableStateFlow(0) val count: StateFlow\u0026lt;Int\u0026gt; = _count.asStateFlow() fun increment() { _count.value += 1 } }   Now, let’s create the Composable UI that interacts with this ViewModel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  import androidx.compose.foundation.layout.* import androidx.compose.material.* import androidx.compose.runtime.* import androidx.compose.ui.Modifier import androidx.compose.ui.platform.testTag import androidx.compose.ui.unit.dp @Composable fun CounterScreen(viewModel: CounterViewModel) { val count by viewModel.count.collectAsState() Column( modifier = Modifier.padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally ) { Text( text = count.toString(), fontSize = 24.sp, modifier = Modifier.testTag(\u0026#34;counterText\u0026#34;) ) Spacer(modifier = Modifier.height(8.dp)) Button( onClick = { viewModel.increment() }, modifier = Modifier.testTag(\u0026#34;incrementButton\u0026#34;) ) { Text(\u0026#34;Increment\u0026#34;) } } }   3. Writing a Common UI Test in CMP Now, let’s write a UI test in commonTest to validate that clicking the button increments the counter:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import androidx.compose.ui.test.* import kotlin.test.Test import kotlin.test.assertEquals class CounterScreenTest { @OptIn(ExperimentalTestApi::class) @Test fun testButtonIncrementsCounter() = runComposeUiTest { val viewModel = CounterViewModel() setContent { CounterScreen(viewModel = viewModel) } onNodeWithTag(\u0026#34;counterText\u0026#34;).assertTextEquals(\u0026#34;0\u0026#34;) onNodeWithTag(\u0026#34;incrementButton\u0026#34;).performClick() onNodeWithTag(\u0026#34;counterText\u0026#34;).assertTextEquals(\u0026#34;1\u0026#34;) } }   4. Running the Tests on Multiple Platforms Now that we have our test written in common code, let’s execute it on Android, Desktop, and iOS.\nRun Tests on Android For Android instrumented tests, run:\n1  ./gradlew connectedAndroidTest   Run Tests on Desktop 1  ./gradlew desktopTest   Run Tests on iOS For iOS simulator tests, run:\n1  ./gradlew :composeApp:iosSimulatorArm64Test   5. Why Test CMP from Common Code? ✅ Write once, test everywhere: No need to duplicate tests across platforms.\n✅ Consistent behavior across platforms: Ensures UI elements function the same way.\n✅ Easier maintenance: Single test suite covering all targets.\nConclusion With Compose Multiplatform UI testing, we can validate UI behavior from shared code without requiring platform-specific test implementations. The compose.uiTest library allows us to test UI interactions like text verification and button clicks, ensuring UI consistency across Android, iOS, and Desktop.\n","description":"Learn how to write and run UI tests in Compose Multiplatform (CMP) from common code, ensuring cross-platform consistency for Android, iOS, and Desktop.","id":7,"section":"posts","tags":["kotlin","compose","cmp","multiplatform"],"title":"Testing in Compose Multiplatform (CMP) from Common Code","uri":"https://carrion.dev/en/posts/cmp-ui-testing/"},{"content":"Exploring Kotlin’s Immutable Collections Library Kotlin\u0026rsquo;s standard collections (List, Set, Map) are mutable by default, which can lead to unintended modifications. To enforce immutability at the API level, JetBrains introduced the Kotlin Immutable Collections library. This library provides a set of truly immutable collection types that prevent accidental modifications and enhance safety in concurrent or multi-threaded environments.\nWhy Use Immutable Collections? While Kotlin already has listOf(), setOf(), and mapOf() for read-only collections, they are not truly immutable. The underlying collection can still be modified if it\u0026rsquo;s referenced elsewhere. Example:\n1 2 3 4 5 6 7  val list = mutableListOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) val readOnlyList: List\u0026lt;String\u0026gt; = list list.add(\u0026#34;D\u0026#34;) // Modifies the original list println(readOnlyList) // Output: [A, B, C, D]  (readOnlyList as MutableList).add(\u0026#34;E\u0026#34;) println(readOnlyList) // Output: [A, B, C, D, E]   To solve this, the Immutable Collections library provides collections that guarantee immutability at runtime.\nKey Features  Truly Immutable – Once created, they cannot be changed. Safe for Multi-threading – Avoids unintended modifications in concurrent environments. Optimized for Performance – Uses structural sharing to prevent unnecessary copying.  How to Use Kotlin Immutable Collections 1. Add the Dependency inFirst, include the Immutable Collections dependency in your build.gradle.kts:\n1 2 3  dependencies { implementation(\u0026#34;org.jetbrains.kotlinx:kotlinx-collections-immutable:0.3.5\u0026#34;) }   2. Creating Immutable Collections The library provides persistentListOf(), persistentSetOf(), and persistentMapOf() to create immutable collections:\n1 2 3 4 5  import kotlinx.collections.immutable.* val immutableList = persistentListOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) val immutableSet = persistentSetOf(1, 2, 3) val immutableMap = persistentMapOf(\u0026#34;key1\u0026#34; to 100, \u0026#34;key2\u0026#34; to 200)   3. Adding and Removing Elements Since these collections are immutable, modifying operations return a new modified copy instead of changing the original collection:\n1 2 3 4 5  val newList = immutableList.add(\u0026#34;D\u0026#34;) // Creates a new list println(newList) // Output: [A, B, C, D]  val newMap = immutableMap.put(\u0026#34;key3\u0026#34;, 300) println(newMap) // Output: {key1=100, key2=200, key3=300}   The original immutableList and immutableMap remain unchanged!\nPerformance Considerations Unlike regular immutable collections (which require full copies for modifications), persistent collections use structural sharing. This means that modifications create a new collection while reusing unchanged parts of the original, improving performance and memory efficiency.\nFor example, adding an item to a persistent list does not create a full copy but instead reuses most of the existing structure:\nOriginal: [A, B, C] New List: [A, B, C, D] (Only \u0026quot;D\u0026quot; is newly allocated) This makes immutable collections efficient even for large datasets.\nBenefits in Jetpack Compose Immutable collections are particularly useful in Jetpack Compose because they optimize state management and recompositions. Here’s why they matter in Compose applications:\n1. Avoid Unnecessary Recompositions  Compose tracks state changes to decide when to recompose UI elements. Mutable lists, sets, or maps might trigger unnecessary recompositions even when data hasn’t changed. Immutable collections ensure that state remains stable, preventing redundant recompositions.  Example:\n1 2 3 4 5 6 7 8  @Composable fun MyListScreen(items: List\u0026lt;String\u0026gt;) { LazyColumn { items(items) { item -\u0026gt; Text(text = item) } } }   If items is a mutable list, even reassigning the same values triggers recomposition. Using an immutable collection like PersistentList ensures that Compose recognizes when data is unchanged:\n1 2  val items = remember { persistentListOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) } MyListScreen(items)   2. State Stability for Performance  Compose optimizes rendering by skipping recompositions when state objects are stable. Immutable collections use structural sharing, meaning that modifications only affect the changed part while reusing the rest. This leads to better performance in large lists or complex UI hierarchies.  3. Predictable UI Behavior  Since immutable collections cannot be modified after creation, they prevent accidental mutations that might lead to unpredictable UI updates. This is especially useful in state-driven architectures (MVI, Redux, etc.), ensuring UI updates only when necessary.  4. Thread Safety  In Compose apps using coroutines (Flows, LiveData, etc.), immutable collections prevent race conditions when multiple threads update state. They ensure safe data flow between ViewModels, repositories, and UI components.  When to Use Immutable Collections? ✅ Functional Programming – Encourages immutability for safer data transformations.\n✅ Thread Safety – Prevents unintended modifications in multi-threaded environments.\n✅ Prevent Bugs – Reduces unexpected side effects due to accidental mutation.\n✅ State Management in Compose – Helps optimize recompositions and improve UI performance.\nConclusion The Kotlin Immutable Collections library provides truly immutable, efficient, and safe collections, making them a great choice for functional programming, concurrent applications, and Jetpack Compose development. By leveraging persistent collections, you can write safer and more predictable Kotlin code.\n🚀 Would you use immutable collections in your projects?\n","description":"Exploring Kotlin’s Immutable Collections Library, use it in Compose to improve performance.","id":8,"section":"posts","tags":["kotlin","collections","compose"],"title":"Exploring Kotlin’s Immutable Collections Library","uri":"https://carrion.dev/en/posts/immutable-collections/"},{"content":"Boosting Android App Performance with Baseline Profiles Introduction In today’s fast-paced mobile world, users expect apps to launch instantly and run smoothly. Performance optimization is crucial, especially concerning app startup time and runtime execution.\nAndroid’s Baseline Profiles offer an effective way to speed up app startup and improve runtime performance by precompiling critical code paths. Google Play even recommends using Baseline Profiles to enhance the user experience, particularly for apps with complex UI rendering or heavy dependencies.\nIn this guide, we\u0026rsquo;ll explore what Baseline Profiles are, how they work, and how to integrate them into your Android app using a dedicated Baseline Profile module to achieve faster startup times and improved runtime performance.\nWhat Are Baseline Profiles? Android apps use the Android Runtime (ART) to execute code, employing Just-In-Time (JIT) and Ahead-Of-Time (AOT) compilation.\nHowever, JIT compilation can introduce delays during app startup since code isn\u0026rsquo;t fully optimized initially. Baseline Profiles solve this problem by allowing developers to specify critical code paths that should be precompiled before the app runs.\nHow Do Baseline Profiles Work?  Precompilation: They contain method and class definitions that are precompiled and optimized before execution. Installation: These profiles are installed on the user’s device upon the app’s first launch. Optimization: ART utilizes them to enhance execution speed, especially during cold starts.  When Should You Use Baseline Profiles? Baseline Profiles are particularly beneficial in the following scenarios:\n✅ Optimizing App Startup – Reducing cold start time by precompiling launch sequences.\n✅ Improving Scroll Performance – Ensuring smoother UI rendering.\n✅ Enhancing Frequently Used Features – Precompiling logic that users interact with often.\nSetting Up Baseline Profiles in a Separate Module Step 1: Create the Baseline Profile Module   Open Android Studio:\n Navigate to File → New → New Module. Select the Baseline Profile Generator template.    Configure the Module:\n Target Application: Choose the app module for which the Baseline Profile will be generated. Module Name: Assign a name, e.g., baselineprofile. Package Name: Define the package name for the module. Language: Select Kotlin or Java. Build Configuration Language: Choose between Kotlin Script (KTS) or Groovy.    Finish: Click Finish to create the module.\n  This process sets up a new module containing the necessary configurations and code to generate and benchmark Baseline Profiles.\nStep 2: Define the Baseline Profile Generator Jetpack Compose-Based Baseline Profile Generator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  @RunWith(AndroidJUnit4::class) @LargeTest class BaselineProfileGenerator { @get:Rule val baselineProfileRule = BaselineProfileRule() @get:Rule val composeTestRule = createAndroidComposeRule\u0026lt;MainActivity\u0026gt;() @Test fun baselineProfile() = baselineProfileRule.collect( packageName = \u0026#34;com.example.app\u0026#34;, includeInStartupProfile = true, profileBlock = { // 1. **App Cold Start**  startActivityAndWait() // 2. **Navigate to Main Screen**  composeTestRule.onNodeWithText(\u0026#34;Get Started\u0026#34;) .performClick() composeTestRule.waitForIdle() // 3. **Scroll Through a LazyColumn List**  composeTestRule.onNodeWithTag(\u0026#34;itemList\u0026#34;) .performScrollToIndex(10) composeTestRule.waitForIdle() // 4. **Open a Detail Screen**  composeTestRule.onNodeWithTag(\u0026#34;item_0\u0026#34;) .performClick() composeTestRule.waitForIdle() // 5. **Perform a Search**  composeTestRule.onNodeWithTag(\u0026#34;searchInput\u0026#34;) .performTextInput(\u0026#34;Kotlin\u0026#34;) composeTestRule.waitForIdle() // 6. **Back Navigation**  composeTestRule.onNodeWithContentDescription(\u0026#34;Back\u0026#34;) .performClick() composeTestRule.waitForIdle() } ) }   Step 3: Generate and Integrate the Baseline Profile   Generate the Baseline Profile:\n  Run the Generate Baseline Profile configuration created by the template.\n  Alternatively, execute the following Gradle task:\n1  ./gradlew :app:generateBaselineProfile     This generates the Baseline Profile and copies it to the appropriate directory in your app module.\n  Integrate the Baseline Profile:\n  The generated profile is automatically included in your app module’s assets.\n  Ensure that your app\u0026rsquo;s build.gradle includes the necessary dependencies:\n1 2 3 4  dependencies { implementation(\u0026#34;androidx.profileinstaller:profileinstaller:1.3.0\u0026#34;) baselineProfile(project(\u0026#34;:baselineprofile\u0026#34;)) }     The profileinstaller library installs the Baseline Profile on user devices, and the baselineProfile dependency links the generated profile to your app.\n  Conclusion Baseline Profiles are a powerful tool for improving app startup time and runtime performance without increasing APK size. By precompiling critical code paths, your app launches faster, providing a smoother and more responsive experience for users.\nBy integrating Baseline Profiles using a dedicated module, you ensure a modular, maintainable, and scalable approach to performance optimization.\nIf you haven’t already, start using Baseline Profiles today and measure their impact on your app’s performance!\n","description":"Boosting Android App Performance with Baseline Profiles with real world example","id":9,"section":"posts","tags":["kotlin","architecture"],"title":"Boosting Android App Performance with Baseline Profiles","uri":"https://carrion.dev/en/posts/baseline-profiles/"},{"content":"Modularization in Gradle Projects with Kotlin: A Comprehensive Guide Introduction As projects grow in complexity, maintaining a monolithic codebase becomes challenging. Modularization is a software design technique that breaks down an application into smaller, independent modules, making the project more scalable, maintainable, and efficient.\nIn this guide, we’ll explore why modularization is essential, different types of modules, and best practices for setting up a modular Gradle project using Kotlin.\nWhy Modularization? Before implementing modularization, it’s important to understand its key benefits:\n Faster Build Times – Gradle compiles independent modules in parallel, reducing build times. Scalability – Easier to manage and extend large projects. Encapsulation – Each module has a well-defined responsibility, improving separation of concerns. Team Collaboration – Teams can work independently on different modules, reducing merge conflicts. Reusability – Common functionality can be extracted into reusable modules.  Example Scenario Imagine an Android app where all features and dependencies reside in a single app module. This setup leads to long build times, tightly coupled code, and difficulties in testing. With modularization, features and shared functionalities can be isolated into separate modules, improving efficiency.\nTypes of Modules in a Gradle Project ✅ Feature Modules Contain independent features of the app, such as:\n feature-auth (Authentication screens) feature-dashboard (Home screen, user data) Can be dynamically loaded using Dynamic Feature Modules in Android.  ✅ Library Modules Reusable components shared across the app, such as:\n ui-components (Custom buttons, toolbars) networking (API calls, Retrofit setup) analytics (Logging, Firebase events)  ✅ Core Modules Contains shared utilities, such as:\n core-utils (Common utilities, extensions)  Gradle Setup for Modularization After defining module types, configuring dependencies correctly is crucial.\nUsing api, implementation, and compileOnly  implementation – Dependency is only visible within the module. api – Dependency is exposed to other modules. compileOnly – Used for compile-time dependencies.  Example:\n1 2 3 4 5  // In feature-auth/build.gradle.kts dependencies { implementation(project(\u0026#34;:core-utils\u0026#34;)) // Only visible in this module  compileOnly(\u0026#34;androidx.annotation:annotation:1.3.0\u0026#34;) }   Dependency Management in Gradle Managing dependencies across multiple modules can be simplified using Version Catalogs, which is the recommended approach in modern Gradle projects.\n✅ Using Version Catalogs (libs.versions.toml) (Recommended) Gradle’s Version Catalogs allow defining dependencies in a .toml file, ensuring consistency and easy updates across modules. This method is now the preferred way to manage dependencies in Gradle.\nStep 1: Define Dependencies in libs.versions.toml Create or update the gradle/libs.versions.toml file:\n1 2 3 4 5 6 7  [versions] retrofit = \u0026#34;2.9.0\u0026#34; coroutines = \u0026#34;1.6.4\u0026#34; [libraries] retrofit = { module = \u0026#34;com.squareup.retrofit2:retrofit\u0026#34;, version.ref = \u0026#34;retrofit\u0026#34; } coroutines = { module = \u0026#34;org.jetbrains.kotlinx:kotlinx-coroutines-core\u0026#34;, version.ref = \u0026#34;coroutines\u0026#34; }   Step 2: Use Version Catalog in build.gradle.kts 1 2 3 4  dependencies { implementation(libs.retrofit) implementation(libs.coroutines) }   This approach provides:\n Centralized Dependency Management – All versions are stored in one place. Safer Updates – Easy bulk updates and compatibility checks. Better Maintainability – Reduces duplication across multiple build.gradle.kts files.  If your project is still using buildSrc, consider migrating to Version Catalogs, as Gradle actively recommends this approach.\nExample Modular Architecture in Kotlin Folder Structure of a Modular Project my-app/ │── app/ # Main application module │── core/ │ ├── core-utils/ # Common utilities │── features/ │ ├── feature-auth/ # Login, signup │ ├── feature-dashboard/ # Dashboard, home screen │── libraries/ │ ├── ui-components/ # Shared UI elements │ ├── networking/ # Retrofit setup, API client Dependency Flow  feature-auth → depends on core-utils and networking app → depends on all feature modules (feature-auth, feature-dashboard)  Best Practices for Modularization ✅ Avoid Cyclic Dependencies\n Feature modules should not depend on each other directly. Use event-based communication (e.g., LiveData, Flow).  ✅ Use Dependency Injection (DI)\n Libraries like Koin help manage dependencies.  ✅ Optimize Gradle Build Speed\n Enable Gradle’s configuration cache:  org.gradle.parallel=true org.gradle.caching=true Conclusion By implementing modularization in Gradle projects, you achieve:\n✔️ Faster build times\n✔️ Better maintainability\n✔️ Scalability for large teams\n✔️ Reusable components\nWould you like to explore a sample Kotlin project showcasing modularization? 🚀\n","description":"Modularization in Gradle Projects with Kotlin: A Comprehensive Guide","id":10,"section":"posts","tags":["kotlin","architecture"],"title":"Modularization in Gradle Projects with Kotlin","uri":"https://carrion.dev/en/posts/gradle-modularization/"},{"content":"Test-Driven Development (TDD) in Kotlin for Android Test-Driven Development (TDD) is a software development practice that emphasizes writing tests before implementing functionality. It follows a Red-Green-Refactor cycle: first, you write a failing test (Red), then implement just enough code to make it pass (Green), and finally, refactor the code while keeping the test green (Refactor). In this post, we\u0026rsquo;ll explore how to apply TDD in Kotlin for Android development using JUnit, MockK, and Coroutines with a real-world example.\nWhy Use TDD in Android Development?  Better Code Quality: Writing tests first ensures better design decisions and maintainability. Faster Debugging: Bugs are caught early before they become complex. Refactoring Confidence: Tests act as a safety net when modifying code. Improved Productivity: Although writing tests first might seem slower initially, it speeds up development in the long run.  Setting Up the Test Environment Before we begin, let\u0026rsquo;s add the necessary dependencies to our Gradle file:\n1 2 3 4  // Unit Testing testImplementation(\u0026#34;junit:junit:4.13.2\u0026#34;) testImplementation(\u0026#34;org.jetbrains.kotlinx:kotlinx-coroutines-test:1.10.1\u0026#34;) testImplementation(\u0026#34;io.mockk:mockk:1.13.16\u0026#34;)   Now, let\u0026rsquo;s create a real-world example demonstrating TDD.\nReal-World Example: Fetching Data in a UseCase We\u0026rsquo;ll implement a UseCase that fetches data from a Repository and runs it on the IO Dispatcher. We\u0026rsquo;ll follow the TDD approach.\nStep 1: Write a Failing Test (Red) First, let\u0026rsquo;s define a test for our FetchUserUseCase. This use case fetches user details from a repository.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  import io.mockk.* import kotlinx.coroutines.CoroutineDispatcher import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.ExperimentalCoroutinesApi import kotlinx.coroutines.test.* import kotlinx.coroutines.runBlocking import org.junit.Before import org.junit.Test import kotlin.test.assertEquals @ExperimentalCoroutinesApi class FetchUserUseCaseTest { private val repository: UserRepository = mockk() private lateinit var useCase: FetchUserUseCase private val testDispatcher = StandardTestDispatcher() @Before fun setup() { useCase = FetchUserUseCase(repository, testDispatcher) // Inject test dispatcher  } @Test fun `fetch user returns expected user`() = runTest { // Given  val expectedUser = User(id = 1, name = \u0026#34;John Doe\u0026#34;) coEvery { repository.getUser(1) } returns expectedUser // When  val result = useCase(1) // Then  assertEquals(expectedUser, result) coVerify { repository.getUser(1) } } }   Understanding Given-When-Then   Given – Set up the initial conditions or dependencies required for the test.\n1 2  val expectedUser = User(id = 1, name = \u0026#34;John Doe\u0026#34;) coEvery { repository.getUser(1) } returns expectedUser    This prepares a mock response for repository.getUser(1) so that it returns expectedUser.    When – Execute the actual function or use case being tested.\n1  val result = useCase(1)    This calls the FetchUserUseCase with a user ID of 1, triggering the behavior we want to test.    Then – Verify that the expected outcome matches the actual outcome.\n1 2  assertEquals(expectedUser, result) coVerify { repository.getUser(1) }    This checks that the function returned the expected user and that the repository’s getUser method was called.    Step 2: Implement Minimal Code to Pass the Test (Green) Now, let\u0026rsquo;s implement the FetchUserUseCase class.\n1 2 3 4 5 6 7 8 9 10 11 12 13  import kotlinx.coroutines.CoroutineDispatcher import kotlinx.coroutines.withContext class FetchUserUseCase( private val repository: UserRepository, private val dispatcher: CoroutineDispatcher = Dispatchers.IO // Injected dispatcher ) { suspend operator fun invoke(userId: Int): User { return withContext(dispatcher) { repository.getUser(userId) } } }   Step 3: Refactor Since our test is passing, we can clean up or improve our implementation if necessary. Here, the implementation is already clean, so no major refactoring is needed.\nUnderstanding Key Parts 1. Mocking with MockK We use MockK to mock our repository:\n1  coEvery { repository.getUser(1) } returns expectedUser   This simulates a function call returning a predefined value.\n2. Using Coroutines with Test Dispatchers We replace Dispatchers.IO with a Test Dispatcher to control coroutine execution.\n3. Verifying Function Calls We ensure that our repository function was called:\n1  coVerify { repository.getUser(1) }   This confirms our code behaves as expected.\nBest Practices for TDD in Kotlin  Write Small, Focused Tests: Each test should verify one thing. Use Mocks Wisely: Avoid over-mocking; only mock dependencies. Prefer Deterministic Tests: Avoid flaky or time-dependent tests. Leverage Coroutines Test Utilities: Use StandardTestDispatcher and runTest. Keep Tests Fast: Unit tests should run in milliseconds.  Conclusion TDD improves code quality and development efficiency. By writing tests first, we ensure reliable and maintainable code. In this post, we built a UseCase that fetches data from a repository while running on the IO Dispatcher, following TDD principles. With MockK and Coroutines, we created a robust testing setup.\nStart applying TDD in your Kotlin projects today and see the benefits firsthand!\n","description":"Test-Driven Development (TDD) in Kotlin for Android with real-world examples using JUnit, MockK, and Coroutines","id":11,"section":"posts","tags":["kotlin","architecture","TDD","testing"],"title":"Test-Driven Development (TDD) in Kotlin for Android","uri":"https://carrion.dev/en/posts/tdd-kotlin/"},{"content":"Clean Architecture in Kotlin \u0026amp; Android Introduction When building Android applications, maintaining scalability and readability is crucial. Without a clear architectural approach, projects can become difficult to maintain as they grow. This is where Clean Architecture, introduced by Uncle Bob (Robert C. Martin), becomes invaluable. It emphasizes separation of concerns, making code more modular, testable, and maintainable.\nUnderstanding Clean Architecture Clean Architecture is structured into three main layers, each with a specific role:\n Presentation Layer: Handles UI and user interactions. Domain Layer: Contains business logic, use cases, and repository interfaces. Data Layer: Implements repositories, manages API calls, and handles database operations.  The core principle of Clean Architecture is dependency direction—each layer should only depend on the layers closer to the core (domain). This ensures flexibility and scalability.\nProject Structure A Clean Architecture project in Kotlin typically follows this structure:\ncom.example.app │── presentation (ViewModels, UI, State) │── domain (UseCases, Repository Interfaces, Models) │── data (Repository Implementations, Data Sources, APIs, DB) Each layer should be in a separate module or package, ensuring proper separation of concerns.\nModularization To further enhance maintainability and scalability, consider structuring your project into separate Gradle modules. This ensures clear separation between different layers and promotes reusability.\nA modularized Clean Architecture project could follow this structure:\ncom.example.app │── app (Main application module) │── feature-user │ │── domain (UseCases, Repository Interfaces, Models) │ │── data (Repository Implementations, Data Sources, APIs, DB) │ │── presentation (UI and ViewModels for user features) │── core (Common utilities, networking, database helpers) Benefits of modularization:\n Faster build times due to isolated module compilation. Improved code encapsulation and separation of concerns. Easier feature development and maintenance. Better testability by allowing independent testing of modules.  Implementing Clean Architecture with Kotlin 1. Domain Layer (Core Business Logic) The domain layer defines the business logic and use cases. It does not depend on any framework or external library, making it the most stable part of the application.\nExample: Defining a Repository Interface 1 2 3  interface UserRepository { suspend fun getUserById(id: String): User }   Example: Use Case 1 2 3 4 5  class GetUserByIdUseCase(private val userRepository: UserRepository) { suspend operator fun invoke(id: String): User { return userRepository.getUserById(id) } }   2. Data Layer (Implementing Repositories and Data Sources) The data layer provides concrete implementations of the repository interfaces. It interacts with APIs, databases, or local storage.\nExample: Data Source 1 2 3 4 5 6 7 8 9  interface UserRemoteDataSource { suspend fun fetchUserById(id: String): User } class UserRemoteDataSourceImpl(private val api: UserApi) : UserRemoteDataSource { override suspend fun fetchUserById(id: String): User { return api.fetchUserById(id) } }   Example: Repository Implementation 1 2 3 4 5  class UserRepositoryImpl(private val remoteDataSource: UserRemoteDataSource) : UserRepository { override suspend fun getUserById(id: String): User { return remoteDataSource.fetchUserById(id) } }   3. Presentation Layer (UI \u0026amp; ViewModel) The presentation layer is responsible for UI logic and state management. It depends on the domain layer but does not interact directly with the data layer.\nExample: ViewModel 1 2 3 4 5 6 7 8 9 10 11  class UserViewModel(private val getUserByIdUseCase: GetUserByIdUseCase) : ViewModel() { private val _user = MutableStateFlow\u0026lt;User?\u0026gt;(null) val user: StateFlow\u0026lt;User?\u0026gt; get() = _user.asStateFlow() fun loadUser(id: String) { viewModelScope.launch { _user.value = getUserByIdUseCase(id) } } }   Best Practices  Keep the Domain Layer Pure: It should have no dependencies on Android frameworks. Use Dependency Injection: Koin helps in managing dependencies cleanly. Follow the Dependency Rule: The inner layers should not depend on the outer layers. Separate Repository Interfaces and Implementations: Interfaces go in the domain layer, and implementations stay in the data layer. Use Data Sources: Encapsulate API and database calls in dedicated data source classes. Modularize Your Code: Use Gradle modules to separate concerns and improve build times.  Conclusion Clean Architecture provides a robust way to structure Android applications. By separating concerns and enforcing clear dependencies, it makes code more testable and scalable. Using Koin for dependency injection further enhances maintainability. Adopting this architecture, along with modularization, will result in a more modular and resilient codebase for your Kotlin projects.\n","description":"Clean Architecture in Kotlin \u0026 Android with practical examples","id":12,"section":"posts","tags":["kotlin","architecture"],"title":"Clean Architecture in Kotlin \u0026 Android","uri":"https://carrion.dev/en/posts/clean-architecture/"},{"content":"Exploring App Architectures in Kotlin: MVC, MVP, MVVM, and MVI Introduction In modern app development, choosing the right architecture is essential for creating maintainable and scalable applications. Architectures define how your codebase is organized and how different components interact. In this post, we’ll explore four popular app architectures: Model-View-Controller (MVC), Model-View-Presenter (MVP), Model-View-ViewModel (MVVM), and Model-View-Intent (MVI). We’ll look at their structure, pros, cons, and practical examples in Kotlin.\n1. Model-View-Controller (MVC) Definition:\nMVC divides an app into three components:\n Model: Manages the data and business logic. View: Displays data to the user, directly accessing the Model for updates. Controller: Handles user input and updates the Model.  Pros:\n Simple to implement and understand. Effective for small apps or prototypes.  Cons:\n Tight coupling between View and Model. Limited separation of concerns; scaling can be challenging.  Kotlin Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // Model data class User(var name: String, var age: Int) // View class UserView { fun displayUser(user: User) { println(\u0026#34;Name: ${user.name}, Age: ${user.age}\u0026#34;) } } // Controller class UserController(private val model: User, private val view: UserView) { fun handleUserInput() { println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; model.name = newName // Directly updates the model  view.displayUser(model) } } fun main() { val user = User(\u0026#34;Alice\u0026#34;, 30) val view = UserView() val controller = UserController(user, view) view.displayUser(user) controller.handleUserInput() }   2. Model-View-Presenter (MVP) Definition:\nIn MVP, the Presenter mediates between the Model and View. Unlike MVC, the View is passive and delegates all interaction logic to the Presenter, which retrieves data from the Model and updates the View.\nPros:\n Better separation of concerns compared to MVC. Easier to test since the Presenter handles all logic.  Cons:\n Presenter classes can become large (\u0026ldquo;God classes\u0026rdquo;). Managing lifecycle events can be challenging.  Kotlin Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // Model data class User(val name: String, val age: Int) // View Interface interface UserView { fun displayUser(name: String, age: Int) } // Presenter class UserPresenter(private val view: UserView) { private var user = User(\u0026#34;Bob\u0026#34;, 25) fun loadUser() { view.displayUser(user.name, user.age) } fun updateUser() { println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; user = user.copy(name = newName) view.displayUser(user.name, user.age) } } // View Implementation class ConsoleUserView : UserView { override fun displayUser(name: String, age: Int) { println(\u0026#34;Name: $name, Age: $age\u0026#34;) } } fun main() { val view = ConsoleUserView() val presenter = UserPresenter(view) presenter.loadUser() presenter.updateUser() }   3. Model-View-ViewModel (MVVM) Definition:\nMVVM promotes a reactive approach. The ViewModel provides data to the View and reacts to changes in the Model. It often uses LiveData or Kotlin’s StateFlow.\nPros:\n Encourages clean separation of concerns. Excellent for reactive programming using coroutines or flows.  Cons:\n Requires familiarity with reactive paradigms. Data binding or state management can add complexity.  Kotlin Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // Model data class User(val name: String, val age: Int) // ViewModel class UserViewModel { private val _user = MutableStateFlow(User(\u0026#34;Charlie\u0026#34;, 28)) val user = _user.asStateFlow() fun updateUser(name: String) { _user.value = _user.value.copy(name = name) } } // View class UserView(private val viewModel: UserViewModel) { fun render() { viewModel.user.collect { user -\u0026gt; println(\u0026#34;Name: ${user.name}, Age: ${user.age}\u0026#34;) } } fun getUserInput(): String { println(\u0026#34;Enter new name for the user:\u0026#34;) return readLine() ?: \u0026#34;\u0026#34; } fun updateUserName() { val newName = getUserInput() viewModel.updateUser(newName) } } fun main() = runBlocking { val viewModel = UserViewModel() val view = UserView(viewModel) view.render() view.updateUserName() }   4. Model-View-Intent (MVI) Definition:\nMVI uses unidirectional data flow. The View sends user intents, the Model processes them, and the state is updated and rendered by the View.\nPros:\n Predictable state management. Encourages immutability and clear data flow.  Cons:\n Steeper learning curve. Overhead for simple apps.  Kotlin Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  // Model data class UserState(val name: String = \u0026#34;\u0026#34;, val age: Int = 0) // Intent sealed class UserIntent { object LoadUser : UserIntent() data class UpdateUser(val name: String) : UserIntent() } // Reducer fun userReducer(currentState: UserState, intent: UserIntent): UserState { return when (intent) { is UserIntent.LoadUser -\u0026gt; UserState(name = \u0026#34;Dave\u0026#34;, age = 40) is UserIntent.UpdateUser -\u0026gt; currentState.copy(name = intent.name) } } // ViewModel class UserViewModel { private val _state = MutableStateFlow(UserState()) val state: StateFlow\u0026lt;UserState\u0026gt; = _state fun processIntent(intent: UserIntent) { _state.update { currentState -\u0026gt; userReducer(currentState, intent) } } } // View class UserView(private val viewModel: UserViewModel) { fun render() { viewModel.state.collect { state -\u0026gt; println(\u0026#34;Name: ${state.name}, Age: ${state.age}\u0026#34;) } } fun sendIntent(intent: UserIntent) { viewModel.processIntent(intent) } } fun main() = runBlocking { val viewModel = UserViewModel() val view = UserView(viewModel) view.sendIntent(UserIntent.LoadUser) view.render() println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; view.sendIntent(UserIntent.UpdateUser(newName)) }   Conclusion Each architecture has its strengths and trade-offs:\n MVC: Best for small, simple apps. MVP: Balances structure and simplicity. MVVM: Ideal for reactive programming. MVI: Great for predictable and scalable state management.  Consider your project’s complexity and requirements when choosing an architecture. Which one do you prefer?\n","description":"Exploring App Architectures in Kotlin: MVC, MVP, MVVM, and MVI","id":13,"section":"posts","tags":["kotlin","architecture"],"title":"Exploring App Architectures in Kotlin","uri":"https://carrion.dev/en/posts/app-architecture/"},{"content":"Exploring More Design Patterns in Kotlin: Part 3 Design Patterns Series  Part 1 Part 2 Part 3  In this third installment, we’ll cover Memento, Command, Visitor, Chain of Responsibility, and Mediator patterns. These patterns address construction, behavioral, and structural challenges, showcasing Kotlin\u0026rsquo;s expressive syntax and modern features.\n1. Memento Pattern The Memento Pattern captures and restores an object\u0026rsquo;s state without exposing its internal details.\nWhen to Use  To implement undo/redo functionality.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  class Editor { var content: String = \u0026#34;\u0026#34; fun createMemento(): Memento = Memento(content) fun restore(memento: Memento) { content = memento.state } data class Memento(val state: String) } class History { private val mementos = mutableListOf\u0026lt;Editor.Memento\u0026gt;() fun save(memento: Editor.Memento) { mementos.add(memento) } fun pop(): Editor.Memento? { if (mementos.isNotEmpty()) { return mementos.removeAt(mementos.lastIndex) } return null } } fun main() { val editor = Editor() val history = History() editor.content = \u0026#34;First Version\u0026#34; history.push(editor.save()) editor.content = \u0026#34;Second Version\u0026#34; history.push(editor.save()) editor.content = \u0026#34;Third Version\u0026#34; println(\u0026#34;Current Content: ${editor.content}\u0026#34;) editor.restore(history.pop()!!) println(\u0026#34;Restored Content: ${editor.content}\u0026#34;) editor.restore(history.pop()!!) println(\u0026#34;Restored Content: ${editor.content}\u0026#34;) }   Why Kotlin? Kotlin’s concise syntax makes state capture and restoration easy to implement.\n2. Command Pattern The Command Pattern encapsulates a request as an object, allowing for parameterization and queuing.\nWhen to Use  To implement undoable operations or command queues.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  interface Command { fun execute() } class Light { fun on() = println(\u0026#34;Light is ON\u0026#34;) fun off() = println(\u0026#34;Light is OFF\u0026#34;) } class LightOnCommand(private val light: Light) : Command { override fun execute() = light.on() } class LightOffCommand(private val light: Light) : Command { override fun execute() = light.off() } fun main() { val light = Light() val commands = listOf(LightOnCommand(light), LightOffCommand(light)) commands.forEach { it.execute() } }   Why Kotlin? Kotlin’s functional approach can further simplify command execution.\n3. Visitor Pattern The Visitor Pattern separates an algorithm from the object structure it operates on by moving the algorithm into a visitor object.\nWhen to Use  When you need to perform operations across a set of objects with varying types.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  interface Shape { fun accept(visitor: ShapeVisitor) } class Circle(val radius: Double) : Shape { override fun accept(visitor: ShapeVisitor) { visitor.visit(this) } } class Rectangle(val width: Double, val height: Double) : Shape { override fun accept(visitor: ShapeVisitor) { visitor.visit(this) } } fun interface ShapeVisitor { fun visit(shape: Shape) } fun main() { val shapes: List\u0026lt;Shape\u0026gt; = listOf(Circle(5.0), Rectangle(4.0, 6.0)) val visitor = ShapeVisitor { shape -\u0026gt; when (shape) { is Circle -\u0026gt; println(\u0026#34;Circle with radius ${shape.radius}\u0026#34;) is Rectangle -\u0026gt; println(\u0026#34;Rectangle with width ${shape.width}and height ${shape.height}\u0026#34;) } } shapes.forEach { it.accept(visitor) } }   Why Kotlin? Kotlin’s fun interface and sealed classes streamline the visitor implementation.\n4. Chain of Responsibility Pattern The Chain of Responsibility Pattern passes a request along a chain of handlers until one processes it.\nWhen to Use  When multiple objects can handle a request, and the handler isn’t determined until runtime.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  interface Handler { fun handle(request: String): Boolean } class AuthHandler(private val next: Handler?) : Handler { override fun handle(request: String): Boolean { println(\u0026#34;AuthHandler processing...\u0026#34;) return next?.handle(request) ?: true } } class LoggingHandler(private val next: Handler?) : Handler { override fun handle(request: String): Boolean { println(\u0026#34;LoggingHandler processing...\u0026#34;) return next?.handle(request) ?: true } } fun main() { val chain = AuthHandler(LoggingHandler(null)) chain.handle(\u0026#34;Request\u0026#34;) }   Why Kotlin? Kotlin’s nullable types and concise delegation simplify chaining handlers.\n5. Mediator Pattern The Mediator Pattern centralizes complex communication between multiple objects by having them communicate through a mediator.\nWhen to Use  When objects interact in complex ways, leading to tangled dependencies.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class Mediator { private val colleagues = mutableListOf\u0026lt;Colleague\u0026gt;() fun addColleague(colleague: Colleague) { colleagues.add(colleague) } fun broadcast(sender: Colleague, message: String) { colleagues.filter { it != sender } .forEach { it.receive(message) } } } interface Colleague { fun send(message: String) fun receive(message: String) } class ConcreteColleague(private val mediator: Mediator) : Colleague { override fun send(message: String) { println(\u0026#34;Sending message: $message\u0026#34;) mediator.broadcast(this, message) } override fun receive(message: String) { println(\u0026#34;Received message: $message\u0026#34;) } } fun main() { val mediator = Mediator() val colleague1 = ConcreteColleague(mediator) val colleague2 = ConcreteColleague(mediator) mediator.addColleague(colleague1) mediator.addColleague(colleague2) colleague1.send(\u0026#34;Hello from Colleague 1\u0026#34;) }   Why Kotlin? Kotlin’s first-class functions and collections simplify broadcasting and interaction.\nConclusion These patterns—Memento, Command, Visitor, Chain of Responsibility, and Mediator—demonstrate Kotlin\u0026rsquo;s ability to enhance classic design patterns with modern features.\nWhich of these patterns do you find most interesting? Let me know! 🚀\n","description":"Kotlin Design Patterns - Part 3","id":14,"section":"posts","tags":["kotlin","design-patterns","architecture"],"title":"Kotlin Design Patterns - Part 3","uri":"https://carrion.dev/en/posts/design-patterns-3/"},{"content":"Understanding SOLID Principles with Kotlin Examples The SOLID principles are a set of design principles that make software designs more understandable, flexible, and maintainable. Introduced by Robert C. Martin, these principles are a cornerstone of object-oriented programming and are especially relevant when building complex systems. In this blog post, we’ll explore each principle with examples written in Kotlin, a language that brings modern syntax and powerful features to the table.\n1. Single Responsibility Principle (SRP) A class should have one, and only one, reason to change.\nThis principle ensures that a class has a single responsibility, making it easier to maintain and less prone to bugs.\nBreaking SRP:\n1 2 3 4 5 6 7 8 9 10 11  class ReportManager { fun generateReport(data: String): String { // Logic to generate report  return \u0026#34;Report: $data\u0026#34; } fun saveReport(report: String) { // Logic to save report  println(\u0026#34;Report saved: $report\u0026#34;) } }   In this example, the ReportManager class violates SRP because it has two responsibilities: generating and saving reports. Any change in report generation logic or saving logic would require modifying the same class.\nFixing SRP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class ReportGenerator { fun generateReport(data: String): String { // Logic to generate report  return \u0026#34;Report: $data\u0026#34; } } class ReportSaver { fun saveReport(report: String) { // Logic to save report  println(\u0026#34;Report saved: $report\u0026#34;) } } fun main() { val generator = ReportGenerator() val saver = ReportSaver() val report = generator.generateReport(\u0026#34;Sales Data\u0026#34;) saver.saveReport(report) }   By separating responsibilities, we make each class focused and easier to test independently.\n2. Open/Closed Principle (OCP) Software entities should be open for extension but closed for modification.\nYou can add new functionality by extending classes without changing the existing code.\nBreaking OCP:\n1 2 3 4 5 6 7 8 9  class Discount { fun calculate(price: Double, type: String): Double { return when (type) { \u0026#34;none\u0026#34; -\u0026gt; price \u0026#34;percentage\u0026#34; -\u0026gt; price * 0.9 else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unknown discount type\u0026#34;) } } }   Here, adding a new discount type requires modifying the calculate method, which violates OCP.\nFixing OCP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  interface DiscountStrategy { fun calculate(price: Double): Double } class NoDiscount : DiscountStrategy { override fun calculate(price: Double): Double = price } class PercentageDiscount(private val percentage: Double) : DiscountStrategy { override fun calculate(price: Double): Double = price * (1 - percentage / 100) } class DiscountCalculator(private val strategy: DiscountStrategy) { fun calculate(price: Double): Double = strategy.calculate(price) } fun main() { val noDiscount = DiscountCalculator(NoDiscount()) println(\u0026#34;Price after no discount: ${noDiscount.calculate(100.0)}\u0026#34;) val percentageDiscount = DiscountCalculator(PercentageDiscount(10.0)) println(\u0026#34;Price after 10% discount: ${percentageDiscount.calculate(100.0)}\u0026#34;) }   By using interfaces and composition, we achieve a design that is open to extension (new discount strategies) and closed to modification (no changes to existing classes).\n3. Liskov Substitution Principle (LSP) Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.\nThis principle ensures that derived classes honor the expectations set by their base class.\nBreaking LSP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  open class Bird { open fun fly() { println(\u0026#34;Flying\u0026#34;) } } class Sparrow : Bird() class Penguin : Bird() { override fun fly() { throw UnsupportedOperationException(\u0026#34;Penguins can\u0026#39;t fly\u0026#34;) } } fun main() { val birds: List\u0026lt;Bird\u0026gt; = listOf(Sparrow(), Penguin()) for (bird in birds) { bird.fly() // This will fail for Penguin  } }   In this example, Penguin violates LSP because it cannot fulfill the contract of Bird. A better approach is to refactor the design:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  interface Flyable { fun fly() } class Sparrow : Flyable { override fun fly() { println(\u0026#34;Flying\u0026#34;) } } class Penguin { fun swim() { println(\u0026#34;Swimming\u0026#34;) } }   Now, behaviors are segregated, and LSP is upheld.\n4. Interface Segregation Principle (ISP) Clients should not be forced to depend on methods they do not use.\nThis principle promotes creating specific interfaces rather than a bloated one.\nBreaking ISP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Machine { fun print() fun scan() fun fax() } class OldPrinter : Machine { override fun print() { println(\u0026#34;Printing\u0026#34;) } override fun scan() { throw UnsupportedOperationException(\u0026#34;Scan not supported\u0026#34;) } override fun fax() { throw UnsupportedOperationException(\u0026#34;Fax not supported\u0026#34;) } }   This implementation forces OldPrinter to implement methods it doesn’t support, violating ISP.\nFixing ISP:\n1 2 3 4 5 6 7 8 9 10 11 12 13  interface Printer { fun print() } interface Scanner { fun scan() } class SimplePrinter : Printer { override fun print() { println(\u0026#34;Printing\u0026#34;) } }   By splitting the functionalities into separate interfaces, we allow devices to implement only what they need.\n5. Dependency Inversion Principle (DIP) High-level modules should not depend on low-level modules. Both should depend on abstractions.\nThis principle reduces the coupling between high-level and low-level modules by introducing abstractions.\nBreaking DIP:\n1 2 3 4 5 6 7 8 9 10 11 12 13  class EmailService { fun sendEmail(message: String) { println(\u0026#34;Sending Email: $message\u0026#34;) } } class NotificationSender { private val emailService = EmailService() fun notifyUser(message: String) { emailService.sendEmail(message) } }   Here, NotificationSender is tightly coupled to EmailService, making it difficult to switch to a different notification service.\nFixing DIP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  interface NotificationService { fun sendNotification(message: String) } class EmailService : NotificationService { override fun sendNotification(message: String) { println(\u0026#34;Sending Email: $message\u0026#34;) } } class SMSService : NotificationService { override fun sendNotification(message: String) { println(\u0026#34;Sending SMS: $message\u0026#34;) } } class NotificationSender(private val service: NotificationService) { fun notifyUser(message: String) { service.sendNotification(message) } } fun main() { val emailSender = NotificationSender(EmailService()) emailSender.notifyUser(\u0026#34;Hello via Email\u0026#34;) val smsSender = NotificationSender(SMSService()) smsSender.notifyUser(\u0026#34;Hello via SMS\u0026#34;) }   Here, NotificationSender depends on the NotificationService abstraction, making it flexible to work with any notification type.\nConclusion The SOLID principles form the foundation for building robust and scalable software. Kotlin, with its expressive syntax and modern features, allows developers to implement these principles elegantly. By adhering to these principles, you can create code that is easier to maintain, extend, and adapt to changing requirements.\n","description":"SOLID Principles explained with Kotlin Examples.","id":15,"section":"posts","tags":["kotlin","solid","architecture"],"title":"Understanding SOLID Principles with Kotlin Examples","uri":"https://carrion.dev/en/posts/solid-kotlin/"},{"content":"Exploring Design Patterns in Kotlin: Part 2 Design Patterns Series  Part 1 Part 2 Part 3  After the overwhelming response to our first post on Kotlin design patterns, we’re back with more! In this second part, we’ll dive into Prototype, Composite, Proxy, Observer, and Strategy patterns. These patterns solve a variety of design challenges and demonstrate Kotlin’s expressive capabilities.\n1. Prototype Pattern The Prototype Pattern is used to create new objects by copying an existing object, ensuring efficient object creation.\nWhen to Use  When creating a new instance is costly or complex. To avoid creating instances of subclasses repeatedly.  Kotlin Implementation Using Kotlin’s data class and its built-in copy function simplifies this pattern.\n1 2 3 4 5 6 7 8 9  data class Document(var title: String, var content: String, var author: String) fun main() { val original = Document(\u0026#34;Design Patterns\u0026#34;, \u0026#34;Content about patterns\u0026#34;, \u0026#34;John Doe\u0026#34;) val copy = original.copy(title = \u0026#34;Prototype Pattern\u0026#34;) println(\u0026#34;Original: $original\u0026#34;) println(\u0026#34;Copy: $copy\u0026#34;) }   Why Kotlin? Kotlin’s data classes inherently support copying with minimal boilerplate, making the Prototype Pattern a breeze to implement.\n2. Composite Pattern The Composite Pattern is used to treat individual objects and groups of objects uniformly.\nWhen to Use  When you have a tree structure and want to manipulate it in a consistent way.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  interface Logger { fun log(message: String) } class ConsoleLogger : Logger { override fun log(message: String) { println(message) } } class FileLogger(private val filePath: String) : Logger { override fun log(message: String) { // Implementation for writing logs to a file  } } class RootLogger(private val loggers: List\u0026lt;Logger\u0026gt;) : Logger { override fun log(message: String) { loggers.forEach { it.log(message) } } } fun main() { val consoleLogger = ConsoleLogger() val fileLogger = FileLogger(\u0026#34;/path/to/log.txt\u0026#34;) val rootLogger = RootLogger(listOf(consoleLogger, fileLogger)) rootLogger.log(\u0026#34;Composite Pattern Example\u0026#34;) }   3. Proxy Pattern The Proxy Pattern provides a surrogate or placeholder to control access to another object.\nWhen to Use  To control access to a resource. To add functionality without modifying the actual object.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Service { fun fetchData(): String } class RealService : Service { override fun fetchData() = \u0026#34;Data from Real Service\u0026#34; } class ProxyService(private val realService: RealService) : Service { override fun fetchData(): String { println(\u0026#34;Proxy: Checking access before delegating.\u0026#34;) return realService.fetchData() } } fun main() { val proxy = ProxyService(RealService()) println(proxy.fetchData()) }   4. Observer Pattern The Observer Pattern defines a one-to-many dependency, so when one object changes state, all its dependents are notified.\nWhen to Use  For event-driven systems. When multiple components need to react to state changes.  Kotlin Implementation Using Kotlin\u0026rsquo;s fun interface makes defining listeners more concise.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  fun interface StateChangeListener { fun onStateChanged(oldState: String, newState: String) } class Subject { private val listeners = mutableListOf\u0026lt;StateChangeListener\u0026gt;() var state: String by Delegates.observable(\u0026#34;Initial State\u0026#34;) { _, old, new -\u0026gt; listeners.forEach { it.onStateChanged(old, new) } } fun addListener(listener: StateChangeListener) { listeners.add(listener) } } fun main() { val subject = Subject() subject.addListener { oldState, newState -\u0026gt; println(\u0026#34;Listener 1: State changed from \u0026#39;$oldState\u0026#39; to \u0026#39;$newState\u0026#39;\u0026#34;) } subject.addListener { oldState, newState -\u0026gt; println(\u0026#34;Listener 2: State changed from \u0026#39;$oldState\u0026#39; to \u0026#39;$newState\u0026#39;\u0026#34;) } subject.state = \u0026#34;State 1\u0026#34; subject.state = \u0026#34;State 2\u0026#34; }   Why Kotlin? Using fun interface simplifies the implementation of single-method interfaces and reduces boilerplate for listeners. Additionally, Kotlin\u0026rsquo;s Delegates.observable makes observing state changes straightforward and powerful, further enhancing the implementation of the Observer Pattern.\n5. Strategy Pattern The Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable.\nWhen to Use  When you need multiple algorithms for a specific task. To avoid hardcoding algorithm logic.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  interface PaymentStrategy { fun pay(amount: Double) } class CreditCardPayment : PaymentStrategy { override fun pay(amount: Double) = println(\u0026#34;Paid $$amountusing Credit Card.\u0026#34;) } class PayPalPayment : PaymentStrategy { override fun pay(amount: Double) = println(\u0026#34;Paid $$amountusing PayPal.\u0026#34;) } class PaymentContext(private var strategy: PaymentStrategy) { fun setStrategy(strategy: PaymentStrategy) { this.strategy = strategy } fun executePayment(amount: Double) = strategy.pay(amount) } fun main() { val context = PaymentContext(CreditCardPayment()) context.executePayment(100.0) context.setStrategy(PayPalPayment()) context.executePayment(200.0) }   Conclusion With Kotlin, design patterns like Prototype, Composite, Proxy, Observer, and Strategy become more intuitive and powerful. These patterns are not just tools—they\u0026rsquo;re stepping stones to cleaner and more maintainable code.\n","description":"Kotlin Design Patterns - Part 2","id":16,"section":"posts","tags":["kotlin","design-patterns","architecture"],"title":"Kotlin Design Patterns - Part 2","uri":"https://carrion.dev/en/posts/design-patterns-2/"},{"content":"Using Koin in Compose Multiplatform Dependency injection is a must-have for scalable applications, and Koin makes it straightforward, even in Compose Multiplatform projects. With the new KoinApplication composable function, you can initialize Koin directly from commonMain code, reducing boilerplate while maintaining platform-specific flexibility. Let’s walk through an example.\nProject Setup Start by creating a Compose Multiplatform project using the KMP Wizard, selecting Android, iOS, Desktop, and Web targets. For this example, we won’t include a server target.\nAdding Dependencies Use Gradle’s version catalog to include the necessary Koin dependencies in libs.versions.toml:\n1 2 3 4 5 6 7 8 9  [versions] koin-bom = \u0026#34;4.1.0-Beta1\u0026#34; [libraries] koin-bom = { module = \u0026#34;io.insert-koin:koin-bom\u0026#34;, version.ref = \u0026#34;koin-bom\u0026#34; } koin-core = { module = \u0026#34;io.insert-koin:koin-core\u0026#34; } koin-android = { module = \u0026#34;io.insert-koin:koin-android\u0026#34; } koin-compose = { module = \u0026#34;io.insert-koin:koin-compose\u0026#34; } koin-compose-viewModel = { module = \u0026#34;io.insert-koin:koin-compose-viewmodel\u0026#34; }   Defining Koin Modules We’ll create two Koin modules: appModule and platformModule. The platformModule defines platform-specific dependencies.\nShared Code Modules 1 2 3 4 5 6 7 8 9 10 11 12  val appModule = module { viewModelOf(::MainViewModel) factoryOf(::GetJokeUseCase) singleOf(::DefaultJokeRepository) bind JokeRepository::class singleOf(::JokeJsonDataSource) bind JokeDataSource::class single { Json { ignoreUnknownKeys = true } } } val Module.localPreferencesDefinition get() = singleOf(::InMemoryLocalPreferences) bind LocalPreferences::class expect val platformModule: Module   Platform-Specific Modules For Android we will use an implementation to the LocalPreferences interface that depends on Android Context so we need a different module declaration:\n1 2 3 4  actual val platformModule: Module get() = module { singleOf(::AndroidPreferences) bind LocalPreferences::class }   For iOS, Desktop, and Web, we reuse the localPreferencesDefinition:\n1 2 3 4  actual val platformModule: Module get() = module { localPreferencesDefinition }   Configuring the App In App.kt, we’ll use the KoinApplication composable function to initialize Koin. Adding KoinAppDeclaration as optional parameter and default to null.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Composable @Preview fun App(koinAppDeclaration: KoinAppDeclaration? = null) { KoinApplication( application = { koinAppDeclaration?.invoke(this) modules(appModule, platformModule) } ) { MaterialTheme { MainScreen() } } }   On Android, we pass a lambda to provide the context and enable logging:\n1 2 3 4 5 6 7 8 9 10 11  class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { App { androidLogger(Level.DEBUG) androidContext(this@MainActivity) } } } }   This flexibility ensures platform-specific setups, like injecting the Android context, without affecting other targets.\nRun the app Run the app on each platform. You can test that all is working fine and each platform gets the configuration needed to run.\nConclusion The new KoinApplication composable simplifies dependency injection in Compose Multiplatform by allowing shared initialization with platform-specific tweaks. This approach reduces boilerplate and enhances code reusability across targets.\nCheck out the complete example on GitHub.\nAlso if you need more info about the different options to declare dependencies on Koin you can refer to a post I made on LinkedIn: Koin DSL\n","description":"Using Koin in Compose Multiplatform from common code with the possibility of configuring each platform.","id":17,"section":"posts","tags":["kotlin","multiplatform","cmp","compose","koin"],"title":"Using Koin in Compose Multiplatform","uri":"https://carrion.dev/en/posts/koin-cmp/"},{"content":"Exploring Design Patterns in Kotlin - Part 1 Design Patterns Series  Part 1 Part 2 Part 3  Design patterns are proven solutions to common problems in software design. With Kotlin’s expressive syntax and modern features, implementing these patterns often becomes cleaner and more concise. In this post, we’ll explore Singleton, Factory Method, Builder, Adapter and Decorator patterns, delving into their purpose, use cases, and Kotlin implementations.\n1. Singleton Pattern The Singleton Pattern ensures that a class has only one instance and provides a global access point to it.\nWhen to Use  Managing shared resources like database connections, logging, or configuration settings.  Kotlin Implementation Kotlin’s object keyword provides a straightforward way to create a Singleton.\n1 2 3 4 5  object DatabaseConnection { fun connect() { println(\u0026#34;Connecting to database...\u0026#34;) } }   Usage 1 2 3  fun main() { DatabaseConnection.connect() }   Advantages in Kotlin  Thread-safe by default. Requires minimal boilerplate compared to traditional implementations in other languages.  2. Factory Method Pattern The Factory Method Pattern delegates the creation of objects to subclasses or helper functions, providing flexibility in object instantiation.\nWhen to Use  When creating objects involves logic or complexity. To decouple object creation from client code.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Shape { fun draw() } class Circle : Shape { override fun draw() = println(\u0026#34;Drawing a Circle\u0026#34;) } class Rectangle : Shape { override fun draw() = println(\u0026#34;Drawing a Rectangle\u0026#34;) } object ShapeFactory { fun createShape(type: String): Shape = when (type) { \u0026#34;Circle\u0026#34; -\u0026gt; Circle() \u0026#34;Rectangle\u0026#34; -\u0026gt; Rectangle() else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unknown shape type\u0026#34;) } }   Usage 1 2 3 4  fun main() { val shape = ShapeFactory.createShape(\u0026#34;Circle\u0026#34;) shape.draw() }   3. Builder Pattern The Builder Pattern is used to construct complex objects step by step. It’s especially useful when an object has many optional parameters or configurations.\nWhen to Use  To avoid constructors with numerous parameters. When the construction process is complex or involves multiple steps.  Kotlin Implementation Kotlin’s apply and DSL capabilities simplify the Builder Pattern.\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Car(val make: String, val model: String, val year: Int) { class Builder { private var make = \u0026#34;\u0026#34; private var model = \u0026#34;\u0026#34; private var year = 0 fun make(make: String) = apply { this.make = make } fun model(model: String) = apply { this.model = model } fun year(year: Int) = apply { this.year = year } fun build() = Car(make, model, year) } }   Usage 1 2 3 4 5 6 7 8 9  fun main() { val car = Car.Builder() .make(\u0026#34;Toyota\u0026#34;) .model(\u0026#34;Corolla\u0026#34;) .year(2022) .build() println(\u0026#34;${car.make}${car.model}, ${car.year}\u0026#34;) }   Why Kotlin? Chaining methods with apply allows a concise and expressive syntax for constructing objects.\n4. Adapter Pattern The Adapter Pattern is used to bridge the gap between incompatible interfaces by translating one interface to another.\nWhen to Use  Integrating with legacy code or external libraries. When two systems or components need to work together but have incompatible interfaces.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // Existing integer provider interface interface OldProvider { fun provide(): Int } class RandomIntProvider : OldProvider { override fun provide(): Int = (1..100).random() } // Target string provider interface interface NewProvider { fun provide(): String } // Adapter class class OldToNewProviderAdapter(private val intProvider: OldProvider) : NewProvider { override fun provide(): String = \u0026#34;Provided number: ${intProvider.provide()}\u0026#34; }   Usage 1 2 3 4 5 6  fun main() { val intProvider = RandomIntProvider() val stringProvider: NewProvider = OldToNewProviderAdapter(intProvider) println(stringProvider.provideString()) }   Why Kotlin? Kotlin’s primary constructors and concise class syntax simplify the implementation of wrapper classes.\n5. Decorator Pattern The Decorator Pattern dynamically adds behavior to objects without altering their structure.\nWhen to Use  To extend functionality of a class at runtime. When subclassing would lead to a bloated hierarchy.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14  interface Coffee { fun cost(): Double fun description(): String } class SimpleCoffee : Coffee { override fun cost() = 5.0 override fun description() = \u0026#34;Simple Coffee\u0026#34; } class MilkDecorator(private val coffee: Coffee) : Coffee { override fun cost() = coffee.cost() + 1.5 override fun description() = coffee.description() + \u0026#34;, Milk\u0026#34; }   Usage 1 2 3 4 5 6  fun main() { val coffee = SimpleCoffee() val coffeeWithMilk = MilkDecorator(coffee) println(\u0026#34;${coffeeWithMilk.description()}costs \\$${coffeeWithMilk.cost()}\u0026#34;) }   Conclusion Kotlin’s modern features like object, when, and apply make implementing traditional design patterns easier and more expressive. These patterns not only solve common design challenges but also demonstrate how Kotlin enhances their implementation.\nAre there other patterns you’d like me to cover in future posts?\n","description":"Kotlin Design Patterns - Part 1","id":18,"section":"posts","tags":["kotlin","design-patterns","architecture"],"title":"Kotlin Design Patterns - Part 1","uri":"https://carrion.dev/en/posts/design-patterns-1/"},{"content":"A Deep Dive into Kotlin Symbol Processing (KSP) with Practical Examples Kotlin Symbol Processing (KSP) is a powerful tool introduced to streamline annotation processing in Kotlin. Compared to kapt (Kotlin Annotation Processing Tool), KSP is faster, offers better integration with Kotlin, and reduces build times significantly. In this post, we’ll explore the fundamentals of KSP, discuss how it works, and demonstrate its use with popular libraries like Koin and Room.\nWhat is KSP? KSP is a lightweight and efficient API for processing Kotlin source code. It allows you to build annotation processors that work directly with Kotlin\u0026rsquo;s syntax tree rather than relying on Java-based tools. This makes it a perfect fit for Kotlin-first projects.\nBenefits of KSP:  Speed: Processes Kotlin code faster than kapt. Kotlin-First: Works directly with Kotlin language constructs, avoiding Java-based abstractions. Lightweight: Reduces boilerplate and integrates seamlessly with Gradle. Compatibility: Many popular libraries now support KSP natively.  Setting Up KSP in Your Project Add the KSP plugin to your project:\nGradle Configuration 1 2 3 4 5 6 7 8 9 10 11 12 13  plugins { kotlin(\u0026#34;jvm\u0026#34;) version \u0026#34;\u0026lt;latest-kotlin-version\u0026gt;\u0026#34; id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;\u0026lt;latest-ksp-version\u0026gt;\u0026#34; } repositories { mavenCentral() } dependencies { implementation(kotlin(\u0026#34;stdlib\u0026#34;)) ksp(\u0026#34;\u0026lt;ksp-processor-library\u0026gt;\u0026#34;) }   Replace \u0026lt;ksp-processor-library\u0026gt; with the library-specific processor dependency, as shown in the examples below.\nExample 1: KSP with Koin Dependency Injection Koin, starting from version 3.4.0, provides annotations to define dependencies, which are processed using KSP to generate Koin modules.\nSetup Koin with KSP Add the following dependencies:\n1 2 3 4 5  dependencies { implementation(\u0026#34;io.insert-koin:koin-core:\u0026lt;version\u0026gt;\u0026#34;) implementation(\u0026#34;io.insert-koin:koin-annotations:\u0026lt;version\u0026gt;\u0026#34;) ksp(\u0026#34;io.insert-koin:koin-ksp-compiler:\u0026lt;version\u0026gt;\u0026#34;) }   Annotate Classes Use Koin annotations to define your dependency graph:\n1 2 3 4 5 6 7 8 9  @Module @ComponentScan class AppModule @Single class UserRepository @Factory class UserUseCase(private val userRepository: UserRepository)   Generated Module The KSP processor automatically generates a Koin module for you. You can include it in your application setup:\n1 2 3 4 5  fun main() { startKoin { modules(AppModuleModule().module) } }   This eliminates the need to manually write the Koin module, saving time and reducing boilerplate.\nExample 2: KSP with Room Database Room is a widely-used ORM for Android. With KSP, Room processes annotations faster, reducing build times significantly.\nSetup Room with KSP Add the following dependencies:\n1 2 3 4  dependencies { implementation(\u0026#34;androidx.room:room-runtime:\u0026lt;version\u0026gt;\u0026#34;) ksp(\u0026#34;androidx.room:room-compiler:\u0026lt;version\u0026gt;\u0026#34;) }   Annotate Entities 1 2 3 4 5  @Entity data class User( @PrimaryKey val id: Int, val name: String )   Generate DAO and Database 1 2 3 4 5 6 7 8 9 10  @Dao interface UserDao { @Query(\u0026#34;SELECT * FROM User\u0026#34;) fun getAllUsers(): List\u0026lt;User\u0026gt; } @Database(entities = [User::class], version = 1) abstract class AppDatabase : RoomDatabase() { abstract fun userDao(): UserDao }   Using KSP, Room generates the necessary code behind the scenes, reducing boilerplate.\nHow to Create a Custom KSP Processor Let’s build a custom KSP processor that generates a Builder class for data classes annotated with @GenerateBuilder. This is a practical and commonly useful feature for many projects.\nCreate the Module First, you should create a module with the API for KSP.\n1 2 3  dependencies { implementation(\u0026#34;com.google.devtools.ksp:symbol-processing-api:\u0026lt;version\u0026gt;\u0026#34;) }   Define the Annotation 1 2 3  @Target(AnnotationTarget.CLASS) @Retention(AnnotationRetention.SOURCE) annotation class GenerateBuilder   KSP Processor Logic The processor can dynamically generate a Builder class based on the properties of the annotated data class. You need to create a class extending SymbolProcessor where all the work will be done in the process function, and a class extending SymbolProcessorProvider, which will provide the implementation of the SymbolProcessor.\nHere is the SymbolProcessor implementation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  class KspBuilderProcessor( private val codeGenerator: CodeGenerator ) : SymbolProcessor { override fun process(resolver: Resolver): List\u0026lt;KSAnnotated\u0026gt; { val symbols = resolver.getSymbolsWithAnnotation(GenerateBuilder::class.qualifiedName.toString()) .filterIsInstance\u0026lt;KSClassDeclaration\u0026gt;() symbols.forEach { symbol -\u0026gt; val className = symbol.simpleName.asString() val packageName = symbol.packageName.asString() val generatedClassName = \u0026#34;${className}Builder\u0026#34; val file = codeGenerator.createNewFile( dependencies = Dependencies(false, symbol.containingFile!!), packageName = packageName, fileName = generatedClassName ) val properties = symbol.getAllProperties() val builderProperties = mutableListOf\u0026lt;String\u0026gt;() val setters = mutableListOf\u0026lt;String\u0026gt;() val buildMethodParams = mutableListOf\u0026lt;String\u0026gt;() properties.forEach { property -\u0026gt; val propName = property.simpleName.asString() val propType = property.type.resolve().declaration.simpleName.asString() .let { if (property.type.resolve().isMarkedNullable) \u0026#34;$it?\u0026#34; else it } val defaultValue = getDefaultValueFromProperty(property) builderProperties.add(\u0026#34; private var $propName: $propType= $defaultValue\u0026#34;) setters.add(\u0026#34; fun set${propName.replaceFirstChar { it.uppercase() }}($propName: $propType) = apply { this.$propName= $propName}\u0026#34;) buildMethodParams.add(\u0026#34; $propName= this.$propName\u0026#34;) } val builderClass = buildString { appendLine(\u0026#34;package $packageName\u0026#34;) appendLine() appendLine(\u0026#34;class $generatedClassName{\u0026#34;) builderProperties.forEach { property -\u0026gt; appendLine(property) } appendLine() setters.forEach { setter -\u0026gt; appendLine(setter) } appendLine() appendLine(\u0026#34; fun build(): $className{\u0026#34;) appendLine(\u0026#34; return $className(\u0026#34;) buildMethodParams.forEach { methodParam -\u0026gt; appendLine(methodParam) } appendLine(\u0026#34; )\u0026#34;) appendLine(\u0026#34; }\u0026#34;) appendLine(\u0026#34;}\u0026#34;) appendLine() appendLine(\u0026#34;fun ${generatedClassName.replaceFirstChar { it.lowercase() }}(block: $generatedClassName.() -\u0026gt; Unit): $className{\u0026#34;) appendLine(\u0026#34; return $generatedClassName().apply(block).build()\u0026#34;) appendLine(\u0026#34;}\u0026#34;) } file.write(builderClass.toByteArray()) file.close() } return symbols.filterNot { it.validate() }.toList() } private fun getDefaultValueFromProperty(property: KSPropertyDeclaration): String { val propType = property.type.resolve().declaration.qualifiedName?.asString() ?: \u0026#34;Any\u0026#34; val isNullable = property.type.resolve().isMarkedNullable return if (isNullable) \u0026#34;null\u0026#34; else when (propType) { \u0026#34;kotlin.String\u0026#34; -\u0026gt; \u0026#34;\\\u0026#34;\\\u0026#34;\u0026#34; \u0026#34;kotlin.Int\u0026#34;, \u0026#34;kotlin.Long\u0026#34;, \u0026#34;kotlin.Short\u0026#34;, \u0026#34;kotlin.Byte\u0026#34; -\u0026gt; \u0026#34;0\u0026#34; \u0026#34;kotlin.Double\u0026#34;, \u0026#34;kotlin.Float\u0026#34; -\u0026gt; \u0026#34;0.0\u0026#34; \u0026#34;kotlin.Boolean\u0026#34; -\u0026gt; \u0026#34;false\u0026#34; else -\u0026gt; throw IllegalArgumentException(\u0026#34;Non-nullable type $propTyperequires a default value\u0026#34;) } } }   And here is the SymbolProcessorProvider:\n1 2 3 4 5  class KspBuilderProvider : SymbolProcessorProvider { override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor { return KspBuilderProcessor(environment.codeGenerator) } }   With these two classes created, you need to create a file with the path src/main/resources/META-INF/services and name com.google.devtools.ksp.processing.SymbolProcessorProvider. Its content will be the full name of the SymbolProcessorProvider class you just created. In this case, it is:\ncom.example.kspbuilder.KspBuilderProvider Use the Custom KSP Processor Add Custom Processor Add the KSP plugin to the build.gradle.kts file on the module where you want to use the annotation:\n1 2 3 4 5 6 7 8  plugins { id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;\u0026lt;version\u0026gt;\u0026#34; } dependencies { implementation(project(\u0026#34;:KspBuilder\u0026#34;)) ksp(project(\u0026#34;:KspBuilder\u0026#34;)) }   Annotate a Class Create a data class with the custom annotation:\n1 2 3 4 5  @GenerateBuilder class Person(val id: Int, val name: String, val age: Int, val address: Address?) @GenerateBuilder class Address(val id: Int, val name: String, val country: String)   Generated Output After building the project, the generated code with KSP will be located under the build/generated/ksp folder.\nFor the Person data class, the generated builder class would look like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class PersonBuilder { private var id: Int = 0 private var name: String = \u0026#34;\u0026#34; private var age: Int = 0 private var address: Address? = null fun setId(id: Int) = apply { this.id = id } fun setName(name: String) = apply { this.name = name } fun setAge(age: Int) = apply { this.age = age } fun setAddress(address: Address?) = apply { this.address = address } fun build(): Person { return Person( id = this.id, name = this.name, age = this.age, address = this.address ) } } fun personBuilder(block: PersonBuilder.() -\u0026gt; Unit): Person { return PersonBuilder().apply(block).build() }   For the Address data class, the generated builder class would look like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class AddressBuilder { private var id: Int = 0 private var name: String = \u0026#34;\u0026#34; private var country: String = \u0026#34;\u0026#34; fun setId(id: Int) = apply { this.id = id } fun setName(name: String) = apply { this.name = name } fun setCountry(country: String) = apply { this.country = country } fun build(): Address { return Address( id = this.id, name = this.name, country = this.country ) } } fun addressBuilder(block: AddressBuilder.() -\u0026gt; Unit): Address { return AddressBuilder().apply(block).build() }   Usage Example 1 2 3 4 5 6 7 8 9 10 11 12  val person = personBuilder { setId(10) setName(\u0026#34;Test\u0026#34;) setAge(100) setAddress( addressBuilder { setId(10) setName(\u0026#34;AddressTest\u0026#34;) setCountry(\u0026#34;Spain\u0026#34;) } ) }   Conclusion Kotlin Symbol Processing is a game-changer for Kotlin developers. Its lightweight and Kotlin-first design makes it a perfect replacement for kapt, and its ability to generate code dynamically opens up new possibilities. Whether you’re using KSP with established libraries like Koin and Room or building custom processors for your use case, KSP provides the tools you need to take your development to the next level.\nTry integrating KSP into your project and see the performance benefits firsthand!\nHere is the repository with the code for the custom KSP processor Github Repo\n","description":"Advanced Kotlin - Kotlin Symbol Processing (KSP)","id":19,"section":"posts","tags":["kotlin","android","advanced"],"title":"A deep dive into Kotlin KSP","uri":"https://carrion.dev/en/posts/kotlin-ksp/"},{"content":"Exploring Kotlin Infix Functions: A Deep Dive Kotlin, as a modern programming language, is packed with features that make code expressive and concise. One of these features is infix functions, which allow you to write cleaner and more readable code. In this blog post, we\u0026rsquo;ll explore what infix functions are, how to use them, and some practical use cases.\nWhat Are Infix Functions? Infix functions in Kotlin are a special kind of function that can be called without using parentheses or the dot operator. This can make certain code patterns more natural and readable, resembling traditional mathematical or DSL (Domain Specific Language) syntax.\nHere’s an example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Point(val x: Int, val y: Int) { infix fun moveBy(offset: Point): Point { return Point(this.x + offset.x, this.y + offset.y) } } fun main() { val point1 = Point(2, 3) val offset = Point(1, 1) // Using the infix notation  val newPoint = point1 moveBy offset println(\u0026#34;New Point: (\\${newPoint.x}, \\${newPoint.y})\u0026#34;) }   In this example, the moveBy function is called using infix notation, improving readability.\nRules and Syntax Here are a few key points about infix functions:\n Single Parameter: The function must take exactly one parameter. Class Member or Extension Function: It must be defined as a member function or an extension function. No Varargs or Default Arguments: The parameter cannot have default values or be a vararg.  Example of an extension function:\n1 2 3 4 5 6 7 8  infix fun String.concatWith(other: String): String { return this + other } fun main() { val result = \u0026#34;Hello\u0026#34; concatWith \u0026#34; World\u0026#34; println(result) // Outputs: Hello World }   Practical Use Cases Infix functions are commonly used in Kotlin to make code more concise and readable. They shine in scenarios where intuitive operations are necessary, such as working with collections, ranges, or creating expressive testing frameworks. Below are some examples of how infix functions can simplify everyday coding tasks:\n  Mapping Keys to Values: The to function in Kotlin\u0026rsquo;s standard library is an infix function that helps in creating pairs, often used in maps.\n1 2 3 4  fun main() { val map = mapOf(\u0026#34;key1\u0026#34; to \u0026#34;value1\u0026#34;, \u0026#34;key2\u0026#34; to 42) println(map) // Outputs: {key1=value1, key2=42} }     Defining Ranges: The until function is an infix function used to define ranges that exclude the upper bound.\n1 2 3 4 5  fun main() { for (i in 1 until 5) { println(i) // Outputs: 1, 2, 3, 4  } }     Mocking in Tests: Libraries like MockK use infix functions to create expressive and readable test setups.\n1 2 3 4 5 6 7 8 9 10  class Calculator { fun add(a: Int, b: Int): Int = a + b } fun test() { val calculator = mockk\u0026lt;Calculator\u0026gt;() every { calculator.add(1, 2) } returns 3 println(calculator.add(1, 2)) // Outputs: 3 }     Dependency Injection with Koin: Koin, a dependency injection framework for Kotlin, uses the bind infix function to define bindings in a clean and readable way.\n1 2 3 4 5 6  interface MyInterface class MyImplementation : MyInterface val appModule = module { single { MyImplementation() } bind MyInterface::class }   The bind infix function enhances readability when declaring that a specific implementation should be used for an interface.\n  When to Use Infix Functions While infix functions can make code cleaner, they should be used judiciously. Use them when:\n The operation is intuitive and widely understood. They enhance readability and flow. They fit naturally into a DSL.  Avoid using infix functions when:\n It could lead to ambiguous or confusing syntax. The function\u0026rsquo;s purpose isn\u0026rsquo;t clear from its name or usage.  Conclusion Kotlin\u0026rsquo;s infix functions are a powerful tool for creating expressive and readable code. Whether you’re defining a DSL, simplifying mathematical operations, or enhancing logical expressions, infix functions can make your code more elegant. However, as with any feature, they should be used thoughtfully to maintain code clarity and avoid overcomplication.\nTry incorporating infix functions in your next Kotlin project and see how they transform your code! What are your favorite infix functions or creative ways to use them? Share your experiences in the comments!\n","description":"Advanced Kotlin - Infix functions","id":20,"section":"posts","tags":["kotlin","android","advanced"],"title":"Kotlin Infix functions","uri":"https://carrion.dev/en/posts/kotlin-infix/"},{"content":"✨ Understanding Kotlin Delegates: The Magic Behind Cleaner Code ✨ Kotlin delegates are a powerful feature that lets you delegate the behavior of a property or even an interface implementation to another object. Instead of writing repetitive logic or managing state directly, you can delegate this responsibility to reusable and specialized classes.\nHow Delegates Work Delegates in Kotlin work by using the by keyword, which redirects the behavior of a property or an interface to a delegate object. For properties, the delegate object provides custom implementations for the get and/or set methods. For interface delegation, the class implementation is forwarded to the provided delegate.\nHere’s an example of property delegation using a custom delegate:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class StringDelegate { private var value: String = \u0026#34;\u0026#34; operator fun getValue(thisRef: Any?, property: kotlin.reflect.KProperty\u0026lt;*\u0026gt;): String { println(\u0026#34;Getting value for \\${property.name}\u0026#34;) return value } operator fun setValue(thisRef: Any?, property: kotlin.reflect.KProperty\u0026lt;*\u0026gt;, newValue: String) { println(\u0026#34;Setting value for \\${property.name} to \\$newValue\u0026#34;) value = newValue } } class Example { var text: String by StringDelegate() } fun main() { val example = Example() example.text = \u0026#34;Hello, Kotlin!\u0026#34; println(example.text) }   Output Setting value for text to Hello, Kotlin! Getting value for text Hello, Kotlin! In this example:\n The StringDelegate class defines custom behavior for property access using the getValue and setValue operators. The text property in the Example class delegates its behavior to an instance of StringDelegate.  Real-World Applications of Delegates 1️⃣ Dependency Injection with Koin In #Koin, you can use the by inject() delegate to inject dependencies directly into your classes. This eliminates the need for manual instantiation:\n1 2 3 4 5 6 7 8 9 10  class DelegatesFragment : Fragment() { private val tracker: AnalyticsTracker by inject() } inline fun \u0026lt;reified T : Any\u0026gt; KoinComponent.inject( qualifier: Qualifier? = null, mode: LazyThreadSafetyMode = KoinPlatformTools.defaultLazyMode(), noinline parameters: ParametersDefinition? = null, ): Lazy\u0026lt;T\u0026gt; = lazy(mode) { get\u0026lt;T\u0026gt;(qualifier, parameters) }   The by inject() delegate automatically resolves the dependency using Koin’s container. It abstracts the boilerplate, resulting in cleaner, testable code.\n2️⃣ State Management in Jetpack Compose In Jetpack Compose, the remember function with mutableStateOf is a great example of delegation. It helps you manage state efficiently within your composables:\n1 2 3 4 5 6 7 8 9 10 11  @Composable fun Counter() { var count by remember { mutableStateOf(0) } Column { Text(\u0026#34;Count: $count\u0026#34;) Button(onClick = { count++ }) { Text(\u0026#34;Increment\u0026#34;) } } }   3️⃣ Lazy Initialization The lazy delegate is perfect for properties that need to be initialized only when accessed for the first time:\n1 2 3 4 5 6 7 8 9  val greeting: String by lazy { println(\u0026#34;Initializing...\u0026#34;) \u0026#34;Hello, Kotlin!\u0026#34; } fun main() { println(greeting) // Initializes here  println(greeting) // Uses cached value }   Output Initializing... Hello, Kotlin! Hello, Kotlin! 4️⃣ Interface Delegation in Constructor Kotlin allows you to delegate the implementation of an interface to another object.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  interface Logger { fun log(message: String) } class ConsoleLogger : Logger { override fun log(message: String) { println(\u0026#34;Log: $message\u0026#34;) } } class FileLogger : Logger { override fun log(message: String) { println(\u0026#34;Writing log to file: $message\u0026#34;) } } class Application(logger: Logger) : Logger by logger fun main() { val consoleApp = Application(ConsoleLogger()) consoleApp.log(\u0026#34;Starting console application\u0026#34;) val fileApp = Application(FileLogger()) fileApp.log(\u0026#34;Starting file application\u0026#34;) }   Output Log: Starting console application Writing log to file: Starting file application Here’s what’s happening:\n The Application class doesn’t implement the Logger methods directly. Instead, it delegates the Logger implementation to the object passed to its constructor using by. This makes it easy to swap implementations without changing the Application class.  Why Use Kotlin Delegates? Delegates encapsulate logic that would otherwise clutter your classes. They help:\n Simplify code by reusing logic (e.g., lazy initialization). Abstract repetitive patterns (e.g., dependency injection). Enhance state management (e.g., Jetpack Compose’s remember). Provide modular and reusable interface implementations (e.g., constructor delegation).  Conclusion Kotlin’s delegate mechanism is a prime example of how the language combines simplicity and power. Delegates are everywhere in Kotlin development. Are you using them in other cases in your projects?\n","description":"Advanced Kotlin - Delegates","id":21,"section":"posts","tags":["kotlin","android","advanced"],"title":"Kotlin Delegates","uri":"https://carrion.dev/en/posts/kotlin-delegates/"},{"content":"Mastering Kotlin Contracts: Unlocking Smarter Code Analysis Kotlin never ceases to amaze with its features that combine elegance and power. One advanced yet often underutilized tool in Kotlin\u0026rsquo;s arsenal is Contracts. Contracts let you guide the Kotlin compiler to make smarter decisions about your code—resulting in better null safety, optimized performance, and fewer runtime errors.\nWhat Are Kotlin Contracts? Kotlin Contracts allow you to define rules about how your functions behave, helping the compiler perform advanced static analysis. They enable features like smart-casts and context-aware checks beyond Kotlin’s default capabilities.\nWhy Use Contracts?  Improve Null Safety: Eliminate redundant null checks by telling the compiler when something is guaranteed to be non-null. Optimize Smart-Casts: Make the compiler aware of variable types in custom scenarios. Reduce Boilerplate: Write cleaner, more intuitive code by offloading repetitive checks to the compiler.  Examples of Kotlin Contracts in Action 1. Simplify Null Checks Let’s create a custom utility to validate non-null values:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @OptIn(ExperimentalContracts::class) inline fun \u0026lt;T\u0026gt; requireNotNull(value: T?, message: String): T { contract { returns() implies (value != null) } if (value == null) { throw IllegalArgumentException(message) } return value } fun processName(name: String?) { val nonNullName = requireNotNull(name, \u0026#34;Name cannot be null\u0026#34;) // No need for additional null checks; compiler knows \u0026#39;nonNullName\u0026#39; is not null!  println(\u0026#34;Processing name: $nonNullName\u0026#34;) } fun main() { processName(\u0026#34;John\u0026#34;) // Works fine  // processName(null) // Throws an IllegalArgumentException }   Something similar is implemented in the functions require and requireNotNull from the Kotlin standard lib:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  /** * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false. * * @sample samples.misc.Preconditions.failRequireWithLazyMessage */ @kotlin.internal.InlineOnly public inline fun require(value: Boolean, lazyMessage: () -\u0026gt; Any): Unit { contract { returns() implies value } if (!value) { val message = lazyMessage() throw IllegalArgumentException(message.toString()) } } /** * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise * returns the not null value. * * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage */ @kotlin.internal.InlineOnly public inline fun \u0026lt;T : Any\u0026gt; requireNotNull(value: T?, lazyMessage: () -\u0026gt; Any): T { contract { returns() implies (value != null) } if (value == null) { val message = lazyMessage() throw IllegalArgumentException(message.toString()) } else { return value } }   How Contracts Help Here  The returns() implies (value != null) contract tells the compiler:  If the function returns successfully, then value is guaranteed to be non-null.\n  This enables smart-casts, so you don’t need manual null checks after the function call.  2. Custom Assertions Here’s how contracts can be used to define custom assertion functions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @OptIn(ExperimentalContracts::class) fun assertValidState(condition: Boolean, message: String) { contract { returns() implies condition } if (!condition) { throw IllegalStateException(message) } } fun performOperation(state: Boolean) { val state: Any? = \u0026#34;Hello\u0026#34; assertValidState(state is String, \u0026#34;Is String\u0026#34;) // Here the compiler knows that the state val is of type String so no need to other cast checks  println(\u0026#34;String length: ${assertion.length}\u0026#34;) } fun main() { performOperation(true) // Prints success  // performOperation(false) // Throws IllegalStateException }   3. Smart-Casts with Custom Conditions Let’s create a utility function that checks if a value matches a specific type. This will demonstrate how contracts enable smarter casting:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  @OptIn(ExperimentalContracts::class) inline fun \u0026lt;reified T\u0026gt; isOfType(value: Any?): Boolean { contract { returns(true) implies (value is T) } return value is T } fun main() { val input: Any? = \u0026#34;Hello, Kotlin!\u0026#34; if (isOfType\u0026lt;String\u0026gt;(input)) { println(\u0026#34;String length: ${input.length}\u0026#34;) } val inputInt: Any? = 10 if (isOfType\u0026lt;Int\u0026gt;(inputInt)) { println(\u0026#34;The value is an integer ${input.toUInt()}\u0026#34;) } }   With this implementation, the compiler knows that within the if block, input is a String, thanks to the contract defined in isOfType. Also the compilers knows that inputInt is an Int so you don\u0026rsquo;t need to cast it.\n4. Optimizing Flow Control Contracts can simplify flow control by enabling the compiler to understand loop invariants or conditions. Here’s an example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  inline fun isNotEmpty(list: List\u0026lt;*\u0026gt;?): Boolean { contract { returns(true) implies (list != null \u0026amp;\u0026amp; list.isNotEmpty()) } return list != null \u0026amp;\u0026amp; list.isNotEmpty() } fun processItems(items: List\u0026lt;String\u0026gt;?) { if (isNotEmpty(items)) { // Compiler knows items is non-null and not empty  println(\u0026#34;Processing ${items.size}items\u0026#34;) } else { println(\u0026#34;No items to process\u0026#34;) } } fun main() { processItems(listOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;)) processItems(null) processItems(emptyList()) }   Output Processing 3 items No items to process No items to process When to Use Contracts Contracts are ideal for:\n Library Development: Safeguard public APIs by enforcing preconditions. DSLs and Frameworks: Simplify type-checking and state validations in Kotlin DSLs. Performance Optimization: Reduce runtime checks by letting the compiler infer conditions at compile time.  Conclusion Kotlin Contracts are a hidden gem that can elevate your code by improving safety, reducing boilerplate, and enabling smarter compiler analysis. Whether you\u0026rsquo;re building libraries, writing complex DSLs, or just optimizing everyday code, contracts provide a powerful tool to guide the Kotlin compiler and ensure code correctness.\nAlso keep in mind that contracts are annotated as experimental feature but they are in Kotlin since 1.3 version and are being used in the standard library so they are stable enough to use them.\n","description":"Advanced Kotlin - Contracts","id":22,"section":"posts","tags":["kotlin","android","advanced"],"title":"Kotlin contracts","uri":"https://carrion.dev/en/posts/kotlin-contracts/"},{"content":"Swift export in Kmp Starting from version 2.1.0 we can start testing the Swift export in Kotlin. This feature allows you to export the Kotlin shared modules to Swift without the use of Objective-C. This will improve the iOS developers experience when using KMP modules.\nAt the moment basic support includes:\n Export multiple Gradle modules to Swift. Define the Swift module names. Flatten package structure  Enable the feature To start testing this functionality you should enable it on gradle.properties file:\nkotlin.experimental.swift-export.enabled=true Configuration After adding the line above you need to add this configuration to the build.gradle.kts file:\n1 2 3 4 5 6 7 8 9 10 11  kotlin { iosX64() iosArm64() iosSimulatorArm64() @OptIn(ExperimentalSwiftExportDsl::class) swiftExport { moduleName = \u0026#34;shared\u0026#34; flattenPackage = \u0026#34;dev.carrion.kmpswiftexport\u0026#34; } }   Next step is configuring xcode to launch the new task embedSwiftExportForXcode instead of embedAndSignAppleFrameworkForXcode. You can do it from xcode build phases configuration of the iosApp or from Android Studio modifying the project.pbxproj file.\nYou should change this line:\nshellScript = \u0026quot;cd \\\u0026quot;$SRCROOT/..\\\u0026quot;\\n./gradlew :shared:embedAndSignAppleFrameworkForXcode\\n\u0026quot;; With this one:\nshellScript = \u0026quot;cd \\\u0026quot;$SRCROOT/..\\\u0026quot;\\n./gradlew :shared:embedSwiftExportForXcode\\n\u0026quot;; After this changes you should be able to launch the app from Android Studio or xcode without any problems.\nBefore enabling the feature If you try to jump to the definition of a kotlin function from xcode in a swift file, you will be prompted with the Objective-C code exported from the kotlin shared module. This file is huge given the complexity of the project used for this example.\nI will show you just a little piece of the 175 lines file generated from the Kotlin source code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;Greeting\u0026#34;))) @interface SharedGreeting : SharedBase - (instancetype)init __attribute__((swift_name(\u0026#34;init()\u0026#34;))) __attribute__((objc_designated_initializer)); + (instancetype)new __attribute__((availability(swift, unavailable, message=\u0026#34;use object initializers instead\u0026#34;))); - (NSString *)greet __attribute__((swift_name(\u0026#34;greet()\u0026#34;))); @end __attribute__((swift_name(\u0026#34;Platform\u0026#34;))) @protocol SharedPlatform @required @property (readonly) NSString *name __attribute__((swift_name(\u0026#34;name\u0026#34;))); @end __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;IOSPlatform\u0026#34;))) @interface SharedIOSPlatform : SharedBase \u0026lt;SharedPlatform\u0026gt; - (instancetype)init __attribute__((swift_name(\u0026#34;init()\u0026#34;))) __attribute__((objc_designated_initializer)); + (instancetype)new __attribute__((availability(swift, unavailable, message=\u0026#34;use object initializers instead\u0026#34;))); @property (readonly) NSString *name __attribute__((swift_name(\u0026#34;name\u0026#34;))); @end __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;Platform_iosKt\u0026#34;))) @interface SharedPlatform_iosKt : SharedBase + (id\u0026lt;SharedPlatform\u0026gt;)getPlatform __attribute__((swift_name(\u0026#34;getPlatform()\u0026#34;))); @end #pragma pop_macro(\u0026#34;_Nullable_result\u0026#34;) #pragma clang diagnostic pop NS_ASSUME_NONNULL_END   After enabling the feature When you enable the feature and build the project, trying to go to the definition of a function from the Kotlin code, xcode will show you the exported Swift code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  @_exported import ExportedKotlinPackages @_implementationOnly import SharedBridge_shared import KotlinRuntime public typealias Greeting = ExportedKotlinPackages.dev.carrion.kmpswiftexport.Greeting public func getPlatform() -\u0026gt; Swift.Never { ExportedKotlinPackages.dev.carrion.kmpswiftexport.getPlatform() } public extension ExportedKotlinPackages.dev.carrion.kmpswiftexport { public final class Greeting : KotlinRuntime.KotlinBase { public override init() { let __kt = dev_carrion_kmpswiftexport_Greeting_init_allocate() super.init(__externalRCRef: __kt) dev_carrion_kmpswiftexport_Greeting_init_initialize__TypesOfArguments__Swift_UInt__(__kt) } public override init( __externalRCRef: Swift.UInt ) { super.init(__externalRCRef: __externalRCRef) } public func greet() -\u0026gt; Swift.String { return dev_carrion_kmpswiftexport_Greeting_greet(self.__externalRCRef()) } } public static func getPlatform() -\u0026gt; Swift.Never { fatalError() } }   The code above this lines is the complete file with 28 lines, a huge difference with the 175 lines from the Objective-C exported code. Also it\u0026rsquo;s important to mention the lower complexity and higher readability on the Swift example.\nConclusion After testing this new feature, I\u0026rsquo;m really amazed with the improvement it brings to the iOS development in KMP projects. Also impressed with the difference in code between Objective-C and Swift exported codes. I\u0026rsquo;m sure this feature will improve in next versions and it will close the bridge between the native and multiplatform development experiences.\nYou can find the repository with the code from this example in SwiftExport, with two branches, main, where it\u0026rsquo;s the usual iOS framework configuration, and swift-export branch which has the new feature enabled.\n","description":"New feature in Kotlin 2.1.0, basic swift export from Kotlin","id":23,"section":"posts","tags":["kotlin","android","kmp"],"title":"Swift export in KMP","uri":"https://carrion.dev/en/posts/swift-export/"},{"content":"Guard conditions in when in Kotlin 2.1.0 One of the new features in Kotlin 2.1.0 is the guard conditions on when expressions, this feature will bring some advantages like:\n Reduce nesting Avoid boilerplate Improve readability  Enable the feature This feature is in preview state, for this you need to enable it starting on Kotlin 2.1.0. In the file build.gradle.kts we should add the new piece of code inside the kotlin block:\n1 2 3 4 5  kotlin { compilerOptions { freeCompilerArgs.add(\u0026#34;-Xwhen-guards\u0026#34;) } }   Use guard conditions on when expression branches For this example we will use a sealed interface to handle the responses from a remote service:\n1 2 3 4 5  sealed interface Response\u0026lt;out T\u0026gt; { data object Loading : Response\u0026lt;Nothing\u0026gt; data class Content \u0026lt;out T\u0026gt; (val data: T?) : Response\u0026lt;T\u0026gt; data class Error(val error: Exception) : Response\u0026lt;Nothing\u0026gt; }   Loading, Content and Error implement the Response interface to manage the different states of the response.\nBefore new feature 1 2 3 4 5 6 7 8 9 10 11 12 13  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handleOld() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content -\u0026gt; if (data != null) { println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } is Response.Error -\u0026gt; if (error is IllegalStateException) { println(\u0026#34;Handled error\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } }   Here you can see how the code to print the Unknown error needs to be in both branches, also it adds nested complexity that reduces the code readability.\nUsing new Guard conditions You must add if statement after the primary condition inside the when branch, see below:\n1 2 3 4 5 6  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled error\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   This way the print statement with the text Unkwon error is used just once, also we remove the nested complexity.\nIf we need to check different conditions on the else branch, we can use an else if in case our response doesn\u0026rsquo;t satisfy the previous conditions.\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) else if this is Response.Error \u0026amp;\u0026amp; this.error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   This example can be simplified using to branches with the same primary condition is Response.Error, in my opinion keeps the code more readable and simple:\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) is Response.Error if error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   Conclusion With this new feature we can add new conditions without repeating code and will allow more concise when expressions. It\u0026rsquo;s in preview state starting from Kotlin 2.1.0 but seems like it will become stable soon.\nHere is the link to the documentation where you can find what\u0026rsquo;s new in Kotlin 2.1.0 included the guard conditions in when expressions kotlinlang\n","description":"New feature since Kotlin 2.1.0, guard conditions in when expressions","id":24,"section":"posts","tags":["kotlin","android","kmp"],"title":"Guard conditions in when starting in Kotlin 2.1.0.","uri":"https://carrion.dev/en/posts/kotlin-guard-conditions-in-when/"},{"content":"Inject runtime parameters with Dagger-Hilt Since Hilt appeared to make it easier the dependency injection in Android, it was impossible to inject runtime parameters without using third party libraries. Since Dagger version 2.31, exists the @AssistedInject annotation. With this annotation we can instruct Dagger-Hilt what dependencies need to be created at runtime and delay the injection of this parameters until we can provide those values.\nThis is necessary to inject parameters into ViewModel constructor and be able to execute some code in the init function. It can be an external API call or some query to our local database.\nIn this post we will learn how to use @AssistedInject from Dagger to inject runtime parameters to ViewModels with Hilt.\nInstallation In the root project build.gradle file, we will include the Hilt classpath:\n1  classpath \u0026#39;com.google.dagger:hilt-android-gradle-plugin:2.31.2-alpha\u0026#39;   Once we have Hilt classpath we will add Hilt plugin to build.gradle file from app module.\n1  apply plugin: \u0026#39;dagger.hilt.android.plugin\u0026#39;   And the next lines to our dependencies block:\n1 2  implementation \u0026#39;com.google.dagger:hilt-android:2.31.2-alpha\u0026#39; kapt \u0026#39;com.google.dagger:hilt-android-compiler:2.31.2-alpha\u0026#39;    We should keep in mind that we need kapt plugin on our build.gradle. For this we will add this line with the rest of plugins in our build.gradle from app module:\n 1  apply plugin: \u0026#39;kotlin-kapt\u0026#39;   Those were the needed dependencies to make Hilt work in our project. In this post we will use libraries that are not defined here.\nIn this link you can see the complete build.gradle file: app/build.gradle\nImplementation For this example we will be using a repository class with a function which receives a name and returns a welcome message. To acomplish this we will create the interface below:\n1 2 3  interface UserRepository { fun getMessage(name: String): String }   And it\u0026rsquo;s implementation:\n1 2 3 4 5  class UserRepositoryImpl @Inject constructor() : UserRepository { override fun getMessage(name: String): String { return \u0026#34;Hi $name\u0026#34; } }   We should annotate the constructor with @Inject so we can declare a @Binds annotation in the Hilt module to be able to inject the implementation when we call an interface of type UserRepository.\nNext we will create our ViewModel, this class will receive the user name from the Activity or Fragment and call the repository to get the welcome message:\n1 2 3 4 5 6 7 8 9  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { ... }   In this ViewModel we can see how we should annotate the constructor with @AssistedInject so Dagger-Hilt knows this class has dependencies that will be injected at runtime. This runtime dependencies will be annotated with @Assisted.\nTo be able to create our ViewModel with the extension by viewModels() from AndroidX library, we should create the Factory class wich will be provided to the extension:\n1 2 3 4 5 6 7 8  class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } }   You can see we need an interface called UserViewModelAssistedFactory. This interface will handle the runtime parameters injected to the ViewModel:\n1 2 3 4 5 6  @AssistedFactory interface UserViewModelAssistedFactory { fun create(name: String): UserViewModel }   It\u0026rsquo;s an interface with a create function. This function receive all the runtime parameters we want to inject in our ViewModel. In this example we only need a name parameter, but in case we need more parameters injected at runtime, they will be provided to this function.\nWith this we are able to complete our ViewModel with the logic to get the answer from the repository and expose it to the Fragment or Activity through a StateFlow.\nThe complete ViewModel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } } private val _message: MutableStateFlow\u0026lt;String\u0026gt; = MutableStateFlow(\u0026#34;\u0026#34;) val message: StateFlow\u0026lt;String\u0026gt; get() = _message init { viewModelScope.launch(dispatcher) { _message.emit(repository.getMessage(name)) } } }   Related to Hilt we only have to create the module to handle the creation of dependencies. For this example we will be using this module:\n1 2 3 4 5 6 7 8 9 10 11 12 13  @Module @InstallIn(ActivityComponent::class) abstract class MainModule { companion object { @Provides @Named(\u0026#34;UserDispatcher\u0026#34;) fun provideUserDispatcher(): CoroutineDispatcher = Dispatchers.IO } @Binds abstract fun provideUserRepository(repositoryImpl: UserRepositoryImpl): UserRepository }   In this module we declare a function to provide a Dispatcher so it will be easier to test this ViewModel in a future. We declare a @Binds function so when we inject a UserRepository interface Hilt provides its implementation UserRepositoryImpl.\nNow we can user our ViewModel in Activities or Fragments:\n1 2 3 4 5 6 7 8  private val navArgs: UserFragmentArgs by navArgs() @Inject lateinit var assistedFactory: UserViewModelAssistedFactory private val userViewModel: UserViewModel by viewModels { UserViewModel.Factory(assistedFactory, navArgs.name) }   We need to @Inject the AssistedFactory and use the UserViewModel.Factory to create our ViewModel.\nFrom this step we only need to observe changes in the ViewModel StateFlow to be able to update our UI. This can be done in Fragments observing from the onViewCreated.\n1 2 3 4 5 6 7 8  override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycleScope.launchWhenStarted { userViewModel.message.collect { binding.name.text = it } } }    Remember you need a class extending Application annotated with @HiltAndroidApp and each Activity or Fragment that uses injection with Hilt need to be annotated with @AndroidEntryPoint.\n Conclusion Now we can inject Runtime values with Dagger @AssistedInject in a simple way and we can keep using navArgs from AndroidX.\nYou can see the complete example in this repository: HiltAssistedInject\n","description":"Inject parameters to ViewModels at Runtime in Android.","id":25,"section":"posts","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Hilt: Inject Runtime parameters to ViewModels.","uri":"https://carrion.dev/en/posts/hilt-inject-parameters-runtime/"},{"content":"Welcome to Carrion.dev Hi droid!\nWelcome to my new Kotlin and Android programming blog. I am Ignacio Carrión and I\u0026rsquo;m an Android developer. I love Kotlin because it boost my Android development eficiency and because it has infinite posibilities outside of Android ecosystem (backend, web, native, multiplatform\u0026hellip;).\nIn this blog I hope I can publish interesting topics about Kotlin and Android at least twice a month. If you want to keep up to date you can subscribe to our newsletter.\nIf you have any question, idea about some topic for the blog or you just want to contact with me, I\u0026rsquo;m available through my email: ignacio@carrion.dev.\nI hope we can learn together!!\n","description":"First post in my new Kotlin and Android development blog","id":26,"section":"posts","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Welcome to my new Kotlin and Android development blog","uri":"https://carrion.dev/en/posts/welcome-to-my-new-kotlin-and-android-development-blog/"},{"content":"About. I\u0026rsquo;m Ignacio Carrión, I live in Valencia (Spain) and the one who appears on the avatar is my dog Wilfred. I like anything related to IT and videogames. At the moment I\u0026rsquo;m working as Android Engineer for Tkww. Before that I worked as Android Developer for other companies and I worked as a programming teacher. While I was working as a teacher, I realized that I love learning and helping others to learn with me. From this motivation arises the idea of this blog, Carrion.dev.\nI hope I can publish something interesting about Kotlin or Android ecosystem at least twice a month. Constructive criticism or ideas about posts will be welcomed. Below you can see the links to my social networks where you can find and contact me.\nContact Portfolio\nGithub\n","description":"Hugo, the world’s fastest framework for building websites","id":30,"section":"","tags":null,"title":"About","uri":"https://carrion.dev/en/about/"}]