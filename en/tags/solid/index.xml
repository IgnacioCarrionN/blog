<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>solid on Carrion.dev</title><link>https://carrion.dev/en/tags/solid/</link><description>Recent content in solid on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Fri, 22 Aug 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/en/tags/solid/index.xml" rel="self" type="application/rss+xml"/><item><title>Dependency Injection + Dependency Inversion: More Robust and Testable Code</title><link>https://carrion.dev/en/posts/dependency-injection-benefits/</link><pubDate>Fri, 22 Aug 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 22 Aug 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/dependency-injection-benefits/</guid><description>Dependency Injection + Dependency Inversion: More Robust and Testable Code Modern applications evolve quickly: features are added, platforms multiply, and teams scale. In this environment, tightly coupled code becomes a bottleneck for change and a source of fragile tests. Two key ideas help us fight this complexity:
Dependency Inversion Principle (DIP) from SOLID: high-level modules should not depend on low-level modules. Both should depend on abstractions. Dependency Injection (DI): a technique and set of tools to provide those dependencies from the outside instead of constructing them internally.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/dip.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>architecture</category><category>solid</category><category>dependency-injection</category><category>testing</category></item><item><title>Understanding SOLID Principles with Kotlin Examples</title><link>https://carrion.dev/en/posts/solid-kotlin/</link><pubDate>Wed, 08 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 08 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/solid-kotlin/</guid><description>Understanding SOLID Principles with Kotlin Examples The SOLID principles are a set of design principles that make software designs more understandable, flexible, and maintainable. Introduced by Robert C. Martin, these principles are a cornerstone of object-oriented programming and are especially relevant when building complex systems. In this blog post, we’ll explore each principle with examples written in Kotlin, a language that brings modern syntax and powerful features to the table.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/di-fix.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>solid</category><category>architecture</category></item></channel></rss>