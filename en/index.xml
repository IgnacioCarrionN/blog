<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>Carrion.dev</title><link>https://carrion.dev/en/</link><description>Recent content on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Tue, 22 Apr 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/en/index.xml" rel="self" type="application/rss+xml"/><item><title>Leveraging expect/actual in Kotlin Multiplatform for Native Implementations</title><link>https://carrion.dev/en/posts/expect-actual-kmp/</link><pubDate>Tue, 22 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 22 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/expect-actual-kmp/</guid><description>Leveraging expect/actual in Kotlin Multiplatform for Native Implementations Kotlin Multiplatform (KMP) has emerged as a powerful solution for sharing code across different platforms while still allowing for platform-specific implementations when needed. At the heart of this capability is the expect/actual mechanism, which enables developers to define a common API in shared code and provide platform-specific implementations. This blog post explores how to effectively use expect/actual to create robust multiplatform applications with native implementations.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/expect-actual-post.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>multiplatform</category><category>kmp</category></item><item><title>Leveraging Sealed Classes and Interfaces for Better Domain Modeling</title><link>https://carrion.dev/en/posts/sealed-classes-domain-modeling/</link><pubDate>Tue, 15 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 15 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/sealed-classes-domain-modeling/</guid><description>Leveraging Sealed Classes and Interfaces for Better Domain Modeling Domain modeling is a crucial aspect of software development, representing the core business concepts and rules in your application. Kotlin provides powerful language features that can help create more expressive, type-safe, and maintainable domain models. Among these features, sealed classes and interfaces stand out as particularly valuable tools. This blog post explores how to leverage these Kotlin features to build better domain models.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/sealed-classes.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category><category>domain modeling</category><category>type safety</category></item><item><title>Composition Over Inheritance: A Kotlin Perspective</title><link>https://carrion.dev/en/posts/composition-over-inheritance/</link><pubDate>Fri, 11 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 11 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/composition-over-inheritance/</guid><description>Composition Over Inheritance: A Kotlin Perspective In object-oriented programming, there are two primary ways to reuse code and establish relationships between classes: inheritance and composition. While both approaches have their place, the principle of &amp;ldquo;composition over inheritance&amp;rdquo; has gained significant traction in modern software design. This blog post explores both approaches, their trade-offs, and why composition is often the preferred choice, with examples in Kotlin.
Understanding Inheritance Inheritance is a mechanism where a class (subclass) can inherit properties and behaviors from another class (superclass).</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/composition-inheritance.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category><category>design patterns</category><category>object-oriented programming</category></item><item><title>Performance Optimization in Jetpack Compose</title><link>https://carrion.dev/en/posts/performance-optimization-compose/</link><pubDate>Tue, 08 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 08 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/performance-optimization-compose/</guid><description>Performance Optimization in Jetpack Compose Performance optimization is crucial for delivering a smooth user experience in Jetpack Compose applications. This article explores key techniques and best practices to ensure your composable functions are efficient and performant.
Understanding Composition and Recomposition One of the fundamental aspects of performance in Compose is understanding how composition and recomposition work:
Smart Recomposition Compose uses smart recomposition to update only the parts of the UI that need to change.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/remember-optimization.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>performance</category><category>optimization</category></item><item><title>Custom Animations and Transitions in Jetpack Compose</title><link>https://carrion.dev/en/posts/custom-animations-transitions-compose/</link><pubDate>Fri, 04 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 04 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/custom-animations-transitions-compose/</guid><description>Custom Animations and Transitions in Jetpack Compose Creating smooth, meaningful animations is crucial for delivering a polished user experience. This article explores how to create custom animations and transitions in Jetpack Compose, from basic animations to complex custom implementations.
Creating Custom Animations Custom animations allow for more complex and unique visual effects:
Custom Animation Specs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Composable fun CustomAnimatedButton( onClick: () -&amp;gt; Unit, content: @Composable () -&amp;gt; Unit ) { var isPressed by remember { mutableStateOf(false) } val scope = rememberCoroutineScope() val scale by animateFloatAsState( targetValue = if (isPressed) 0.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/pulsating-dot.gif" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>animation</category><category>transitions</category></item><item><title>Advanced State Management in Compose: Effects and Flows</title><link>https://carrion.dev/en/posts/advanced-state-management-compose/</link><pubDate>Tue, 01 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 01 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/advanced-state-management-compose/</guid><description>Advanced State Management in Compose: Effects and Flows This article explores advanced state management patterns in Jetpack Compose, focusing on Effects and Flow integration. For fundamental concepts like mutableStateOf and state hoisting, check out our companion article Basic State Management in Jetpack Compose.
Understanding Compose Effects Effects in Compose are tools to handle side effects and lifecycle events in a composable-friendly way. Let&amp;rsquo;s explore the different types of effects and their use cases:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/state-management-compose-advanced.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>state</category><category>flows</category><category>effects</category></item><item><title>State Management Patterns in Jetpack Compose</title><link>https://carrion.dev/en/posts/state-management-patterns-compose/</link><pubDate>Fri, 28 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 28 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/state-management-patterns-compose/</guid><description>State Management Patterns in Jetpack Compose State management is a crucial aspect of building robust and maintainable Jetpack Compose applications. This article explores essential patterns and best practices for managing state effectively in your Compose UI, including immutable state, event-based updates, and testing strategies.
Understanding State Management Patterns Effective state management in Compose requires understanding how to structure and handle state changes in a way that&amp;rsquo;s maintainable, testable, and scalable. This involves several key patterns:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/state-management-compose.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>patterns</category><category>state</category></item><item><title>Building Type-safe DSLs with Kotlin: From Basics to Advanced Patterns</title><link>https://carrion.dev/en/posts/building-type-safe-dsls/</link><pubDate>Tue, 25 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 25 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/building-type-safe-dsls/</guid><description>Building Type-safe DSLs with Kotlin: From Basics to Advanced Patterns Domain-Specific Languages (DSLs) in Kotlin allow you to create expressive, readable, and type-safe APIs. This article explores how to build effective DSLs using Kotlin&amp;rsquo;s powerful features, focusing on scope control with @DslMarker to prevent common mistakes in nested DSLs.
By the end of this article, you&amp;rsquo;ll understand:
How to design clean and intuitive DSL APIs When and how to use @DslMarker for better scope control Best practices for maintaining type safety throughout your DSL Common pitfalls and how to avoid them Basic DSL Concepts Let&amp;rsquo;s explore the fundamental concepts of Kotlin DSLs by building a simple HTML builder:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/type-safe-dsls.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>dsl</category><category>type-safety</category><category>design-patterns</category></item><item><title>Advanced Generics and Variance in Kotlin: A Comprehensive Guide</title><link>https://carrion.dev/en/posts/advanced-kotlin-generics/</link><pubDate>Fri, 21 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 21 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/advanced-kotlin-generics/</guid><description>Advanced Generics and Variance in Kotlin: A Comprehensive Guide Understanding advanced generics and variance in Kotlin is crucial for writing type-safe, reusable code. This article explores these concepts in depth, providing practical examples and real-world applications.
Understanding Variance Variance in Kotlin determines how generic types with different type arguments relate to each other. Understanding variance is easier when thinking in terms of producers and consumers:
Producer: Only produces/provides values of type T (output) Consumer: Only consumes/accepts values of type T (input) This producer/consumer relationship directly maps to the two types of variance:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/advanced-generics.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>generics</category><category>variance</category><category>type-safety</category></item><item><title>Flow Composition Patterns: Combining Multiple Flows Effectively</title><link>https://carrion.dev/en/posts/flow-composition-patterns/</link><pubDate>Tue, 18 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 18 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/flow-composition-patterns/</guid><description>Flow Composition Patterns: Combining Multiple Flows Effectively When working with Kotlin Flows in real-world applications, you often need to combine multiple data streams to create more complex workflows. This article explores various Flow composition patterns and best practices for effectively combining multiple Flows.
Understanding Flow Composition Flow composition is the process of combining multiple Flows to create a new Flow that represents a more complex data stream. Kotlin provides several operators for Flow composition, each serving different use cases.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/flow-composition.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>coroutines</category><category>flows</category><category>patterns</category></item><item><title>Understanding Flow Operators: Buffer, Conflate, Debounce, and Sample</title><link>https://carrion.dev/en/posts/flow-operators-buffer-conflate/</link><pubDate>Fri, 14 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 14 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/flow-operators-buffer-conflate/</guid><description>Understanding Flow Operators: Buffer, Conflate, Debounce, and Sample When working with Kotlin Flows, especially in scenarios involving fast-emitting producers and slow collectors, it&amp;rsquo;s crucial to understand how to manage the flow of data effectively. This post explores four essential Flow operators that help handle such scenarios: buffer, conflate, debounce, and sample.
The Problem: Slow Collectors Before diving into the operators, let&amp;rsquo;s understand the problem they solve. Consider this scenario:
1 2 3 4 5 6 7 8 9 flow { for (i in 1.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev//images/kotlin/flow-operators.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>flows</category><category>coroutines</category></item><item><title>Converting Callbacks to Coroutines and Flows in Kotlin</title><link>https://carrion.dev/en/posts/callback-to-flow-conversion/</link><pubDate>Tue, 11 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 11 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/callback-to-flow-conversion/</guid><description>Converting Callbacks to Coroutines and Flows in Kotlin Callback-based APIs have been a common pattern in asynchronous programming for many years. However, with Kotlin&amp;rsquo;s coroutines and flows, we can transform these callbacks into more modern, sequential code that&amp;rsquo;s easier to read and maintain. In this article, we&amp;rsquo;ll explore how to use suspendCoroutine and callbackFlow to convert callback-based APIs into coroutines and flows.
Understanding suspendCoroutine The suspendCoroutine function is a powerful tool that allows you to wrap callback-based APIs into suspend functions.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/suspend-coroutine.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>coroutines</category><category>flows</category><category>callbacks</category></item><item><title>Understanding Hot and Cold Flows in Kotlin</title><link>https://carrion.dev/en/posts/kotlin-flows-hot-cold/</link><pubDate>Fri, 07 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 07 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-flows-hot-cold/</guid><description>Understanding Hot and Cold Flows in Kotlin Kotlin Flow is a powerful feature for handling reactive streams of data. One of the fundamental concepts to understand when working with flows is the distinction between hot and cold flows. This article will explain the differences and provide practical examples of both types.
Cold Flows: The Default Behavior Cold flows are the default type in Kotlin Flow. They start producing values only when a collector starts collecting from them.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/flows.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>coroutines</category><category>flows</category></item><item><title>Achieving Compile-Time Safety in Koin: A Comprehensive Guide</title><link>https://carrion.dev/en/posts/koin-compile-safety/</link><pubDate>Tue, 04 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 04 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/koin-compile-safety/</guid><description>Achieving Compile-Time Safety in Koin: A Comprehensive Guide Dependency injection is a fundamental pattern in modern Android development, but how can we ensure our DI configuration is correct before running the app? In this post, we&amp;rsquo;ll explore two powerful approaches to achieve compile-time safety with Koin: using the DSL&amp;rsquo;s verify() function and leveraging Koin Annotations with KSP.
The Problem: Runtime vs. Compile-Time Validation Traditional dependency injection often reveals configuration issues only at runtime:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-ksp-config.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>koin</category></item><item><title>Reliable Timekeeping with the TrustedTime API in Android</title><link>https://carrion.dev/en/posts/trusted-time-api/</link><pubDate>Wed, 19 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 19 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/trusted-time-api/</guid><description>Reliable Timekeeping with the TrustedTime API in Android Accurate timekeeping is crucial for many app functionalities, including scheduling, transaction logging, and security. However, relying on a device&amp;rsquo;s system clock can be problematic since users can alter their device’s time settings. To address this, Google has introduced the TrustedTime API, providing a reliable and tamper-resistant time source for Android apps.
Understanding the TrustedTime API The TrustedTime API leverages Google&amp;rsquo;s secure infrastructure to offer a trustworthy timestamp, independent of the device&amp;rsquo;s local time settings.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/trusted-time-api.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>google</category></item><item><title>Kotlin Multiplatform Architecture Best Practices for Mobile Apps</title><link>https://carrion.dev/en/posts/kmp-architecture/</link><pubDate>Tue, 11 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 11 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kmp-architecture/</guid><description>Kotlin Multiplatform Architecture Best Practices for Mobile Apps Kotlin Multiplatform (KMP) allows developers to share business logic between Android and iOS while keeping platform-specific implementations where necessary. Structuring a KMP project efficiently is key to maintaining scalability, testability, and clean architecture. In this guide, we’ll explore best practices for architecting a KMP mobile application with Compose Multiplatform and Clean Architecture.
1. Project Structure A well-organized project structure improves maintainability and separation of concerns.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/expect-actual.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>compose</category><category>cmp</category><category>multiplatform</category><category>cleancode</category><category>architecture</category></item><item><title>Mocks, Fakes, and More</title><link>https://carrion.dev/en/posts/test-doubles/</link><pubDate>Thu, 06 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 06 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/test-doubles/</guid><description>Mocks, Fakes, and More: Understanding Test Doubles in Kotlin When writing tests in Kotlin, especially for Android development, we often need to replace real dependencies with test doubles. However, not all test doubles are the same—terms like mocks, fakes, stubs, spies, and dummies often come up. In this post, we’ll break down their differences with Kotlin examples using only plain Kotlin (no third-party libraries).
1. Understanding Test Doubles Test doubles are objects that stand in for real dependencies in tests.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/mock.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>testing</category><category>mock</category><category>tdd</category></item><item><title>Testing in Compose Multiplatform (CMP) from Common Code</title><link>https://carrion.dev/en/posts/cmp-ui-testing/</link><pubDate>Mon, 03 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 03 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/cmp-ui-testing/</guid><description>Testing in Compose Multiplatform (CMP) from Common Code Compose Multiplatform (CMP) enables building UI for multiple platforms using Jetpack Compose. Fortunately, CMP also supports writing and running UI tests in the common code, making testing more efficient across platforms. In this post, we’ll explore how to test CMP applications using compose.uiTest and run them on Android, Desktop, and iOS.
1. Setting Up Common UI Testing CMP provides compose.uiTest, allowing UI tests to be written in the shared module without platform-specific dependencies.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/compose-test.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>compose</category><category>cmp</category><category>multiplatform</category></item><item><title>Exploring Kotlin’s Immutable Collections Library</title><link>https://carrion.dev/en/posts/immutable-collections/</link><pubDate>Thu, 30 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 30 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/immutable-collections/</guid><description>Exploring Kotlin’s Immutable Collections Library Kotlin&amp;rsquo;s standard collections (List, Set, Map) are mutable by default, which can lead to unintended modifications. To enforce immutability at the API level, JetBrains introduced the Kotlin Immutable Collections library. This library provides a set of truly immutable collection types that prevent accidental modifications and enhance safety in concurrent or multi-threaded environments.
Why Use Immutable Collections? While Kotlin already has listOf(), setOf(), and mapOf() for read-only collections, they are not truly immutable.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/readonly-list.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>collections</category><category>compose</category></item><item><title>Boosting Android App Performance with Baseline Profiles</title><link>https://carrion.dev/en/posts/baseline-profiles/</link><pubDate>Mon, 27 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 27 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/baseline-profiles/</guid><description>Boosting Android App Performance with Baseline Profiles Introduction In today’s fast-paced mobile world, users expect apps to launch instantly and run smoothly. Performance optimization is crucial, especially concerning app startup time and runtime execution.
Android’s Baseline Profiles offer an effective way to speed up app startup and improve runtime performance by precompiling critical code paths. Google Play even recommends using Baseline Profiles to enhance the user experience, particularly for apps with complex UI rendering or heavy dependencies.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/baseline-profile.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Modularization in Gradle Projects with Kotlin</title><link>https://carrion.dev/en/posts/gradle-modularization/</link><pubDate>Thu, 23 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 23 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/gradle-modularization/</guid><description>Modularization in Gradle Projects with Kotlin: A Comprehensive Guide Introduction As projects grow in complexity, maintaining a monolithic codebase becomes challenging. Modularization is a software design technique that breaks down an application into smaller, independent modules, making the project more scalable, maintainable, and efficient.
In this guide, we’ll explore why modularization is essential, different types of modules, and best practices for setting up a modular Gradle project using Kotlin.
Why Modularization?</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/folder-structure.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Test-Driven Development (TDD) in Kotlin for Android</title><link>https://carrion.dev/en/posts/tdd-kotlin/</link><pubDate>Mon, 20 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 20 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/tdd-kotlin/</guid><description>Test-Driven Development (TDD) in Kotlin for Android Test-Driven Development (TDD) is a software development practice that emphasizes writing tests before implementing functionality. It follows a Red-Green-Refactor cycle: first, you write a failing test (Red), then implement just enough code to make it pass (Green), and finally, refactor the code while keeping the test green (Refactor). In this post, we&amp;rsquo;ll explore how to apply TDD in Kotlin for Android development using JUnit, MockK, and Coroutines with a real-world example.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/tdd-cycle.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category><category>TDD</category><category>testing</category></item><item><title>Clean Architecture in Kotlin &amp; Android</title><link>https://carrion.dev/en/posts/clean-architecture/</link><pubDate>Sat, 18 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Sat, 18 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/clean-architecture/</guid><description>Clean Architecture in Kotlin &amp;amp; Android Introduction When building Android applications, maintaining scalability and readability is crucial. Without a clear architectural approach, projects can become difficult to maintain as they grow. This is where Clean Architecture, introduced by Uncle Bob (Robert C. Martin), becomes invaluable. It emphasizes separation of concerns, making code more modular, testable, and maintainable.
Understanding Clean Architecture Clean Architecture is structured into three main layers, each with a specific role:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/domain-layer.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Exploring App Architectures in Kotlin</title><link>https://carrion.dev/en/posts/app-architecture/</link><pubDate>Wed, 15 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 15 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/app-architecture/</guid><description>Exploring App Architectures in Kotlin: MVC, MVP, MVVM, and MVI Introduction In modern app development, choosing the right architecture is essential for creating maintainable and scalable applications. Architectures define how your codebase is organized and how different components interact. In this post, we’ll explore four popular app architectures: Model-View-Controller (MVC), Model-View-Presenter (MVP), Model-View-ViewModel (MVVM), and Model-View-Intent (MVI). We’ll look at their structure, pros, cons, and practical examples in Kotlin.
1. Model-View-Controller (MVC) Definition:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/mvvm.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Kotlin Design Patterns - Part 3</title><link>https://carrion.dev/en/posts/design-patterns-3/</link><pubDate>Mon, 13 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 13 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/design-patterns-3/</guid><description>Exploring More Design Patterns in Kotlin: Part 3 Design Patterns Series Part 1 Part 2 Part 3 In this third installment, we’ll cover Memento, Command, Visitor, Chain of Responsibility, and Mediator patterns. These patterns address construction, behavioral, and structural challenges, showcasing Kotlin&amp;rsquo;s expressive syntax and modern features.
1. Memento Pattern The Memento Pattern captures and restores an object&amp;rsquo;s state without exposing its internal details.
When to Use To implement undo/redo functionality.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/memento-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item><item><title>Understanding SOLID Principles with Kotlin Examples</title><link>https://carrion.dev/en/posts/solid-kotlin/</link><pubDate>Wed, 08 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 08 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/solid-kotlin/</guid><description>Understanding SOLID Principles with Kotlin Examples The SOLID principles are a set of design principles that make software designs more understandable, flexible, and maintainable. Introduced by Robert C. Martin, these principles are a cornerstone of object-oriented programming and are especially relevant when building complex systems. In this blog post, we’ll explore each principle with examples written in Kotlin, a language that brings modern syntax and powerful features to the table.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/di-fix.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>solid</category><category>architecture</category></item><item><title>Kotlin Design Patterns - Part 2</title><link>https://carrion.dev/en/posts/design-patterns-2/</link><pubDate>Mon, 06 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 06 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/design-patterns-2/</guid><description>Exploring Design Patterns in Kotlin: Part 2 Design Patterns Series Part 1 Part 2 Part 3 After the overwhelming response to our first post on Kotlin design patterns, we’re back with more! In this second part, we’ll dive into Prototype, Composite, Proxy, Observer, and Strategy patterns. These patterns solve a variety of design challenges and demonstrate Kotlin’s expressive capabilities.
1. Prototype Pattern The Prototype Pattern is used to create new objects by copying an existing object, ensuring efficient object creation.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/proxy-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item><item><title>Using Koin in Compose Multiplatform</title><link>https://carrion.dev/en/posts/koin-cmp/</link><pubDate>Thu, 02 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 02 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/koin-cmp/</guid><description>Using Koin in Compose Multiplatform Dependency injection is a must-have for scalable applications, and Koin makes it straightforward, even in Compose Multiplatform projects. With the new KoinApplication composable function, you can initialize Koin directly from commonMain code, reducing boilerplate while maintaining platform-specific flexibility. Let’s walk through an example.
Project Setup Start by creating a Compose Multiplatform project using the KMP Wizard, selecting Android, iOS, Desktop, and Web targets. For this example, we won’t include a server target.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-cmp.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>multiplatform</category><category>cmp</category><category>compose</category><category>koin</category></item><item><title>Kotlin Design Patterns - Part 1</title><link>https://carrion.dev/en/posts/design-patterns-1/</link><pubDate>Mon, 30 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 30 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/design-patterns-1/</guid><description>Exploring Design Patterns in Kotlin - Part 1 Design Patterns Series Part 1 Part 2 Part 3 Design patterns are proven solutions to common problems in software design. With Kotlin’s expressive syntax and modern features, implementing these patterns often becomes cleaner and more concise. In this post, we’ll explore Singleton, Factory Method, Builder, Adapter and Decorator patterns, delving into their purpose, use cases, and Kotlin implementations.
1. Singleton Pattern The Singleton Pattern ensures that a class has only one instance and provides a global access point to it.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/singleton-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item><item><title>A deep dive into Kotlin KSP</title><link>https://carrion.dev/en/posts/kotlin-ksp/</link><pubDate>Fri, 27 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 27 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-ksp/</guid><description>A Deep Dive into Kotlin Symbol Processing (KSP) with Practical Examples Kotlin Symbol Processing (KSP) is a powerful tool introduced to streamline annotation processing in Kotlin. Compared to kapt (Kotlin Annotation Processing Tool), KSP is faster, offers better integration with Kotlin, and reduces build times significantly. In this post, we’ll explore the fundamentals of KSP, discuss how it works, and demonstrate its use with popular libraries like Koin and Room.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-annotations.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Kotlin Infix functions</title><link>https://carrion.dev/en/posts/kotlin-infix/</link><pubDate>Thu, 26 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 26 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-infix/</guid><description>Exploring Kotlin Infix Functions: A Deep Dive Kotlin, as a modern programming language, is packed with features that make code expressive and concise. One of these features is infix functions, which allow you to write cleaner and more readable code. In this blog post, we&amp;rsquo;ll explore what infix functions are, how to use them, and some practical use cases.
What Are Infix Functions? Infix functions in Kotlin are a special kind of function that can be called without using parentheses or the dot operator.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-infix.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Kotlin Delegates</title><link>https://carrion.dev/en/posts/kotlin-delegates/</link><pubDate>Mon, 23 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 23 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-delegates/</guid><description>✨ Understanding Kotlin Delegates: The Magic Behind Cleaner Code ✨ Kotlin delegates are a powerful feature that lets you delegate the behavior of a property or even an interface implementation to another object. Instead of writing repetitive logic or managing state directly, you can delegate this responsibility to reusable and specialized classes.
How Delegates Work Delegates in Kotlin work by using the by keyword, which redirects the behavior of a property or an interface to a delegate object.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-delegate.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Kotlin contracts</title><link>https://carrion.dev/en/posts/kotlin-contracts/</link><pubDate>Fri, 20 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 20 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-contracts/</guid><description>Mastering Kotlin Contracts: Unlocking Smarter Code Analysis Kotlin never ceases to amaze with its features that combine elegance and power. One advanced yet often underutilized tool in Kotlin&amp;rsquo;s arsenal is Contracts. Contracts let you guide the Kotlin compiler to make smarter decisions about your code—resulting in better null safety, optimized performance, and fewer runtime errors.
What Are Kotlin Contracts? Kotlin Contracts allow you to define rules about how your functions behave, helping the compiler perform advanced static analysis.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/kotlin-contract.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Swift export in KMP</title><link>https://carrion.dev/en/posts/swift-export/</link><pubDate>Wed, 18 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 18 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/swift-export/</guid><description>Swift export in Kmp Starting from version 2.1.0 we can start testing the Swift export in Kotlin. This feature allows you to export the Kotlin shared modules to Swift without the use of Objective-C. This will improve the iOS developers experience when using KMP modules.
At the moment basic support includes:
Export multiple Gradle modules to Swift. Define the Swift module names. Flatten package structure Enable the feature To start testing this functionality you should enable it on gradle.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/swift-export.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>kmp</category></item><item><title>Guard conditions in when starting in Kotlin 2.1.0.</title><link>https://carrion.dev/en/posts/kotlin-guard-conditions-in-when/</link><pubDate>Tue, 17 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 17 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/en/posts/kotlin-guard-conditions-in-when/</guid><description>Guard conditions in when in Kotlin 2.1.0 One of the new features in Kotlin 2.1.0 is the guard conditions on when expressions, this feature will bring some advantages like:
Reduce nesting Avoid boilerplate Improve readability Enable the feature This feature is in preview state, for this you need to enable it starting on Kotlin 2.1.0. In the file build.gradle.kts we should add the new piece of code inside the kotlin block:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/guard-when-new.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>kmp</category></item><item><title>Hilt: Inject Runtime parameters to ViewModels.</title><link>https://carrion.dev/en/posts/hilt-inject-parameters-runtime/</link><pubDate>Wed, 24 Feb 2021 07:00:06 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 24 Feb 2021 07:00:06 +0100</atom:modified><guid>https://carrion.dev/en/posts/hilt-inject-parameters-runtime/</guid><description>Inject runtime parameters with Dagger-Hilt Since Hilt appeared to make it easier the dependency injection in Android, it was impossible to inject runtime parameters without using third party libraries. Since Dagger version 2.31, exists the @AssistedInject annotation. With this annotation we can instruct Dagger-Hilt what dependencies need to be created at runtime and delay the injection of this parameters until we can provide those values.
This is necessary to inject parameters into ViewModel constructor and be able to execute some code in the init function.</description><dc:creator>Ignacio</dc:creator><media:content url="https://carrion.dev/images/kotlin/kotlin-logo.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>jetpack</category><category>coroutines</category><category>androidx</category></item><item><title>Welcome to my new Kotlin and Android development blog</title><link>https://carrion.dev/en/posts/welcome-to-my-new-kotlin-and-android-development-blog/</link><pubDate>Tue, 23 Feb 2021 10:00:06 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 23 Feb 2021 10:00:06 +0100</atom:modified><guid>https://carrion.dev/en/posts/welcome-to-my-new-kotlin-and-android-development-blog/</guid><description>Welcome to Carrion.dev Hi droid!
Welcome to my new Kotlin and Android programming blog. I am Ignacio Carrión and I&amp;rsquo;m an Android developer. I love Kotlin because it boost my Android development eficiency and because it has infinite posibilities outside of Android ecosystem (backend, web, native, multiplatform&amp;hellip;).
In this blog I hope I can publish interesting topics about Kotlin and Android at least twice a month. If you want to keep up to date you can subscribe to our newsletter.</description><dc:creator>Ignacio</dc:creator><category>kotlin</category><category>android</category><category>jetpack</category><category>coroutines</category><category>androidx</category></item></channel></rss>