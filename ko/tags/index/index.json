[{"content":"Explorando Arquitecturas de Apps en Kotlin: MVC, MVP, MVVM y MVI Introducci贸n En el desarrollo moderno de aplicaciones, elegir la arquitectura adecuada es esencial para crear aplicaciones mantenibles y escalables. Las arquitecturas definen c贸mo se organiza tu base de c贸digo y c贸mo interact煤an los diferentes componentes. En este art铆culo, exploraremos cuatro arquitecturas populares: Model-View-Controller (MVC), Model-View-Presenter (MVP), Model-View-ViewModel (MVVM) y Model-View-Intent (MVI). Analizaremos su estructura, ventajas, desventajas y ejemplos pr谩cticos en Kotlin.\n1. Model-View-Controller (MVC) Definici贸n:\nMVC divide una aplicaci贸n en tres componentes:\n Model: Gestiona los datos y la l贸gica de negocio. View: Muestra los datos al usuario, accediendo directamente al Model para actualizaciones. Controller: Maneja la entrada del usuario y actualiza el Model.  Ventajas:\n Simple de implementar y entender. Eficaz para aplicaciones peque帽as o prototipos.  Desventajas:\n Acoplamiento estrecho entre la View y el Model. Separaci贸n limitada de preocupaciones; escalar puede ser desafiante.  Ejemplo en Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // Model data class User(var name: String, var age: Int) // View class UserView { fun displayUser(user: User) { println(\u0026#34;Name: ${user.name}, Age: ${user.age}\u0026#34;) } } // Controller class UserController(private val model: User, private val view: UserView) { fun handleUserInput() { println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; model.name = newName // Directly updates the model  view.displayUser(model) } } fun main() { val user = User(\u0026#34;Alice\u0026#34;, 30) val view = UserView() val controller = UserController(user, view) view.displayUser(user) controller.handleUserInput() }   2. Model-View-Presenter (MVP) Definici贸n:\nEn MVP, el Presenter act煤a como mediador entre el Model y la View. A diferencia de MVC, la View es pasiva y delega toda la l贸gica de interacci贸n al Presenter, quien obtiene datos del Model y actualiza la View.\nVentajas:\n Mejor separaci贸n de preocupaciones en comparaci贸n con MVC. M谩s f谩cil de probar, ya que el Presenter maneja toda la l贸gica.  Desventajas:\n Las clases de Presenter pueden volverse grandes (\u0026ldquo;clases Dios\u0026rdquo;). Manejar eventos del ciclo de vida puede ser desafiante.  Ejemplo en Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // Model data class User(val name: String, val age: Int) // View Interface interface UserView { fun displayUser(name: String, age: Int) } // Presenter class UserPresenter(private val view: UserView) { private var user = User(\u0026#34;Bob\u0026#34;, 25) fun loadUser() { view.displayUser(user.name, user.age) } fun updateUser() { println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; user = user.copy(name = newName) view.displayUser(user.name, user.age) } } // View Implementation class ConsoleUserView : UserView { override fun displayUser(name: String, age: Int) { println(\u0026#34;Name: $name, Age: $age\u0026#34;) } } fun main() { val view = ConsoleUserView() val presenter = UserPresenter(view) presenter.loadUser() presenter.updateUser() }   3. Model-View-ViewModel (MVVM) Definici贸n:\nMVVM promueve un enfoque reactivo. El ViewModel proporciona datos a la View y reacciona a los cambios en el Model. A menudo utiliza LiveData o StateFlow de Kotlin.\nVentajas:\n Fomenta una clara separaci贸n de preocupaciones. Excelente para programaci贸n reactiva utilizando corutinas o flujos.  Desventajas:\n Requiere familiaridad con paradigmas reactivos. El enlace de datos o la gesti贸n de estados puede agregar complejidad.  Ejemplo en Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // Model data class User(val name: String, val age: Int) // ViewModel class UserViewModel { private val _user = MutableStateFlow(User(\u0026#34;Charlie\u0026#34;, 28)) val user = _user.asStateFlow() fun updateUser(name: String) { _user.value = _user.value.copy(name = name) } } // View class UserView(private val viewModel: UserViewModel) { fun render() { viewModel.user.collect { user -\u0026gt; println(\u0026#34;Name: ${user.name}, Age: ${user.age}\u0026#34;) } } fun getUserInput(): String { println(\u0026#34;Enter new name for the user:\u0026#34;) return readLine() ?: \u0026#34;\u0026#34; } fun updateUserName() { val newName = getUserInput() viewModel.updateUser(newName) } } fun main() = runBlocking { val viewModel = UserViewModel() val view = UserView(viewModel) view.render() view.updateUserName() }   4. Model-View-Intent (MVI) Definici贸n:\nMVI utiliza un flujo de datos unidireccional. La View env铆a intenciones del usuario, el Model las procesa, y el estado se actualiza y es renderizado por la View.\nVentajas:\n Gesti贸n de estado predecible. Fomenta la inmutabilidad y un flujo de datos claro.  Desventajas:\n Curva de aprendizaje pronunciada. Sobrecarga para aplicaciones simples.  Ejemplo en Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  // Model data class UserState(val name: String = \u0026#34;\u0026#34;, val age: Int = 0) // Intent sealed class UserIntent { object LoadUser : UserIntent() data class UpdateUser(val name: String) : UserIntent() } // Reducer fun userReducer(currentState: UserState, intent: UserIntent): UserState { return when (intent) { is UserIntent.LoadUser -\u0026gt; UserState(name = \u0026#34;Dave\u0026#34;, age = 40) is UserIntent.UpdateUser -\u0026gt; currentState.copy(name = intent.name) } } // ViewModel class UserViewModel { private val _state = MutableStateFlow(UserState()) val state: StateFlow\u0026lt;UserState\u0026gt; = _state fun processIntent(intent: UserIntent) { _state.update { currentState -\u0026gt; userReducer(currentState, intent) } } } // View class UserView(private val viewModel: UserViewModel) { fun render() { viewModel.state.collect { state -\u0026gt; println(\u0026#34;Name: ${state.name}, Age: ${state.age}\u0026#34;) } } fun sendIntent(intent: UserIntent) { viewModel.processIntent(intent) } } fun main() = runBlocking { val viewModel = UserViewModel() val view = UserView(viewModel) view.sendIntent(UserIntent.LoadUser) view.render() println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; view.sendIntent(UserIntent.UpdateUser(newName)) }   Conclusi贸n Cada arquitectura tiene sus fortalezas y compromisos:\n MVC: Mejor para aplicaciones peque帽as y simples. MVP: Equilibra estructura y simplicidad. MVVM: Ideal para programaci贸n reactiva. MVI: Excelente para la gesti贸n de estado predecible y escalable.  Considera la complejidad y los requisitos de tu proyecto al elegir una arquitectura. 驴Cu谩l prefieres t煤?\n","description":"Explorando Arquitecturas de Apps en Kotlin: MVC, MVP, MVVM y MVI","id":2,"section":"es","tags":["kotlin","architecture"],"title":"Explorando Arquitecturas de Apps en Kotlin","uri":"https://carrion.dev/ko/es/posts/app-architecture/"},{"content":"Explorando M谩s Patrones de Dise帽o en Kotlin: Parte 3  Part 1 Part 2 Part 3  En esta tercera entrega, cubriremos los patrones Memento, Command, Visitor, Chain of Responsibility y Mediator. Estos patrones abordan desaf铆os de construcci贸n, comportamiento y estructura, mostrando la sintaxis expresiva y las caracter铆sticas modernas de Kotlin.\n1. Patr贸n Memento El Patr贸n Memento captura y restaura el estado de un objeto sin exponer sus detalles internos.\nCu谩ndo Usar  Para implementar funcionalidad de deshacer/rehacer.  Implementaci贸n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  class Editor { var content: String = \u0026#34;\u0026#34; fun createMemento(): Memento = Memento(content) fun restore(memento: Memento) { content = memento.state } data class Memento(val state: String) } class History { private val mementos = mutableListOf\u0026lt;Editor.Memento\u0026gt;() fun save(memento: Editor.Memento) { mementos.add(memento) } fun pop(): Editor.Memento? { if (mementos.isNotEmpty()) { return mementos.removeAt(mementos.lastIndex) } return null } } fun main() { val editor = Editor() val history = History() editor.content = \u0026#34;First Version\u0026#34; history.save(editor.createMemento()) editor.content = \u0026#34;Second Version\u0026#34; history.save(editor.createMemento()) editor.content = \u0026#34;Third Version\u0026#34; println(\u0026#34;Current Content: ${editor.content}\u0026#34;) editor.restore(history.pop()!!) println(\u0026#34;Restored Content: ${editor.content}\u0026#34;) editor.restore(history.pop()!!) println(\u0026#34;Restored Content: ${editor.content}\u0026#34;) }   Por Qu茅 Kotlin? La sintaxis concisa de Kotlin facilita la captura y restauraci贸n de estados.\n2. Patr贸n Command El Patr贸n Command encapsula una solicitud como un objeto, permitiendo la parametrizaci贸n y el encolado.\nCu谩ndo Usar  Para implementar operaciones deshacibles o colas de comandos.  Implementaci贸n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  interface Command { fun execute() } class Light { fun on() = println(\u0026#34;Light is ON\u0026#34;) fun off() = println(\u0026#34;Light is OFF\u0026#34;) } class LightOnCommand(private val light: Light) : Command { override fun execute() = light.on() } class LightOffCommand(private val light: Light) : Command { override fun execute() = light.off() } fun main() { val light = Light() val commands = listOf(LightOnCommand(light), LightOffCommand(light)) commands.forEach { it.execute() } }   Por Qu茅 Kotlin? El enfoque funcional de Kotlin puede simplificar a煤n m谩s la ejecuci贸n de comandos.\n3. Patr贸n Visitor El Patr贸n Visitor separa un algoritmo de la estructura de objetos sobre la que opera, moviendo el algoritmo a un objeto visitante.\nCu谩ndo Usar  Cuando necesitas realizar operaciones en un conjunto de objetos con tipos variados.  Implementaci贸n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  interface Shape { fun accept(visitor: ShapeVisitor) } class Circle(val radius: Double) : Shape { override fun accept(visitor: ShapeVisitor) { visitor.visit(this) } } class Rectangle(val width: Double, val height: Double) : Shape { override fun accept(visitor: ShapeVisitor) { visitor.visit(this) } } fun interface ShapeVisitor { fun visit(shape: Shape) } fun main() { val shapes: List\u0026lt;Shape\u0026gt; = listOf(Circle(5.0), Rectangle(4.0, 6.0)) val visitor = ShapeVisitor { shape -\u0026gt; when (shape) { is Circle -\u0026gt; println(\u0026#34;Circle with radius ${shape.radius}\u0026#34;) is Rectangle -\u0026gt; println(\u0026#34;Rectangle with width ${shape.width}and height ${shape.height}\u0026#34;) } } shapes.forEach { it.accept(visitor) } }   Por Qu茅 Kotlin? Las fun interface y las clases selladas de Kotlin simplifican la implementaci贸n del visitante.\n4. Patr贸n Chain of Responsibility El Patr贸n Chain of Responsibility pasa una solicitud a lo largo de una cadena de manejadores hasta que uno la procesa.\nCu谩ndo Usar  Cuando m煤ltiples objetos pueden manejar una solicitud y el handler se determina en tiempo de ejecuci贸n.  Implementaci贸n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  interface Handler { fun handle(request: String): Boolean } class AuthHandler(private val next: Handler?) : Handler { override fun handle(request: String): Boolean { println(\u0026#34;AuthHandler processing...\u0026#34;) return next?.handle(request) ?: true } } class LoggingHandler(private val next: Handler?) : Handler { override fun handle(request: String): Boolean { println(\u0026#34;LoggingHandler processing...\u0026#34;) return next?.handle(request) ?: true } } fun main() { val chain = AuthHandler(LoggingHandler(null)) chain.handle(\u0026#34;Request\u0026#34;) }   Por Qu茅 Kotlin? Los tipos nulos de Kotlin y su delegaci贸n concisa simplifican el encadenamiento de handlers.\n5. Patr贸n Mediator El Patr贸n Mediator centraliza la comunicaci贸n compleja entre m煤ltiples objetos haciendo que se comuniquen a trav茅s de un mediador.\nCu谩ndo Usar  Cuando los objetos interact煤an de manera compleja, lo que lleva a dependencias enredadas.  Implementaci贸n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class Mediator { private val colleagues = mutableListOf\u0026lt;Colleague\u0026gt;() fun addColleague(colleague: Colleague) { colleagues.add(colleague) } fun broadcast(sender: Colleague, message: String) { colleagues.filter { it != sender } .forEach { it.receive(message) } } } interface Colleague { fun send(message: String) fun receive(message: String) } class ConcreteColleague(private val mediator: Mediator) : Colleague { override fun send(message: String) { println(\u0026#34;Sending message: $message\u0026#34;) mediator.broadcast(this, message) } override fun receive(message: String) { println(\u0026#34;Received message: $message\u0026#34;) } } fun main() { val mediator = Mediator() val colleague1 = ConcreteColleague(mediator) val colleague2 = ConcreteColleague(mediator) mediator.addColleague(colleague1) mediator.addColleague(colleague2) colleague1.send(\u0026#34;Hello from Colleague 1\u0026#34;) }   Por Qu茅 Kotlin? Las funciones de primera clase y las colecciones de Kotlin simplifican la difusi贸n y la interacci贸n.\nConclusi贸n Estos patronesMemento, Command, Visitor, Chain of Responsibility y Mediatordemuestran la capacidad de Kotlin para mejorar patrones de dise帽o cl谩sicos con caracter铆sticas modernas.\n驴Cu谩l de estos patrones encuentras m谩s interesante? 隆H谩zmelo saber! \n","description":"Kotlin Design Patterns - Part 3","id":3,"section":"es","tags":["kotlin","design-patterns","architecture"],"title":"Kotlin Design Patterns - Part 3","uri":"https://carrion.dev/ko/es/posts/design-patterns-3/"},{"content":"Entendiendo los principios SOLID con ejemplos en Kotlin Los principios SOLID son un conjunto de principios de dise帽o que hacen que los dise帽os de software sean m谩s comprensibles, flexibles y mantenibles. Introducidos por Robert C. Martin, estos principios son una piedra angular de la programaci贸n orientada a objetos y son especialmente relevantes al construir sistemas complejos. En este blog, exploraremos cada principio con ejemplos escritos en Kotlin, un lenguaje que ofrece una sintaxis moderna y caracter铆sticas poderosas.\n1. Principio de Responsabilidad nica (SRP) Una clase debe tener una, y solo una, raz贸n para cambiar.\nEste principio asegura que una clase tenga una 煤nica responsabilidad, lo que la hace m谩s f谩cil de mantener y menos propensa a errores.\nRompiendo SRP:\n1 2 3 4 5 6 7 8 9 10 11  class ReportManager { fun generateReport(data: String): String { // L贸gica para generar reporte  return \u0026#34;Report: $data\u0026#34; } fun saveReport(report: String) { // L贸gica para guardar reporte  println(\u0026#34;Report saved: $report\u0026#34;) } }   En este ejemplo, la clase ReportManager viola el SRP porque tiene dos responsabilidades: generar y guardar reportes. Cualquier cambio en la l贸gica de generaci贸n o de guardado requerir铆a modificar la misma clase.\nCorrigiendo SRP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class ReportGenerator { fun generateReport(data: String): String { // L贸gica para generar reporte  return \u0026#34;Report: $data\u0026#34; } } class ReportSaver { fun saveReport(report: String) { // L贸gica para guardar reporte  println(\u0026#34;Report saved: $report\u0026#34;) } } fun main() { val generator = ReportGenerator() val saver = ReportSaver() val report = generator.generateReport(\u0026#34;Sales Data\u0026#34;) saver.saveReport(report) }   Separando responsabilidades, hacemos que cada clase est茅 enfocada y sea m谩s f谩cil de probar de manera independiente.\n2. Principio Abierto/Cerrado (OCP) Las entidades de software deben estar abiertas para extensi贸n, pero cerradas para modificaci贸n.\nPuedes a帽adir nueva funcionalidad extendiendo clases sin cambiar el c贸digo existente.\nRompiendo OCP:\n1 2 3 4 5 6 7 8 9  class Discount { fun calculate(price: Double, type: String): Double { return when (type) { \u0026#34;none\u0026#34; -\u0026gt; price \u0026#34;percentage\u0026#34; -\u0026gt; price * 0.9 else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unknown discount type\u0026#34;) } } }   Aqu铆, a帽adir un nuevo tipo de descuento requiere modificar el m茅todo calculate, lo que viola el OCP.\nCorrigiendo OCP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  interface DiscountStrategy { fun calculate(price: Double): Double } class NoDiscount : DiscountStrategy { override fun calculate(price: Double): Double = price } class PercentageDiscount(private val percentage: Double) : DiscountStrategy { override fun calculate(price: Double): Double = price * (1 - percentage / 100) } class DiscountCalculator(private val strategy: DiscountStrategy) { fun calculate(price: Double): Double = strategy.calculate(price) } fun main() { val noDiscount = DiscountCalculator(NoDiscount()) println(\u0026#34;Price after no discount: ${noDiscount.calculate(100.0)}\u0026#34;) val percentageDiscount = DiscountCalculator(PercentageDiscount(10.0)) println(\u0026#34;Price after 10% discount: ${percentageDiscount.calculate(100.0)}\u0026#34;) }   Usando interfaces y composici贸n, logramos un dise帽o que est谩 abierto a la extensi贸n (nuevas estrategias de descuento) y cerrado a la modificaci贸n (sin cambios en las clases existentes).\n3. Principio de Sustituci贸n de Liskov (LSP) Los objetos de una superclase deben poder ser reemplazados con objetos de una subclase sin afectar la correcci贸n del programa.\nEste principio asegura que las clases derivadas respeten las expectativas establecidas por su clase base.\nRompiendo LSP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  open class Bird { open fun fly() { println(\u0026#34;Flying\u0026#34;) } } class Sparrow : Bird() class Penguin : Bird() { override fun fly() { throw UnsupportedOperationException(\u0026#34;Penguins can\u0026#39;t fly\u0026#34;) } } fun main() { val birds: List\u0026lt;Bird\u0026gt; = listOf(Sparrow(), Penguin()) for (bird in birds) { bird.fly() // Esto fallar谩 para Penguin  } }   En este ejemplo, Penguin viola LSP porque no puede cumplir el contrato de Bird. Una mejor aproximaci贸n es refactorizar el dise帽o:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  interface Flyable { fun fly() } class Sparrow : Flyable { override fun fly() { println(\u0026#34;Flying\u0026#34;) } } class Penguin { fun swim() { println(\u0026#34;Swimming\u0026#34;) } }   Ahora, los comportamientos est谩n segregados, y se respeta el LSP.\n4. Principio de Segregaci贸n de Interfaces (ISP) Los clientes no deber铆an estar obligados a depender de m茅todos que no utilizan.\nEste principio promueve la creaci贸n de interfaces espec铆ficas en lugar de una 煤nica interfaz inflada.\nRompiendo ISP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Machine { fun print() fun scan() fun fax() } class OldPrinter : Machine { override fun print() { println(\u0026#34;Printing\u0026#34;) } override fun scan() { throw UnsupportedOperationException(\u0026#34;Scan not supported\u0026#34;) } override fun fax() { throw UnsupportedOperationException(\u0026#34;Fax not supported\u0026#34;) } }   Esta implementaci贸n fuerza a OldPrinter a implementar m茅todos que no soporta, violando ISP.\nCorrigiendo ISP:\n1 2 3 4 5 6 7 8 9 10 11 12 13  interface Printer { fun print() } interface Scanner { fun scan() } class SimplePrinter : Printer { override fun print() { println(\u0026#34;Printing\u0026#34;) } }   Dividiendo las funcionalidades en interfaces separadas, permitimos que los dispositivos implementen solo lo que necesitan.\n5. Principio de Inversi贸n de Dependencias (DIP) Los m贸dulos de alto nivel no deben depender de m贸dulos de bajo nivel. Ambos deben depender de abstracciones.\nEste principio reduce el acoplamiento entre los m贸dulos de alto y bajo nivel al introducir abstracciones.\nRompiendo DIP:\n1 2 3 4 5 6 7 8 9 10 11 12 13  class EmailService { fun sendEmail(message: String) { println(\u0026#34;Sending Email: $message\u0026#34;) } } class NotificationSender { private val emailService = EmailService() fun notifyUser(message: String) { emailService.sendEmail(message) } }   Aqu铆, NotificationSender est谩 fuertemente acoplado a EmailService, lo que dificulta cambiar a un servicio de notificaci贸n diferente.\nCorrigiendo DIP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  interface NotificationService { fun sendNotification(message: String) } class EmailService : NotificationService { override fun sendNotification(message: String) { println(\u0026#34;Sending Email: $message\u0026#34;) } } class SMSService : NotificationService { override fun sendNotification(message: String) { println(\u0026#34;Sending SMS: $message\u0026#34;) } } class NotificationSender(private val service: NotificationService) { fun notifyUser(message: String) { service.sendNotification(message) } } fun main() { val emailSender = NotificationSender(EmailService()) emailSender.notifyUser(\u0026#34;Hello via Email\u0026#34;) val smsSender = NotificationSender(SMSService()) smsSender.notifyUser(\u0026#34;Hello via SMS\u0026#34;) }   Aqu铆, NotificationSender depende de la abstracci贸n NotificationService, haci茅ndolo flexible para trabajar con cualquier tipo de notificaci贸n.\nConclusi贸n Los principios SOLID forman la base para construir software robusto y escalable. Kotlin, con su sintaxis expresiva y caracter铆sticas modernas, permite a los desarrolladores implementar estos principios de manera elegante. Al adherirse a estos principios, puedes crear c贸digo que sea m谩s f谩cil de mantener, extender y adaptar a los cambios en los requisitos.\n","description":"Principios SOLID explicados con ejemplos de Kotlin.","id":4,"section":"es","tags":["kotlin","solid","architecture"],"title":"Entendiendo los principios SOLID con ejemplos en Kotlin","uri":"https://carrion.dev/ko/es/posts/solid-kotlin/"},{"content":"Explorando patrones de dise帽o en Kotlin: Parte2 Design Patterns Series  Part 1 Part 2 Part 3  Despu茅s de la gran acogida del primer art铆culo Patrones de dise帽o en Kotlin, volvemos con m谩s! En esta segunda parte, revisaremos los patrones de Prototype, Composite, Proxy, Observer, y Strategy. Estos patrones resuelven una variedad de desafios de dise帽o y demuestran las capacidades expresivas de Kotlin.\n1. Patr贸n Prototype El Patr贸n Prototype es usado para crear nuevos objeto copiando una objeto existente, asegurando la creaci贸n eficaz de objetos.\nCuando usarlo  Cuando crear una nueva instancia es complejo o costoso. Para evitar crear instancias de subclases de forma repetida.  Implementaci贸n en Kotlin Usar las clases data de Kotlin y su funci贸n copy simplifica este patr贸n.\n1 2 3 4 5 6 7 8 9  data class Document(var title: String, var content: String, var author: String) fun main() { val original = Document(\u0026#34;Design Patterns\u0026#34;, \u0026#34;Content about patterns\u0026#34;, \u0026#34;John Doe\u0026#34;) val copy = original.copy(title = \u0026#34;Prototype Pattern\u0026#34;) println(\u0026#34;Original: $original\u0026#34;) println(\u0026#34;Copy: $copy\u0026#34;) }   Por qu茅 Kotlin? Las clases data de Kotlin soportan de forma nativa copiar los objetos con c贸digo m铆nimo, haciendo que aplicar el patr贸n Prototype sea muy sencillo.\n2. Patr贸n Composite El Patr贸n Composite es usado para tratar objetos individuales y grupos de forma uniforme.\nCuando usarlo  Cuando tienes una estructura en 谩rbol y quieres manipularlo de una forma consistente.  Implementaci贸n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  interface Logger { fun log(message: String) } class ConsoleLogger : Logger { override fun log(message: String) { println(message) } } class FileLogger(private val filePath: String) : Logger { override fun log(message: String) { // Implementation for writing logs to a file  } } class RootLogger(private val loggers: List\u0026lt;Logger\u0026gt;) : Logger { override fun log(message: String) { loggers.forEach { it.log(message) } } } fun main() { val consoleLogger = ConsoleLogger() val fileLogger = FileLogger(\u0026#34;/path/to/log.txt\u0026#34;) val rootLogger = RootLogger(listOf(consoleLogger, fileLogger)) rootLogger.log(\u0026#34;Composite Pattern Example\u0026#34;) }   3. Patr贸n Proxy El Patr贸n Proxy sirve de puerta de entrada para controlar el acceso a otro objeto.\nCuando utilizarlo  Para controlar el acceso a otro recurso. Para a帽adir funcionalidad sin modificar el objeto existente.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Service { fun fetchData(): String } class RealService : Service { override fun fetchData() = \u0026#34;Data from Real Service\u0026#34; } class ProxyService(private val realService: RealService) : Service { override fun fetchData(): String { println(\u0026#34;Proxy: Checking access before delegating.\u0026#34;) return realService.fetchData() } } fun main() { val proxy = ProxyService(RealService()) println(proxy.fetchData()) }   4. Patr贸n Observer El Patr贸n Observer define una dependencia de uno-a-muchos, por lo que cuando un objeto cambia su estado, todos los que dependen de el son notificados.\nCuando utilizarlo  Para sistemas dirigidos por eventos. Cuando m煤ltiples componentes necesitan reaccionar a cambios de estado.  Implementaci贸n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  fun interface StateChangeListener { fun onStateChanged(oldState: String, newState: String) } class Subject { private val listeners = mutableListOf\u0026lt;StateChangeListener\u0026gt;() var state: String by Delegates.observable(\u0026#34;Initial State\u0026#34;) { _, old, new -\u0026gt; listeners.forEach { it.onStateChanged(old, new) } } fun addListener(listener: StateChangeListener) { listeners.add(listener) } } fun main() { val subject = Subject() subject.addListener { oldState, newState -\u0026gt; println(\u0026#34;Listener 1: State changed from \u0026#39;$oldState\u0026#39; to \u0026#39;$newState\u0026#39;\u0026#34;) } subject.addListener { oldState, newState -\u0026gt; println(\u0026#34;Listener 2: State changed from \u0026#39;$oldState\u0026#39; to \u0026#39;$newState\u0026#39;\u0026#34;) } subject.state = \u0026#34;State 1\u0026#34; subject.state = \u0026#34;State 2\u0026#34; }   Por qu茅 Kotlin? Usar fun interface simplifica la implementaci贸n de interfaces con un s贸lo m茅todo. De forma adicional, los Delegates.observable de Kotlin hace que observar cambios de estado sea m谩s directo, facilitando la implementaci贸n del patr贸n Observer.\n5. Patr贸n Strategy El Patr贸n Strategy define una seria de algoritmos, encapsula cada uno de ellos, y luego los hace intercambiables.\nCuando utilizar  Cuando necesitas vaerios algoritmos para una tarea en concreto.  Implementaci贸n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  interface PaymentStrategy { fun pay(amount: Double) } class CreditCardPayment : PaymentStrategy { override fun pay(amount: Double) = println(\u0026#34;Paid $$amountusing Credit Card.\u0026#34;) } class PayPalPayment : PaymentStrategy { override fun pay(amount: Double) = println(\u0026#34;Paid $$amountusing PayPal.\u0026#34;) } class PaymentContext(private var strategy: PaymentStrategy) { fun setStrategy(strategy: PaymentStrategy) { this.strategy = strategy } fun executePayment(amount: Double) = strategy.pay(amount) } fun main() { val context = PaymentContext(CreditCardPayment()) context.executePayment(100.0) context.setStrategy(PayPalPayment()) context.executePayment(200.0) }   Conclusi贸n Con Kotlin, los patrones de dise帽o como Prototype, Composite, Proxy, Observer, y Strategy se vuelven m谩s intuitivos. Estos patrones no son solo herramientas, son los fundamentos para un c贸digo m谩s claro y mantenible.\n","description":"Kotlin Patrones de dise帽o - Parte 2","id":5,"section":"es","tags":["kotlin","design-patterns","architecture"],"title":"Patrones de dise帽o en Kotlin - Parte 2","uri":"https://carrion.dev/ko/es/posts/design-patterns-2/"},{"content":"Usando Koin en Compose Multiplatform La inyecci贸n de dependencias es algo imprescindible para crear aplicaciones escalables, y Koin hace que sea muy sencillo, incluso en proyectos con Compose Multiplatform. Con la nueva funci贸n composable KoinApplication, puedes inicializar Koin directamente desde el c贸digo com煤n, reduciendo la cantidad de c贸digo necesario mientras se mantiene la flexibilidad de configurar cada plataforma por separado. Vamos a ver un ejemplo.\nProject Setup Empieza creando un proyecto de Compose Multiplatform usando el KMP Wizard, seleccionando Android, iOS, Desktop y Web como plataformas. Para este ejemplo no vamos a incluir Server como plataforma.\nA帽adiendo las dependencias Usa el version catalog de Gradle para incluir las dependencias necesarias de Koin en libs.versions.toml:\n1 2 3 4 5 6 7 8 9  [versions] koin-bom = \u0026#34;4.1.0-Beta1\u0026#34; [libraries] koin-bom = { module = \u0026#34;io.insert-koin:koin-bom\u0026#34;, version.ref = \u0026#34;koin-bom\u0026#34; } koin-core = { module = \u0026#34;io.insert-koin:koin-core\u0026#34; } koin-android = { module = \u0026#34;io.insert-koin:koin-android\u0026#34; } koin-compose = { module = \u0026#34;io.insert-koin:koin-compose\u0026#34; } koin-compose-viewModel = { module = \u0026#34;io.insert-koin:koin-compose-viewmodel\u0026#34; }   Definiendo los m贸dulos de Koin Vamos a crear dos m贸dulos de Koin: appModule y platformModule. El platformModule define las dependencias espec铆ficas de cada plataforma.\nM贸dulos compartidos 1 2 3 4 5 6 7 8 9 10 11 12  val appModule = module { viewModelOf(::MainViewModel) factoryOf(::GetJokeUseCase) singleOf(::DefaultJokeRepository) bind JokeRepository::class singleOf(::JokeJsonDataSource) bind JokeDataSource::class single { Json { ignoreUnknownKeys = true } } } val Module.localPreferencesDefinition get() = singleOf(::InMemoryLocalPreferences) bind LocalPreferences::class expect val platformModule: Module   M贸dulos espec铆ficos de cada plataforma Para Android vamos a usar una implementaci贸n de la interfaz de LocalPreferences que depende del contexto de Android por lo que necesitamos un m贸dulo distinto al resto de plataformas:\n1 2 3 4  actual val platformModule: Module get() = module { singleOf(::AndroidPreferences) bind LocalPreferences::class }   Para iOS, Desktop y Web, reutilizaremos la localPreferencesDefinition que se puede ver m谩s arriba:\n1 2 3 4  actual val platformModule: Module get() = module { localPreferencesDefinition }   Configurando la App En el archivo App.kt, podemos usar la funci贸n composable KoinApplication. A帽adiendo el par谩metro KoinAppDeclaration como opcional y con valor por defecto a null.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Composable @Preview fun App(koinAppDeclaration: KoinAppDeclaration? = null) { KoinApplication( application = { koinAppDeclaration?.invoke(this) modules(appModule, platformModule) } ) { MaterialTheme { MainScreen() } } }   En Android, usamos la lambda para proveer el contexto y activar el logging:\n1 2 3 4 5 6 7 8 9 10 11  class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { App { androidLogger(Level.DEBUG) androidContext(this@MainActivity) } } } }   Esta flexibilidad nos asegura configuraciones espec铆ficas por plataforma, como inyectar el contexto de Android, sin afectar al resto de plataformas.\nCorriendo la App Compila la aplicaci贸n en cada plataforma. Podr谩s probar que todo est谩 funcionando y cada plataforma recibe la configuraci贸n que necesita para funcionar.\nConclusi贸n La nueva funci贸n composable KoinApplication simplifica la inyecci贸n de dependencias en Compose Multiplatform permitiendo inizializar Koin de forma compartida manteniendo la posibilidad de configurar cada plataforma por separado si fuera necesario. Esta forma de proceder reduce el c贸digo necesario y promueve la reusabilidad del c贸digo entre plataformas.\nPuedes descargar el c贸digo completo para este ejemplo en GitHub.\nTambi茅n si necesitas m谩s informaci贸n acerca de las diferentes opciones para declarar dependencias en Koin puedes visitar un post que publiqu茅 en LinkedIn: Koin DSL\n","description":"Usando Koin en Compose Multiplatform desde el c贸digo com煤n con posibilidad de configurar cada una de las plataformas.","id":6,"section":"es","tags":["kotlin","multiplatform","cmp","compose","koin"],"title":"Usando Koin en Compose Multiplatform","uri":"https://carrion.dev/ko/es/posts/koin-cmp/"},{"content":"Explorando patrones de dise帽o en Kotlin - Parte 1 Serie Patrones de dise帽o Design Patterns Series  Part 1 Part 2 Part 3  Los patrones de dise帽o son soluciones probadas a problemas comunes en el dise帽o de software. Con la sintaxis y funcionalidades modernas de Kotlin, implementar estos patrones normalmente resulta m谩s limpio y conciso. En este post, exploraremos los patrones de Singleton, Factory Method, Builder, Adapter and Decorator, profundizando en su prop贸sito, casos de uso y implementaciones en Kotlin.\n1. Patr贸n Singleton El Patr贸n Singleton asegura que una clase tiene solo una instancia y provee un punto de acceso global a ella.\nCuando utilizar  Al manejar recursos compartidos como conexiones a bases de datos.  Implementaci贸n en Kotlin La palabra reservada de Kotlin object provee una forma r谩pida de crear un Singleton.\n1 2 3 4 5  object DatabaseConnection { fun connect() { println(\u0026#34;Connecting to database...\u0026#34;) } }   Uso 1 2 3  fun main() { DatabaseConnection.connect() }   Ventajas en Kotlin  Por defecto es Thread-safe. Requiere un c贸digo m铆nimo comparado con implementaciones tradicionales en otros lenguajes.  2. Patr贸n Factory Method El Patr贸n Factory Method delega la creaci贸n de objectos a clases o funciones, lo que provee de flexibilidad a la hora de instanciar los objetos.\nCuando utilizarlo  Cuando crear los objetos requiere de l贸gica o tiene complejidad. Para desacoplar la creaci贸n del objeto del c贸digo del cliente.  Implementaci贸n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Shape { fun draw() } class Circle : Shape { override fun draw() = println(\u0026#34;Drawing a Circle\u0026#34;) } class Rectangle : Shape { override fun draw() = println(\u0026#34;Drawing a Rectangle\u0026#34;) } object ShapeFactory { fun createShape(type: String): Shape = when (type) { \u0026#34;Circle\u0026#34; -\u0026gt; Circle() \u0026#34;Rectangle\u0026#34; -\u0026gt; Rectangle() else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unknown shape type\u0026#34;) } }   Uso 1 2 3 4  fun main() { val shape = ShapeFactory.createShape(\u0026#34;Circle\u0026#34;) shape.draw() }   3. Patr贸n Builder El Patr贸n Builder es usado para construir objetos complejos paso a paso. Es especialmente 煤til cuando un objeto tiene muchos par谩metros opcionales o configuraciones distintas.\nCuando utilizar  Para evitar constructores con demasiados par谩metros. Cuando el proceso de contrucci贸n del objeto es complejo o incluye multiples pasos.  Implementaci贸n en Kotlin En Kotlin el uso de apply o las capacidades de DSL simplifican el patr贸n Builder.\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Car(val make: String, val model: String, val year: Int) { class Builder { private var make = \u0026#34;\u0026#34; private var model = \u0026#34;\u0026#34; private var year = 0 fun make(make: String) = apply { this.make = make } fun model(model: String) = apply { this.model = model } fun year(year: Int) = apply { this.year = year } fun build() = Car(make, model, year) } }   Uso 1 2 3 4 5 6 7 8 9  fun main() { val car = Car.Builder() .make(\u0026#34;Toyota\u0026#34;) .model(\u0026#34;Corolla\u0026#34;) .year(2022) .build() println(\u0026#34;${car.make}${car.model}, ${car.year}\u0026#34;) }   ** Por qu茅 en Kotlin?** Enlazar m茅todos con apply permite una sintaxis m谩s concisa y expresiva cuando se construye objetos.\n4. Patr贸n Adapter El Patr贸n Adapter es usado para hacer de puente entre interfaces que no son compatibles traduciendo una interfaz a la otra.\nCuando utilizar  Cuando se integra nuevo c贸digo con c贸digo antiguo o librer铆as externas. Cuando dos sistemas o componentes necesitan trabajar en conjunto pero tienen interfaces incompatibles.  Implementaci贸n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // Existing integer provider interface interface OldProvider { fun provide(): Int } class RandomIntProvider : OldProvider { override fun provide(): Int = (1..100).random() } // Target string provider interface interface NewProvider { fun provide(): String } // Adapter class class OldToNewProviderAdapter(private val intProvider: OldProvider) : NewProvider { override fun provide(): String = \u0026#34;Provided number: ${intProvider.provide()}\u0026#34; }   Uso 1 2 3 4 5 6  fun main() { val intProvider = RandomIntProvider() val stringProvider: NewProvider = OldToNewProviderAdapter(intProvider) println(stringProvider.provideString()) }   Por qu茅 en Kotlin? Los constructores primaries de Kotlin y la sintaxis concisa simplifican la implementaci贸n de clases de tipo wrapper.\n5. Patr贸n Decorator El Patr贸n Decorator a帽ade din谩micamente comportamientos a los objetos sin alterar su estructura.\nCuando usarlo  Para extender la funcionalidad de una clase en tiempo de ejecuci贸n. Cuando heredar llevar铆a a una jerarqu铆a sobrecargada.  Implementaci贸n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14  interface Coffee { fun cost(): Double fun description(): String } class SimpleCoffee : Coffee { override fun cost() = 5.0 override fun description() = \u0026#34;Simple Coffee\u0026#34; } class MilkDecorator(private val coffee: Coffee) : Coffee { override fun cost() = coffee.cost() + 1.5 override fun description() = coffee.description() + \u0026#34;, Milk\u0026#34; }   Uso 1 2 3 4 5 6  fun main() { val coffee = SimpleCoffee() val coffeeWithMilk = MilkDecorator(coffee) println(\u0026#34;${coffeeWithMilk.description()}costs \\$${coffeeWithMilk.cost()}\u0026#34;) }   Conclusi贸n Las funcionalidades modernas de Kotlin como object, when y apply hacen que implementar los patrones de dise帽o tradicionales sea m谩s f谩cil y expresivo. Estos patrones no solo resuelven desaf铆os comunes de dise帽o si no que demuestran como Kotlin mejora su implementaci贸n.\nHay otros patrones de dise帽o que te gustaria que cubriera en futuros posts?\n","description":"Kotlin Patrones de dise帽o - Parte 1","id":7,"section":"es","tags":["kotlin","design-patterns","architecture"],"title":"Patrones de dise帽o en Kotlin - Parte 1","uri":"https://carrion.dev/ko/es/posts/design-patterns-1/"},{"content":"Explorando Kotlin Symbol Processing (KSP) con ejemplos pr谩cticos Kotlin Symbol Processing (KSP) es una herramienta muy potente usada para simplificar el procesamiento de anotaciones en Kotlin. Comparado con kapt (Kotlin Annotation Processing Tool), KSP es m谩s r谩pido, ofrece mejor integraci贸n con Kotlin y reduce los tiempos de compilaci贸n de forma significativa. En este post, exploraremos los fundamentos de KSP, discutiremos c贸mo funciona y mostraremos como su uso en librer铆as populares como Koin y Room.\nQu茅 es KSP? KSP es una API ligera y eficiente para procesar c贸digo Kotlin. Permite crear procesadores de anotaciones que funcionan directamente con la sintaxis de Kotlin en lugar de depender de herramientas basadas en Java. Esto lo convierte en una opci贸n ideal para proyectos orientados a Kotlin.\nBeneficios de KSP:  Velocidad: Procesa c贸digo Kotlin m谩s r谩pido que kapt. Dise帽o centrado en Kotlin: Funciona directamente con los constructos del lenguaje Kotlin, evitando abstracciones basadas en Java. Ligero: Reduce el c贸digo repetitivo y se integra perfectamente con Gradle. Compatibilidad: Muchas bibliotecas populares ahora son compatibles con KSP de manera nativa.  Setting Up KSP in Your Project Agrega el plugin de KSP a tu proyecto\nConfiguraci贸n de Gradle 1 2 3 4 5 6 7 8 9 10 11 12 13  plugins { kotlin(\u0026#34;jvm\u0026#34;) version \u0026#34;\u0026lt;latest-kotlin-version\u0026gt;\u0026#34; id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;\u0026lt;latest-ksp-version\u0026gt;\u0026#34; } repositories { mavenCentral() } dependencies { implementation(kotlin(\u0026#34;stdlib\u0026#34;)) ksp(\u0026#34;\u0026lt;ksp-processor-library\u0026gt;\u0026#34;) }   Reemplaza \u0026lt;ksp-processor-library\u0026gt; con la dependencia del procesador espec铆fico de la biblioteca, como se muestra en los ejemplos a continuaci贸n.\nEjemplo 1: KSP con las anotaciones de Koin Koin desde la versi贸n 3.4.0, permite definir dependencias a trav茅s de anotaciones, que luego son procesadas usando KSP para generar los m贸dulos de Koin.\nConfiguraci贸n de Koin con KSP A帽ade las siguientes dependencias:\n1 2 3 4 5  dependencies { implementation(\u0026#34;io.insert-koin:koin-core:\u0026lt;version\u0026gt;\u0026#34;) implementation(\u0026#34;io.insert-koin:koin-annotations:\u0026lt;version\u0026gt;\u0026#34;) ksp(\u0026#34;io.insert-koin:koin-ksp-compiler:\u0026lt;version\u0026gt;\u0026#34;) }   Anota las clases Usa las anotaciones de Koin para definir tu grafo de dependencias:\n1 2 3 4 5 6 7 8 9  @Module @ComponentScan class AppModule @Single class UserRepository @Factory class UserUseCase(private val userRepository: UserRepository)   M贸dulo generado El procesador de KSP genera autom谩ticamente un m贸dulo de Koin. Puedes incluirlo en la configuraci贸n de tu aplicaci贸n:\n1 2 3 4 5  fun main() { startKoin { modules(AppModuleModule().module) } }   Esto elimina la necesidad de escribir manualmente el m贸dulo de Koin, ahorrando tiempo y reduciendo el c贸digo repetitivo.\nExample 2: KSP con base de datos Room Room es un ORM ampliamente utilizado para Android. Con KSP, Room procesa anotaciones m谩s r谩pidamente, reduciendo significativamente los tiempos de compilaci贸n\nConfiguraci贸n de Room con KSP Agrega las siguientes dependencias:\n1 2 3 4  dependencies { implementation(\u0026#34;androidx.room:room-runtime:\u0026lt;version\u0026gt;\u0026#34;) ksp(\u0026#34;androidx.room:room-compiler:\u0026lt;version\u0026gt;\u0026#34;) }   Anota las entidades 1 2 3 4 5  @Entity data class User( @PrimaryKey val id: Int, val name: String )   Generar DAO y Base de Datos 1 2 3 4 5 6 7 8 9 10  @Dao interface UserDao { @Query(\u0026#34;SELECT * FROM User\u0026#34;) fun getAllUsers(): List\u0026lt;User\u0026gt; } @Database(entities = [User::class], version = 1) abstract class AppDatabase : RoomDatabase() { abstract fun userDao(): UserDao }   Usando KSP, Room genera el c贸digo necesario de forma autom谩tica, reduciendo el c贸digo repetitivo.\nComo crear un procesador KSP personalizado Construyamos un procesador KSP personalizado que genere una clase Builder para clases de datos anotadas con @GenerateBuilder.\nCrear el m贸dulo Primero, debes crear un m贸dulo con la API para KSP.\n1 2 3  dependencies { implementation(\u0026#34;com.google.devtools.ksp:symbol-processing-api:\u0026lt;version\u0026gt;\u0026#34;) }   Definir la anotaci贸n 1 2 3  @Target(AnnotationTarget.CLASS) @Retention(AnnotationRetention.SOURCE) annotation class GenerateBuilder   L贸gica del procesador KSP El procesador puede generar din谩micamente una clase Builder basada en las propiedades de la data class con la anotaci贸n. Necesitas crear una clase que extienda SymbolProcessor donde todo el trabajo se realizar谩 en la funci贸n process, y una clase extendiendo SymbolProcessorProvider, que proveer谩 de la implementaci贸n del SymbolProcessor.\nAqu铆 la implementaci贸n de SymbolProcessor:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  class KspBuilderProcessor( private val codeGenerator: CodeGenerator ) : SymbolProcessor { override fun process(resolver: Resolver): List\u0026lt;KSAnnotated\u0026gt; { val symbols = resolver.getSymbolsWithAnnotation(GenerateBuilder::class.qualifiedName.toString()) .filterIsInstance\u0026lt;KSClassDeclaration\u0026gt;() symbols.forEach { symbol -\u0026gt; val className = symbol.simpleName.asString() val packageName = symbol.packageName.asString() val generatedClassName = \u0026#34;${className}Builder\u0026#34; val file = codeGenerator.createNewFile( dependencies = Dependencies(false, symbol.containingFile!!), packageName = packageName, fileName = generatedClassName ) val properties = symbol.getAllProperties() val builderProperties = mutableListOf\u0026lt;String\u0026gt;() val setters = mutableListOf\u0026lt;String\u0026gt;() val buildMethodParams = mutableListOf\u0026lt;String\u0026gt;() properties.forEach { property -\u0026gt; val propName = property.simpleName.asString() val propType = property.type.resolve().declaration.simpleName.asString() .let { if (property.type.resolve().isMarkedNullable) \u0026#34;$it?\u0026#34; else it } val defaultValue = getDefaultValueFromProperty(property) builderProperties.add(\u0026#34; private var $propName: $propType= $defaultValue\u0026#34;) setters.add(\u0026#34; fun set${propName.replaceFirstChar { it.uppercase() }}($propName: $propType) = apply { this.$propName= $propName}\u0026#34;) buildMethodParams.add(\u0026#34; $propName= this.$propName\u0026#34;) } val builderClass = buildString { appendLine(\u0026#34;package $packageName\u0026#34;) appendLine() appendLine(\u0026#34;class $generatedClassName{\u0026#34;) builderProperties.forEach { property -\u0026gt; appendLine(property) } appendLine() setters.forEach { setter -\u0026gt; appendLine(setter) } appendLine() appendLine(\u0026#34; fun build(): $className{\u0026#34;) appendLine(\u0026#34; return $className(\u0026#34;) buildMethodParams.forEach { methodParam -\u0026gt; appendLine(methodParam) } appendLine(\u0026#34; )\u0026#34;) appendLine(\u0026#34; }\u0026#34;) appendLine(\u0026#34;}\u0026#34;) appendLine() appendLine(\u0026#34;fun ${generatedClassName.replaceFirstChar { it.lowercase() }}(block: $generatedClassName.() -\u0026gt; Unit): $className{\u0026#34;) appendLine(\u0026#34; return $generatedClassName().apply(block).build()\u0026#34;) appendLine(\u0026#34;}\u0026#34;) } file.write(builderClass.toByteArray()) file.close() } return symbols.filterNot { it.validate() }.toList() } private fun getDefaultValueFromProperty(property: KSPropertyDeclaration): String { val propType = property.type.resolve().declaration.qualifiedName?.asString() ?: \u0026#34;Any\u0026#34; val isNullable = property.type.resolve().isMarkedNullable return if (isNullable) \u0026#34;null\u0026#34; else when (propType) { \u0026#34;kotlin.String\u0026#34; -\u0026gt; \u0026#34;\\\u0026#34;\\\u0026#34;\u0026#34; \u0026#34;kotlin.Int\u0026#34;, \u0026#34;kotlin.Long\u0026#34;, \u0026#34;kotlin.Short\u0026#34;, \u0026#34;kotlin.Byte\u0026#34; -\u0026gt; \u0026#34;0\u0026#34; \u0026#34;kotlin.Double\u0026#34;, \u0026#34;kotlin.Float\u0026#34; -\u0026gt; \u0026#34;0.0\u0026#34; \u0026#34;kotlin.Boolean\u0026#34; -\u0026gt; \u0026#34;false\u0026#34; else -\u0026gt; throw IllegalArgumentException(\u0026#34;Non-nullable type $propTyperequires a default value\u0026#34;) } } }   Y aqu铆 la clase que extiende de SymbolProcessorProvider:\n1 2 3 4 5  class KspBuilderProvider : SymbolProcessorProvider { override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor { return KspBuilderProcessor(environment.codeGenerator) } }   Con estas dos clases ya solo falta crear un fichero con ruta src/main/resources/META-INF/services y nombre com.google.devtools.ksp.processing.SymbolProcessorProvider. Su contenido ser谩 el nombre completo de la clase que extiende de SymbolProcessorProvider que acabas de crear. En este caso quedar铆a as铆:\ncom.example.kspbuilder.KspBuilderProvider Usando el procesador KSP personalizado Agregar el procesador personalizado A帽ade el plugin KSP al fichero build.gradle.kts en el m贸dulo donde quieres utilizar la anotaci贸n:\n1 2 3 4 5 6 7 8  plugins { id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;\u0026lt;version\u0026gt;\u0026#34; } dependencies { implementation(project(\u0026#34;:KspBuilder\u0026#34;)) ksp(project(\u0026#34;:KspBuilder\u0026#34;)) }   Anotar la clase Crea una data class con la anotaci贸n:\n1 2 3 4 5  @GenerateBuilder class Person(val id: Int, val name: String, val age: Int, val address: Address?) @GenerateBuilder class Address(val id: Int, val name: String, val country: String)   C贸digo generado Despu茅s de compilar el proyecto, el c贸digo generado con KSP se localiza en el directorio build/generated/ksp.\nPara la data class Person, la clase builder generada se ve as铆:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class PersonBuilder { private var id: Int = 0 private var name: String = \u0026#34;\u0026#34; private var age: Int = 0 private var address: Address? = null fun setId(id: Int) = apply { this.id = id } fun setName(name: String) = apply { this.name = name } fun setAge(age: Int) = apply { this.age = age } fun setAddress(address: Address?) = apply { this.address = address } fun build(): Person { return Person( id = this.id, name = this.name, age = this.age, address = this.address ) } } fun personBuilder(block: PersonBuilder.() -\u0026gt; Unit): Person { return PersonBuilder().apply(block).build() }   Para la data class Address, la clase builder generada ser铆a as铆:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class AddressBuilder { private var id: Int = 0 private var name: String = \u0026#34;\u0026#34; private var country: String = \u0026#34;\u0026#34; fun setId(id: Int) = apply { this.id = id } fun setName(name: String) = apply { this.name = name } fun setCountry(country: String) = apply { this.country = country } fun build(): Address { return Address( id = this.id, name = this.name, country = this.country ) } } fun addressBuilder(block: AddressBuilder.() -\u0026gt; Unit): Address { return AddressBuilder().apply(block).build() }   Ejemplo de uso 1 2 3 4 5 6 7 8 9 10 11 12  val person = personBuilder { setId(10) setName(\u0026#34;Test\u0026#34;) setAge(100) setAddress( addressBuilder { setId(10) setName(\u0026#34;AddressTest\u0026#34;) setCountry(\u0026#34;Spain\u0026#34;) } ) }   Conclusi贸n KSp es una herramienta muy importante para los desarrolladores Kotlin. Su dise帽o ligero y centrado en Kotlin hace que sea un reemplazo perfecto de kapt, su habilidad para generar c贸digo din谩micamente abre un gran abanico de posibilidades. Tanto si usas KSP con librer铆as como Koin y Room o creas tu propio procesador para tu caso de uso, KSP brinda las herramientas necesarias para elevar tu desarrollo al siguiente nivel.\nIntenta integrar KSP en tu pr贸ximo proyecto y observa los beneficios de primera mano!\nAqu铆 dejo el repositorio con el c贸digo utilizado para crear el procesador KSP personalizado Github Repo\n","description":"Kotlin Avanzado - Kotlin Symbol Processing (KSP)","id":8,"section":"es","tags":["kotlin","android","advanced"],"title":"Explorando Kotlin KSP","uri":"https://carrion.dev/ko/es/posts/kotlin-ksp/"},{"content":"Explorando las funciones Infix en Kotlin Kotlin, es un lenguaje de programaci贸n moderno con funcionalidades que permiten escribir un c贸digo m谩s expresivo y conciso. Una de estas funcionalidades son las infix functions, que permiten escribir c贸digo m谩s limpio y legible. En este post, exploraremos que son las funciones infix, como usarlas y algunos ejemplo pr谩cticos.\nQu茅 son las funciones Infix? Las funciones infix en Kotlin son un tipo especial de funci贸n que pueden ser llamadas sin el uso de par茅ntesis o el punto. Esto puede hacer que ciertos patrones de c贸digo se lean de forma m谩s natural, asemej谩ndose a la sintaxis tradicional relacionada con matem谩ticas o DSL.\nEste ser铆a un ejemplo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Point(val x: Int, val y: Int) { infix fun moveBy(offset: Point): Point { return Point(this.x + offset.x, this.y + offset.y) } } fun main() { val point1 = Point(2, 3) val offset = Point(1, 1) // Using the infix notation  val newPoint = point1 moveBy offset println(\u0026#34;New Point: (\\${newPoint.x}, \\${newPoint.y})\u0026#34;) }   En este ejemplo, la funci贸n moveBy se llama usando la notaci贸n infix, mejorando la legibilidad.\nReglas y sintaxis Aqu铆 estan unos puntos clave acerca de las funciones infix:\n Solo un par谩metro: La funci贸n debe recibir ex谩ctamente un par谩metro. Miembros de clase o funciones de extensi贸n: Debe estar definida como una funci贸n de clase o una funci贸n de extensi贸n. No Varargs or argumentos por defecto: El par谩metro no puede tener valores por defecto o ser un vararg.  Ejemplo con una funci贸n de extensi贸n:\n1 2 3 4 5 6 7 8  infix fun String.concatWith(other: String): String { return this + other } fun main() { val result = \u0026#34;Hello\u0026#34; concatWith \u0026#34; World\u0026#34; println(result) // Outputs: Hello World }   Casos de uso pr谩cticos Las funciones infix son comunmente utilizadas en Kotlin para hacer el c贸digo m谩s conciso y legible. Brillan en escenarios donde las operaciones intuitivas son necesarias, como cuando se trabaja con colecciones, rangos o expresiones de frameworks de testing o de inyecci贸n de dependencias. Abajo de estas l铆neas hay algunos ejemplos de como las funciones infix pueden simplificar el c贸digo que escribimos diariamente:\n  Mapeando claves con valores: La funci贸n to en la librer铆a estandar de Kotlin es una funci贸n infix que ayuda a crear pares, normalmente se usan en los mapas.\n1 2 3 4  fun main() { val map = mapOf(\u0026#34;key1\u0026#34; to \u0026#34;value1\u0026#34;, \u0026#34;key2\u0026#34; to 42) println(map) // Outputs: {key1=value1, key2=42} }     Definiendo rangos: La funci贸n until es una funci贸n infix que se usa para definir rangos donde se excluye el l铆mite superior.\n1 2 3 4 5  fun main() { for (i in 1 until 5) { println(i) // Outputs: 1, 2, 3, 4  } }     Definiendo el comportamiento de mocks: Librer铆as tales como MockK usan funciones infix para crear configuraciones de test m谩s expresivas y legibles.\n1 2 3 4 5 6 7 8 9 10  class Calculator { fun add(a: Int, b: Int): Int = a + b } fun test() { val calculator = mockk\u0026lt;Calculator\u0026gt;() every { calculator.add(1, 2) } returns 3 println(calculator.add(1, 2)) // Outputs: 3 }     Inyecci贸n de dependencias con Koin: Koin, un framework de inyecci贸n de dependencias para Kotlin, usa la funci贸n infix bind para definir las relaciones entre clases e interfaces de una manera m谩s legible y limpia.\n1 2 3 4 5 6  interface MyInterface class MyImplementation : MyInterface val appModule = module { single { MyImplementation() } bind MyInterface::class }   La funci贸n infix bind mejora la legibilidad cuando declaras que implementaci贸n espec铆fica debe usarse para inyectar una interfaz.\n  Cuando usar funciones Infix Mientras las funciones infix pueden hacer el c贸digo m谩s limpio, deben usarse con cuidado:\n La operaci贸n es intuitiva y f谩cilmente entendible. Cuando mejoran la legibilidad y el flujo. Encajan naturalmente dentro del DSL.  Evitar las funciones infix en los siguientes casos:\n Puede llevar a una sintaxis ambigua y confusa. El prop贸sito de la funci贸n no est谩 claro con el nombre o uso.  Conclusi贸n Las funciones infix de Kotlin son una herramienta poderosa para crear c贸digo m谩s expresivo y legible. Definiendo un DSL, simplificando operaciones matem谩ticas, o mejorando expresiones l贸gicas, las funciones infix pueden hacer tu c贸digo m谩s eleganto. De todas formas, al igual que con cualquier otra funcionalidad, debe ser usadas con cuidado para mantener la claridad del c贸digo y evitar sobrecomplicaciones.\nIntenta incorporar funciones infix en tu pr贸ximo proyecto de Kotlin y f铆jate como transforma tu c贸digo! 驴Cuales son tus funciones infix favoritas o que formas creativas tienes de usarlas?\n","description":"Kotlin avanzado - Funciones Infix","id":9,"section":"es","tags":["kotlin","android","advanced"],"title":"Funciones Infix en Kotlin","uri":"https://carrion.dev/ko/es/posts/kotlin-infix/"},{"content":" Entendiendo los Kotlin Delegates: La magia detr谩s de c贸digo m谩s limpio  Los Kotlin delegates son una funcionalidad muy 煤til que te permite delegar el comportamiento de una propiedad o incluso una implementaci贸n de una interfaz a otro objecto. En lugar de escribir l贸gica repetitiva o manejar el estado directamente, puedes delegar esta responsabilidad a clases especializadas y reusables.\nComo funcionan los Delegates Delegates en Kotlin funcionan usando la palabra reservada by, que redirecciona el comportamiento de una propiedad o interfaz al objeto delegado. Para propiedades, el objeto delegado provee una implementaci贸n personalizada de los m茅todos get y o set. Para la delegaci贸n de interfaces, la implementaci贸n de esa interfaz es delegada al objecto.\nEsto es un ejemplo de una propiedad delegada:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class StringDelegate { private var value: String = \u0026#34;\u0026#34; operator fun getValue(thisRef: Any?, property: kotlin.reflect.KProperty\u0026lt;*\u0026gt;): String { println(\u0026#34;Getting value for \\${property.name}\u0026#34;) return value } operator fun setValue(thisRef: Any?, property: kotlin.reflect.KProperty\u0026lt;*\u0026gt;, newValue: String) { println(\u0026#34;Setting value for \\${property.name} to \\$newValue\u0026#34;) value = newValue } } class Example { var text: String by StringDelegate() } fun main() { val example = Example() example.text = \u0026#34;Hello, Kotlin!\u0026#34; println(example.text) }   Output Setting value for text to Hello, Kotlin! Getting value for text Hello, Kotlin! En este ejemplo:\n La clase StringDelegate define un comportamiento personalizado del acceso a la propiedad usando los operadores getValuey setValue. La propiedad text en la clase Exampledelega su comportamiento a la instancia de StringDelegate.  Aplicaciones reales de Kotlin Delegates 1锔 Inyecci贸n de dependencias con Koin En #Koin, puedes usar el delegado by inject() para inyectar dependencias directamente en tus clases. Esto elimina la necesidad de instanciar manualmente:\n1 2 3 4 5 6 7 8 9 10  class DelegatesFragment : Fragment() { private val tracker: AnalyticsTracker by inject() } inline fun \u0026lt;reified T : Any\u0026gt; KoinComponent.inject( qualifier: Qualifier? = null, mode: LazyThreadSafetyMode = KoinPlatformTools.defaultLazyMode(), noinline parameters: ParametersDefinition? = null, ): Lazy\u0026lt;T\u0026gt; = lazy(mode) { get\u0026lt;T\u0026gt;(qualifier, parameters) }   El delegado by inject() autom谩ticamente resuelve la dependencia usando el contenedor de Koin. Esto abstrae la l贸gica, resultando en c贸digo m谩s limpio y testeable.\n2锔 Manejo de estados en Jetpack Compose En Jetpack Compose, la funci贸n remember junto con mutableStateOf es un gran ejemplo de delegaci贸n. Esto ayuda a manejar el estado de forma eficiente dentro de los composables:\n1 2 3 4 5 6 7 8 9 10 11  @Composable fun Counter() { var count by remember { mutableStateOf(0) } Column { Text(\u0026#34;Count: $count\u0026#34;) Button(onClick = { count++ }) { Text(\u0026#34;Increment\u0026#34;) } } }   3锔 Inicializaci贸n Lazy El delegado lazy es perfecto para propiedades que necesitan ser inicializadas solo cuando se acceden por primera vez:\n1 2 3 4 5 6 7 8 9  val greeting: String by lazy { println(\u0026#34;Initializing...\u0026#34;) \u0026#34;Hello, Kotlin!\u0026#34; } fun main() { println(greeting) // Initializes here  println(greeting) // Uses cached value }   Output Initializing... Hello, Kotlin! Hello, Kotlin! 4锔 Delegaci贸n de interfaces Kotlin permite delegar la implementaci贸n de una interfaz a otro objeto.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  interface Logger { fun log(message: String) } class ConsoleLogger : Logger { override fun log(message: String) { println(\u0026#34;Log: $message\u0026#34;) } } class FileLogger : Logger { override fun log(message: String) { println(\u0026#34;Writing log to file: $message\u0026#34;) } } class Application(logger: Logger) : Logger by logger fun main() { val consoleApp = Application(ConsoleLogger()) consoleApp.log(\u0026#34;Starting console application\u0026#34;) val fileApp = Application(FileLogger()) fileApp.log(\u0026#34;Starting file application\u0026#34;) }   Output Log: Starting console application Writing log to file: Starting file application Esto es lo que est谩 pasando:\n La clase Application no tiene que implementar los m茅todos Logger de forma directa. En su lugar, delega la implementaci贸n de Logger al objeto pasado por constructor usando by. Esto hace m谩s sencillo cambiar las implementaciones sin necesidad de cambiar la clase Application.  Por qu茅 usar Kotlin Delegates? Los Delegates encapsulan la l贸gica que de otra manera cargar铆an y desordenar铆an tus clases. Ayudan a:\n Simplificar el c贸digo al reutilizar l贸gica, por ejemplo con la inicializaci贸n lazy. Abstraen patrones repetitivos, por ejemplo con la inyecci贸n de dependencias con #koin. Mejoran el manejo de los estados con la funci贸n mutableStateOf de Compose. Provee implementaciones modulares y reutilizables de interfaces.  Conclusion El mecanismo de los delegados en Kotlin es un ejemplo de como este lenguaje combina simplicidad con funcionalidad. Los delegados est谩n en todas partes en el desarrollo de Kotlin. En qu茅 otros casos los utilizas en tus proyectos?\n","description":"Kotlin avanzado - Delegates","id":10,"section":"es","tags":["kotlin","android","advanced"],"title":"Kotlin Delegates","uri":"https://carrion.dev/ko/es/posts/kotlin-delegates/"},{"content":"Kotlin Avanzado - Contracts: C贸mo volver al compilador de Kotlin m谩s inteligente Kotlin nunca deja de impresionarme con sus funcionalidades. Una funci贸n avanzada pero poco utilizada en el arsenal de Kotlin son los Contracts. Los contratos te permiten guiar al compilador de Kotlin para que tome mejores decisiones acerca de tu c贸digo, resultando en mejor seguridad ante nulos, mejor rendimiento o incluso menores errores en tiempo de ejecuci贸n.\nQu茅 son los contratos de Kotlin? Los contratos de Kotlin te permiten definir reglas acerca de como se comporta tu c贸digo, ayudando al compilador a hacer un an谩lisis est谩tico m谩s avanzado. Los contratos habilitan funcionalidades como smart-casts y comprobaciones teniendo en cuenta el contexto, superando las capacidades b谩sicas de Kotlin.\nPor qu茅 usar contratos?  Mejora la seguridad ante nulos: Elimina las comprobaciones de nulos redundantes ayudando al compilador a saber cuando algo est谩 garantizado que no sea nulo. Smart-casts optimizados: Hace que el compilador conozca el tipo de las variables en casos espec铆ficos. Reduce la repetic贸n de c贸digo: Escribe c贸digo m谩s limpio e intuitivo delegando las comprobaciones repetitivas al compilador.  Ejemplos de contratos en Kotlin 1. Simplificar las comprobaciones de nuloss Vamos a crear una funci贸n para validar valores no nulos:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @OptIn(ExperimentalContracts::class) inline fun \u0026lt;T\u0026gt; requireNotNull(value: T?, message: String): T { contract { returns() implies (value != null) } if (value == null) { throw IllegalArgumentException(message) } return value } fun processName(name: String?) { val nonNullName = requireNotNull(name, \u0026#34;Name cannot be null\u0026#34;) // No need for additional null checks; compiler knows \u0026#39;nonNullName\u0026#39; is not null!  println(\u0026#34;Processing name: $nonNullName\u0026#34;) } fun main() { processName(\u0026#34;John\u0026#34;) // Works fine  // processName(null) // Throws an IllegalArgumentException }   C贸mo los contratos nos ayudan aqu铆?  La parte del contrato returns() implies (value != null) le dice al compilador:  Si la funci贸n retorna de forma satisfactoria, entonces value est谩 garantizado que no es nulo.\n  Esto habilita smart-casts, de manera que no tienes que volver a comprobar si es nulo manualmente una vez llamada esta funci贸n.  Algo muy similar se hace en las funciones require y requireNotNull de la librer铆a estandar de Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  /** * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false. * * @sample samples.misc.Preconditions.failRequireWithLazyMessage */ @kotlin.internal.InlineOnly public inline fun require(value: Boolean, lazyMessage: () -\u0026gt; Any): Unit { contract { returns() implies value } if (!value) { val message = lazyMessage() throw IllegalArgumentException(message.toString()) } } /** * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise * returns the not null value. * * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage */ @kotlin.internal.InlineOnly public inline fun \u0026lt;T : Any\u0026gt; requireNotNull(value: T?, lazyMessage: () -\u0026gt; Any): T { contract { returns() implies (value != null) } if (value == null) { val message = lazyMessage() throw IllegalArgumentException(message.toString()) } else { return value } }   2. Afirmaciones personalizadas Aqu铆 se ve como los contratos pueden ser usados para definir afirmaciones personalizadas:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @OptIn(ExperimentalContracts::class) fun assertValidState(condition: Boolean, message: String) { contract { returns() implies condition } if (!condition) { throw IllegalStateException(message) } } fun performOperation(state: Boolean) { val state: Any? = \u0026#34;Hello\u0026#34; assertValidState(state is String, \u0026#34;Is String\u0026#34;) // Here the compiler knows that the state val is of type String so no need to other cast checks  println(\u0026#34;String length: ${assertion.length}\u0026#34;) } fun main() { performOperation(true) // Prints success  // performOperation(false) // Throws IllegalStateException }   3. Smart-Casts con condiciones personalizadas Vamos a crear una funcionalidad custom que comprueba si una valor coincide con un tipo espec铆fico. Esto demostrar谩 como los contratos pueden ayudar a mejorar las comprobaciones:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  @OptIn(ExperimentalContracts::class) inline fun \u0026lt;reified T\u0026gt; isOfType(value: Any?): Boolean { contract { returns(true) implies (value is T) } return value is T } fun main() { val input: Any? = \u0026#34;Hello, Kotlin!\u0026#34; if (isOfType\u0026lt;String\u0026gt;(input)) { println(\u0026#34;String length: ${input.length}\u0026#34;) } val inputInt: Any? = 10 if (isOfType\u0026lt;Int\u0026gt;(inputInt)) { println(\u0026#34;The value is an integer ${input.toUInt()}\u0026#34;) } }   Con esta implementaci贸n, el compilador sabe que dentro del bloque if, input es un String, gracias al contrato definido en isOfType. The la misma manera, el compilador sabe que inputInt es de tipo Int y no hace falta comprobar el tipo de nuevo.\n4. Optimizando el control del flujo Los contratos pueden simplificar el control del flujo habilitando al compilador para entender las invariantes o condiciones. Por ejemplo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  inline fun isNotEmpty(list: List\u0026lt;*\u0026gt;?): Boolean { contract { returns(true) implies (list != null \u0026amp;\u0026amp; list.isNotEmpty()) } return list != null \u0026amp;\u0026amp; list.isNotEmpty() } fun processItems(items: List\u0026lt;String\u0026gt;?) { if (isNotEmpty(items)) { // Compiler knows items is non-null and not empty  println(\u0026#34;Processing ${items.size}items\u0026#34;) } else { println(\u0026#34;No items to process\u0026#34;) } } fun main() { processItems(listOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;)) processItems(null) processItems(emptyList()) }   Salida Processing 3 items No items to process No items to process Cuando usar contratos Los contratos son ideales para:\n Desarrollo de librer铆as: Proteger APIs p煤blicas forzando condiciones pre existentes. DSLs y Frameworks: Simplificando la comprobaci贸n de tipos y validaci贸n de estados en DSLs de Kotlin. Optimizaciones en tiempo de ejecuci贸n: Reduce las comprobaciones en tiempo de ejecuci贸n al permitir al compilador inferir las condiciones en tiempo de compilaci贸n.  Conclusion Los contratos de Kotlin son una gema oculta que pueden perfeccionar tu c贸digo mejorando la seguridad, reduciendo la repetici贸n de c贸digo, y permitiendo un an谩lisis por parte del compilador m谩s inteligente. Tanto si est谩s creando librer铆as, escribiendo complejos DSLs, o simplemente optimizando c贸digo del d铆a a d铆a, los contratos proveen una herramienta muy poderosa para guiar al compilador de Kotlin y asegurando un c贸digo correcto.\nTener en cuenta que los contratos est谩n anotados como funcionalidad experimental pero est谩n implementados en Kotlin desde la versi贸n 1.3 y se usan extensamente en la librer铆a estandar de Kotlin as铆 que son lo suficiente estables como para utilizarlos.\n","description":"Kotlin avanzado - Contracts","id":11,"section":"es","tags":["kotlin","android","advanced"],"title":"Kotlin contracts","uri":"https://carrion.dev/ko/es/posts/kotlin-contracts/"},{"content":"Exportar a Swift en KMP Empezando con la versi贸n 2.1.0 podemos empezar a probar a exportar a Swift en Kotlin. Esta funcionalidad te permite exportar los m贸dulos compartidos de Kotlin a Swift sin usar Objective-C. Esto mejorar谩 la experiancia de los desarrolladores de iOS cuando usen m贸dulos de KMP.\nActualmente el soporte b谩sico incluye:\n Exportar m煤ltiples m贸dulos de Gradle a swift. Definir los nombres de los m贸dulos swift. Simplificar la estructura de paquetes.  Activar la funcionalidad Para empezar a probar esta funcionalidad debes activarla en el fichero gradle.properties:\nkotlin.experimental.swift-export.enabled=true Configuraci贸n Despu茅s de a帽adir la l铆nea mostrada arriba necesitas a帽adir esta configuraci贸n al fichero build.gradle.kts:\n1 2 3 4 5 6 7 8 9 10 11  kotlin { iosX64() iosArm64() iosSimulatorArm64() @OptIn(ExperimentalSwiftExportDsl::class) swiftExport { moduleName = \u0026#34;shared\u0026#34; flattenPackage = \u0026#34;dev.carrion.kmpswiftexport\u0026#34; } }   El siguiente paso es configurar xcode para lanzar la nueva tarea embedSwiftExportForXcode en lugar de embedAndSignAppleFrameworkForXcode. Puedes realizar este cambio desde la configuraci贸n de Build phases de la iosApp desde xcode o bien desde Android Studio modificando el fichero project.pbxproj.\nDebes cambiar esta l铆nea:\nshellScript = \u0026quot;cd \\\u0026quot;$SRCROOT/..\\\u0026quot;\\n./gradlew :shared:embedAndSignAppleFrameworkForXcode\\n\u0026quot;; Por esta otra:\nshellScript = \u0026quot;cd \\\u0026quot;$SRCROOT/..\\\u0026quot;\\n./gradlew :shared:embedSwiftExportForXcode\\n\u0026quot;; Despu茅s de aplicar estos cambios deber铆as ser capaz de lanzar la aplicaci贸n de iOS desde Android Studio o desde xcode sin ning煤n problema.\nAntes de activar la funcionalidad Si intentas navegar a la definici贸n de una funci贸n de Kotlin desde xcode en un archivo swift, se mostrar谩 el c贸digo Objective-C que se exporta del m贸dulo compartido de Kotlin. Este fichero generado es enorme teniendo en cuenta la complejidad del projecto usado para este ejemplo.\nTe voy a mostrar a continuaci贸n una peque帽a pieza del archivo de 175 l铆neas generado desde el c贸digo de Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;Greeting\u0026#34;))) @interface SharedGreeting : SharedBase - (instancetype)init __attribute__((swift_name(\u0026#34;init()\u0026#34;))) __attribute__((objc_designated_initializer)); + (instancetype)new __attribute__((availability(swift, unavailable, message=\u0026#34;use object initializers instead\u0026#34;))); - (NSString *)greet __attribute__((swift_name(\u0026#34;greet()\u0026#34;))); @end __attribute__((swift_name(\u0026#34;Platform\u0026#34;))) @protocol SharedPlatform @required @property (readonly) NSString *name __attribute__((swift_name(\u0026#34;name\u0026#34;))); @end __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;IOSPlatform\u0026#34;))) @interface SharedIOSPlatform : SharedBase \u0026lt;SharedPlatform\u0026gt; - (instancetype)init __attribute__((swift_name(\u0026#34;init()\u0026#34;))) __attribute__((objc_designated_initializer)); + (instancetype)new __attribute__((availability(swift, unavailable, message=\u0026#34;use object initializers instead\u0026#34;))); @property (readonly) NSString *name __attribute__((swift_name(\u0026#34;name\u0026#34;))); @end __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;Platform_iosKt\u0026#34;))) @interface SharedPlatform_iosKt : SharedBase + (id\u0026lt;SharedPlatform\u0026gt;)getPlatform __attribute__((swift_name(\u0026#34;getPlatform()\u0026#34;))); @end #pragma pop_macro(\u0026#34;_Nullable_result\u0026#34;) #pragma clang diagnostic pop NS_ASSUME_NONNULL_END   After enabling the feature Cuando activas al funcionalidad de exportar a Swift y compilas el proyecto, al intentar navegar a la definici贸n de una funci贸n del c贸digo compartido de Kotlin, xcode te mostrar谩 el c贸digo exportado de Swift.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  @_exported import ExportedKotlinPackages @_implementationOnly import SharedBridge_shared import KotlinRuntime public typealias Greeting = ExportedKotlinPackages.dev.carrion.kmpswiftexport.Greeting public func getPlatform() -\u0026gt; Swift.Never { ExportedKotlinPackages.dev.carrion.kmpswiftexport.getPlatform() } public extension ExportedKotlinPackages.dev.carrion.kmpswiftexport { public final class Greeting : KotlinRuntime.KotlinBase { public override init() { let __kt = dev_carrion_kmpswiftexport_Greeting_init_allocate() super.init(__externalRCRef: __kt) dev_carrion_kmpswiftexport_Greeting_init_initialize__TypesOfArguments__Swift_UInt__(__kt) } public override init( __externalRCRef: Swift.UInt ) { super.init(__externalRCRef: __externalRCRef) } public func greet() -\u0026gt; Swift.String { return dev_carrion_kmpswiftexport_Greeting_greet(self.__externalRCRef()) } } public static func getPlatform() -\u0026gt; Swift.Never { fatalError() } }   El c贸digo mostrado arriba es el fichero completo con 28 l铆neas, una gran diferencia con las 175 l铆neas del c贸digo exportado en Objective-C. Tambi茅n es importante mencionar la menor complejidad y mayor legibilidad del c贸digo swift.\nConclusion Despu茅s de probar esta nueva funcionalidad, estoy realmente impresionado con la mejora que supone para el desarrollo de iOS en los proyectos KMP. Tambi茅n me sorprende la diferencia en el c贸digo exportado en Objective-C y swift. Estoy seguro que esta funcionalidad mejorar谩 en las siguientes versiones y acercar谩 la experiencia entre el desarrollo nativo y el desarrollo multiplataforma.\nPuedes encontrar el repositorio con el c贸digo usado en este ejemplo en SwiftExport, con dos ramas, main, con la configuraci贸n del t铆pico iOS framework conf, y la rama swift-export con la nueva funcionalidad habilitada.\n","description":"Nueva funcionalidad en Kotlin 2.1.0, exportar directamente a swift desde Kotlin","id":12,"section":"es","tags":["kotlin","android","kmp"],"title":"Exportar a Swift en KMP","uri":"https://carrion.dev/ko/es/posts/swift-export/"},{"content":"Condiciones en las expresiones when en Kotlin 2.1.0 Una de las nuevas funcionalidades de Kotlin 2.1.0 es las condiciones en las expresiones when, lo que tendr铆a varias ventajas entre las que se incluye:\n Reducir anidaciones Evita c贸digo repetido Mejorar legibilidad  Activar la funcionalidad en Kotlin 2.1.0 Esta funcionalidad se encuentra en preview lo que es necesario activarla expl铆citamente para poder usarla en Kotlin 2.1.0. En el fichero build.gradle.kts a帽adiremos el siguiente c贸digo dentro del bloque de kotlin {}:\n1 2 3 4 5  kotlin { compilerOptions { freeCompilerArgs.add(\u0026#34;-Xwhen-guards\u0026#34;) } }   Uso de condicionales dentro de las ramas de la expresiones when Para este ejemplo usaremos una sealed interface para manejar respuestas de un servicio remoto:\n1 2 3 4 5  sealed interface Response\u0026lt;out T\u0026gt; { data object Loading : Response\u0026lt;Nothing\u0026gt; data class Content \u0026lt;out T\u0026gt; (val data: T?) : Response\u0026lt;T\u0026gt; data class Error(val error: Exception) : Response\u0026lt;Nothing\u0026gt; }   Esta interfaz la implementan Loading, Content y Error para gestionar los distintos estados de una respuesta.\nAntes de la nueva funcionalidad 1 2 3 4 5 6 7 8 9 10 11 12 13  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handleOld() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content -\u0026gt; if (data != null) { println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } is Response.Error -\u0026gt; if (error is IllegalStateException) { println(\u0026#34;Handled error\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } }   Como se puede ver en este caso se repite el c贸digo que muestra por pantalla Unknown error adem谩s de a帽adir anidaciones que dificultan la lectura del c贸digo.\nUsando los nuevos condicionales Se debe a帽adir el if justo despu茅s de la condici贸n primaria de la rama, por ejemplo:\n1 2 3 4 5 6  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled error\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   De esta manera no se repite el c贸digo que mostraba por pantalla el texto de Unknown error y adem谩s eliminamos las anidaciones facilitando la lectura del c贸digo.\nEn caso de necesitar comprobar varias condiciones en la rama else se podr铆a a帽adir una rama else if que controle el flujo de los casos que no cumplen las condiciones anteriores.\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) else if this is Response.Error \u0026amp;\u0026amp; this.error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   Esto 煤ltimo se puede simplificar usando dos ramas con la misma primera condici贸n de is Response.Error que a mi parecer queda m谩s simple:\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) is Response.Error if error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   Conclusi贸n Con esta nueva funcionalidad se podr谩 a帽adir nuevas condiciones sin tener que repetir c贸digo y permitir谩 que las expresiones when sean m谩s concisas. En la versi贸n 2.1.0 de Kotlin est谩 en modo preview pero se espera que pronto esta nueva funcionalidad sea estable.\nAqu铆 el enlace a la documentaci贸n con las novedades de Kotlin 2.1.0 donde se explica la funcionalidad de condicionales en las expresiones when kotlinlang\n","description":"Nueva funcionalidad en Kotlin 2.1.0, condiciones en las expresiones when","id":13,"section":"es","tags":["kotlin","android","kmp"],"title":"Condiciones en las expresiones when para Kotlin 2.1.0.","uri":"https://carrion.dev/ko/es/posts/kotlin-guard-conditions-in-when/"},{"content":"Inyecci贸n de valores en tiempo de ejecuci贸n con Dagger-Hilt Desde que apareci贸 Hilt para facilitar la inyecci贸n de dependencias en aplicaciones Android, no era posible la inyecci贸n de dependencias en tiempo de ejecuci贸n sin utilizar librer铆as ajenas a Dagger o Hilt. Desde la versi贸n 2.31 se incorpora en Dagger la anotaci贸n @AssistedInject. Con esta anotaci贸n vamos a ser capaces de indicar a Dagger-Hilt que dependencias se tienen que resolver en tiempo de ejecuci贸n y retrasar la inyecci贸n de esos par谩metros hasta tener los valores.\nEsto era necesario para poder inyectar valores en los constructores de los ViewModel y poder ejecutar alguna operaci贸n en el m茅todo init del mismo. Como puede ser una petici贸n a una API externa o bien una consulta en la base de datos local.\nEn este art铆culo veremos como implementar el @AssistedInject de Dagger para la inyecci贸n de valores en tiempo de ejecuci贸n en ViewModels con Hilt.\nInstalaci贸n En el fichero build.gradle ra铆z del proyecto, incluiremos el siguiente classpath:\n1  classpath \u0026#39;com.google.dagger:hilt-android-gradle-plugin:2.31.2-alpha\u0026#39;   Una vez a帽adido el classpath a帽adiremos el plugin de Hilt en el fichero build.gradle del m贸dulo app.\n1  apply plugin: \u0026#39;dagger.hilt.android.plugin\u0026#39;   Y tambi茅n las siguientes l铆neas a nuestras dependencias:\n1 2  implementation \u0026#39;com.google.dagger:hilt-android:2.31.2-alpha\u0026#39; kapt \u0026#39;com.google.dagger:hilt-android-compiler:2.31.2-alpha\u0026#39;   Tambi茅n hay que tener en cuenta tener a帽adido en nuestro build.gradle el plugin de kapt. Para ello a帽adiremos lo siguiente a nuestro archivo de build.gradle del m贸dulo app junto al resto de plugins:\n1  apply plugin: \u0026#39;kotlin-kapt\u0026#39;   Esa son las dependencias necesarias para implementar Hilt en nuestro proyecto. A lo largo de este post se usan distintas librer铆as como que no se definen en este art铆culo.\nEn este enlace puedes ver un ejemplo de un archivo build.gradle completo: app/build.gradle\nImplementaci贸n Para este ejemplo usaremos una clase repositorio encargada de recibir el nombre de usuario y devolver un mensaje de bienvenida. Para ello crearemos la siguiente interfaz:\n1 2 3  interface UserRepository { fun getMessage(name: String): String }   Y su implementaci贸n:\n1 2 3 4 5  class UserRepositoryImpl @Inject constructor() : UserRepository { override fun getMessage(name: String): String { return \u0026#34;Hi $name\u0026#34; } }   Anotamos el constructor con @Inject para posteriormente poder declarar un @Binds en el m贸dulo de Hilt e inyectar la implementaci贸n cada vez que se pida una interfaz del tipo UserRepository.\nVamos a crear el siguiente ViewModel que ser谩 el encargado de recibir el nombre del usuario desde el Activity o Fragment y llamar al repositorio para recibir el mensaje de bienvenida:\n1 2 3 4 5 6 7 8 9  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { ... }   En este ViewModel podemos ver como se anota el constructor con @AssistedInject para indicar a Dagger-Hilt que esta clase contiene dependencias que se deben inyectar en tiempo de ejecuci贸n. Esas dependencias est谩n anotadas con @Assisted.\nPara poder crear el ViewModel con la extensi贸n by viewModels() de la librer铆a de AndroidX debemos crear la Factory que m谩s tarde pasaremos a la extensi贸n:\n1 2 3 4 5 6 7 8  class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } }   Como puedes ver necesitamos la interfaz UserViewModelAssistedFactory que es la encargada de proveer los par谩metros en tiempo de ejecuci贸n. Esta interfaz la implementamos de la siguiente forma:\n1 2 3 4 5 6  @AssistedFactory interface UserViewModelAssistedFactory { fun create(name: String): UserViewModel }   Se trata de una interfaz con una funci贸n create que recibe los par谩metros a inyectar en tiempo de ejecuci贸n. En nuestro caso solo necesitamos el name, pero en caso de necesitar inyectar m谩s par谩metros en tiempo de ejecuci贸n, se pasar铆an como par谩metro a esta funci贸n.\nCon esto ya podemos completar nuestro ViewModel con la l贸gica necesaria para pedir la respuesta al repositorio y exponer al Fragment o Activity a trav茅s de un StateFlow.\nEl ViewModel completo quedar铆a:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } } private val _message: MutableStateFlow\u0026lt;String\u0026gt; = MutableStateFlow(\u0026#34;\u0026#34;) val message: StateFlow\u0026lt;String\u0026gt; get() = _message init { viewModelScope.launch(dispatcher) { _message.emit(repository.getMessage(name)) } } }   Relativo a Hilt solo nos faltar铆a declarar el m贸dulo indicando como proveer las dependencias. Para este ejemplo usaremos el siguiente m贸dulo:\n1 2 3 4 5 6 7 8 9 10 11 12 13  @Module @InstallIn(ActivityComponent::class) abstract class MainModule { companion object { @Provides @Named(\u0026#34;UserDispatcher\u0026#34;) fun provideUserDispatcher(): CoroutineDispatcher = Dispatchers.IO } @Binds abstract fun provideUserRepository(repositoryImpl: UserRepositoryImpl): UserRepository }   En este m贸dulo declaramos un Dispatcher para que sea m谩s sencillo testear este ViewModel en un futuro. Y hacemos @Binds de nuestra interfaz UserRepository con su implementaci贸n UserRepositoryImpl.\nAhora podemos inyectar nuestro repositorio en una Activity o Fragment de la siguiente forma:\n1 2 3 4 5 6 7 8  private val navArgs: UserFragmentArgs by navArgs() @Inject lateinit var assistedFactory: UserViewModelAssistedFactory private val userViewModel: UserViewModel by viewModels { UserViewModel.Factory(assistedFactory, navArgs.name) }   Simplemente nos faltar铆a observar los cambios en el StateFlow del ViewModel para poder actualizar nuestra UI. Eso se har铆a de la siguiente manera en un Fragment aunque ser铆a muy similar en un Activity\n1 2 3 4 5 6 7 8  override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycleScope.launchWhenStarted { userViewModel.message.collect { binding.name.text = it } } }    Recordar que es necesario anotar una clase que extienda de Application con @HiltAndroidApp y cada uno de las Activities o Fragments que usen inyecci贸n con Hilt con la anotaci贸n @AndroidEntryPoint.\n Conclusi贸n Como hemos podido observar con @AssistedInject de Dagger podemos inyectar valores en tiempo de ejecuci贸n de una forma sencilla y podemos seguir utilizando los navArgs de AndroidX.\nEn el siguiente repositorio teneis el ejemplo completo: HiltAssistedInject\n","description":"Como inyectar valores en tiempo de ejecuci贸n a los ViewModel en Android.","id":14,"section":"es","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Hilt: Inyectar valores al ViewModel en tiempo de ejecuci贸n.","uri":"https://carrion.dev/ko/es/posts/hilt-inject-parameters-runtime/"},{"content":"Bienvenido a Carrion.dev Saludos Androide!!\nBienvenido a mi nuevo blog de Kotlin y programaci贸n Android. Me llamo Ignacio Carri贸n y soy dessarrollador Android. Me encanta el lenguaje Kotlin por las facilidades que me aporta al programar para Android y las infinitas posibilidades que ofrece en otros 谩mbitos (backend, web, nativo, multiplataforma).\nEn este blog espero poder publicar cosas interesantes acerca del lenguaje Kotlin y el ecosistema Android al menos cada dos semanas. Si quieres mantenerte al d铆a no dudes en apuntarte a nuestra newsletter.\nSi tienes alguna duda, idea acerca de la que podemos hablar en un post o simplemente quieres contactar estoy disponible a trav茅s del correo: ignacio@carrion.dev.\nEspero que aprendamos mucho todos juntos!!\n","description":"Primer post en mi nuevo blog de Kotlin y Android.","id":15,"section":"es","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Bienvenido a mi nuevo blog sobre Kotlin y desarrollo Android","uri":"https://carrion.dev/ko/es/posts/welcome-to-my-new-kotlin-and-android-development-blog/"},{"content":"Sobre mi. Me llamo Ignacio Carri贸n, vivo en Valencia (Espa帽a) y el que aparece en la foto es mi perro Wilfred. Me gusta cualquier cosa relacionada con la inform谩tica y los videojuegos. Actualmente trabajo como Senior Android Engineer para Tkww. Anteriormente he trabajado en otras empresas como desarrollador Android y tambi茅n he impartido clases de programaci贸n. A raiz de mi trabajo como profesor me d铆 cuenta de que realmente me encanta aprender y que la gente aprenda conmigo. De esa motivaci贸n surge la idea de crear este blog, Carrion.dev.\nEspero poder ir publicando de forma as铆dua cosas interesantes acerca del lenguaje Kotlin y el ecosistema Android. Cualquier cr铆tica constructiva e ideas acerca de posibles temas para art铆culos ser谩n bien recibidas. Abajo aparecen los enlaces a las redes sociales en las que podr谩s encontrarme y contactar conmigo.\nContactar Portfolio\nGithub\n","description":"Ignacio Carri贸n, Desarrollador Android","id":20,"section":"es","tags":null,"title":"Sobre mi","uri":"https://carrion.dev/ko/es/about/"}]