[{"content":"Usando Koin en Compose Multiplatform La inyección de dependencias es algo imprescindible para crear aplicaciones escalables, y Koin hace que sea muy sencillo, incluso en proyectos con Compose Multiplatform. Con la nueva función composable KoinApplication, puedes inicializar Koin directamente desde el código común, reduciendo la cantidad de código necesario mientras se mantiene la flexibilidad de configurar cada plataforma por separado. Vamos a ver un ejemplo.\nProject Setup Empieza creando un proyecto de Compose Multiplatform usando el KMP Wizard, seleccionando Android, iOS, Desktop y Web como plataformas. Para este ejemplo no vamos a incluir Server como plataforma.\nAñadiendo las dependencias Usa el version catalog de Gradle para incluir las dependencias necesarias de Koin en libs.versions.toml:\n1 2 3 4 5 6 7 8 9  [versions] koin-bom = \u0026#34;4.1.0-Beta1\u0026#34; [libraries] koin-bom = { module = \u0026#34;io.insert-koin:koin-bom\u0026#34;, version.ref = \u0026#34;koin-bom\u0026#34; } koin-core = { module = \u0026#34;io.insert-koin:koin-core\u0026#34; } koin-android = { module = \u0026#34;io.insert-koin:koin-android\u0026#34; } koin-compose = { module = \u0026#34;io.insert-koin:koin-compose\u0026#34; } koin-compose-viewModel = { module = \u0026#34;io.insert-koin:koin-compose-viewmodel\u0026#34; }   Definiendo los módulos de Koin Vamos a crear dos módulos de Koin: appModule y platformModule. El platformModule define las dependencias específicas de cada plataforma.\nMódulos compartidos 1 2 3 4 5 6 7 8 9 10 11 12  val appModule = module { viewModelOf(::MainViewModel) factoryOf(::GetJokeUseCase) singleOf(::DefaultJokeRepository) bind JokeRepository::class singleOf(::JokeJsonDataSource) bind JokeDataSource::class single { Json { ignoreUnknownKeys = true } } } val Module.localPreferencesDefinition get() = singleOf(::InMemoryLocalPreferences) bind LocalPreferences::class expect val platformModule: Module   Módulos específicos de cada plataforma Para Android vamos a usar una implementación de la interfaz de LocalPreferences que depende del contexto de Android por lo que necesitamos un módulo distinto al resto de plataformas:\n1 2 3 4  actual val platformModule: Module get() = module { singleOf(::AndroidPreferences) bind LocalPreferences::class }   Para iOS, Desktop y Web, reutilizaremos la localPreferencesDefinition que se puede ver más arriba:\n1 2 3 4  actual val platformModule: Module get() = module { localPreferencesDefinition }   Configurando la App En el archivo App.kt, podemos usar la función composable KoinApplication. Añadiendo el parámetro KoinAppDeclaration como opcional y con valor por defecto a null.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Composable @Preview fun App(koinAppDeclaration: KoinAppDeclaration? = null) { KoinApplication( application = { koinAppDeclaration?.invoke(this) modules(appModule, platformModule) } ) { MaterialTheme { MainScreen() } } }   En Android, usamos la lambda para proveer el contexto y activar el logging:\n1 2 3 4 5 6 7 8 9 10 11  class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { App { androidLogger(Level.DEBUG) androidContext(this@MainActivity) } } } }   Esta flexibilidad nos asegura configuraciones específicas por plataforma, como inyectar el contexto de Android, sin afectar al resto de plataformas.\nCorriendo la App Compila la aplicación en cada plataforma. Podrás probar que todo está funcionando y cada plataforma recibe la configuración que necesita para funcionar.\nConclusión La nueva función composable KoinApplication simplifica la inyección de dependencias en Compose Multiplatform permitiendo inizializar Koin de forma compartida manteniendo la posibilidad de configurar cada plataforma por separado si fuera necesario. Esta forma de proceder reduce el código necesario y promueve la reusabilidad del código entre plataformas.\nPuedes descargar el código completo para este ejemplo en GitHub.\nTambién si necesitas más información acerca de las diferentes opciones para declarar dependencias en Koin puedes visitar un post que publiqué en LinkedIn: Koin DSL\n","description":"Usando Koin en Compose Multiplatform desde el código común con posibilidad de configurar cada una de las plataformas.","id":2,"section":"es","tags":["kotlin","multiplatform","cmp","compose","koin"],"title":"Usando Koin en Compose Multiplatform","uri":"https://carrion.dev/ko/es/posts/koin-cmp/"},{"content":"Explorando patrones de diseño Creacionales y Estructurales en Kotlin Los patrones de diseño son soluciones probadas a problemas comunes en el diseño de software. Con la sintaxis y funcionalidades modernas de Kotlin, implementar estos patrones normalmente resulta más limpio y conciso. En este post, exploraremos los patrones de Singleton, Factory Method, Builder, Adapter and Decorator, profundizando en su propósito, casos de uso y implementaciones en Kotlin.\n1. Patrón Singleton El Patrón Singleton asegura que una clase tiene solo una instancia y provee un punto de acceso global a ella.\nCuando utilizar  Al manejar recursos compartidos como conexiones a bases de datos.  Implementación en Kotlin La palabra reservada de Kotlin object provee una forma rápida de crear un Singleton.\n1 2 3 4 5  object DatabaseConnection { fun connect() { println(\u0026#34;Connecting to database...\u0026#34;) } }   Uso 1 2 3  fun main() { DatabaseConnection.connect() }   Ventajas en Kotlin  Por defecto es Thread-safe. Requiere un código mínimo comparado con implementaciones tradicionales en otros lenguajes.  2. Patrón Factory Method El Patrón Factory Method delega la creación de objectos a clases o funciones, lo que provee de flexibilidad a la hora de instanciar los objetos.\nCuando utilizarlo  Cuando crear los objetos requiere de lógica o tiene complejidad. Para desacoplar la creación del objeto del código del cliente.  Implementación en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Shape { fun draw() } class Circle : Shape { override fun draw() = println(\u0026#34;Drawing a Circle\u0026#34;) } class Rectangle : Shape { override fun draw() = println(\u0026#34;Drawing a Rectangle\u0026#34;) } object ShapeFactory { fun createShape(type: String): Shape = when (type) { \u0026#34;Circle\u0026#34; -\u0026gt; Circle() \u0026#34;Rectangle\u0026#34; -\u0026gt; Rectangle() else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unknown shape type\u0026#34;) } }   Uso 1 2 3 4  fun main() { val shape = ShapeFactory.createShape(\u0026#34;Circle\u0026#34;) shape.draw() }   3. Patrón Builder El Patrón Builder es usado para construir objetos complejos paso a paso. Es especialmente útil cuando un objeto tiene muchos parámetros opcionales o configuraciones distintas.\nCuando utilizar  Para evitar constructores con demasiados parámetros. Cuando el proceso de contrucción del objeto es complejo o incluye multiples pasos.  Implementación en Kotlin En Kotlin el uso de apply o las capacidades de DSL simplifican el patrón Builder.\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Car(val make: String, val model: String, val year: Int) { class Builder { private var make = \u0026#34;\u0026#34; private var model = \u0026#34;\u0026#34; private var year = 0 fun make(make: String) = apply { this.make = make } fun model(model: String) = apply { this.model = model } fun year(year: Int) = apply { this.year = year } fun build() = Car(make, model, year) } }   Uso 1 2 3 4 5 6 7 8 9  fun main() { val car = Car.Builder() .make(\u0026#34;Toyota\u0026#34;) .model(\u0026#34;Corolla\u0026#34;) .year(2022) .build() println(\u0026#34;${car.make}${car.model}, ${car.year}\u0026#34;) }   ** Por qué en Kotlin?** Enlazar métodos con apply permite una sintaxis más concisa y expresiva cuando se construye objetos.\n4. Patrón Adapter El Patrón Adapter es usado para hacer de puente entre interfaces que no son compatibles traduciendo una interfaz a la otra.\nCuando utilizar  Cuando se integra nuevo código con código antiguo o librerías externas. Cuando dos sistemas o componentes necesitan trabajar en conjunto pero tienen interfaces incompatibles.  Implementación en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // Existing integer provider interface interface OldProvider { fun provide(): Int } class RandomIntProvider : OldProvider { override fun provide(): Int = (1..100).random() } // Target string provider interface interface NewProvider { fun provide(): String } // Adapter class class OldToNewProviderAdapter(private val intProvider: OldProvider) : NewProvider { override fun provide(): String = \u0026#34;Provided number: ${intProvider.provide()}\u0026#34; }   Uso 1 2 3 4 5 6  fun main() { val intProvider = RandomIntProvider() val stringProvider: NewProvider = OldToNewProviderAdapter(intProvider) println(stringProvider.provideString()) }   Por qué en Kotlin? Los constructores primaries de Kotlin y la sintaxis concisa simplifican la implementación de clases de tipo wrapper.\n5. Patrón Decorator El Patrón Decorator añade dinámicamente comportamientos a los objetos sin alterar su estructura.\nCuando usarlo  Para extender la funcionalidad de una clase en tiempo de ejecución. Cuando heredar llevaría a una jerarquía sobrecargada.  Implementación en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14  interface Coffee { fun cost(): Double fun description(): String } class SimpleCoffee : Coffee { override fun cost() = 5.0 override fun description() = \u0026#34;Simple Coffee\u0026#34; } class MilkDecorator(private val coffee: Coffee) : Coffee { override fun cost() = coffee.cost() + 1.5 override fun description() = coffee.description() + \u0026#34;, Milk\u0026#34; }   Uso 1 2 3 4 5 6  fun main() { val coffee = SimpleCoffee() val coffeeWithMilk = MilkDecorator(coffee) println(\u0026#34;${coffeeWithMilk.description()}costs \\$${coffeeWithMilk.cost()}\u0026#34;) }   Conclusión Las funcionalidades modernas de Kotlin como object, when y apply hacen que implementar los patrones de diseño tradicionales sea más fácil y expresivo. Estos patrones no solo resuelven desafíos comunes de diseño si no que demuestran como Kotlin mejora su implementación.\nHay otros patrones de diseño que te gustaria que cubriera en futuros posts?\n","description":"Kotlin Patrones de diseño - Creacionales y Estructurales","id":3,"section":"es","tags":["kotlin","design-patterns","architecture"],"title":"Patrones de diseño en Kotlin - Parte 1","uri":"https://carrion.dev/ko/es/posts/design-patterns-1/"},{"content":"Explorando Kotlin Symbol Processing (KSP) con ejemplos prácticos Kotlin Symbol Processing (KSP) es una herramienta muy potente usada para simplificar el procesamiento de anotaciones en Kotlin. Comparado con kapt (Kotlin Annotation Processing Tool), KSP es más rápido, ofrece mejor integración con Kotlin y reduce los tiempos de compilación de forma significativa. En este post, exploraremos los fundamentos de KSP, discutiremos cómo funciona y mostraremos como su uso en librerías populares como Koin y Room.\nQué es KSP? KSP es una API ligera y eficiente para procesar código Kotlin. Permite crear procesadores de anotaciones que funcionan directamente con la sintaxis de Kotlin en lugar de depender de herramientas basadas en Java. Esto lo convierte en una opción ideal para proyectos orientados a Kotlin.\nBeneficios de KSP:  Velocidad: Procesa código Kotlin más rápido que kapt. Diseño centrado en Kotlin: Funciona directamente con los constructos del lenguaje Kotlin, evitando abstracciones basadas en Java. Ligero: Reduce el código repetitivo y se integra perfectamente con Gradle. Compatibilidad: Muchas bibliotecas populares ahora son compatibles con KSP de manera nativa.  Setting Up KSP in Your Project Agrega el plugin de KSP a tu proyecto\nConfiguración de Gradle 1 2 3 4 5 6 7 8 9 10 11 12 13  plugins { kotlin(\u0026#34;jvm\u0026#34;) version \u0026#34;\u0026lt;latest-kotlin-version\u0026gt;\u0026#34; id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;\u0026lt;latest-ksp-version\u0026gt;\u0026#34; } repositories { mavenCentral() } dependencies { implementation(kotlin(\u0026#34;stdlib\u0026#34;)) ksp(\u0026#34;\u0026lt;ksp-processor-library\u0026gt;\u0026#34;) }   Reemplaza \u0026lt;ksp-processor-library\u0026gt; con la dependencia del procesador específico de la biblioteca, como se muestra en los ejemplos a continuación.\nEjemplo 1: KSP con las anotaciones de Koin Koin desde la versión 3.4.0, permite definir dependencias a través de anotaciones, que luego son procesadas usando KSP para generar los módulos de Koin.\nConfiguración de Koin con KSP Añade las siguientes dependencias:\n1 2 3 4 5  dependencies { implementation(\u0026#34;io.insert-koin:koin-core:\u0026lt;version\u0026gt;\u0026#34;) implementation(\u0026#34;io.insert-koin:koin-annotations:\u0026lt;version\u0026gt;\u0026#34;) ksp(\u0026#34;io.insert-koin:koin-ksp-compiler:\u0026lt;version\u0026gt;\u0026#34;) }   Anota las clases Usa las anotaciones de Koin para definir tu grafo de dependencias:\n1 2 3 4 5 6 7 8 9  @Module @ComponentScan class AppModule @Single class UserRepository @Factory class UserUseCase(private val userRepository: UserRepository)   Módulo generado El procesador de KSP genera automáticamente un módulo de Koin. Puedes incluirlo en la configuración de tu aplicación:\n1 2 3 4 5  fun main() { startKoin { modules(AppModuleModule().module) } }   Esto elimina la necesidad de escribir manualmente el módulo de Koin, ahorrando tiempo y reduciendo el código repetitivo.\nExample 2: KSP con base de datos Room Room es un ORM ampliamente utilizado para Android. Con KSP, Room procesa anotaciones más rápidamente, reduciendo significativamente los tiempos de compilación\nConfiguración de Room con KSP Agrega las siguientes dependencias:\n1 2 3 4  dependencies { implementation(\u0026#34;androidx.room:room-runtime:\u0026lt;version\u0026gt;\u0026#34;) ksp(\u0026#34;androidx.room:room-compiler:\u0026lt;version\u0026gt;\u0026#34;) }   Anota las entidades 1 2 3 4 5  @Entity data class User( @PrimaryKey val id: Int, val name: String )   Generar DAO y Base de Datos 1 2 3 4 5 6 7 8 9 10  @Dao interface UserDao { @Query(\u0026#34;SELECT * FROM User\u0026#34;) fun getAllUsers(): List\u0026lt;User\u0026gt; } @Database(entities = [User::class], version = 1) abstract class AppDatabase : RoomDatabase() { abstract fun userDao(): UserDao }   Usando KSP, Room genera el código necesario de forma automática, reduciendo el código repetitivo.\nComo crear un procesador KSP personalizado Construyamos un procesador KSP personalizado que genere una clase Builder para clases de datos anotadas con @GenerateBuilder.\nCrear el módulo Primero, debes crear un módulo con la API para KSP.\n1 2 3  dependencies { implementation(\u0026#34;com.google.devtools.ksp:symbol-processing-api:\u0026lt;version\u0026gt;\u0026#34;) }   Definir la anotación 1 2 3  @Target(AnnotationTarget.CLASS) @Retention(AnnotationRetention.SOURCE) annotation class GenerateBuilder   Lógica del procesador KSP El procesador puede generar dinámicamente una clase Builder basada en las propiedades de la data class con la anotación. Necesitas crear una clase que extienda SymbolProcessor donde todo el trabajo se realizará en la función process, y una clase extendiendo SymbolProcessorProvider, que proveerá de la implementación del SymbolProcessor.\nAquí la implementación de SymbolProcessor:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  class KspBuilderProcessor( private val codeGenerator: CodeGenerator ) : SymbolProcessor { override fun process(resolver: Resolver): List\u0026lt;KSAnnotated\u0026gt; { val symbols = resolver.getSymbolsWithAnnotation(GenerateBuilder::class.qualifiedName.toString()) .filterIsInstance\u0026lt;KSClassDeclaration\u0026gt;() symbols.forEach { symbol -\u0026gt; val className = symbol.simpleName.asString() val packageName = symbol.packageName.asString() val generatedClassName = \u0026#34;${className}Builder\u0026#34; val file = codeGenerator.createNewFile( dependencies = Dependencies(false, symbol.containingFile!!), packageName = packageName, fileName = generatedClassName ) val properties = symbol.getAllProperties() val builderProperties = mutableListOf\u0026lt;String\u0026gt;() val setters = mutableListOf\u0026lt;String\u0026gt;() val buildMethodParams = mutableListOf\u0026lt;String\u0026gt;() properties.forEach { property -\u0026gt; val propName = property.simpleName.asString() val propType = property.type.resolve().declaration.simpleName.asString() .let { if (property.type.resolve().isMarkedNullable) \u0026#34;$it?\u0026#34; else it } val defaultValue = getDefaultValueFromProperty(property) builderProperties.add(\u0026#34; private var $propName: $propType= $defaultValue\u0026#34;) setters.add(\u0026#34; fun set${propName.replaceFirstChar { it.uppercase() }}($propName: $propType) = apply { this.$propName= $propName}\u0026#34;) buildMethodParams.add(\u0026#34; $propName= this.$propName\u0026#34;) } val builderClass = buildString { appendLine(\u0026#34;package $packageName\u0026#34;) appendLine() appendLine(\u0026#34;class $generatedClassName{\u0026#34;) builderProperties.forEach { property -\u0026gt; appendLine(property) } appendLine() setters.forEach { setter -\u0026gt; appendLine(setter) } appendLine() appendLine(\u0026#34; fun build(): $className{\u0026#34;) appendLine(\u0026#34; return $className(\u0026#34;) buildMethodParams.forEach { methodParam -\u0026gt; appendLine(methodParam) } appendLine(\u0026#34; )\u0026#34;) appendLine(\u0026#34; }\u0026#34;) appendLine(\u0026#34;}\u0026#34;) appendLine() appendLine(\u0026#34;fun ${generatedClassName.replaceFirstChar { it.lowercase() }}(block: $generatedClassName.() -\u0026gt; Unit): $className{\u0026#34;) appendLine(\u0026#34; return $generatedClassName().apply(block).build()\u0026#34;) appendLine(\u0026#34;}\u0026#34;) } file.write(builderClass.toByteArray()) file.close() } return symbols.filterNot { it.validate() }.toList() } private fun getDefaultValueFromProperty(property: KSPropertyDeclaration): String { val propType = property.type.resolve().declaration.qualifiedName?.asString() ?: \u0026#34;Any\u0026#34; val isNullable = property.type.resolve().isMarkedNullable return if (isNullable) \u0026#34;null\u0026#34; else when (propType) { \u0026#34;kotlin.String\u0026#34; -\u0026gt; \u0026#34;\\\u0026#34;\\\u0026#34;\u0026#34; \u0026#34;kotlin.Int\u0026#34;, \u0026#34;kotlin.Long\u0026#34;, \u0026#34;kotlin.Short\u0026#34;, \u0026#34;kotlin.Byte\u0026#34; -\u0026gt; \u0026#34;0\u0026#34; \u0026#34;kotlin.Double\u0026#34;, \u0026#34;kotlin.Float\u0026#34; -\u0026gt; \u0026#34;0.0\u0026#34; \u0026#34;kotlin.Boolean\u0026#34; -\u0026gt; \u0026#34;false\u0026#34; else -\u0026gt; throw IllegalArgumentException(\u0026#34;Non-nullable type $propTyperequires a default value\u0026#34;) } } }   Y aquí la clase que extiende de SymbolProcessorProvider:\n1 2 3 4 5  class KspBuilderProvider : SymbolProcessorProvider { override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor { return KspBuilderProcessor(environment.codeGenerator) } }   Con estas dos clases ya solo falta crear un fichero con ruta src/main/resources/META-INF/services y nombre com.google.devtools.ksp.processing.SymbolProcessorProvider. Su contenido será el nombre completo de la clase que extiende de SymbolProcessorProvider que acabas de crear. En este caso quedaría así:\ncom.example.kspbuilder.KspBuilderProvider Usando el procesador KSP personalizado Agregar el procesador personalizado Añade el plugin KSP al fichero build.gradle.kts en el módulo donde quieres utilizar la anotación:\n1 2 3 4 5 6 7 8  plugins { id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;\u0026lt;version\u0026gt;\u0026#34; } dependencies { implementation(project(\u0026#34;:KspBuilder\u0026#34;)) ksp(project(\u0026#34;:KspBuilder\u0026#34;)) }   Anotar la clase Crea una data class con la anotación:\n1 2 3 4 5  @GenerateBuilder class Person(val id: Int, val name: String, val age: Int, val address: Address?) @GenerateBuilder class Address(val id: Int, val name: String, val country: String)   Código generado Después de compilar el proyecto, el código generado con KSP se localiza en el directorio build/generated/ksp.\nPara la data class Person, la clase builder generada se ve así:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class PersonBuilder { private var id: Int = 0 private var name: String = \u0026#34;\u0026#34; private var age: Int = 0 private var address: Address? = null fun setId(id: Int) = apply { this.id = id } fun setName(name: String) = apply { this.name = name } fun setAge(age: Int) = apply { this.age = age } fun setAddress(address: Address?) = apply { this.address = address } fun build(): Person { return Person( id = this.id, name = this.name, age = this.age, address = this.address ) } } fun personBuilder(block: PersonBuilder.() -\u0026gt; Unit): Person { return PersonBuilder().apply(block).build() }   Para la data class Address, la clase builder generada sería así:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class AddressBuilder { private var id: Int = 0 private var name: String = \u0026#34;\u0026#34; private var country: String = \u0026#34;\u0026#34; fun setId(id: Int) = apply { this.id = id } fun setName(name: String) = apply { this.name = name } fun setCountry(country: String) = apply { this.country = country } fun build(): Address { return Address( id = this.id, name = this.name, country = this.country ) } } fun addressBuilder(block: AddressBuilder.() -\u0026gt; Unit): Address { return AddressBuilder().apply(block).build() }   Ejemplo de uso 1 2 3 4 5 6 7 8 9 10 11 12  val person = personBuilder { setId(10) setName(\u0026#34;Test\u0026#34;) setAge(100) setAddress( addressBuilder { setId(10) setName(\u0026#34;AddressTest\u0026#34;) setCountry(\u0026#34;Spain\u0026#34;) } ) }   Conclusión KSp es una herramienta muy importante para los desarrolladores Kotlin. Su diseño ligero y centrado en Kotlin hace que sea un reemplazo perfecto de kapt, su habilidad para generar código dinámicamente abre un gran abanico de posibilidades. Tanto si usas KSP con librerías como Koin y Room o creas tu propio procesador para tu caso de uso, KSP brinda las herramientas necesarias para elevar tu desarrollo al siguiente nivel.\nIntenta integrar KSP en tu próximo proyecto y observa los beneficios de primera mano!\nAquí dejo el repositorio con el código utilizado para crear el procesador KSP personalizado Github Repo\n","description":"Kotlin Avanzado - Kotlin Symbol Processing (KSP)","id":4,"section":"es","tags":["kotlin","android","advanced"],"title":"Explorando Kotlin KSP","uri":"https://carrion.dev/ko/es/posts/kotlin-ksp/"},{"content":"Explorando las funciones Infix en Kotlin Kotlin, es un lenguaje de programación moderno con funcionalidades que permiten escribir un código más expresivo y conciso. Una de estas funcionalidades son las infix functions, que permiten escribir código más limpio y legible. En este post, exploraremos que son las funciones infix, como usarlas y algunos ejemplo prácticos.\nQué son las funciones Infix? Las funciones infix en Kotlin son un tipo especial de función que pueden ser llamadas sin el uso de paréntesis o el punto. Esto puede hacer que ciertos patrones de código se lean de forma más natural, asemejándose a la sintaxis tradicional relacionada con matemáticas o DSL.\nEste sería un ejemplo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Point(val x: Int, val y: Int) { infix fun moveBy(offset: Point): Point { return Point(this.x + offset.x, this.y + offset.y) } } fun main() { val point1 = Point(2, 3) val offset = Point(1, 1) // Using the infix notation  val newPoint = point1 moveBy offset println(\u0026#34;New Point: (\\${newPoint.x}, \\${newPoint.y})\u0026#34;) }   En este ejemplo, la función moveBy se llama usando la notación infix, mejorando la legibilidad.\nReglas y sintaxis Aquí estan unos puntos clave acerca de las funciones infix:\n Solo un parámetro: La función debe recibir exáctamente un parámetro. Miembros de clase o funciones de extensión: Debe estar definida como una función de clase o una función de extensión. No Varargs or argumentos por defecto: El parámetro no puede tener valores por defecto o ser un vararg.  Ejemplo con una función de extensión:\n1 2 3 4 5 6 7 8  infix fun String.concatWith(other: String): String { return this + other } fun main() { val result = \u0026#34;Hello\u0026#34; concatWith \u0026#34; World\u0026#34; println(result) // Outputs: Hello World }   Casos de uso prácticos Las funciones infix son comunmente utilizadas en Kotlin para hacer el código más conciso y legible. Brillan en escenarios donde las operaciones intuitivas son necesarias, como cuando se trabaja con colecciones, rangos o expresiones de frameworks de testing o de inyección de dependencias. Abajo de estas líneas hay algunos ejemplos de como las funciones infix pueden simplificar el código que escribimos diariamente:\n  Mapeando claves con valores: La función to en la librería estandar de Kotlin es una función infix que ayuda a crear pares, normalmente se usan en los mapas.\n1 2 3 4  fun main() { val map = mapOf(\u0026#34;key1\u0026#34; to \u0026#34;value1\u0026#34;, \u0026#34;key2\u0026#34; to 42) println(map) // Outputs: {key1=value1, key2=42} }     Definiendo rangos: La función until es una función infix que se usa para definir rangos donde se excluye el límite superior.\n1 2 3 4 5  fun main() { for (i in 1 until 5) { println(i) // Outputs: 1, 2, 3, 4  } }     Definiendo el comportamiento de mocks: Librerías tales como MockK usan funciones infix para crear configuraciones de test más expresivas y legibles.\n1 2 3 4 5 6 7 8 9 10  class Calculator { fun add(a: Int, b: Int): Int = a + b } fun test() { val calculator = mockk\u0026lt;Calculator\u0026gt;() every { calculator.add(1, 2) } returns 3 println(calculator.add(1, 2)) // Outputs: 3 }     Inyección de dependencias con Koin: Koin, un framework de inyección de dependencias para Kotlin, usa la función infix bind para definir las relaciones entre clases e interfaces de una manera más legible y limpia.\n1 2 3 4 5 6  interface MyInterface class MyImplementation : MyInterface val appModule = module { single { MyImplementation() } bind MyInterface::class }   La función infix bind mejora la legibilidad cuando declaras que implementación específica debe usarse para inyectar una interfaz.\n  Cuando usar funciones Infix Mientras las funciones infix pueden hacer el código más limpio, deben usarse con cuidado:\n La operación es intuitiva y fácilmente entendible. Cuando mejoran la legibilidad y el flujo. Encajan naturalmente dentro del DSL.  Evitar las funciones infix en los siguientes casos:\n Puede llevar a una sintaxis ambigua y confusa. El propósito de la función no está claro con el nombre o uso.  Conclusión Las funciones infix de Kotlin son una herramienta poderosa para crear código más expresivo y legible. Definiendo un DSL, simplificando operaciones matemáticas, o mejorando expresiones lógicas, las funciones infix pueden hacer tu código más eleganto. De todas formas, al igual que con cualquier otra funcionalidad, debe ser usadas con cuidado para mantener la claridad del código y evitar sobrecomplicaciones.\nIntenta incorporar funciones infix en tu próximo proyecto de Kotlin y fíjate como transforma tu código! ¿Cuales son tus funciones infix favoritas o que formas creativas tienes de usarlas?\n","description":"Kotlin avanzado - Funciones Infix","id":5,"section":"es","tags":["kotlin","android","advanced"],"title":"Funciones Infix en Kotlin","uri":"https://carrion.dev/ko/es/posts/kotlin-infix/"},{"content":"✨ Entendiendo los Kotlin Delegates: La magia detrás de código más limpio ✨ Los Kotlin delegates son una funcionalidad muy útil que te permite delegar el comportamiento de una propiedad o incluso una implementación de una interfaz a otro objecto. En lugar de escribir lógica repetitiva o manejar el estado directamente, puedes delegar esta responsabilidad a clases especializadas y reusables.\nComo funcionan los Delegates Delegates en Kotlin funcionan usando la palabra reservada by, que redirecciona el comportamiento de una propiedad o interfaz al objeto delegado. Para propiedades, el objeto delegado provee una implementación personalizada de los métodos get y o set. Para la delegación de interfaces, la implementación de esa interfaz es delegada al objecto.\nEsto es un ejemplo de una propiedad delegada:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class StringDelegate { private var value: String = \u0026#34;\u0026#34; operator fun getValue(thisRef: Any?, property: kotlin.reflect.KProperty\u0026lt;*\u0026gt;): String { println(\u0026#34;Getting value for \\${property.name}\u0026#34;) return value } operator fun setValue(thisRef: Any?, property: kotlin.reflect.KProperty\u0026lt;*\u0026gt;, newValue: String) { println(\u0026#34;Setting value for \\${property.name} to \\$newValue\u0026#34;) value = newValue } } class Example { var text: String by StringDelegate() } fun main() { val example = Example() example.text = \u0026#34;Hello, Kotlin!\u0026#34; println(example.text) }   Output Setting value for text to Hello, Kotlin! Getting value for text Hello, Kotlin! En este ejemplo:\n La clase StringDelegate define un comportamiento personalizado del acceso a la propiedad usando los operadores getValuey setValue. La propiedad text en la clase Exampledelega su comportamiento a la instancia de StringDelegate.  Aplicaciones reales de Kotlin Delegates 1️⃣ Inyección de dependencias con Koin En #Koin, puedes usar el delegado by inject() para inyectar dependencias directamente en tus clases. Esto elimina la necesidad de instanciar manualmente:\n1 2 3 4 5 6 7 8 9 10  class DelegatesFragment : Fragment() { private val tracker: AnalyticsTracker by inject() } inline fun \u0026lt;reified T : Any\u0026gt; KoinComponent.inject( qualifier: Qualifier? = null, mode: LazyThreadSafetyMode = KoinPlatformTools.defaultLazyMode(), noinline parameters: ParametersDefinition? = null, ): Lazy\u0026lt;T\u0026gt; = lazy(mode) { get\u0026lt;T\u0026gt;(qualifier, parameters) }   El delegado by inject() automáticamente resuelve la dependencia usando el contenedor de Koin. Esto abstrae la lógica, resultando en código más limpio y testeable.\n2️⃣ Manejo de estados en Jetpack Compose En Jetpack Compose, la función remember junto con mutableStateOf es un gran ejemplo de delegación. Esto ayuda a manejar el estado de forma eficiente dentro de los composables:\n1 2 3 4 5 6 7 8 9 10 11  @Composable fun Counter() { var count by remember { mutableStateOf(0) } Column { Text(\u0026#34;Count: $count\u0026#34;) Button(onClick = { count++ }) { Text(\u0026#34;Increment\u0026#34;) } } }   3️⃣ Inicialización Lazy El delegado lazy es perfecto para propiedades que necesitan ser inicializadas solo cuando se acceden por primera vez:\n1 2 3 4 5 6 7 8 9  val greeting: String by lazy { println(\u0026#34;Initializing...\u0026#34;) \u0026#34;Hello, Kotlin!\u0026#34; } fun main() { println(greeting) // Initializes here  println(greeting) // Uses cached value }   Output Initializing... Hello, Kotlin! Hello, Kotlin! 4️⃣ Delegación de interfaces Kotlin permite delegar la implementación de una interfaz a otro objeto.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  interface Logger { fun log(message: String) } class ConsoleLogger : Logger { override fun log(message: String) { println(\u0026#34;Log: $message\u0026#34;) } } class FileLogger : Logger { override fun log(message: String) { println(\u0026#34;Writing log to file: $message\u0026#34;) } } class Application(logger: Logger) : Logger by logger fun main() { val consoleApp = Application(ConsoleLogger()) consoleApp.log(\u0026#34;Starting console application\u0026#34;) val fileApp = Application(FileLogger()) fileApp.log(\u0026#34;Starting file application\u0026#34;) }   Output Log: Starting console application Writing log to file: Starting file application Esto es lo que está pasando:\n La clase Application no tiene que implementar los métodos Logger de forma directa. En su lugar, delega la implementación de Logger al objeto pasado por constructor usando by. Esto hace más sencillo cambiar las implementaciones sin necesidad de cambiar la clase Application.  Por qué usar Kotlin Delegates? Los Delegates encapsulan la lógica que de otra manera cargarían y desordenarían tus clases. Ayudan a:\n Simplificar el código al reutilizar lógica, por ejemplo con la inicialización lazy. Abstraen patrones repetitivos, por ejemplo con la inyección de dependencias con #koin. Mejoran el manejo de los estados con la función mutableStateOf de Compose. Provee implementaciones modulares y reutilizables de interfaces.  Conclusion El mecanismo de los delegados en Kotlin es un ejemplo de como este lenguaje combina simplicidad con funcionalidad. Los delegados están en todas partes en el desarrollo de Kotlin. En qué otros casos los utilizas en tus proyectos?\n","description":"Kotlin avanzado - Delegates","id":6,"section":"es","tags":["kotlin","android","advanced"],"title":"Kotlin Delegates","uri":"https://carrion.dev/ko/es/posts/kotlin-delegates/"},{"content":"Kotlin Avanzado - Contracts: Cómo volver al compilador de Kotlin más inteligente Kotlin nunca deja de impresionarme con sus funcionalidades. Una función avanzada pero poco utilizada en el arsenal de Kotlin son los Contracts. Los contratos te permiten guiar al compilador de Kotlin para que tome mejores decisiones acerca de tu código, resultando en mejor seguridad ante nulos, mejor rendimiento o incluso menores errores en tiempo de ejecución.\nQué son los contratos de Kotlin? Los contratos de Kotlin te permiten definir reglas acerca de como se comporta tu código, ayudando al compilador a hacer un análisis estático más avanzado. Los contratos habilitan funcionalidades como smart-casts y comprobaciones teniendo en cuenta el contexto, superando las capacidades básicas de Kotlin.\nPor qué usar contratos?  Mejora la seguridad ante nulos: Elimina las comprobaciones de nulos redundantes ayudando al compilador a saber cuando algo está garantizado que no sea nulo. Smart-casts optimizados: Hace que el compilador conozca el tipo de las variables en casos específicos. Reduce la repeticón de código: Escribe código más limpio e intuitivo delegando las comprobaciones repetitivas al compilador.  Ejemplos de contratos en Kotlin 1. Simplificar las comprobaciones de nuloss Vamos a crear una función para validar valores no nulos:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @OptIn(ExperimentalContracts::class) inline fun \u0026lt;T\u0026gt; requireNotNull(value: T?, message: String): T { contract { returns() implies (value != null) } if (value == null) { throw IllegalArgumentException(message) } return value } fun processName(name: String?) { val nonNullName = requireNotNull(name, \u0026#34;Name cannot be null\u0026#34;) // No need for additional null checks; compiler knows \u0026#39;nonNullName\u0026#39; is not null!  println(\u0026#34;Processing name: $nonNullName\u0026#34;) } fun main() { processName(\u0026#34;John\u0026#34;) // Works fine  // processName(null) // Throws an IllegalArgumentException }   Cómo los contratos nos ayudan aquí?  La parte del contrato returns() implies (value != null) le dice al compilador:  Si la función retorna de forma satisfactoria, entonces value está garantizado que no es nulo.\n  Esto habilita smart-casts, de manera que no tienes que volver a comprobar si es nulo manualmente una vez llamada esta función.  Algo muy similar se hace en las funciones require y requireNotNull de la librería estandar de Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  /** * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false. * * @sample samples.misc.Preconditions.failRequireWithLazyMessage */ @kotlin.internal.InlineOnly public inline fun require(value: Boolean, lazyMessage: () -\u0026gt; Any): Unit { contract { returns() implies value } if (!value) { val message = lazyMessage() throw IllegalArgumentException(message.toString()) } } /** * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise * returns the not null value. * * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage */ @kotlin.internal.InlineOnly public inline fun \u0026lt;T : Any\u0026gt; requireNotNull(value: T?, lazyMessage: () -\u0026gt; Any): T { contract { returns() implies (value != null) } if (value == null) { val message = lazyMessage() throw IllegalArgumentException(message.toString()) } else { return value } }   2. Afirmaciones personalizadas Aquí se ve como los contratos pueden ser usados para definir afirmaciones personalizadas:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @OptIn(ExperimentalContracts::class) fun assertValidState(condition: Boolean, message: String) { contract { returns() implies condition } if (!condition) { throw IllegalStateException(message) } } fun performOperation(state: Boolean) { val state: Any? = \u0026#34;Hello\u0026#34; assertValidState(state is String, \u0026#34;Is String\u0026#34;) // Here the compiler knows that the state val is of type String so no need to other cast checks  println(\u0026#34;String length: ${assertion.length}\u0026#34;) } fun main() { performOperation(true) // Prints success  // performOperation(false) // Throws IllegalStateException }   3. Smart-Casts con condiciones personalizadas Vamos a crear una funcionalidad custom que comprueba si una valor coincide con un tipo específico. Esto demostrará como los contratos pueden ayudar a mejorar las comprobaciones:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  @OptIn(ExperimentalContracts::class) inline fun \u0026lt;reified T\u0026gt; isOfType(value: Any?): Boolean { contract { returns(true) implies (value is T) } return value is T } fun main() { val input: Any? = \u0026#34;Hello, Kotlin!\u0026#34; if (isOfType\u0026lt;String\u0026gt;(input)) { println(\u0026#34;String length: ${input.length}\u0026#34;) } val inputInt: Any? = 10 if (isOfType\u0026lt;Int\u0026gt;(inputInt)) { println(\u0026#34;The value is an integer ${input.toUInt()}\u0026#34;) } }   Con esta implementación, el compilador sabe que dentro del bloque if, input es un String, gracias al contrato definido en isOfType. The la misma manera, el compilador sabe que inputInt es de tipo Int y no hace falta comprobar el tipo de nuevo.\n4. Optimizando el control del flujo Los contratos pueden simplificar el control del flujo habilitando al compilador para entender las invariantes o condiciones. Por ejemplo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  inline fun isNotEmpty(list: List\u0026lt;*\u0026gt;?): Boolean { contract { returns(true) implies (list != null \u0026amp;\u0026amp; list.isNotEmpty()) } return list != null \u0026amp;\u0026amp; list.isNotEmpty() } fun processItems(items: List\u0026lt;String\u0026gt;?) { if (isNotEmpty(items)) { // Compiler knows items is non-null and not empty  println(\u0026#34;Processing ${items.size}items\u0026#34;) } else { println(\u0026#34;No items to process\u0026#34;) } } fun main() { processItems(listOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;)) processItems(null) processItems(emptyList()) }   Salida Processing 3 items No items to process No items to process Cuando usar contratos Los contratos son ideales para:\n Desarrollo de librerías: Proteger APIs públicas forzando condiciones pre existentes. DSLs y Frameworks: Simplificando la comprobación de tipos y validación de estados en DSLs de Kotlin. Optimizaciones en tiempo de ejecución: Reduce las comprobaciones en tiempo de ejecución al permitir al compilador inferir las condiciones en tiempo de compilación.  Conclusion Los contratos de Kotlin son una gema oculta que pueden perfeccionar tu código mejorando la seguridad, reduciendo la repetición de código, y permitiendo un análisis por parte del compilador más inteligente. Tanto si estás creando librerías, escribiendo complejos DSLs, o simplemente optimizando código del día a día, los contratos proveen una herramienta muy poderosa para guiar al compilador de Kotlin y asegurando un código correcto.\nTener en cuenta que los contratos están anotados como funcionalidad experimental pero están implementados en Kotlin desde la versión 1.3 y se usan extensamente en la librería estandar de Kotlin así que son lo suficiente estables como para utilizarlos.\n","description":"Kotlin avanzado - Contracts","id":7,"section":"es","tags":["kotlin","android","advanced"],"title":"Kotlin contracts","uri":"https://carrion.dev/ko/es/posts/kotlin-contracts/"},{"content":"Exportar a Swift en KMP Empezando con la versión 2.1.0 podemos empezar a probar a exportar a Swift en Kotlin. Esta funcionalidad te permite exportar los módulos compartidos de Kotlin a Swift sin usar Objective-C. Esto mejorará la experiancia de los desarrolladores de iOS cuando usen módulos de KMP.\nActualmente el soporte básico incluye:\n Exportar múltiples módulos de Gradle a swift. Definir los nombres de los módulos swift. Simplificar la estructura de paquetes.  Activar la funcionalidad Para empezar a probar esta funcionalidad debes activarla en el fichero gradle.properties:\nkotlin.experimental.swift-export.enabled=true Configuración Después de añadir la línea mostrada arriba necesitas añadir esta configuración al fichero build.gradle.kts:\n1 2 3 4 5 6 7 8 9 10 11  kotlin { iosX64() iosArm64() iosSimulatorArm64() @OptIn(ExperimentalSwiftExportDsl::class) swiftExport { moduleName = \u0026#34;shared\u0026#34; flattenPackage = \u0026#34;dev.carrion.kmpswiftexport\u0026#34; } }   El siguiente paso es configurar xcode para lanzar la nueva tarea embedSwiftExportForXcode en lugar de embedAndSignAppleFrameworkForXcode. Puedes realizar este cambio desde la configuración de Build phases de la iosApp desde xcode o bien desde Android Studio modificando el fichero project.pbxproj.\nDebes cambiar esta línea:\nshellScript = \u0026quot;cd \\\u0026quot;$SRCROOT/..\\\u0026quot;\\n./gradlew :shared:embedAndSignAppleFrameworkForXcode\\n\u0026quot;; Por esta otra:\nshellScript = \u0026quot;cd \\\u0026quot;$SRCROOT/..\\\u0026quot;\\n./gradlew :shared:embedSwiftExportForXcode\\n\u0026quot;; Después de aplicar estos cambios deberías ser capaz de lanzar la aplicación de iOS desde Android Studio o desde xcode sin ningún problema.\nAntes de activar la funcionalidad Si intentas navegar a la definición de una función de Kotlin desde xcode en un archivo swift, se mostrará el código Objective-C que se exporta del módulo compartido de Kotlin. Este fichero generado es enorme teniendo en cuenta la complejidad del projecto usado para este ejemplo.\nTe voy a mostrar a continuación una pequeña pieza del archivo de 175 líneas generado desde el código de Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;Greeting\u0026#34;))) @interface SharedGreeting : SharedBase - (instancetype)init __attribute__((swift_name(\u0026#34;init()\u0026#34;))) __attribute__((objc_designated_initializer)); + (instancetype)new __attribute__((availability(swift, unavailable, message=\u0026#34;use object initializers instead\u0026#34;))); - (NSString *)greet __attribute__((swift_name(\u0026#34;greet()\u0026#34;))); @end __attribute__((swift_name(\u0026#34;Platform\u0026#34;))) @protocol SharedPlatform @required @property (readonly) NSString *name __attribute__((swift_name(\u0026#34;name\u0026#34;))); @end __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;IOSPlatform\u0026#34;))) @interface SharedIOSPlatform : SharedBase \u0026lt;SharedPlatform\u0026gt; - (instancetype)init __attribute__((swift_name(\u0026#34;init()\u0026#34;))) __attribute__((objc_designated_initializer)); + (instancetype)new __attribute__((availability(swift, unavailable, message=\u0026#34;use object initializers instead\u0026#34;))); @property (readonly) NSString *name __attribute__((swift_name(\u0026#34;name\u0026#34;))); @end __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;Platform_iosKt\u0026#34;))) @interface SharedPlatform_iosKt : SharedBase + (id\u0026lt;SharedPlatform\u0026gt;)getPlatform __attribute__((swift_name(\u0026#34;getPlatform()\u0026#34;))); @end #pragma pop_macro(\u0026#34;_Nullable_result\u0026#34;) #pragma clang diagnostic pop NS_ASSUME_NONNULL_END   After enabling the feature Cuando activas al funcionalidad de exportar a Swift y compilas el proyecto, al intentar navegar a la definición de una función del código compartido de Kotlin, xcode te mostrará el código exportado de Swift.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  @_exported import ExportedKotlinPackages @_implementationOnly import SharedBridge_shared import KotlinRuntime public typealias Greeting = ExportedKotlinPackages.dev.carrion.kmpswiftexport.Greeting public func getPlatform() -\u0026gt; Swift.Never { ExportedKotlinPackages.dev.carrion.kmpswiftexport.getPlatform() } public extension ExportedKotlinPackages.dev.carrion.kmpswiftexport { public final class Greeting : KotlinRuntime.KotlinBase { public override init() { let __kt = dev_carrion_kmpswiftexport_Greeting_init_allocate() super.init(__externalRCRef: __kt) dev_carrion_kmpswiftexport_Greeting_init_initialize__TypesOfArguments__Swift_UInt__(__kt) } public override init( __externalRCRef: Swift.UInt ) { super.init(__externalRCRef: __externalRCRef) } public func greet() -\u0026gt; Swift.String { return dev_carrion_kmpswiftexport_Greeting_greet(self.__externalRCRef()) } } public static func getPlatform() -\u0026gt; Swift.Never { fatalError() } }   El código mostrado arriba es el fichero completo con 28 líneas, una gran diferencia con las 175 líneas del código exportado en Objective-C. También es importante mencionar la menor complejidad y mayor legibilidad del código swift.\nConclusion Después de probar esta nueva funcionalidad, estoy realmente impresionado con la mejora que supone para el desarrollo de iOS en los proyectos KMP. También me sorprende la diferencia en el código exportado en Objective-C y swift. Estoy seguro que esta funcionalidad mejorará en las siguientes versiones y acercará la experiencia entre el desarrollo nativo y el desarrollo multiplataforma.\nPuedes encontrar el repositorio con el código usado en este ejemplo en SwiftExport, con dos ramas, main, con la configuración del típico iOS framework conf, y la rama swift-export con la nueva funcionalidad habilitada.\n","description":"Nueva funcionalidad en Kotlin 2.1.0, exportar directamente a swift desde Kotlin","id":8,"section":"es","tags":["kotlin","android","kmp"],"title":"Exportar a Swift en KMP","uri":"https://carrion.dev/ko/es/posts/swift-export/"},{"content":"Condiciones en las expresiones when en Kotlin 2.1.0 Una de las nuevas funcionalidades de Kotlin 2.1.0 es las condiciones en las expresiones when, lo que tendría varias ventajas entre las que se incluye:\n Reducir anidaciones Evita código repetido Mejorar legibilidad  Activar la funcionalidad en Kotlin 2.1.0 Esta funcionalidad se encuentra en preview lo que es necesario activarla explícitamente para poder usarla en Kotlin 2.1.0. En el fichero build.gradle.kts añadiremos el siguiente código dentro del bloque de kotlin {}:\n1 2 3 4 5  kotlin { compilerOptions { freeCompilerArgs.add(\u0026#34;-Xwhen-guards\u0026#34;) } }   Uso de condicionales dentro de las ramas de la expresiones when Para este ejemplo usaremos una sealed interface para manejar respuestas de un servicio remoto:\n1 2 3 4 5  sealed interface Response\u0026lt;out T\u0026gt; { data object Loading : Response\u0026lt;Nothing\u0026gt; data class Content \u0026lt;out T\u0026gt; (val data: T?) : Response\u0026lt;T\u0026gt; data class Error(val error: Exception) : Response\u0026lt;Nothing\u0026gt; }   Esta interfaz la implementan Loading, Content y Error para gestionar los distintos estados de una respuesta.\nAntes de la nueva funcionalidad 1 2 3 4 5 6 7 8 9 10 11 12 13  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handleOld() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content -\u0026gt; if (data != null) { println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } is Response.Error -\u0026gt; if (error is IllegalStateException) { println(\u0026#34;Handled error\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } }   Como se puede ver en este caso se repite el código que muestra por pantalla Unknown error además de añadir anidaciones que dificultan la lectura del código.\nUsando los nuevos condicionales Se debe añadir el if justo después de la condición primaria de la rama, por ejemplo:\n1 2 3 4 5 6  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled error\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   De esta manera no se repite el código que mostraba por pantalla el texto de Unknown error y además eliminamos las anidaciones facilitando la lectura del código.\nEn caso de necesitar comprobar varias condiciones en la rama else se podría añadir una rama else if que controle el flujo de los casos que no cumplen las condiciones anteriores.\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) else if this is Response.Error \u0026amp;\u0026amp; this.error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   Esto último se puede simplificar usando dos ramas con la misma primera condición de is Response.Error que a mi parecer queda más simple:\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) is Response.Error if error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   Conclusión Con esta nueva funcionalidad se podrá añadir nuevas condiciones sin tener que repetir código y permitirá que las expresiones when sean más concisas. En la versión 2.1.0 de Kotlin está en modo preview pero se espera que pronto esta nueva funcionalidad sea estable.\nAquí el enlace a la documentación con las novedades de Kotlin 2.1.0 donde se explica la funcionalidad de condicionales en las expresiones when kotlinlang\n","description":"Nueva funcionalidad en Kotlin 2.1.0, condiciones en las expresiones when","id":9,"section":"es","tags":["kotlin","android","kmp"],"title":"Condiciones en las expresiones when para Kotlin 2.1.0.","uri":"https://carrion.dev/ko/es/posts/kotlin-guard-conditions-in-when/"},{"content":"Inyección de valores en tiempo de ejecución con Dagger-Hilt Desde que apareció Hilt para facilitar la inyección de dependencias en aplicaciones Android, no era posible la inyección de dependencias en tiempo de ejecución sin utilizar librerías ajenas a Dagger o Hilt. Desde la versión 2.31 se incorpora en Dagger la anotación @AssistedInject. Con esta anotación vamos a ser capaces de indicar a Dagger-Hilt que dependencias se tienen que resolver en tiempo de ejecución y retrasar la inyección de esos parámetros hasta tener los valores.\nEsto era necesario para poder inyectar valores en los constructores de los ViewModel y poder ejecutar alguna operación en el método init del mismo. Como puede ser una petición a una API externa o bien una consulta en la base de datos local.\nEn este artículo veremos como implementar el @AssistedInject de Dagger para la inyección de valores en tiempo de ejecución en ViewModels con Hilt.\nInstalación En el fichero build.gradle raíz del proyecto, incluiremos el siguiente classpath:\n1  classpath \u0026#39;com.google.dagger:hilt-android-gradle-plugin:2.31.2-alpha\u0026#39;   Una vez añadido el classpath añadiremos el plugin de Hilt en el fichero build.gradle del módulo app.\n1  apply plugin: \u0026#39;dagger.hilt.android.plugin\u0026#39;   Y también las siguientes líneas a nuestras dependencias:\n1 2  implementation \u0026#39;com.google.dagger:hilt-android:2.31.2-alpha\u0026#39; kapt \u0026#39;com.google.dagger:hilt-android-compiler:2.31.2-alpha\u0026#39;   También hay que tener en cuenta tener añadido en nuestro build.gradle el plugin de kapt. Para ello añadiremos lo siguiente a nuestro archivo de build.gradle del módulo app junto al resto de plugins:\n1  apply plugin: \u0026#39;kotlin-kapt\u0026#39;   Esa son las dependencias necesarias para implementar Hilt en nuestro proyecto. A lo largo de este post se usan distintas librerías como que no se definen en este artículo.\nEn este enlace puedes ver un ejemplo de un archivo build.gradle completo: app/build.gradle\nImplementación Para este ejemplo usaremos una clase repositorio encargada de recibir el nombre de usuario y devolver un mensaje de bienvenida. Para ello crearemos la siguiente interfaz:\n1 2 3  interface UserRepository { fun getMessage(name: String): String }   Y su implementación:\n1 2 3 4 5  class UserRepositoryImpl @Inject constructor() : UserRepository { override fun getMessage(name: String): String { return \u0026#34;Hi $name\u0026#34; } }   Anotamos el constructor con @Inject para posteriormente poder declarar un @Binds en el módulo de Hilt e inyectar la implementación cada vez que se pida una interfaz del tipo UserRepository.\nVamos a crear el siguiente ViewModel que será el encargado de recibir el nombre del usuario desde el Activity o Fragment y llamar al repositorio para recibir el mensaje de bienvenida:\n1 2 3 4 5 6 7 8 9  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { ... }   En este ViewModel podemos ver como se anota el constructor con @AssistedInject para indicar a Dagger-Hilt que esta clase contiene dependencias que se deben inyectar en tiempo de ejecución. Esas dependencias están anotadas con @Assisted.\nPara poder crear el ViewModel con la extensión by viewModels() de la librería de AndroidX debemos crear la Factory que más tarde pasaremos a la extensión:\n1 2 3 4 5 6 7 8  class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } }   Como puedes ver necesitamos la interfaz UserViewModelAssistedFactory que es la encargada de proveer los parámetros en tiempo de ejecución. Esta interfaz la implementamos de la siguiente forma:\n1 2 3 4 5 6  @AssistedFactory interface UserViewModelAssistedFactory { fun create(name: String): UserViewModel }   Se trata de una interfaz con una función create que recibe los parámetros a inyectar en tiempo de ejecución. En nuestro caso solo necesitamos el name, pero en caso de necesitar inyectar más parámetros en tiempo de ejecución, se pasarían como parámetro a esta función.\nCon esto ya podemos completar nuestro ViewModel con la lógica necesaria para pedir la respuesta al repositorio y exponer al Fragment o Activity a través de un StateFlow.\nEl ViewModel completo quedaría:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } } private val _message: MutableStateFlow\u0026lt;String\u0026gt; = MutableStateFlow(\u0026#34;\u0026#34;) val message: StateFlow\u0026lt;String\u0026gt; get() = _message init { viewModelScope.launch(dispatcher) { _message.emit(repository.getMessage(name)) } } }   Relativo a Hilt solo nos faltaría declarar el módulo indicando como proveer las dependencias. Para este ejemplo usaremos el siguiente módulo:\n1 2 3 4 5 6 7 8 9 10 11 12 13  @Module @InstallIn(ActivityComponent::class) abstract class MainModule { companion object { @Provides @Named(\u0026#34;UserDispatcher\u0026#34;) fun provideUserDispatcher(): CoroutineDispatcher = Dispatchers.IO } @Binds abstract fun provideUserRepository(repositoryImpl: UserRepositoryImpl): UserRepository }   En este módulo declaramos un Dispatcher para que sea más sencillo testear este ViewModel en un futuro. Y hacemos @Binds de nuestra interfaz UserRepository con su implementación UserRepositoryImpl.\nAhora podemos inyectar nuestro repositorio en una Activity o Fragment de la siguiente forma:\n1 2 3 4 5 6 7 8  private val navArgs: UserFragmentArgs by navArgs() @Inject lateinit var assistedFactory: UserViewModelAssistedFactory private val userViewModel: UserViewModel by viewModels { UserViewModel.Factory(assistedFactory, navArgs.name) }   Simplemente nos faltaría observar los cambios en el StateFlow del ViewModel para poder actualizar nuestra UI. Eso se haría de la siguiente manera en un Fragment aunque sería muy similar en un Activity\n1 2 3 4 5 6 7 8  override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycleScope.launchWhenStarted { userViewModel.message.collect { binding.name.text = it } } }    Recordar que es necesario anotar una clase que extienda de Application con @HiltAndroidApp y cada uno de las Activities o Fragments que usen inyección con Hilt con la anotación @AndroidEntryPoint.\n Conclusión Como hemos podido observar con @AssistedInject de Dagger podemos inyectar valores en tiempo de ejecución de una forma sencilla y podemos seguir utilizando los navArgs de AndroidX.\nEn el siguiente repositorio teneis el ejemplo completo: HiltAssistedInject\n","description":"Como inyectar valores en tiempo de ejecución a los ViewModel en Android.","id":10,"section":"es","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Hilt: Inyectar valores al ViewModel en tiempo de ejecución.","uri":"https://carrion.dev/ko/es/posts/hilt-inject-parameters-runtime/"},{"content":"Bienvenido a Carrion.dev Saludos Androide!!\nBienvenido a mi nuevo blog de Kotlin y programación Android. Me llamo Ignacio Carrión y soy dessarrollador Android. Me encanta el lenguaje Kotlin por las facilidades que me aporta al programar para Android y las infinitas posibilidades que ofrece en otros ámbitos (backend, web, nativo, multiplataforma).\nEn este blog espero poder publicar cosas interesantes acerca del lenguaje Kotlin y el ecosistema Android al menos cada dos semanas. Si quieres mantenerte al día no dudes en apuntarte a nuestra newsletter.\nSi tienes alguna duda, idea acerca de la que podemos hablar en un post o simplemente quieres contactar estoy disponible a través del correo: ignacio@carrion.dev.\nEspero que aprendamos mucho todos juntos!!\n","description":"Primer post en mi nuevo blog de Kotlin y Android.","id":11,"section":"es","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Bienvenido a mi nuevo blog sobre Kotlin y desarrollo Android","uri":"https://carrion.dev/ko/es/posts/welcome-to-my-new-kotlin-and-android-development-blog/"},{"content":"Sobre mi. Me llamo Ignacio Carrión, vivo en Valencia (España) y el que aparece en la foto es mi perro Wilfred. Me gusta cualquier cosa relacionada con la informática y los videojuegos. Actualmente trabajo como Senior Android Engineer para Tkww. Anteriormente he trabajado en otras empresas como desarrollador Android y también he impartido clases de programación. A raiz de mi trabajo como profesor me dí cuenta de que realmente me encanta aprender y que la gente aprenda conmigo. De esa motivación surge la idea de crear este blog, Carrion.dev.\nEspero poder ir publicando de forma asídua cosas interesantes acerca del lenguaje Kotlin y el ecosistema Android. Cualquier crítica constructiva e ideas acerca de posibles temas para artículos serán bien recibidas. Abajo aparecen los enlaces a las redes sociales en las que podrás encontrarme y contactar conmigo.\nContactar Portfolio\nGithub\n","description":"Ignacio Carrión, Desarrollador Android","id":16,"section":"es","tags":null,"title":"Sobre mi","uri":"https://carrion.dev/ko/es/about/"}]