<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>architecture on Carrion.dev</title><link>https://carrion.dev/ko/tags/architecture/</link><description>Recent content in architecture on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>ko</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Fri, 22 Aug 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/ko/tags/architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>Inyección de Dependencias + Inversión de Dependencias: Código más Robusto y Testeable</title><link>https://carrion.dev/ko/es/posts/dependency-injection-benefits/</link><pubDate>Fri, 22 Aug 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 22 Aug 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/dependency-injection-benefits/</guid><description>Inyección de Dependencias + Inversión de Dependencias: Código más Robusto y Testeable Las aplicaciones modernas evolucionan rápido: se añaden funcionalidades, se multiplican las plataformas y los equipos crecen. En este contexto, el acoplamiento fuerte se convierte en un freno al cambio y en una fuente de tests frágiles. Dos ideas clave nos ayudan a combatir esta complejidad:
Principio de Inversión de Dependencias (DIP) de SOLID: los módulos de alto nivel no deben depender de los de bajo nivel.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/dip.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>architecture</category><category>solid</category><category>dependency-injection</category><category>testing</category></item><item><title>Patrones DataSource y Repository: Construyendo una Capa de Datos Robusta</title><link>https://carrion.dev/ko/es/posts/datasources-repository-patterns/</link><pubDate>Fri, 13 Jun 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 13 Jun 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/datasources-repository-patterns/</guid><description>Patrones DataSource y Repository: Construyendo una Capa de Datos Robusta En el desarrollo de aplicaciones modernas, gestionar el acceso a datos de manera eficiente es crucial para crear software mantenible y escalable. Dos patrones arquitectónicos que mejoran significativamente la gestión de datos son los patrones DataSource y Repository. Este artículo explora qué son estos patrones, cómo funcionan juntos y cómo implementarlos de manera efectiva con ejemplos prácticos.
¿Qué Son los DataSources?</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/repository.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>architecture</category><category>clean-architecture</category><category>repository-pattern</category><category>datasources</category><category>software-design</category></item><item><title>Casos de Uso: Mejorando la Arquitectura de tu Proyecto</title><link>https://carrion.dev/ko/es/posts/usecases-architecture/</link><pubDate>Fri, 06 Jun 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 06 Jun 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/usecases-architecture/</guid><description>Casos de Uso: Mejorando la Arquitectura de tu Proyecto En el desarrollo de software moderno, crear aplicaciones mantenibles, testables y escalables es un desafío constante. Un patrón arquitectónico que ha ganado una tracción significativa es el uso de Casos de Uso (también conocidos como Interactores en algunos contextos). Este artículo explora qué son los Casos de Uso, por qué mejoran la arquitectura de tu proyecto y cómo implementarlos de manera efectiva con ejemplos sencillos.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/usecase.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>architecture</category><category>clean-architecture</category><category>usecases</category><category>software-design</category></item><item><title>Aprovechando las Sealed Classes e Interfaces para un Mejor Modelado de Dominio</title><link>https://carrion.dev/ko/es/posts/sealed-classes-domain-modeling/</link><pubDate>Tue, 15 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 15 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/sealed-classes-domain-modeling/</guid><description>Aprovechando las Sealed Classes e Interfaces para un Mejor Modelado de Dominio El modelado de dominio es un aspecto crucial del desarrollo de software, representando los conceptos y reglas de negocio fundamentales en tu aplicación. Kotlin proporciona potentes características de lenguaje que pueden ayudar a crear modelos de dominio más expresivos, con seguridad de tipos y mantenibles. Entre estas características, las sealed classes e interfaces destacan como herramientas particularmente valiosas. Este artículo explora cómo aprovechar estas características de Kotlin para construir mejores modelos de dominio.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/sealed-classes.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category><category>domain modeling</category><category>type safety</category></item><item><title>Mejores Prácticas de Arquitectura en Kotlin Multiplatform para Aplicaciones Móviles</title><link>https://carrion.dev/ko/es/posts/kmp-architecture/</link><pubDate>Tue, 11 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 11 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/kmp-architecture/</guid><description>Mejores Prácticas de Arquitectura en Kotlin Multiplatform para Aplicaciones Móviles Kotlin Multiplatform (KMP) permite a los desarrolladores compartir la lógica de negocio entre Android y iOS mientras mantienen implementaciones específicas de cada plataforma cuando es necesario. Estructurar un proyecto KMP de manera eficiente es clave para mantener la escalabilidad, testabilidad y aplicar Clean Architecture. En esta guía, exploraremos las mejores prácticas para diseñar una aplicación móvil con Compose Multiplatform y Clean Architecture.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/expect-actual.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>compose</category><category>cmp</category><category>multiplatform</category><category>cleancode</category><category>architecture</category></item><item><title>Mejorando el Rendimiento de las Aplicaciones Android con Baseline Profiles</title><link>https://carrion.dev/ko/es/posts/baseline-profiles/</link><pubDate>Mon, 27 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 27 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/baseline-profiles/</guid><description>Mejorando el Rendimiento de las Aplicaciones Android con Baseline Profiles Introducción En el mundo móvil actual, los usuarios esperan que las aplicaciones se inicien al instante y funcionen sin problemas. La optimización del rendimiento es crucial, especialmente en lo que respecta al tiempo de inicio y la ejecución en tiempo de ejecución.
Los Baseline Profiles de Android ofrecen una forma eficaz de acelerar el inicio de la aplicación y mejorar el rendimiento en tiempo de ejecución al precompilar rutas de código críticas.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/baseline-profile.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Modularización en Proyectos Gradle con Kotlin</title><link>https://carrion.dev/ko/es/posts/gradle-modularization/</link><pubDate>Thu, 23 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 23 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/gradle-modularization/</guid><description>Modularización en Proyectos Gradle con Kotlin: Una Guía Completa Introducción A medida que los proyectos crecen en complejidad, mantener una base de código monolítica se vuelve un desafío. La modularización es una técnica de diseño de software que divide una aplicación en módulos más pequeños e independientes, haciendo que el proyecto sea más escalable, mantenible y eficiente.
En esta guía, exploraremos por qué la modularización es esencial, los diferentes tipos de módulos y las mejores prácticas para configurar un proyecto modular en Gradle usando Kotlin.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/folder-structure.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Test-Driven Development (TDD) en Kotlin para Android</title><link>https://carrion.dev/ko/es/posts/tdd-kotlin/</link><pubDate>Mon, 20 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 20 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/tdd-kotlin/</guid><description>Test-Driven Development (TDD) en Kotlin para Android El Test-Driven Development (TDD) es una práctica de desarrollo de software que enfatiza escribir pruebas antes de implementar la funcionalidad. Sigue un ciclo Rojo-Verde-Refactorización: primero, escribes una prueba que falla (Rojo), luego implementas el código mínimo para que pase (Verde), y finalmente, refactorizas el código manteniendo la prueba en verde (Refactorización). En esta publicación, exploraremos cómo aplicar TDD en Kotlin para el desarrollo de Android usando JUnit, MockK y Coroutines, con un ejemplo del mundo real.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/tdd-cycle.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category><category>TDD</category><category>testing</category></item><item><title>Clean Architecture en Kotlin &amp; Android</title><link>https://carrion.dev/ko/es/posts/clean-architecture/</link><pubDate>Sat, 18 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Sat, 18 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/clean-architecture/</guid><description>Clean Architecture en Kotlin &amp;amp; Android Introducción Al desarrollar aplicaciones Android, mantener la escalabilidad y la legibilidad es crucial. Sin un enfoque arquitectónico claro, los proyectos pueden volverse difíciles de mantener a medida que crecen. Aquí es donde Clean Architecture, introducida por Uncle Bob (Robert C. Martin), se vuelve invaluable. Esta arquitectura enfatiza la separación de responsabilidades, haciendo que el código sea más modular, testeable y mantenible.
Entendiendo Clean Architecture Clean Architecture está estructurada en tres capas principales, cada una con un rol específico:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/domain-layer.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Explorando Arquitecturas de Apps en Kotlin</title><link>https://carrion.dev/ko/es/posts/app-architecture/</link><pubDate>Wed, 15 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 15 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/app-architecture/</guid><description>Explorando Arquitecturas de Apps en Kotlin: MVC, MVP, MVVM y MVI Introducción En el desarrollo moderno de aplicaciones, elegir la arquitectura adecuada es esencial para crear aplicaciones mantenibles y escalables. Las arquitecturas definen cómo se organiza tu base de código y cómo interactúan los diferentes componentes. En este artículo, exploraremos cuatro arquitecturas populares: Model-View-Controller (MVC), Model-View-Presenter (MVP), Model-View-ViewModel (MVVM) y Model-View-Intent (MVI). Analizaremos su estructura, ventajas, desventajas y ejemplos prácticos en Kotlin.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/mvvm.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Kotlin Design Patterns - Part 3</title><link>https://carrion.dev/ko/es/posts/design-patterns-3/</link><pubDate>Mon, 13 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 13 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/design-patterns-3/</guid><description>Explorando Más Patrones de Diseño en Kotlin: Parte 3 Part 1 Part 2 Part 3 En esta tercera entrega, cubriremos los patrones Memento, Command, Visitor, Chain of Responsibility y Mediator. Estos patrones abordan desafíos de construcción, comportamiento y estructura, mostrando la sintaxis expresiva y las características modernas de Kotlin.
1. Patrón Memento El Patrón Memento captura y restaura el estado de un objeto sin exponer sus detalles internos.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/memento-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item><item><title>Entendiendo los principios SOLID con ejemplos en Kotlin</title><link>https://carrion.dev/ko/es/posts/solid-kotlin/</link><pubDate>Wed, 08 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 08 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/solid-kotlin/</guid><description>Entendiendo los principios SOLID con ejemplos en Kotlin Los principios SOLID son un conjunto de principios de diseño que hacen que los diseños de software sean más comprensibles, flexibles y mantenibles. Introducidos por Robert C. Martin, estos principios son una piedra angular de la programación orientada a objetos y son especialmente relevantes al construir sistemas complejos. En este blog, exploraremos cada principio con ejemplos escritos en Kotlin, un lenguaje que ofrece una sintaxis moderna y características poderosas.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/di-fix.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>solid</category><category>architecture</category></item><item><title>Patrones de diseño en Kotlin - Parte 2</title><link>https://carrion.dev/ko/es/posts/design-patterns-2/</link><pubDate>Mon, 06 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 06 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/design-patterns-2/</guid><description>Explorando patrones de diseño en Kotlin: Parte2 Design Patterns Series Part 1 Part 2 Part 3 Después de la gran acogida del primer artículo Patrones de diseño en Kotlin, volvemos con más! En esta segunda parte, revisaremos los patrones de Prototype, Composite, Proxy, Observer, y Strategy. Estos patrones resuelven una variedad de desafios de diseño y demuestran las capacidades expresivas de Kotlin.
1. Patrón Prototype El Patrón Prototype es usado para crear nuevos objeto copiando una objeto existente, asegurando la creación eficaz de objetos.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/proxy-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item><item><title>Patrones de diseño en Kotlin - Parte 1</title><link>https://carrion.dev/ko/es/posts/design-patterns-1/</link><pubDate>Mon, 30 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 30 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/design-patterns-1/</guid><description>Explorando patrones de diseño en Kotlin - Parte 1 Serie Patrones de diseño Design Patterns Series Part 1 Part 2 Part 3 Los patrones de diseño son soluciones probadas a problemas comunes en el diseño de software. Con la sintaxis y funcionalidades modernas de Kotlin, implementar estos patrones normalmente resulta más limpio y conciso. En este post, exploraremos los patrones de Singleton, Factory Method, Builder, Adapter and Decorator, profundizando en su propósito, casos de uso y implementaciones en Kotlin.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/singleton-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item></channel></rss>