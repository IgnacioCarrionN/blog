<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>architecture on Carrion.dev</title><link>https://carrion.dev/ko/tags/architecture/</link><description>Recent content in architecture on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>ko</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Thu, 23 Jan 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/ko/tags/architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>Modularización en Proyectos Gradle con Kotlin</title><link>https://carrion.dev/ko/es/posts/gradle-modularization/</link><pubDate>Thu, 23 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 23 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/gradle-modularization/</guid><description>Modularización en Proyectos Gradle con Kotlin: Una Guía Completa Introducción A medida que los proyectos crecen en complejidad, mantener una base de código monolítica se vuelve un desafío. La modularización es una técnica de diseño de software que divide una aplicación en módulos más pequeños e independientes, haciendo que el proyecto sea más escalable, mantenible y eficiente.
En esta guía, exploraremos por qué la modularización es esencial, los diferentes tipos de módulos y las mejores prácticas para configurar un proyecto modular en Gradle usando Kotlin.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/folder-structure.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Test-Driven Development (TDD) en Kotlin para Android</title><link>https://carrion.dev/ko/es/posts/tdd-kotlin/</link><pubDate>Mon, 20 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 20 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/tdd-kotlin/</guid><description>Test-Driven Development (TDD) en Kotlin para Android El Test-Driven Development (TDD) es una práctica de desarrollo de software que enfatiza escribir pruebas antes de implementar la funcionalidad. Sigue un ciclo Rojo-Verde-Refactorización: primero, escribes una prueba que falla (Rojo), luego implementas el código mínimo para que pase (Verde), y finalmente, refactorizas el código manteniendo la prueba en verde (Refactorización). En esta publicación, exploraremos cómo aplicar TDD en Kotlin para el desarrollo de Android usando JUnit, MockK y Coroutines, con un ejemplo del mundo real.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/tdd-cycle.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category><category>TDD</category><category>testing</category></item><item><title>Clean Architecture en Kotlin &amp; Android</title><link>https://carrion.dev/ko/es/posts/clean-architecture/</link><pubDate>Sat, 18 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Sat, 18 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/clean-architecture/</guid><description>Clean Architecture en Kotlin &amp;amp; Android Introducción Al desarrollar aplicaciones Android, mantener la escalabilidad y la legibilidad es crucial. Sin un enfoque arquitectónico claro, los proyectos pueden volverse difíciles de mantener a medida que crecen. Aquí es donde Clean Architecture, introducida por Uncle Bob (Robert C. Martin), se vuelve invaluable. Esta arquitectura enfatiza la separación de responsabilidades, haciendo que el código sea más modular, testeable y mantenible.
Entendiendo Clean Architecture Clean Architecture está estructurada en tres capas principales, cada una con un rol específico:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/domain-layer.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Explorando Arquitecturas de Apps en Kotlin</title><link>https://carrion.dev/ko/es/posts/app-architecture/</link><pubDate>Wed, 15 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 15 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/app-architecture/</guid><description>Explorando Arquitecturas de Apps en Kotlin: MVC, MVP, MVVM y MVI Introducción En el desarrollo moderno de aplicaciones, elegir la arquitectura adecuada es esencial para crear aplicaciones mantenibles y escalables. Las arquitecturas definen cómo se organiza tu base de código y cómo interactúan los diferentes componentes. En este artículo, exploraremos cuatro arquitecturas populares: Model-View-Controller (MVC), Model-View-Presenter (MVP), Model-View-ViewModel (MVVM) y Model-View-Intent (MVI). Analizaremos su estructura, ventajas, desventajas y ejemplos prácticos en Kotlin.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/mvvm.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Kotlin Design Patterns - Part 3</title><link>https://carrion.dev/ko/es/posts/design-patterns-3/</link><pubDate>Mon, 13 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 13 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/design-patterns-3/</guid><description>Explorando Más Patrones de Diseño en Kotlin: Parte 3 Part 1 Part 2 Part 3 En esta tercera entrega, cubriremos los patrones Memento, Command, Visitor, Chain of Responsibility y Mediator. Estos patrones abordan desafíos de construcción, comportamiento y estructura, mostrando la sintaxis expresiva y las características modernas de Kotlin.
1. Patrón Memento El Patrón Memento captura y restaura el estado de un objeto sin exponer sus detalles internos.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/memento-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item><item><title>Entendiendo los principios SOLID con ejemplos en Kotlin</title><link>https://carrion.dev/ko/es/posts/solid-kotlin/</link><pubDate>Wed, 08 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 08 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/solid-kotlin/</guid><description>Entendiendo los principios SOLID con ejemplos en Kotlin Los principios SOLID son un conjunto de principios de diseño que hacen que los diseños de software sean más comprensibles, flexibles y mantenibles. Introducidos por Robert C. Martin, estos principios son una piedra angular de la programación orientada a objetos y son especialmente relevantes al construir sistemas complejos. En este blog, exploraremos cada principio con ejemplos escritos en Kotlin, un lenguaje que ofrece una sintaxis moderna y características poderosas.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/di-fix.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>solid</category><category>architecture</category></item><item><title>Patrones de diseño en Kotlin - Parte 2</title><link>https://carrion.dev/ko/es/posts/design-patterns-2/</link><pubDate>Mon, 06 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 06 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/design-patterns-2/</guid><description>Explorando patrones de diseño en Kotlin: Parte2 Design Patterns Series Part 1 Part 2 Part 3 Después de la gran acogida del primer artículo Patrones de diseño en Kotlin, volvemos con más! En esta segunda parte, revisaremos los patrones de Prototype, Composite, Proxy, Observer, y Strategy. Estos patrones resuelven una variedad de desafios de diseño y demuestran las capacidades expresivas de Kotlin.
1. Patrón Prototype El Patrón Prototype es usado para crear nuevos objeto copiando una objeto existente, asegurando la creación eficaz de objetos.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/proxy-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item><item><title>Patrones de diseño en Kotlin - Parte 1</title><link>https://carrion.dev/ko/es/posts/design-patterns-1/</link><pubDate>Mon, 30 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 30 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/ko/es/posts/design-patterns-1/</guid><description>Explorando patrones de diseño en Kotlin - Parte 1 Serie Patrones de diseño Design Patterns Series Part 1 Part 2 Part 3 Los patrones de diseño son soluciones probadas a problemas comunes en el diseño de software. Con la sintaxis y funcionalidades modernas de Kotlin, implementar estos patrones normalmente resulta más limpio y conciso. En este post, exploraremos los patrones de Singleton, Factory Method, Builder, Adapter and Decorator, profundizando en su propósito, casos de uso y implementaciones en Kotlin.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/singleton-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item></channel></rss>