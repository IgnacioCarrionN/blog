[{"content":"Entendiendo los Operadores de Flujo (Flow): Buffer, Conflate, Debounce y Sample Cuando trabajamos con flujos de Kotlin (Flows), especialmente en escenarios que involucran productores que emiten r√°pidamente y colectores lentos, es crucial entender c√≥mo gestionar el flujo de datos de manera efectiva. Este post explora cuatro operadores esenciales de Flow que ayudan a manejar estos escenarios: buffer, conflate, debounce y sample.\nEl Problema: Colectores Lentos Antes de profundizar en los operadores, entendamos el problema que resuelven. Considera este escenario:\n1 2 3 4 5 6 7 8 9  flow { for (i in 1..100) { emit(i) delay(100) // Emit every 100ms  } }.collect { value: Int -\u0026gt; delay(300) // Process for 300ms  println(\u0026#34;Processed $value\u0026#34;) }   En este caso, el colector es m√°s lento que el productor, lo que puede llevar a problemas de contrapresi√≥n. Cada operador que discutiremos proporciona una estrategia diferente para manejar esta situaci√≥n.\nOperador Buffer El operador buffer crea un canal con capacidad espec√≠fica para almacenar emisiones mientras el colector procesa los valores anteriores.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  flow { for (i in 1..5) { emit(i) println(\u0026#34;Emitting $i\u0026#34;) delay(100) } }.buffer(2) // Buffer capacity of 2  .collect { value: Int -\u0026gt; println(\u0026#34;Collecting $value\u0026#34;) delay(300) // Slow collector } // Output: // Emitting 1 // Emitting 2 // Emitting 3 // Collecting 1 (t=300ms) // Collecting 2 (t=600ms) // Emitting 4 // Emitting 5 // Collecting 3 (t=900ms) // Collecting 4 (t=1200ms) // Collecting 5 (t=1500ms)   Cu√°ndo Usar Buffer  Cuando necesitas almacenar un n√∫mero espec√≠fico de emisiones Cuando necesitas procesar todos los valores pero quieres independizar las velocidades del productor y el colector Cuando es importante mantener el orden de procesamiento  Operador Conflate El operador conflate mantiene solo el √∫ltimo valor, descartando los valores intermedios si el colector no puede mantener el ritmo.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  flow { for (i in 1..5) { emit(i) println(\u0026#34;Emitting $i\u0026#34;) delay(100) } }.conflate() .collect { value: Int -\u0026gt; println(\u0026#34;Collecting $value\u0026#34;) delay(300) // Slow collector } // Output: // Emitting 1 // Emitting 2 // Collecting 1 (t=300ms) // Emitting 3 // Emitting 4 // Collecting 4 (t=600ms) // Emitting 5 // Collecting 5 (t=900ms)   Cu√°ndo Usar Conflate  Cuando solo interesa el valor m√°s reciente En escenarios de interfaz de usuario donde no es necesario mostrar estados intermedios Cuando no es cr√≠tico procesar cada valor individual  Operador Debounce El operador debounce emite un valor solo despu√©s de que ha pasado un tiempo espec√≠fico sin nuevas emisiones.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  flow { emit(1) delay(90) emit(2) // Will be dropped  delay(90) emit(3) // Will be dropped  delay(150) // Longer than debounce timeout  emit(4) // Will be emitted }.debounce(100) .collect { value: Int -\u0026gt; println(\u0026#34;Collecting $value\u0026#34;) } // Output: // Collecting 1 (t=100ms) // Collecting 4 (t=430ms) // (Values 2 and 3 are dropped because new values arrived before debounce timeout)   Cu√°ndo Usar Debounce  Para implementar b√∫squeda mientras se escribe Para manejar eventos r√°pidos de interfaz de usuario Cuando necesitas esperar \u0026ldquo;per√≠odos de calma\u0026rdquo; antes de procesar  Operador Sample El operador sample toma peri√≥dicamente el valor m√°s reciente del flujo en intervalos espec√≠ficos.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  flow { var i = 0 while (i \u0026lt; 10) { emit(i++) delay(50) // Emit every 50ms  } }.sample(100) // Sample every 100ms  .collect { value: Int -\u0026gt; println(\u0026#34;Sampled value: $value\u0026#34;) } // Output: // Sampled value: 1 (t=100ms) // Sampled value: 3 (t=200ms) // Sampled value: 5 (t=300ms) // Sampled value: 7 (t=400ms) // Sampled value: 9 (t=500ms) // (Only captures the latest value every 100ms)   Cu√°ndo Usar Sample  Cuando requieres actualizaciones regulares en intervalos fijos Para mostrar datos en tiempo real donde los valores intermedios no son relevantes Para limitar la tasa de procesamiento independientemente de la frecuencia de emisi√≥n  Comparaci√≥n y Mejores Pr√°cticas Aqu√≠ hay una comparaci√≥n r√°pida de estos operadores:\n   Operador Comportamiento Caso de Uso     buffer Almacena emisiones Procesamiento completo manteniendo el orden   conflate Mantiene solo el √∫ltimo Actualizaciones de interfaz, √∫ltimo valor   debounce Espera per√≠odo de calma B√∫squeda en tiempo real, eventos r√°pidos   sample Muestreo peri√≥dico Actualizaciones regulares, control de frecuencia    Conclusi√≥n Comprender estos operadores de Flow es fundamental para construir aplicaciones reactivas eficientes:\n Utiliza buffer cuando necesites procesar todos los valores y controlar el uso de memoria Utiliza conflate cuando solo importe el √∫ltimo valor Utiliza debounce cuando manejes eventos r√°pidos que requieran \u0026ldquo;tiempo de asentamiento\u0026rdquo; Utiliza sample cuando necesites actualizaciones regulares en intervalos fijos  Selecciona el operador adecuado seg√∫n tu caso de uso espec√≠fico y los requisitos de completitud de datos, orden y frecuencia de procesamiento.\nRecuerda que estos operadores se pueden combinar para crear flujos de procesamiento de datos m√°s sofisticados, pero evita sobre-complicar tus flujos. Considera siempre el equilibrio entre la completitud de datos, el uso de memoria y la eficiencia de procesamiento.\n","description":"An√°lisis profundo de los operadores de flujo en Kotlin (Flow): buffer, conflate, debounce y sample. Aprende cu√°ndo y c√≥mo usar cada operador con ejemplos pr√°cticos.","id":2,"section":"es","tags":["kotlin","flows","coroutines"],"title":"Entendiendo los Operadores de Flujo (Flow): Buffer, Conflate, Debounce y Sample","uri":"https://carrion.dev/ko/es/posts/flow-operators-buffer-conflate/"},{"content":"Convirtiendo Callbacks a Coroutines y Flows en Kotlin Las APIs basadas en callbacks han sido un patr√≥n com√∫n en la programaci√≥n as√≠ncrona durante muchos a√±os. Sin embargo, con las corrutinas y flows de Kotlin, podemos transformar estos callbacks en c√≥digo moderno y secuencial que es m√°s f√°cil de leer y mantener. En este art√≠culo, exploraremos c√≥mo usar suspendCoroutine y callbackFlow para convertir APIs basadas en callbacks a corrutinas y flows.\nEntendiendo suspendCoroutine La funci√≥n suspendCoroutine es una herramienta poderosa que nos permite envolver APIs basadas en callbacks en funciones suspend. Esta transformaci√≥n hace que el c√≥digo as√≠ncrono sea m√°s secuencial y f√°cil de manejar.\nUso B√°sico de suspendCoroutine Aqu√≠ hay un ejemplo simple de c√≥mo convertir una funci√≥n basada en callbacks a una funci√≥n suspend:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // Traditional callback-based API interface LocationCallback { fun onLocationFound(location: Location) fun onError(error: Exception) } class LocationService { fun getCurrentLocation(callback: LocationCallback) { // Simulating async location fetch  // Implementation details...  } } // Converted to suspend function suspend fun LocationService.getLocationSuspend(): Location { return suspendCoroutine\u0026lt;Location\u0026gt; { continuation: Continuation\u0026lt;Location\u0026gt; -\u0026gt; getCurrentLocation(object : LocationCallback { override fun onLocationFound(location: Location) { continuation.resume(location) } override fun onError(error: Exception) { continuation.resumeWithException(error) } }) } } // Usage suspend fun fetchLocation() { try { val location = locationService.getLocationSuspend() println(\u0026#34;Ubicaci√≥n recibida: $location\u0026#34;) } catch (e: Exception) { println(\u0026#34;Error al obtener la ubicaci√≥n: ${e.message}\u0026#34;) } }   Manejo de Cancelaci√≥n Cuando trabajamos con suspendCoroutine, es importante manejar la cancelaci√≥n adecuadamente:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  suspend fun LocationService.getLocationSuspendWithCancellation(): Location { return suspendCancellableCoroutine\u0026lt;Location\u0026gt; { continuation: CancellableContinuation\u0026lt;Location\u0026gt; -\u0026gt; val callback = object : LocationCallback { override fun onLocationFound(location: Location) { continuation.resume(location) } override fun onError(error: Exception) { continuation.resumeWithException(error) } } getCurrentLocation(callback) continuation.invokeOnCancellation { // Cleanup resources, remove callbacks, etc.  removeLocationUpdates(callback) } } }   Convirtiendo a Flows con callbackFlow Mientras que suspendCoroutine es excelente para operaciones √∫nicas, callbackFlow es perfecto para manejar flujos de datos o eventos. Nos permite convertir APIs basadas en callbacks que emiten m√∫ltiples valores en Kotlin Flows.\nEjemplo B√°sico de callbackFlow Aqu√≠ te mostramos c√≥mo convertir una API de actualizaciones de ubicaci√≥n a un Flow:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  interface LocationUpdatesCallback { fun onLocationUpdate(location: Location) fun onError(error: Exception) } class LocationService { fun startLocationUpdates(callback: LocationUpdatesCallback) { // Implementation details...  } fun stopLocationUpdates(callback: LocationUpdatesCallback) { // Implementation details...  } } fun LocationService.locationUpdatesFlow(): Flow\u0026lt;Location\u0026gt; = callbackFlow { val callback = object : LocationUpdatesCallback { override fun onLocationUpdate(location: Location) { trySend(location) } override fun onError(error: Exception) { close(error) } } startLocationUpdates(callback) // Clean up when the flow is cancelled  awaitClose { stopLocationUpdates(callback) } } // Usage suspend fun trackLocation() { locationService.locationUpdatesFlow() .catch { error: Throwable -\u0026gt; println(\u0026#34;Error en actualizaciones de ubicaci√≥n: ${error.message}\u0026#34;) } .collect { location: Location -\u0026gt; println(\u0026#34;Nueva ubicaci√≥n: $location\u0026#34;) } }   Manejo de Contrapresi√≥n (Backpressure) Cuando tratamos con actualizaciones frecuentes, es importante manejar la contrapresi√≥n adecuadamente:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  fun SensorService.sensorUpdatesFlow(): Flow\u0026lt;SensorData\u0026gt; = callbackFlow { val callback = object : SensorCallback { override fun onSensorUpdate(data: SensorData) { // Use trySend instead of send to handle backpressure  if (!trySend(data).isSuccess) { // Handle unsuccessful send  println(\u0026#34;Buffer full, dropping sensor update\u0026#34;) } } } registerSensorCallback(callback) awaitClose { unregisterSensorCallback(callback) } }.buffer(Channel.CONFLATED) // Keep only the latest value   Mejores Pr√°cticas   Manejo de Errores\n Siempre manejar errores apropiadamente tanto en suspendCoroutine como en callbackFlow Usar bloques try-catch para suspendCoroutine Usar el operador catch para flows    Gesti√≥n de Recursos\n Limpiar recursos en awaitClose para callbackFlow Usar suspendCancellableCoroutine cuando se necesite manejar cancelaci√≥n    Consideraciones de Contrapresi√≥n\n Elegir estrategias de buffer apropiadas para tu caso de uso Considerar usar canales conflated o buffered seg√∫n tus necesidades    Pruebas\n Escribir pruebas tanto para escenarios de √©xito como de error Probar el comportamiento de cancelaci√≥n Verificar la limpieza de recursos    Patrones Comunes y Ejemplos Manejo de Timeout 1 2 3 4 5 6 7 8 9 10 11 12 13 14  suspend fun apiCallWithTimeout(): Result\u0026lt;String\u0026gt; = withTimeout(5000L) { suspendCoroutine\u0026lt;Result\u0026lt;String\u0026gt;\u0026gt; { continuation: Continuation\u0026lt;Result\u0026lt;String\u0026gt;\u0026gt; -\u0026gt; api.call(object : ApiCallback { override fun onSuccess(result: Result\u0026lt;String\u0026gt;) { continuation.resume(result) } override fun onError(error: Exception) { continuation.resumeWithException(error) } }) } }   Combinando M√∫ltiples Callbacks 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  fun MultipleSourceService.combinedUpdatesFlow(): Flow\u0026lt;Update\u0026gt; = callbackFlow { val callback1 = object : SourceCallback { override fun onUpdate(data: Update) { trySend(data) } } val callback2 = object : SourceCallback { override fun onUpdate(data: Update) { trySend(data) } } registerCallbacks(callback1, callback2) awaitClose { unregisterCallbacks(callback1, callback2) } }.buffer(Channel.BUFFERED)   Conclusi√≥n La conversi√≥n de APIs basadas en callbacks a corrutinas y flows puede mejorar significativamente la legibilidad y mantenibilidad del c√≥digo. Usando suspendCoroutine para operaciones √∫nicas y callbackFlow para flujos de datos, puedes modernizar c√≥digo legacy y aprovechar al m√°ximo las potentes caracter√≠sticas de concurrencia de Kotlin.\nRecuerda siempre manejar los errores apropiadamente, gestionar los recursos correctamente y considerar la contrapresi√≥n cuando trates con actualizaciones de alta frecuencia. Con estas herramientas y patrones, puedes cerrar efectivamente la brecha entre las APIs basadas en callbacks y la concurrencia moderna de Kotlin.\n","description":"Aprende c√≥mo transformar APIs basadas en callbacks a corrutinas y flows modernos de Kotlin usando suspendCoroutine y callbackFlow","id":3,"section":"es","tags":["kotlin","coroutines","flows","callbacks"],"title":"Convirtiendo Callbacks a Corrutinas y Flows en Kotlin","uri":"https://carrion.dev/ko/es/posts/callback-to-flow-conversion/"},{"content":"Entendiendo los Hot y Cold Flows en Kotlin Kotlin Flow es una potente caracter√≠stica para manejar flows reactivos de datos. Uno de los conceptos fundamentales para entender cuando trabajamos con flows es la distinci√≥n entre hot y cold flows. Este art√≠culo explicar√° las diferencias y proporcionar√° ejemplos pr√°cticos de ambos tipos.\nCold Flows: El Comportamiento por Defecto Los cold flows son el tipo predeterminado en Kotlin Flow. Comienzan a producir valores solo cuando un collector empieza a recolectar de ellos. Cada collector obtiene su propio flow independiente de valores desde el principio.\nCaracter√≠sticas de los Cold Flows:  Comienzan a producir valores solo cuando son recolectados Cada collector recibe todos los valores desde el principio Los valores se producen independientemente para cada collector Los recursos no se comparten entre collectors  Aqu√≠ hay un ejemplo de un flujo cold:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  fun numbers(): Flow\u0026lt;Int\u0026gt; = flow { println(\u0026#34;Flow started\u0026#34;) for (i in 1..3) { delay(100) emit(i) } } suspend fun main() { val numbersFlow = numbers() // First collector  println(\u0026#34;First collector starting\u0026#34;) numbersFlow.collect { value: Int -\u0026gt; println(\u0026#34;Collector 1: $value\u0026#34;) } // Second collector  println(\u0026#34;Second collector starting\u0026#34;) numbersFlow.collect { value: Int -\u0026gt; println(\u0026#34;Collector 2: $value\u0026#34;) } }   Output:\nFirst collector starting Flow started Collector 1: 1 Collector 1: 2 Collector 1: 3 Second collector starting Flow started Collector 2: 1 Collector 2: 2 Collector 2: 3 Hot Flows: Estado Compartido y Eventos Los hot flows, por otro lado, pueden comenzar a producir valores independientemente de los collectors y pueden compartir el mismo flow de valores entre m√∫ltiples collectors. Son √∫tiles para representar eventos en tiempo real o estado compartido.\nTipos de Hot Flows:  StateFlow: Para representar estado SharedFlow: Para representar eventos  Ejemplo de StateFlow: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class TemperatureSensor { private val _temperature = MutableStateFlow(20.0) // Initial temperature  val temperature: StateFlow\u0026lt;Double\u0026gt; = _temperature.asStateFlow() fun updateTemperature(newTemp: Double) { _temperature.update { newTemp } } } suspend fun main() { val sensor = TemperatureSensor() // First collector  launch { sensor.temperature.collect { temp: Double -\u0026gt; println(\u0026#34;Display 1: $temp¬∞C\u0026#34;) } } delay(100) println(\u0026#34;Updating temperature to 22.5¬∞C\u0026#34;) sensor.updateTemperature(22.5) delay(100) // Late collector - will only see the current value (22.5) and future updates  launch { println(\u0026#34;Display 2 starting collection...\u0026#34;) sensor.temperature.collect { temp: Double -\u0026gt; println(\u0026#34;Display 2: $temp¬∞C\u0026#34;) } } delay(100) println(\u0026#34;Updating temperature to 23.0¬∞C\u0026#34;) sensor.updateTemperature(23.0) }   Output:\nDisplay 1: 20.0¬∞C Updating temperature to 22.5¬∞C Display 1: 22.5¬∞C Display 2 starting collection... Display 2: 22.5¬∞C Updating temperature to 23.0¬∞C Display 1: 23.0¬∞C Display 2: 23.0¬∞C Ejemplo de SharedFlow: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class EventBus { private val _events = MutableSharedFlow\u0026lt;String\u0026gt;() val events = _events.asSharedFlow() suspend fun emit(event: String) { _events.emit(event) } } suspend fun main() { val eventBus = EventBus() // First subscriber  launch { eventBus.events.collect { event: String -\u0026gt; println(\u0026#34;Subscriber 1: $event\u0026#34;) } } delay(100) println(\u0026#34;Emitting first event\u0026#34;) eventBus.emit(\u0026#34;User logged in\u0026#34;) delay(100) // Late subscriber - will miss the \u0026#34;User logged in\u0026#34; event  launch { println(\u0026#34;Subscriber 2 starting collection...\u0026#34;) eventBus.events.collect { event: String -\u0026gt; println(\u0026#34;Subscriber 2: $event\u0026#34;) } } delay(100) println(\u0026#34;Emitting second event\u0026#34;) eventBus.emit(\u0026#34;Data updated\u0026#34;) }   Output:\nSubscriber 1: User logged in Subscriber 2 starting collection... Emitting second event Subscriber 1: Data updated Subscriber 2: Data updated Diferencias Clave Entre Hot y Cold Flows   Tiempo de Ejecuci√≥n\n Cold Flow: Se ejecuta por cada collector Hot Flow: Puede ejecutarse independientemente de los collectors    Compartici√≥n de Valores\n Cold Flow: Cada collector obtiene su propio flow Hot Flow: M√∫ltiples collectors comparten el mismo flow    Uso de Recursos\n Cold Flow: Recursos asignados por collector Hot Flow: Recursos compartidos entre collectors    Casos de Uso\n Cold Flow: Transformaciones de datos, consultas a base de datos Hot Flow: Estados de UI, eventos en tiempo real, broadcasts    Cu√°ndo Usar Cada Tipo Usa Cold Flows Cuando:  Cada collector necesita su propio flow independiente Est√°s realizando operaciones que consumen muchos recursos Necesitas reiniciar el flow desde el principio para cada collector  Usa Hot Flows Cuando:  M√∫ltiples partes de tu app necesitan el mismo flow de datos Est√°s manejando estado de UI Necesitas transmitir eventos a m√∫ltiples suscriptores Quieres compartir recursos entre collectors  Mejores Pr√°cticas   Cold Flows\n √ösalos para operaciones que deben ejecutarse independientemente Considera usar buffer() para optimizaci√≥n de rendimiento Limpia los recursos en onCompletion    Hot Flows\n Usa StateFlow para gesti√≥n de estado Usa SharedFlow para eventos Considera cuidadosamente los tama√±os de replay y buffer Maneja la contrapresi√≥n adecuadamente    Al entender estas diferencias, puedes elegir el tipo correcto de flow para tu caso de uso espec√≠fico y crear flows reactivos m√°s eficientes y mantenibles en tus aplicaciones Kotlin.\n","description":"Una gu√≠a completa para entender las diferencias entre hot y cold flows en Kotlin, con ejemplos pr√°cticos","id":4,"section":"es","tags":["kotlin","coroutines","flows"],"title":"Entendiendo los Hot y Cold Flows en Kotlin","uri":"https://carrion.dev/ko/es/posts/kotlin-flows-hot-cold/"},{"content":"Logrando Seguridad en Tiempo de Compilaci√≥n con Koin: Una Gu√≠a Completa La inyecci√≥n de dependencias es un patr√≥n fundamental en el desarrollo moderno de Android, pero ¬øc√≥mo podemos asegurarnos de que nuestra configuraci√≥n de DI sea correcta antes de ejecutar la aplicaci√≥n? En esta publicaci√≥n, exploraremos dos poderosos enfoques para lograr la seguridad en tiempo de compilaci√≥n con Koin: usando la funci√≥n verify() del DSL y aprovechando las Anotaciones de Koin con KSP.\nEl Problema: Validaci√≥n en Tiempo de Ejecuci√≥n vs. Tiempo de Compilaci√≥n La inyecci√≥n de dependencias tradicional a menudo revela problemas de configuraci√≥n solo en tiempo de ejecuci√≥n:\n Las dependencias faltantes causan fallos Las dependencias circulares no se detectan hasta el tiempo de ejecuci√≥n Los desajustes de tipos se manifiestan cuando la aplicaci√≥n est√° en ejecuci√≥n El alcance (scoping) incorrecto lleva a comportamientos inesperados  Estos problemas pueden ser particularmente problem√°ticos en aplicaciones grandes donde los grafos de dependencias son complejos y no todos los caminos est√°n cubiertos por tests.\nSoluci√≥n 1: Koin DSL con verify() El primer enfoque utiliza la funci√≥n incorporada verify() de Koin para verificar las configuraciones de m√≥dulos durante la fase de compilaci√≥n.\nC√≥mo Funciona 1 2 3 4 5 6 7 8 9 10 11 12  val appModule = module { single\u0026lt;Repository\u0026gt; { DefaultRepository() } factory { UseCase(get()) } viewModel { MainViewModel(get()) } } class ModuleCheck { @Test fun verifyKoinModules() { appModule.verify() } }   Al crear una test unitario que llama a verify() en tus m√≥dulos y hacerla parte de tu proceso de construcci√≥n, puedes detectar problemas comunes tempranamente.\nVentajas  F√°cil de implementar No requiere dependencias adicionales Funciona con c√≥digo existente de Koin DSL Se puede integrar en pipelines de CI/CD  Limitaciones  Requiere ejecuci√≥n expl√≠cita de tests Menor soporte de IDE Sin errores directos de compilaci√≥n No puede detectar todos los problemas potenciales  Soluci√≥n 2: Anotaciones de Koin con KSP El segundo enfoque utiliza el Procesamiento de S√≠mbolos de Kotlin (KSP) y el sistema de anotaciones de Koin para validar los grafos de dependencias durante la compilaci√≥n.\nConfiguraci√≥n 1 2 3 4 5 6 7 8 9 10 11 12 13  // build.gradle.kts plugins { id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;2.1.10-1.0.31\u0026#34; } dependencies { implementation(\u0026#34;io.insert-koin:koin-annotations:2.0.0-RC5\u0026#34;) ksp(\u0026#34;io.insert-koin:koin-ksp-compiler:2.0.0-RC5\u0026#34;) } ksp { arg(\u0026#34;KOIN_CONFIG_CHECK\u0026#34;, \u0026#34;true\u0026#34;) }   C√≥mo Funciona En lugar de usar el DSL, defines las dependencias usando anotaciones:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  @SingleOf(binds = [Repository::class]) class DefaultRepository : Repository { // Implementaci√≥n } @Module class AppModule { @Factory fun provideUseCase(repository: Repository): UseCase { return UseCase(repository) } } @Module class ViewModelModule { @KoinViewModel fun provideMainViewModel( useCase: UseCase ): MainViewModel = MainViewModel(useCase) }   KSP procesa estas anotaciones durante la compilaci√≥n y:\n Genera definiciones de dependencias con seguridad de tipos Valida el grafo de dependencias Asegura que todas las dependencias puedan resolverse Verifica dependencias circulares Verifica la consistencia del alcance  Ventajas  Validaci√≥n real en tiempo de compilaci√≥n Mejor soporte de IDE Declaraciones de dependencias m√°s expl√≠citas Detecta problemas durante la compilaci√≥n Seguridad de tipos por dise√±o  Limitaciones  Requiere configuraci√≥n adicional M√°s verboso que DSL Requiere migraci√≥n desde c√≥digo basado en DSL A√∫n en fase Release Candidate  Comparando los Enfoques    Caracter√≠stica DSL + verify() Anotaciones + KSP     Complejidad de Configuraci√≥n Baja Media   Momento de Validaci√≥n Tiempo de construcci√≥n (v√≠a tests) Tiempo de compilaci√≥n   Soporte de IDE Limitado Bueno   Esfuerzo de Migraci√≥n Bajo Medio   Seguridad de Tipos Buena Excelente   Mensajes de Error Fallos en tests Errores de compilaci√≥n   Curva de Aprendizaje Suave Moderada    ¬øQu√© Enfoque Deber√≠as Elegir? Elige DSL + verify() si:  Tienes una base de c√≥digo existente con Koin DSL Quieres una soluci√≥n simple Prefieres una configuraci√≥n m√°s flexible Te sientes c√≥modo con la validaci√≥n basada en tests  Elige Anotaciones + KSP si:  Est√°s comenzando un nuevo proyecto Quieres verdadera seguridad en tiempo de compilaci√≥n Prefieres declaraciones de dependencias expl√≠citas Valoras el soporte del IDE y la seguridad de tipos  Mejores Pr√°cticas Independientemente del enfoque que elijas:\n  Haz que la validaci√≥n sea parte de tu proceso de construcci√≥n\n Para DSL: Incluye test de verificaci√≥n en tu construcci√≥n Para Anotaciones: Habilita la validaci√≥n KSP    Documenta tu grafo de dependencias\n Mant√©n una estructura clara de m√≥dulos Documenta las decisiones de alcance Mant√©n una arquitectura limpia    Monitorea los tiempos de construcci√≥n\n Ambos enfoques pueden impactar los tiempos de construcci√≥n El procesamiento KSP agrega tiempo de compilaci√≥n La ejecuci√≥n de tests agrega tiempo de construcci√≥n    Considera una migraci√≥n gradual\n Puedes mezclar ambos enfoques Migra gradualmente de DSL a anotaciones Comienza con nuevas caracter√≠sticas usando tu enfoque elegido    Conclusi√≥n Ambos enfoques ofrecen valiosas formas de lograr la seguridad en tiempo de compilaci√≥n en tu inyecci√≥n de dependencias con Koin. El DSL con verify() proporciona un enfoque m√°s simple basado en tests, mientras que las anotaciones con KSP ofrecen garant√≠as m√°s fuertes en tiempo de compilaci√≥n con mejor soporte de herramientas.\nElige el enfoque que mejor se adapte a las necesidades de tu proyecto, considerando factores como la base de c√≥digo existente, la experiencia del equipo y el nivel deseado de seguridad de tipos. Recuerda que ambos enfoques son significativamente mejores que confiar √∫nicamente en la validaci√≥n en tiempo de ejecuci√≥n.\nRecursos  Documentaci√≥n de Koin Gu√≠a de Anotaciones de Koin Documentaci√≥n de KSP Proyecto de Ejemplo  ","description":"La inyecci√≥n de dependencias es un patr√≥n fundamental en el desarrollo moderno de Android, pero ¬øc√≥mo podemos asegurarnos de que nuestra configuraci√≥n de DI sea correcta antes de ejecutar la aplicaci√≥n? En esta publicaci√≥n, exploraremos dos poderosos enfoques para lograr la seguridad en tiempo de compilaci√≥n con Koin: usando la funci√≥n `verify()` del DSL y aprovechando las Anotaciones de Koin con KSP.","id":5,"section":"es","tags":["kotlin","android","koin"],"title":"Logrando Seguridad en Tiempo de Compilaci√≥n con Koin: Una Gu√≠a Completa","uri":"https://carrion.dev/ko/es/posts/koin-compile-safety/"},{"content":"Gesti√≥n Confiable del Tiempo con la API TrustedTime en Android\nLa gesti√≥n precisa del tiempo es crucial para muchas funcionalidades de las aplicaciones, como la programaci√≥n de tareas, el registro de transacciones y la seguridad. Sin embargo, depender del reloj del sistema de un dispositivo puede ser problem√°tico, ya que los usuarios pueden modificar la configuraci√≥n de la hora. Para abordar este problema, Google ha introducido la API TrustedTime, que proporciona una fuente de tiempo confiable y resistente a manipulaciones para las aplicaciones de Android.\nComprendiendo la API TrustedTime La API TrustedTime aprovecha la infraestructura segura de Google para ofrecer una marca de tiempo confiable, independiente de la configuraci√≥n horaria local del dispositivo. Se sincroniza peri√≥dicamente con los servidores de tiempo precisos de Google, reduciendo la necesidad de solicitudes frecuentes a la red. La API tambi√©n tiene en cuenta la deriva del reloj, alertando a los desarrolladores cuando la precisi√≥n del tiempo puede degradarse entre sincronizaciones.\nImportancia de la Gesti√≥n Precisa del Tiempo Depender √∫nicamente del reloj de un dispositivo puede causar problemas como:\n Inconsistencia de Datos: Las aplicaciones que dependen del orden de los eventos pueden enfrentar corrupci√≥n de datos si los usuarios manipulan la hora del dispositivo. Riesgos de Seguridad: Las medidas de seguridad basadas en el tiempo, como OTP y controles de acceso, requieren un reloj preciso. Programaciones No Confiables: Los recordatorios y eventos programados pueden fallar si la hora del dispositivo es incorrecta. Deriva del Reloj: Los relojes internos pueden desviarse debido a factores como cambios de temperatura y niveles de bater√≠a. Problemas de Sincronizaci√≥n entre Dispositivos: Configuraciones horarias inconsistentes en diferentes dispositivos pueden interrumpir la sincronizaci√≥n de datos. Alto Consumo de Bater√≠a y Datos: Consultar constantemente servidores de tiempo en la red consume recursos, lo que TrustedTime ayuda a optimizar.  Aplicaciones Pr√°cticas de TrustedTime La API TrustedTime mejora la seguridad y confiabilidad en varios escenarios:\n Aplicaciones Financieras: Garantiza marcas de tiempo precisas para transacciones. Juegos: Previene exploits basados en el tiempo. E-Commerce: Realiza un seguimiento preciso del procesamiento y entrega de pedidos. Ofertas por Tiempo Limitado: Garantiza que las promociones expiren correctamente. Dispositivos IoT: Sincroniza relojes en m√∫ltiples dispositivos. Aplicaciones de Productividad: Mantiene marcas de tiempo precisas en la edici√≥n de documentos en la nube.  Integrando TrustedTime en tu Aplicaci√≥n Android 1. Agregar la Dependencia Incluye la API TrustedTime en tu archivo build.gradle:\n1  implementation \u0026#39;com.google.android.gms:play-services-time:16.0.1\u0026#39;   2. Inicializar TrustedTimeClient 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class MyApp : Application() { var trustedTimeClient: TrustedTimeClient? = null private set override fun onCreate() { super.onCreate() TrustedTime.createClient(this).addOnCompleteListener { task -\u0026gt; if (task.isSuccessful) { trustedTimeClient = task.result } else { // Manejar error  } } } }   3. Usando TrustedTime en una Actividad o Fragment Para recuperar la hora confiable dentro de una actividad o fragmento, podemos acceder al TrustedTimeClient desde la clase de aplicaci√≥n:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class MainActivity : AppCompatActivity() { private val trustedTimeClient: TrustedTimeClient? get() = (application as MyApp).trustedTimeClient override fun onCreate(savedInstanceState: Bundle?) { super.onCreate() setContentView(R.layout.activity_main) getTrustedTime() } private fun getTrustedTime() { val currentTimeMillis = trustedTimeClient?.computeCurrentUnixEpochMillis() ?: System.currentTimeMillis() Log.d(\u0026#34;TrustedTime\u0026#34;, \u0026#34;Hora confiable actual: $currentTimeMillis\u0026#34;) } }   Al recuperar trustedTimeClient desde MyApp, evitamos inicializaciones redundantes y aseguramos una √∫nica fuente confiable de tiempo en toda la aplicaci√≥n.\n4. Recuperar TrustedTime con un Mecanismo de Respaldo 1 2  val currentTimeMillis = trustedTimeClient?.computeCurrentUnixEpochMillis() ?: System.currentTimeMillis()   Esto garantiza un respaldo al reloj del sistema si TrustedTime no est√° disponible.\nConsideraciones y Limitaciones  Requiere Conexi√≥n a Internet: TrustedTime necesita acceso a Internet despu√©s del arranque del dispositivo para funcionar correctamente. Deriva del Reloj: Aunque la API proporciona una estimaci√≥n del error, no puede prevenir completamente la deriva del reloj. Protecci√≥n contra Manipulaci√≥n: Reduce, pero no elimina por completo, los riesgos de manipulaci√≥n del tiempo. Disponibilidad y Limitaciones de la API TrustedTime: La API TrustedTime est√° disponible en todos los dispositivos que ejecutan Google Play Services en Android 5 (Lollipop) y versiones superiores.  Al integrar la API TrustedTime, los desarrolladores pueden mejorar la precisi√≥n y seguridad de las funcionalidades dependientes del tiempo en sus aplicaciones, garantizando una experiencia consistente y confiable para los usuarios.\n","description":"La API TrustedTime aprovecha la infraestructura segura de Google para ofrecer una marca de tiempo confiable","id":6,"section":"es","tags":["kotlin","android","google"],"title":"Gesti√≥n Confiable del Tiempo con la API TrustedTime en Android","uri":"https://carrion.dev/ko/es/posts/trusted-time-api/"},{"content":"Mejores Pr√°cticas de Arquitectura en Kotlin Multiplatform para Aplicaciones M√≥viles Kotlin Multiplatform (KMP) permite a los desarrolladores compartir la l√≥gica de negocio entre Android y iOS mientras mantienen implementaciones espec√≠ficas de cada plataforma cuando es necesario. Estructurar un proyecto KMP de manera eficiente es clave para mantener la escalabilidad, testabilidad y aplicar Clean Architecture. En esta gu√≠a, exploraremos las mejores pr√°cticas para dise√±ar una aplicaci√≥n m√≥vil con Compose Multiplatform y Clean Architecture.\n1. Estructura del Proyecto Una estructura de proyecto bien organizada mejora el mantenimiento y la separaci√≥n de responsabilidades. Un enfoque com√∫n es seguir una estructura multi-m√≥dulo, ya sea con un √∫nico m√≥dulo compartido o con m√∫ltiples m√≥dulos basados en feature:\nproject-root/ ‚îú‚îÄ‚îÄ core/ ‚îÇ ‚îú‚îÄ‚îÄ network/ # Network shared logic ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ src/commonMain/ # Shared networking ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ src/androidMain/ # Android-specific implementations ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ src/iosMain/ # iOS-specific implementations ‚îú‚îÄ‚îÄ features/ # Feature-based modules ‚îÇ ‚îú‚îÄ‚îÄ feature1/ # Example feature module ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ domain/ # Domain layer (Use cases, repositories interfaces) ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ data/ # Data layer (Implementations, APIs, Database) ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ presentation/ # UI and ViewModels for Compose Multiplatform ‚îú‚îÄ‚îÄ composeApp/ # Application module integrating all features ‚îÇ ‚îú‚îÄ‚îÄ src/commonMain/ # Can contain shared UI and navigation logic ‚îÇ ‚îú‚îÄ‚îÄ src/androidMain/ # Android-specific implementations if needed ‚îÇ ‚îú‚îÄ‚îÄ src/iosMain/ # iOS-specific implementations if needed ‚îú‚îÄ‚îÄ androidApp/ # Android application module ‚îú‚îÄ‚îÄ iosApp/ # iOS application module  Feature Modules: En lugar de un √∫nico m√≥dulo compartido, se pueden tener m√≥dulos compartidos por feature para mejorar la modularidad y escalabilidad. Estos pueden dividirse a√∫n m√°s en domain, data y presentation para una mejor separaci√≥n de responsabilidades. Core Modules: Contiene utilidades compartidas como networking, logging y l√≥gica de dominio com√∫n. ComposeApp Module: Act√∫a como el m√≥dulo principal de la aplicaci√≥n, integrando todos los m√≥dulos de features y manejando la navegaci√≥n, similar a un m√≥dulo app en un proyecto est√°ndar de Android.  En la mayor√≠a de los proyectos de Compose Multiplatform, el m√≥dulo composeApp se usa para ensamblar todas las features, gestionar la navegaci√≥n y manejar otras preocupaciones a nivel de aplicaci√≥n, similar al m√≥dulo app en un proyecto est√°ndar de Android.\n2. Aplicando Clean Architecture en KMP Seguir Clean Architecture ayuda a mantener la separaci√≥n de responsabilidades y mejorar la testabilidad. La arquitectura puede estructurarse en las siguientes capas:\nCapa de Dominio (commonMain)  Contiene la l√≥gica de negocio (Casos de uso, Interactors). Define las interfaces de repositorio para el acceso a datos. No depende de ninguna implementaci√≥n espec√≠fica de la plataforma.  1 2 3  interface UserRepository { suspend fun getUser(): User }   Capa de Datos (commonMain, espec√≠fica por plataforma)  Implementa las interfaces de repositorio. Usa expect/actual para APIs espec√≠ficas de plataforma como networking, bases de datos, etc. Obtiene y procesa datos antes de exponerlos a la capa de dominio.  Ejemplo de expect/actual para un cliente HTTP:\n1 2 3  expect class HttpClientProvider { fun getClient(): HttpClient }   Implementaci√≥n espec√≠fica para Android:\n1 2 3  actual class HttpClientProvider { actual fun getClient() = HttpClient(Android) {} }   Implementaci√≥n espec√≠fica para iOS:\n1 2 3  actual class HttpClientProvider { actual fun getClient() = HttpClient(Ios) {} }   Capa de Presentaci√≥n (Compose Multiplatform) Con Compose Multiplatform, podemos compartir componentes de UI entre plataformas mientras aprovechamos la renderizaci√≥n nativa. El m√≥dulo composeApp integra todos los m√≥dulos de features y maneja la navegaci√≥n y la l√≥gica a nivel de aplicaci√≥n.\n1 2 3 4 5 6 7  @Composable fun UserScreen(viewModel: UserViewModel) { val user by viewModel.userState.collectAsState() Column(modifier = Modifier.padding(16.dp)) { Text(\u0026#34;Hello, ${user?.name ?: \u0026#34;Guest\u0026#34;}\u0026#34;, style = MaterialTheme.typography.h6) } }   En Android, esto se renderiza con Jetpack Compose, y en iOS, con Compose para iOS.\n3. Gesti√≥n del Estado en KMP La gesti√≥n del estado en un proyecto KMP puede manejarse eficientemente con StateFlow.\n1 2 3 4 5 6 7 8 9 10  class UserViewModel(private val repository: UserRepository) { private val _userState = MutableStateFlow\u0026lt;User?\u0026gt;(null) val userState: StateFlow\u0026lt;User?\u0026gt; = _userState fun loadUser() { viewModelScope.launch { _userState.value = repository.getUser() } } }   Dado que Compose Multiplatform soporta collectAsState(), podemos observar y renderizar cambios de estado directamente en la UI.\n4. Testing en KMP  Unit Tests en commonTest usando kotlin.test. Pruebas espec√≠ficas de plataforma en androidTest y iosTest.  Ejemplo de prueba unitaria compartida:\n1 2 3 4 5  @Test fun testUserRepository() = runTest { val repository = FakeUserRepository() assertNotNull(repository.getUser()) }   Conclusi√≥n Siguiendo estas mejores pr√°cticas, puedes construir aplicaciones KMP escalables y mantenibles:\n Usa una estructura de proyecto modularizada con un m√≥dulo compartido o m√≥dulos por feature. Sigue Clean Architecture para mejorar la mantenibilidad. Aprovecha Compose Multiplatform para la UI, utilizando un m√≥dulo composeApp para integrar m√≥dulos de features y manejar la navegaci√≥n. Los m√≥dulos de features pueden dividirse a√∫n m√°s en dominio, datos y presentaci√≥n para mejorar la separaci√≥n de responsabilidades. Gestiona el estado eficientemente con StateFlow. Escribe pruebas completas tanto en c√≥digo compartido como en implementaciones espec√≠ficas de plataforma.  KMP permite compartir c√≥digo de manera eficiente mientras se preservan optimizaciones espec√≠ficas de cada plataforma, lo que lo convierte en una opci√≥n poderosa para el desarrollo de aplicaciones m√≥viles.\n¬øTe gustar√≠a un repositorio en GitHub con un ejemplo de esta configuraci√≥n? üöÄ\n","description":"Consejos de arquitectura para proyectos KMP usando Clean Architecture","id":7,"section":"es","tags":["kotlin","compose","cmp","multiplatform","cleancode","architecture"],"title":"Mejores Pr√°cticas de Arquitectura en Kotlin Multiplatform para Aplicaciones M√≥viles","uri":"https://carrion.dev/ko/es/posts/kmp-architecture/"},{"content":"Mocks, Fakes y M√°s: Entendiendo los Test Doubles en Kotlin Al escribir tests en Kotlin, especialmente para el desarrollo de Android, a menudo necesitamos reemplazar dependencias reales con test doubles. Sin embargo, no todos los test doubles son iguales: t√©rminos como mocks, fakes, stubs, spies y dummies aparecen con frecuencia. En esta publicaci√≥n, desglosaremos sus diferencias con ejemplos en Kotlin utilizando solo Kotlin puro (sin bibliotecas de terceros).\n1. Entendiendo los Test Doubles Los test doubles son objetos que sustituyen dependencias reales en las tests. Ayudan a aislar el sistema bajo prueba (SUT) y hacen que las tests sean m√°s confiables. Aqu√≠ est√°n los principales tipos:\n Dummy ‚Äì Un objeto de relleno que se pasa como argumento pero no se utiliza en la ejecuci√≥n del test. Stub ‚Äì Proporciona respuestas predefinidas pero no contiene l√≥gica. Fake ‚Äì Una implementaci√≥n liviana con l√≥gica en memoria. Mock ‚Äì Un test double que verifica interacciones. Spy ‚Äì Envuelve un objeto real permitiendo la modificaci√≥n selectiva de su comportamiento.  2. Objetos Dummy Un dummy es un objeto que solo existe para satisfacer la firma de un m√©todo, pero nunca se usa realmente.\nEjemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  interface EmailSender { fun sendEmail(email: String, message: String) } class UserService(private val emailSender: EmailSender) { fun registerUser(user: User) { // The user registers, but we don\u0026#39;t actually send an email  } } data class User(val name: String, val email: String) // Test fun testRegisterUser() { val dummyEmailSender = object : EmailSender { override fun sendEmail(email: String, message: String) { // This will never be called in the test  } } val userService = UserService(dummyEmailSender) userService.registerUser(User(\u0026#34;John Doe\u0026#34;, \u0026#34;john@example.com\u0026#34;)) }   3. Stubs Un stub devuelve respuestas predefinidas a las llamadas a m√©todos, pero no rastrea interacciones.\nEjemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  interface UserRepository { fun getUser(id: Int): User? } class StubUserRepository : UserRepository { override fun getUser(id: Int): User? { return if (id == 1) User(\u0026#34;John Doe\u0026#34;, \u0026#34;john@example.com\u0026#34;) else null } } // Test fun testGetUser() { val stubRepo = StubUserRepository() val user = stubRepo.getUser(1) assert(user?.name == \u0026#34;John Doe\u0026#34;) }   4. Fakes Un fake es una versi√≥n simplificada pero funcional de una clase real, a menudo utilizando almacenamiento en memoria.\nEjemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class FakeUserRepository : UserRepository { private val users = mutableMapOf\u0026lt;Int, User\u0026gt;() override fun getUser(id: Int): User? = users[id] fun addUser(id: Int, user: User) { users[id] = user } } // Test fun testFakeUserRepository() { val fakeRepo = FakeUserRepository() fakeRepo.addUser(1, User(\u0026#34;Jane Doe\u0026#34;, \u0026#34;jane@example.com\u0026#34;)) assert(fakeRepo.getUser(1)?.name == \u0026#34;Jane Doe\u0026#34;) }   5. Mocks Un mock es un test double que verifica interacciones. Sin un framework de mocking, debemos rastrear manualmente las llamadas.\nEjemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class MockEmailSender : EmailSender { var wasSendEmailCalled = false var sentTo: String? = null var sentMessage: String? = null override fun sendEmail(email: String, message: String) { wasSendEmailCalled = true sentTo = email sentMessage = message } } // Test fun testSendWelcomeEmail() { val mockEmailSender = MockEmailSender() val service = NotificationService(mockEmailSender) service.sendWelcomeEmail(User(\u0026#34;test@example.com\u0026#34;, \u0026#34;test@example.com\u0026#34;)) assert(mockEmailSender.wasSendEmailCalled) assert(mockEmailSender.sentTo == \u0026#34;test@example.com\u0026#34;) assert(mockEmailSender.sentMessage == \u0026#34;Welcome!\u0026#34;) } class NotificationService(private val emailSender: EmailSender) { fun sendWelcomeEmail(user: User) { emailSender.sendEmail(user.email, \u0026#34;Welcome!\u0026#34;) } }   6. Spies Un spy envuelve un objeto real mientras permite la modificaci√≥n selectiva de su comportamiento. Sin una biblioteca, debemos extender la clase real y sobrescribir comportamientos espec√≠ficos.\nEjemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  open class MathService { open fun add(a: Int, b: Int) = a + b } class SpyMathService : MathService() { var wasAddCalled = false var lastA: Int? = null var lastB: Int? = null override fun add(a: Int, b: Int): Int { wasAddCalled = true lastA = a lastB = b return super.add(a, b) // Calls the real implementation  } }   7. Uso de MockK para Mocks y Spies Si bien es posible crear mocks y spies manualmente, usar una biblioteca como MockK simplifica el proceso.\nEjemplo usando MockK: 1 2 3 4 5 6 7 8 9 10 11  import io.mockk.* fun testMockKExample() { val mockEmailSender = mockk\u0026lt;EmailSender\u0026gt;() every { mockEmailSender.sendEmail(any(), any()) } just Runs val service = NotificationService(mockEmailSender) service.sendWelcomeEmail(User(\u0026#34;test@example.com\u0026#34;, \u0026#34;test@example.com\u0026#34;)) verify { mockEmailSender.sendEmail(\u0026#34;test@example.com\u0026#34;, \u0026#34;Welcome!\u0026#34;) } }   MockK proporciona caracter√≠sticas avanzadas como spies autom√°ticos, mocks relajados y captura de argumentos, lo que facilita la escritura de tests mantenibles.\nConclusi√≥n Comprender los test doubles te ayuda a escribir mejores tests al aislar dependencias. Usa:\n‚úÖ Dummies cuando se requiere un argumento pero no se usa.\n‚úÖ Stubs para devolver valores predefinidos.\n‚úÖ Fakes para implementaciones livianas.\n‚úÖ Mocks para verificar interacciones.\n‚úÖ Spies cuando necesitas mockeo parcial.\n‚úÖ MockK para un mockeo m√°s f√°cil y potente.\nAl elegir el tipo correcto, puedes hacer que tus tests sean m√°s confiables y mantenibles.\n","description":"Mocks, Fakes y M√°s: Entendiendo los Test Doubles en Kotlin","id":8,"section":"es","tags":["kotlin","testing","mock","tdd"],"title":"Mocks, Fakes y M√°s","uri":"https://carrion.dev/ko/es/posts/test-doubles/"},{"content":"Tests en Compose Multiplatform (CMP) desde C√≥digo Com√∫n Compose Multiplatform (CMP) permite construir UI para m√∫ltiples plataformas utilizando Jetpack Compose. Afortunadamente, CMP tambi√©n admite escribir y ejecutar tests de UI en el c√≥digo com√∫n, lo que hace que los test sean m√°s eficientes en todas las plataformas. En esta publicaci√≥n, exploraremos c√≥mo probar aplicaciones CMP utilizando compose.uiTest y ejecutarlas en Android, Desktop e iOS.\n1. Configuraci√≥n de Test de UI Comunes CMP proporciona compose.uiTest, lo que permite escribir test de UI en el m√≥dulo compartido sin depender de plataformas espec√≠ficas. Esto significa que puedes escribir una vez y probar en todas partes.\nActualizaci√≥n de la Configuraci√≥n del Proyecto Para habilitar los tests, actualiza tu archivo build.gradle.kts en el m√≥dulo compartido:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  kotlin { androidTarget { instrumentedTestVariant.sourceSetTree.set(KotlinSourceSetTree.test) } sourceSets { val commonTest by getting { dependencies { implementation(kotlin(\u0026#34;test\u0026#34;)) @OptIn(org.jetbrains.compose.ExperimentalComposeLibrary::class) implementation(compose.uiTest) } } val desktopTest by getting { dependencies { implementation(compose.desktop.currentOs) } } } }   Declaraci√≥n de Dependencias para Tests de UI en Android En el nivel ra√≠z de tu archivo build.gradle.kts, agrega las dependencias necesarias para los tests en Android:\n1 2 3 4  dependencies { androidTestImplementation(\u0026#34;androidx.compose.ui:ui-test-junit4-android:1.5.4\u0026#34;) debugImplementation(\u0026#34;androidx.compose.ui:ui-test-manifest:1.5.4\u0026#34;) }   Configuraci√≥n Espec√≠fica para Tests en Android Para tests instrumentadas en Android, agrega lo siguiente a tu build.gradle.kts:\n1 2 3 4 5  android { defaultConfig { testInstrumentationRunner = \u0026#34;androidx.test.runner.AndroidJUnitRunner\u0026#34; } }   2. Implementaci√≥n de una UI de Contador Simple Vamos a crear un CounterViewModel que ser√° probado:\n1 2 3 4 5 6 7 8 9 10 11 12  import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.asStateFlow class CounterViewModel { private val _count = MutableStateFlow(0) val count: StateFlow\u0026lt;Int\u0026gt; = _count.asStateFlow() fun increment() { _count.value += 1 } }   Ahora, creemos la UI con Composables que interact√∫a con este ViewModel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  import androidx.compose.foundation.layout.* import androidx.compose.material.* import androidx.compose.runtime.* import androidx.compose.ui.Modifier import androidx.compose.ui.platform.testTag import androidx.compose.ui.unit.dp @Composable fun CounterScreen(viewModel: CounterViewModel) { val count by viewModel.count.collectAsState() Column( modifier = Modifier.padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally ) { Text(text = count.toString(), fontSize = 24.sp, modifier = Modifier.testTag(\u0026#34;counterText\u0026#34;)) Spacer(modifier = Modifier.height(8.dp)) Button(onClick = { viewModel.increment() }, modifier = Modifier.testTag(\u0026#34;incrementButton\u0026#34;)) { Text(\u0026#34;Increment\u0026#34;) } } }   3. Escribiendo un Test de UI Com√∫n en CMP Ahora, escribamos un test de UI en commonTest para validar que al hacer clic en el bot√≥n, el contador se incremente:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import androidx.compose.ui.test.* import kotlin.test.Test import kotlin.test.assertEquals class CounterScreenTest { @OptIn(ExperimentalTestApi::class) @Test fun testButtonIncrementsCounter() = runComposeUiTest { val viewModel = CounterViewModel() setContent { CounterScreen(viewModel = viewModel) } onNodeWithTag(\u0026#34;counterText\u0026#34;).assertTextEquals(\u0026#34;0\u0026#34;) onNodeWithTag(\u0026#34;incrementButton\u0026#34;).performClick() onNodeWithTag(\u0026#34;counterText\u0026#34;).assertTextEquals(\u0026#34;1\u0026#34;) } }   4. Ejecutando los Tests en M√∫ltiples Plataformas Ahora que hemos escrito nuestr test en c√≥digo com√∫n, ejecut√©mosla en Android, Desktop e iOS.\nEjecutar Tests en Android Para tests instrumentadas en Android, ejecuta:\n1  ./gradlew connectedAndroidTest   Ejecutar Tests en Desktop 1  ./gradlew desktopTest   Ejecutar Tests en iOS Para tests en el simulador de iOS, ejecuta:\n1  ./gradlew :composeApp:iosSimulatorArm64Test   5. ¬øPor Qu√© Probar CMP desde C√≥digo Com√∫n? ‚úÖ Escribe una vez, prueba en todas partes: No es necesario duplicar tests en cada plataforma.\n‚úÖ Comportamiento consistente en todas las plataformas: Garantiza que los elementos de la UI funcionen de la misma manera.\n‚úÖ Mantenimiento m√°s f√°cil: Una √∫nica suite de tests cubriendo todos los objetivos.\nConclusi√≥n Con los tests de UI en Compose Multiplatform, podemos validar el comportamiento de la UI desde c√≥digo compartido sin necesidad de implementaciones de test espec√≠ficos por plataforma. La biblioteca compose.uiTest nos permite probar interacciones de UI como la verificaci√≥n de texto y clics en botones, asegurando consistencia en Android, iOS y Desktop.\n","description":"Aprende como escribir y correr tests de UI en Compose Multiplatform (CMP) desde el c√≥digo com√∫n, consiguiendo consistencia entre plataformas para Android, iOS y Desktop.","id":9,"section":"es","tags":["kotlin","compose","cmp","multiplatform"],"title":"Tests en Compose Multiplatform (CMP) desde C√≥digo Com√∫n","uri":"https://carrion.dev/ko/es/posts/cmp-ui-testing/"},{"content":"Explorando la Librer√≠a de Colecciones Inmutables de Kotlin Las colecciones est√°ndar de Kotlin (List, Set, Map) son mutables por defecto, lo que puede provocar modificaciones no deseadas. Para garantizar la inmutabilidad a nivel de API, JetBrains introdujo la librer√≠a de Colecciones Inmutables de Kotlin. Esta librer√≠a proporciona un conjunto de tipos de colecci√≥n verdaderamente inmutables que evitan modificaciones accidentales y mejoran la seguridad en entornos concurrentes o de m√∫ltiples hilos.\n¬øPor qu√© usar colecciones inmutables? Aunque Kotlin ya ofrece listOf(), setOf() y mapOf() para colecciones de solo lectura, estas no son verdaderamente inmutables. La colecci√≥n subyacente a√∫n puede modificarse si se referencia en otro lugar. Ejemplo:\n1 2 3 4 5 6 7  val list = mutableListOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) val readOnlyList: List\u0026lt;String\u0026gt; = list list.add(\u0026#34;D\u0026#34;) // Modifies the original list println(readOnlyList) // Output: [A, B, C, D]  (readOnlyList as MutableList).add(\u0026#34;E\u0026#34;) println(readOnlyList) // Output: [A, B, C, D, E]   Para resolver esto, la librer√≠a de Colecciones Inmutables proporciona colecciones que garantizan la inmutabilidad en tiempo de ejecuci√≥n.\nCaracter√≠sticas clave  Verdaderamente inmutables ‚Äì Una vez creadas, no pueden modificarse. Seguras para m√∫ltiples hilos ‚Äì Evitan modificaciones no intencionadas en entornos concurrentes. Optimizadas para el rendimiento ‚Äì Utilizan compartici√≥n estructural para evitar copias innecesarias.  ¬øC√≥mo usar las Colecciones Inmutables de Kotlin? 1. Agregar la dependencia Primero, incluye la dependencia de Colecciones Inmutables en tu build.gradle.kts:\n1 2 3  dependencies { implementation(\u0026#34;org.jetbrains.kotlinx:kotlinx-collections-immutable:0.3.5\u0026#34;) }   2. Crear colecciones inmutables La librer√≠a proporciona persistentListOf(), persistentSetOf() y persistentMapOf() para crear colecciones inmutables:\n1 2 3 4 5  import kotlinx.collections.immutable.* val immutableList = persistentListOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) val immutableSet = persistentSetOf(1, 2, 3) val immutableMap = persistentMapOf(\u0026#34;key1\u0026#34; to 100, \u0026#34;key2\u0026#34; to 200)   3. Agregar y eliminar elementos Dado que estas colecciones son inmutables, las operaciones de modificaci√≥n devuelven una nueva copia modificada en lugar de cambiar la colecci√≥n original:\n1 2 3 4 5  val newList = immutableList.add(\u0026#34;D\u0026#34;) // Creates a new list println(newList) // Output: [A, B, C, D]  val newMap = immutableMap.put(\u0026#34;key3\u0026#34;, 300) println(newMap) // Output: {key1=100, key2=200, key3=300}   La immutableList y immutableMap originales permanecen sin cambios.\nConsideraciones de rendimiento A diferencia de las colecciones inmutables est√°ndar (que requieren copias completas para modificaciones), las colecciones persistentes utilizan compartici√≥n estructural. Esto significa que las modificaciones crean una nueva colecci√≥n reutilizando las partes no modificadas de la original, mejorando el rendimiento y la eficiencia de la memoria.\nPor ejemplo, agregar un elemento a una lista persistente no crea una copia completa, sino que reutiliza la mayor parte de la estructura existente:\nOriginal: [A, B, C] New List: [A, B, C, D] (Only \u0026quot;D\u0026quot; is newly allocated) Esto hace que las colecciones inmutables sean eficientes incluso para grandes conjuntos de datos.\nBeneficios en Jetpack Compose Las colecciones inmutables son especialmente √∫tiles en Jetpack Compose, ya que optimizan la gesti√≥n del estado y las recomposiciones. A continuaci√≥n, se explica por qu√© son importantes en las aplicaciones Compose:\n1. Evitan recomposiciones innecesarias  Compose rastrea los cambios de estado para decidir cu√°ndo recomponer los elementos de la UI. Las listas, conjuntos o mapas mutables pueden provocar recomposiciones innecesarias incluso cuando los datos no han cambiado. Las colecciones inmutables garantizan que el estado permanezca estable, evitando recomposiciones redundantes.  Ejemplo:\n1 2 3 4 5 6 7 8  @Composable fun MyListScreen(items: List\u0026lt;String\u0026gt;) { LazyColumn { items(items) { item -\u0026gt; Text(text = item) } } }   Si items es una lista mutable, incluso reasignando los mismos valores se activa una recomposici√≥n. Usar una colecci√≥n inmutable como PersistentList garantiza que Compose reconozca cuando los datos no han cambiado:\n1 2  val items = remember { persistentListOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) } MyListScreen(items)   2. Estabilidad del estado para mejorar el rendimiento  Compose optimiza el renderizado omitiendo recomposiciones cuando los objetos de estado son estables. Las colecciones inmutables usan compartici√≥n estructural, lo que significa que las modificaciones solo afectan la parte cambiada mientras reutilizan el resto. Esto mejora el rendimiento en listas grandes o jerarqu√≠as de UI complejas.  3. Comportamiento predecible de la UI  Dado que las colecciones inmutables no pueden modificarse despu√©s de la creaci√≥n, evitan mutaciones accidentales que podr√≠an generar actualizaciones impredecibles en la UI. Esto es especialmente √∫til en arquitecturas dirigidas por estado (MVI, Redux, etc.), asegurando que la UI se actualice solo cuando sea necesario.  4. Seguridad en m√∫ltiples hilos  En aplicaciones Compose que usan corrutinas (Flows, LiveData, etc.), las colecciones inmutables previenen condiciones de carrera cuando m√∫ltiples hilos actualizan el estado. Garantizan un flujo de datos seguro entre ViewModels, repositorios y componentes de UI.  ¬øCu√°ndo usar colecciones inmutables? ‚úÖ Programaci√≥n funcional ‚Äì Fomenta la inmutabilidad para transformaciones de datos m√°s seguras.\n‚úÖ Seguridad en m√∫ltiples hilos ‚Äì Evita modificaciones no intencionadas en entornos concurrentes.\n‚úÖ Prevenci√≥n de errores ‚Äì Reduce efectos secundarios inesperados debido a mutaciones accidentales.\n‚úÖ Gesti√≥n del estado en Compose ‚Äì Ayuda a optimizar recomposiciones y mejora el rendimiento de la UI.\nConclusi√≥n La librer√≠a de Colecciones Inmutables de Kotlin proporciona colecciones verdaderamente inmutables, eficientes y seguras, lo que las convierte en una excelente opci√≥n para la programaci√≥n funcional, aplicaciones concurrentes y desarrollo con Jetpack Compose. Al aprovechar colecciones persistentes, puedes escribir c√≥digo Kotlin m√°s seguro y predecible.\nüöÄ ¬øUsar√≠as colecciones inmutables en tus proyectos?\n","description":"Explorando la Librer√≠a de Colecciones Inmutables de Kotlin, usala en Compose para mejorar el rendimiento.","id":10,"section":"es","tags":["kotlin","collections","compose"],"title":"Explorando la Librer√≠a de Colecciones Inmutables de Kotlin","uri":"https://carrion.dev/ko/es/posts/immutable-collections/"},{"content":"Mejorando el Rendimiento de las Aplicaciones Android con Baseline Profiles Introducci√≥n En el mundo m√≥vil actual, los usuarios esperan que las aplicaciones se inicien al instante y funcionen sin problemas. La optimizaci√≥n del rendimiento es crucial, especialmente en lo que respecta al tiempo de inicio y la ejecuci√≥n en tiempo de ejecuci√≥n.\nLos Baseline Profiles de Android ofrecen una forma eficaz de acelerar el inicio de la aplicaci√≥n y mejorar el rendimiento en tiempo de ejecuci√≥n al precompilar rutas de c√≥digo cr√≠ticas. Google Play incluso recomienda el uso de Baseline Profiles para mejorar la experiencia del usuario, especialmente en aplicaciones con una renderizaci√≥n de UI compleja o dependencias pesadas.\nEn esta gu√≠a, exploraremos qu√© son los Baseline Profiles, c√≥mo funcionan y c√≥mo integrarlos en tu aplicaci√≥n Android utilizando un m√≥dulo dedicado de Baseline Profile para lograr tiempos de inicio m√°s r√°pidos y un mejor rendimiento en tiempo de ejecuci√≥n.\n¬øQu√© son los Baseline Profiles? Las aplicaciones de Android utilizan el Android Runtime (ART) para ejecutar c√≥digo, empleando Just-In-Time (JIT) y Ahead-Of-Time (AOT) compilation.\nSin embargo, la compilaci√≥n JIT puede introducir retrasos durante el inicio de la aplicaci√≥n, ya que el c√≥digo no est√° completamente optimizado inicialmente. Baseline Profiles resuelven este problema al permitir que los desarrolladores especifiquen rutas de c√≥digo cr√≠ticas que deben precompilarse antes de ejecutar la aplicaci√≥n.\n¬øC√≥mo funcionan los Baseline Profiles?  Precompilaci√≥n: Contienen definiciones de m√©todos y clases que se precompilan y optimizan antes de la ejecuci√≥n. Instalaci√≥n: Estos perfiles se instalan en el dispositivo del usuario en el primer inicio de la aplicaci√≥n. Optimizaci√≥n: ART los utiliza para mejorar la velocidad de ejecuci√≥n, especialmente durante los inicios en fr√≠o.  ¬øCu√°ndo deber√≠as usar Baseline Profiles? Los Baseline Profiles son especialmente beneficiosos en los siguientes escenarios:\n‚úÖ Optimizaci√≥n del Inicio de la Aplicaci√≥n ‚Äì Reducci√≥n del tiempo de inicio en fr√≠o mediante la precompilaci√≥n de secuencias de lanzamiento.\n‚úÖ Mejora del Rendimiento del Desplazamiento ‚Äì Garantiza una renderizaci√≥n de UI m√°s fluida.\n‚úÖ Optimizaci√≥n de Funcionalidades Frecuentemente Usadas ‚Äì Precompilaci√≥n de la l√≥gica con la que los usuarios interact√∫an con frecuencia.\nConfiguraci√≥n de Baseline Profiles en un M√≥dulo Separado Paso 1: Crear el M√≥dulo de Baseline Profile   Abrir Android Studio:\n Navegar a File ‚Üí New ‚Üí New Module. Seleccionar la plantilla Baseline Profile Generator.    Configurar el M√≥dulo:\n Aplicaci√≥n Objetivo: Elegir el m√≥dulo de la aplicaci√≥n para el cual se generar√° el Baseline Profile. Nombre del M√≥dulo: Asignar un nombre, por ejemplo, baselineprofile. Nombre del Paquete: Definir el nombre del paquete para el m√≥dulo. Lenguaje: Seleccionar Kotlin o Java. Lenguaje de Configuraci√≥n de Build: Elegir entre Kotlin Script (KTS) o Groovy.    Finalizar: Hacer clic en Finish para crear el m√≥dulo.\n  Este proceso configura un nuevo m√≥dulo que contiene las configuraciones y el c√≥digo necesarios para generar y evaluar Baseline Profiles.\nPaso 2: Definir el Generador de Baseline Profile Generador de Baseline Profile Basado en Jetpack Compose 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  @RunWith(AndroidJUnit4::class) @LargeTest class BaselineProfileGenerator { @get:Rule val baselineProfileRule = BaselineProfileRule() @get:Rule val composeTestRule = createAndroidComposeRule\u0026lt;MainActivity\u0026gt;() @Test fun baselineProfile() = baselineProfileRule.collect( packageName = \u0026#34;com.example.app\u0026#34;, includeInStartupProfile = true, profileBlock = { // 1. **Inicio en Fr√≠o de la Aplicaci√≥n**  startActivityAndWait() // 2. **Navegar a la Pantalla Principal**  composeTestRule.onNodeWithText(\u0026#34;Get Started\u0026#34;) .performClick() composeTestRule.waitForIdle() // 3. **Desplazarse a trav√©s de una Lista LazyColumn**  composeTestRule.onNodeWithTag(\u0026#34;itemList\u0026#34;) .performScrollToIndex(10) composeTestRule.waitForIdle() // 4. **Abrir una Pantalla de Detalle**  composeTestRule.onNodeWithTag(\u0026#34;item_0\u0026#34;) .performClick() composeTestRule.waitForIdle() // 5. **Realizar una B√∫squeda**  composeTestRule.onNodeWithTag(\u0026#34;searchInput\u0026#34;) .performTextInput(\u0026#34;Kotlin\u0026#34;) composeTestRule.waitForIdle() // 6. **Navegaci√≥n hacia atr√°s**  composeTestRule.onNodeWithContentDescription(\u0026#34;Back\u0026#34;) .performClick() composeTestRule.waitForIdle() } ) }   Paso 3: Generar e Integrar el Baseline Profile   Generar el Baseline Profile:\n  Ejecutar la configuraci√≥n Generate Baseline Profile creada por la plantilla.\n  Alternativamente, ejecutar la siguiente tarea de Gradle:\n1  ./gradlew :app:generateBaselineProfile     Esto genera el Baseline Profile y lo copia en el directorio apropiado dentro del m√≥dulo de la aplicaci√≥n.\n  Integrar el Baseline Profile:\n  El perfil generado se incluye autom√°ticamente en los assets del m√≥dulo de la aplicaci√≥n.\n  Asegurar que el archivo build.gradle del m√≥dulo de la aplicaci√≥n incluya las dependencias necesarias:\n1 2 3 4  dependencies { implementation(\u0026#34;androidx.profileinstaller:profileinstaller:1.3.0\u0026#34;) baselineProfile(project(\u0026#34;:baselineprofile\u0026#34;)) }     La biblioteca profileinstaller instala el Baseline Profile en los dispositivos de los usuarios, y la dependencia baselineProfile vincula el perfil generado a la aplicaci√≥n.\n  Conclusi√≥n Los Baseline Profiles son una herramienta poderosa para mejorar el tiempo de inicio y el rendimiento en tiempo de ejecuci√≥n sin aumentar el tama√±o del APK. Al precompilar rutas de c√≥digo cr√≠ticas, tu aplicaci√≥n se iniciar√° m√°s r√°pido, brindando una experiencia m√°s fluida y receptiva a los usuarios.\nAl integrar Baseline Profiles mediante un m√≥dulo dedicado, garantizas un enfoque modular, mantenible y escalable para la optimizaci√≥n del rendimiento.\nSi a√∫n no lo has hecho, comienza a usar Baseline Profiles hoy mismo y mide su impacto en el rendimiento de tu aplicaci√≥n.\n","description":"Mejorando el Rendimiento de las Aplicaciones Android con Baseline Profiles con un ejemplo real","id":11,"section":"es","tags":["kotlin","architecture"],"title":"Mejorando el Rendimiento de las Aplicaciones Android con Baseline Profiles","uri":"https://carrion.dev/ko/es/posts/baseline-profiles/"},{"content":"Modularizaci√≥n en Proyectos Gradle con Kotlin: Una Gu√≠a Completa Introducci√≥n A medida que los proyectos crecen en complejidad, mantener una base de c√≥digo monol√≠tica se vuelve un desaf√≠o. La modularizaci√≥n es una t√©cnica de dise√±o de software que divide una aplicaci√≥n en m√≥dulos m√°s peque√±os e independientes, haciendo que el proyecto sea m√°s escalable, mantenible y eficiente.\nEn esta gu√≠a, exploraremos por qu√© la modularizaci√≥n es esencial, los diferentes tipos de m√≥dulos y las mejores pr√°cticas para configurar un proyecto modular en Gradle usando Kotlin.\n¬øPor qu√© Modularizar? Antes de implementar la modularizaci√≥n, es importante comprender sus principales beneficios:\n Tiempos de compilaci√≥n m√°s r√°pidos ‚Äì Gradle compila m√≥dulos independientes en paralelo, reduciendo los tiempos de compilaci√≥n. Escalabilidad ‚Äì Facilita la gesti√≥n y expansi√≥n de proyectos grandes. Encapsulaci√≥n ‚Äì Cada m√≥dulo tiene una responsabilidad bien definida, mejorando la separaci√≥n de preocupaciones. Colaboraci√≥n en equipo ‚Äì Diferentes equipos pueden trabajar de forma independiente en m√≥dulos distintos, reduciendo conflictos de integraci√≥n. Reutilizaci√≥n ‚Äì Se pueden extraer funcionalidades comunes en m√≥dulos reutilizables.  Escenario de Ejemplo Imagina una app de Android donde todas las caracter√≠sticas y dependencias residen en un solo m√≥dulo app. Esta configuraci√≥n conduce a tiempos de compilaci√≥n largos, c√≥digo fuertemente acoplado y dificultades en las pruebas. Con la modularizaci√≥n, las funcionalidades y componentes compartidos pueden aislarse en m√≥dulos separados, mejorando la eficiencia.\nTipos de M√≥dulos en un Proyecto Gradle ‚úÖ M√≥dulos de Funcionalidad (Feature Modules) Contienen caracter√≠sticas independientes de la aplicaci√≥n, como:\n feature-auth (Pantallas de autenticaci√≥n) feature-dashboard (Pantalla principal, datos del usuario) Pueden cargarse din√°micamente usando Dynamic Feature Modules en Android.  ‚úÖ M√≥dulos de Biblioteca (Library Modules) Componentes reutilizables compartidos en toda la aplicaci√≥n, como:\n ui-components (Botones personalizados, toolbars) networking (Llamadas a API, configuraci√≥n de Retrofit) analytics (Registro de eventos, Firebase)  ‚úÖ M√≥dulos Core Contienen utilidades compartidas, como:\n core-utils (Funciones comunes, extensiones)  Configuraci√≥n de Gradle para Modularizaci√≥n Despu√©s de definir los tipos de m√≥dulos, es crucial configurar correctamente las dependencias.\nUso de api, implementation y compileOnly  implementation ‚Äì La dependencia solo es visible dentro del m√≥dulo. api ‚Äì La dependencia se expone a otros m√≥dulos. compileOnly ‚Äì Se usa para dependencias solo en tiempo de compilaci√≥n.  Ejemplo:\n1 2 3 4 5  // En feature-auth/build.gradle.kts dependencies { implementation(project(\u0026#34;:core-utils\u0026#34;)) // Solo visible en este m√≥dulo  compileOnly(\u0026#34;androidx.annotation:annotation:1.3.0\u0026#34;) }   Gesti√≥n de Dependencias en Gradle Administrar dependencias en m√∫ltiples m√≥dulos puede simplificarse utilizando Version Catalogs, que es el enfoque recomendado en proyectos Gradle modernos.\n‚úÖ Uso de Version Catalogs (libs.versions.toml) (Recomendado) Los Version Catalogs de Gradle permiten definir dependencias en un archivo .toml, garantizando consistencia y facilitando las actualizaciones en todos los m√≥dulos. Este m√©todo es ahora el preferido para gestionar dependencias en Gradle.\nPaso 1: Definir dependencias en libs.versions.toml Crea o actualiza el archivo gradle/libs.versions.toml:\n1 2 3 4 5 6 7  [versions] retrofit = \u0026#34;2.9.0\u0026#34; coroutines = \u0026#34;1.6.4\u0026#34; [libraries] retrofit = { module = \u0026#34;com.squareup.retrofit2:retrofit\u0026#34;, version.ref = \u0026#34;retrofit\u0026#34; } coroutines = { module = \u0026#34;org.jetbrains.kotlinx:kotlinx-coroutines-core\u0026#34;, version.ref = \u0026#34;coroutines\u0026#34; }   Paso 2: Usar Version Catalog en build.gradle.kts 1 2 3 4  dependencies { implementation(libs.retrofit) implementation(libs.coroutines) }   Este enfoque proporciona:\n Gesti√≥n centralizada de dependencias ‚Äì Todas las versiones se almacenan en un solo lugar. Actualizaciones seguras ‚Äì Permite actualizaciones en bloque y verificaci√≥n de compatibilidad. Mejor mantenibilidad ‚Äì Reduce la duplicaci√≥n en m√∫ltiples archivos build.gradle.kts.  Si tu proyecto a√∫n usa buildSrc, considera migrar a Version Catalogs, ya que Gradle recomienda activamente este enfoque.\nEjemplo de Arquitectura Modular en Kotlin Estructura de Carpetas de un Proyecto Modular my-app/ ‚îÇ‚îÄ‚îÄ app/ # M√≥dulo principal de la aplicaci√≥n ‚îÇ‚îÄ‚îÄ core/ ‚îÇ ‚îú‚îÄ‚îÄ core-utils/ # Utilidades comunes ‚îÇ‚îÄ‚îÄ features/ ‚îÇ ‚îú‚îÄ‚îÄ feature-auth/ # Inicio de sesi√≥n, registro ‚îÇ ‚îú‚îÄ‚îÄ feature-dashboard/ # Panel de usuario, pantalla principal ‚îÇ‚îÄ‚îÄ libraries/ ‚îÇ ‚îú‚îÄ‚îÄ ui-components/ # Elementos de UI reutilizables ‚îÇ ‚îú‚îÄ‚îÄ networking/ # Configuraci√≥n de Retrofit, cliente API Flujo de Dependencias  feature-auth ‚Üí depende de core-utils y networking app ‚Üí depende de todos los m√≥dulos de funcionalidad (feature-auth, feature-dashboard)  Mejores Pr√°cticas para Modularizaci√≥n ‚úÖ Evitar Dependencias C√≠clicas\n Los m√≥dulos de funcionalidad no deben depender directamente entre s√≠. Usa comunicaci√≥n basada en eventos (por ejemplo, LiveData, Flow).  ‚úÖ Usar Inyecci√≥n de Dependencias (DI)\n Bibliotecas como Koin ayudan a gestionar dependencias.  ‚úÖ Optimizar la Velocidad de Compilaci√≥n en Gradle\n Habilitar la cach√© de configuraci√≥n de Gradle:  org.gradle.parallel=true org.gradle.caching=true Conclusi√≥n Al implementar la modularizaci√≥n en proyectos Gradle, se logra:\n‚úîÔ∏è Tiempos de compilaci√≥n m√°s r√°pidos\n‚úîÔ∏è Mejor mantenibilidad\n‚úîÔ∏è Escalabilidad para equipos grandes\n‚úîÔ∏è Componentes reutilizables\n¬øTe gustar√≠a explorar un proyecto de Kotlin de ejemplo que muestre la modularizaci√≥n? üöÄ\n","description":"Modularizaci√≥n en Proyectos Gradle con Kotlin: Una Gu√≠a Completa","id":12,"section":"es","tags":["kotlin","architecture"],"title":"Modularizaci√≥n en Proyectos Gradle con Kotlin","uri":"https://carrion.dev/ko/es/posts/gradle-modularization/"},{"content":"Test-Driven Development (TDD) en Kotlin para Android El Test-Driven Development (TDD) es una pr√°ctica de desarrollo de software que enfatiza escribir pruebas antes de implementar la funcionalidad. Sigue un ciclo Rojo-Verde-Refactorizaci√≥n: primero, escribes una prueba que falla (Rojo), luego implementas el c√≥digo m√≠nimo para que pase (Verde), y finalmente, refactorizas el c√≥digo manteniendo la prueba en verde (Refactorizaci√≥n). En esta publicaci√≥n, exploraremos c√≥mo aplicar TDD en Kotlin para el desarrollo de Android usando JUnit, MockK y Coroutines, con un ejemplo del mundo real.\n¬øPor qu√© usar Test-Driven Development en el desarrollo de Android?  Mejor calidad del c√≥digo: Escribir pruebas primero garantiza mejores decisiones de dise√±o y mantenibilidad. Depuraci√≥n m√°s r√°pida: Los errores se detectan temprano antes de volverse complejos. Confianza al refactorizar: Las pruebas act√∫an como una red de seguridad al modificar c√≥digo. Mayor productividad: Aunque escribir pruebas primero puede parecer m√°s lento al principio, acelera el desarrollo a largo plazo.  Configuraci√≥n del entorno de prueba Antes de comenzar, agreguemos las dependencias necesarias a nuestro archivo Gradle:\n1 2 3 4  // Pruebas unitarias testImplementation(\u0026#34;junit:junit:4.13.2\u0026#34;) testImplementation(\u0026#34;org.jetbrains.kotlinx:kotlinx-coroutines-test:1.10.1\u0026#34;) testImplementation(\u0026#34;io.mockk:mockk:1.13.16\u0026#34;)   Ahora, crearemos un ejemplo del mundo real para demostrar Test-Driven Development.\nEjemplo del mundo real: Obtener datos en un UseCase Implementaremos un UseCase que obtiene datos de un Repositorio y los ejecuta en el Dispatcher IO. Seguiremos el enfoque Test-Driven Development.\nPaso 1: Escribir una prueba que falle (Rojo) Primero, definamos una prueba para nuestro FetchUserUseCase. Este caso de uso obtiene los detalles de un usuario desde un repositorio.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  import io.mockk.* import kotlinx.coroutines.CoroutineDispatcher import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.ExperimentalCoroutinesApi import kotlinx.coroutines.test.* import kotlinx.coroutines.runBlocking import org.junit.Before import org.junit.Test import kotlin.test.assertEquals @ExperimentalCoroutinesApi class FetchUserUseCaseTest { private val repository: UserRepository = mockk() private lateinit var useCase: FetchUserUseCase private val testDispatcher = StandardTestDispatcher() @Before fun setup() { useCase = FetchUserUseCase(repository, testDispatcher) // Inyectar dispatcher de prueba  } @Test fun `fetch user returns expected user`() = runTest { // Given  val expectedUser = User(id = 1, name = \u0026#34;John Doe\u0026#34;) coEvery { repository.getUser(1) } returns expectedUser // When  val result = useCase(1) // Then  assertEquals(expectedUser, result) coVerify { repository.getUser(1) } } }   Entendiendo Given-When-Then   Given (Dado) ‚Äì Configurar las condiciones o dependencias necesarias para la prueba.\n1 2  val expectedUser = User(id = 1, name = \u0026#34;John Doe\u0026#34;) coEvery { repository.getUser(1) } returns expectedUser    Esto prepara una respuesta simulada para repository.getUser(1), de modo que devuelva expectedUser.    When (Cuando) ‚Äì Ejecutar la funci√≥n o caso de uso que se est√° probando.\n1  val result = useCase(1)    Esto llama a FetchUserUseCase con un ID de usuario 1, activando el comportamiento que queremos probar.    Then (Entonces) ‚Äì Verificar que el resultado esperado coincida con el resultado real.\n1 2  assertEquals(expectedUser, result) coVerify { repository.getUser(1) }    Esto comprueba que la funci√≥n devolvi√≥ el usuario esperado y que el m√©todo getUser del repositorio fue llamado.    Paso 2: Implementar el c√≥digo m√≠nimo para que pase la prueba (Verde) Ahora, implementemos la clase FetchUserUseCase.\n1 2 3 4 5 6 7 8 9 10 11 12 13  import kotlinx.coroutines.CoroutineDispatcher import kotlinx.coroutines.withContext class FetchUserUseCase( private val repository: UserRepository, private val dispatcher: CoroutineDispatcher = Dispatchers.IO // Dispatcher inyectado ) { suspend operator fun invoke(userId: Int): User { return withContext(dispatcher) { repository.getUser(userId) } } }   Paso 3: Refactorizar Dado que nuestra prueba est√° pasando, podemos limpiar o mejorar nuestra implementaci√≥n si es necesario. Aqu√≠, la implementaci√≥n ya es clara, por lo que no se requieren grandes refactorizaciones.\nEntendiendo las partes clave 1. Simulaci√≥n con MockK Usamos MockK para simular nuestro repositorio:\n1  coEvery { repository.getUser(1) } returns expectedUser   Esto simula una llamada a una funci√≥n que devuelve un valor predefinido.\n2. Uso de Coroutines con Test Dispatchers Reemplazamos Dispatchers.IO con un Test Dispatcher para controlar la ejecuci√≥n de las corrutinas.\n3. Verificaci√≥n de llamadas a funciones Nos aseguramos de que la funci√≥n del repositorio haya sido llamada:\n1  coVerify { repository.getUser(1) }   Esto confirma que nuestro c√≥digo se comporta como se espera.\nMejores pr√°cticas para Test-Driven Development en Kotlin  Escribir pruebas peque√±as y enfocadas: Cada prueba debe verificar una sola cosa. Usar mocks con prudencia: Evita el exceso de mocks; solo simula dependencias reales. Preferir pruebas deterministas: Evita pruebas inestables o dependientes del tiempo. Aprovechar las utilidades de prueba de Coroutines: Usa StandardTestDispatcher y runTest. Mantener pruebas r√°pidas: Las pruebas unitarias deben ejecutarse en milisegundos.  Conclusi√≥n Test-Driven Development mejora la calidad del c√≥digo y la eficiencia en el desarrollo. Al escribir pruebas primero, garantizamos c√≥digo confiable y mantenible. En esta publicaci√≥n, construimos un UseCase que obtiene datos de un repositorio ejecut√°ndolo en el Dispatcher IO, siguiendo los principios de Test-Driven Development. Con MockK y Coroutines, creamos una configuraci√≥n de pruebas robusta.\n¬°Comienza a aplicar Test-Driven Development en tus proyectos de Kotlin hoy mismo y experimenta los beneficios de primera mano!\nüöÄ ¬øQu√© sigue? ¬øTe gustar√≠a que ampliemos este contenido con pruebas de ViewModel o pruebas de UI con Jetpack Compose? ¬°D√©jamelo saber en los comentarios!\n","description":"Test-Driven Development (TDD) en Kotlin para Android con ejemplos reales usando JUnit, MockK y Coroutines","id":13,"section":"es","tags":["kotlin","architecture","TDD","testing"],"title":"Test-Driven Development (TDD) en Kotlin para Android","uri":"https://carrion.dev/ko/es/posts/tdd-kotlin/"},{"content":"Clean Architecture en Kotlin \u0026amp; Android Introducci√≥n Al desarrollar aplicaciones Android, mantener la escalabilidad y la legibilidad es crucial. Sin un enfoque arquitect√≥nico claro, los proyectos pueden volverse dif√≠ciles de mantener a medida que crecen. Aqu√≠ es donde Clean Architecture, introducida por Uncle Bob (Robert C. Martin), se vuelve invaluable. Esta arquitectura enfatiza la separaci√≥n de responsabilidades, haciendo que el c√≥digo sea m√°s modular, testeable y mantenible.\nEntendiendo Clean Architecture Clean Architecture est√° estructurada en tres capas principales, cada una con un rol espec√≠fico:\n Capa de Presentaci√≥n: Maneja la UI y las interacciones del usuario. Capa de Dominio: Contiene la l√≥gica de negocio, casos de uso e interfaces de repositorio. Capa de Datos: Implementa los repositorios, maneja llamadas a APIs y operaciones de base de datos.  El principio central de Clean Architecture es la direcci√≥n de las dependencias: cada capa solo debe depender de las capas m√°s cercanas al n√∫cleo (dominio). Esto garantiza flexibilidad y escalabilidad.\nEstructura del Proyecto Un proyecto con Clean Architecture en Kotlin t√≠picamente sigue esta estructura:\ncom.example.app ‚îÇ‚îÄ‚îÄ presentation (ViewModels, UI, Estado) ‚îÇ‚îÄ‚îÄ domain (Casos de Uso, Interfaces de Repositorio, Modelos) ‚îÇ‚îÄ‚îÄ data (Implementaciones de Repositorio, Fuentes de Datos, APIs, DB) Cada capa debe estar en un m√≥dulo o paquete separado, asegurando una correcta separaci√≥n de responsabilidades.\nModularizaci√≥n Para mejorar a√∫n m√°s el mantenimiento y la escalabilidad, considera estructurar tu proyecto en m√≥dulos de Gradle. Esto garantiza una clara separaci√≥n entre capas y promueve la reutilizaci√≥n.\nUn proyecto modularizado con Clean Architecture podr√≠a seguir esta estructura:\ncom.example.app ‚îÇ‚îÄ‚îÄ app (M√≥dulo principal de la aplicaci√≥n) ‚îÇ‚îÄ‚îÄ feature-user ‚îÇ ‚îÇ‚îÄ‚îÄ domain (Casos de Uso, Interfaces de Repositorio, Modelos) ‚îÇ ‚îÇ‚îÄ‚îÄ data (Implementaciones de Repositorio, Fuentes de Datos, APIs, DB) ‚îÇ ‚îÇ‚îÄ‚îÄ presentation (UI y ViewModels para funcionalidades de usuario) ‚îÇ‚îÄ‚îÄ core (Utilidades comunes, networking, helpers de base de datos) Beneficios de la modularizaci√≥n:\n Tiempos de compilaci√≥n m√°s r√°pidos debido a la compilaci√≥n aislada de m√≥dulos. Mejor encapsulaci√≥n del c√≥digo y separaci√≥n de responsabilidades. Desarrollo y mantenimiento de funcionalidades m√°s sencillo. Mayor facilidad para realizar pruebas unitarias en m√≥dulos independientes.  Implementando Clean Architecture con Kotlin 1. Capa de Dominio (L√≥gica de Negocio Central) La capa de dominio define la l√≥gica de negocio y los casos de uso. No debe depender de ning√∫n framework o librer√≠a externa, lo que la convierte en la parte m√°s estable de la aplicaci√≥n.\nEjemplo: Definir una Interfaz de Repositorio 1 2 3  interface UserRepository { suspend fun getUserById(id: String): User }   Ejemplo: Caso de Uso 1 2 3 4 5  class GetUserByIdUseCase(private val userRepository: UserRepository) { suspend operator fun invoke(id: String): User { return userRepository.getUserById(id) } }   2. Capa de Datos (Implementaci√≥n de Repositorios y Fuentes de Datos) La capa de datos proporciona implementaciones concretas de las interfaces de repositorio. Interact√∫a con APIs, bases de datos o almacenamiento local.\nEjemplo: Fuente de Datos 1 2 3 4 5 6 7 8 9  interface UserRemoteDataSource { suspend fun fetchUserById(id: String): User } class UserRemoteDataSourceImpl(private val api: UserApi) : UserRemoteDataSource { override suspend fun fetchUserById(id: String): User { return api.fetchUserById(id) } }   Ejemplo: Implementaci√≥n del Repositorio 1 2 3 4 5  class UserRepositoryImpl(private val remoteDataSource: UserRemoteDataSource) : UserRepository { override suspend fun getUserById(id: String): User { return remoteDataSource.fetchUserById(id) } }   3. Capa de Presentaci√≥n (UI \u0026amp; ViewModel) La capa de presentaci√≥n es responsable de la l√≥gica de UI y la gesti√≥n de estados. Depende de la capa de dominio, pero no interact√∫a directamente con la capa de datos.\nEjemplo: ViewModel 1 2 3 4 5 6 7 8 9 10 11  class UserViewModel(private val getUserByIdUseCase: GetUserByIdUseCase) : ViewModel() { private val _user = MutableStateFlow\u0026lt;User?\u0026gt;(null) val user: StateFlow\u0026lt;User?\u0026gt; get() = _user.asStateFlow() fun loadUser(id: String) { viewModelScope.launch { _user.value = getUserByIdUseCase(id) } } }   Mejores Pr√°cticas  Mant√©n la Capa de Dominio Pura: No debe depender de frameworks de Android. Usa Inyecci√≥n de Dependencias: Koin ayuda a gestionar las dependencias de manera limpia. Sigue la Regla de las Dependencias: Las capas internas no deben depender de las externas. Separa Interfaces e Implementaciones de Repositorios: Las interfaces van en la capa de dominio, las implementaciones en la capa de datos. Usa Fuentes de Datos: Encapsula llamadas a APIs y bases de datos en clases dedicadas. Modulariza tu C√≥digo: Usa m√≥dulos de Gradle para separar responsabilidades y mejorar los tiempos de compilaci√≥n.  Conclusi√≥n Clean Architecture proporciona una forma robusta de estructurar aplicaciones Android. Al separar responsabilidades y aplicar dependencias claras, el c√≥digo se vuelve m√°s testeable y escalable. Usar Koin para la inyecci√≥n de dependencias mejora a√∫n m√°s la mantenibilidad. Adoptar esta arquitectura, junto con modularizaci√≥n, resultar√° en una base de c√≥digo m√°s modular y resistente para tus proyectos en Kotlin.\n","description":"Clean Architecture en Kotlin \u0026 Android con ejemplos pr√°cticos","id":14,"section":"es","tags":["kotlin","architecture"],"title":"Clean Architecture en Kotlin \u0026 Android","uri":"https://carrion.dev/ko/es/posts/clean-architecture/"},{"content":"Explorando Arquitecturas de Apps en Kotlin: MVC, MVP, MVVM y MVI Introducci√≥n En el desarrollo moderno de aplicaciones, elegir la arquitectura adecuada es esencial para crear aplicaciones mantenibles y escalables. Las arquitecturas definen c√≥mo se organiza tu base de c√≥digo y c√≥mo interact√∫an los diferentes componentes. En este art√≠culo, exploraremos cuatro arquitecturas populares: Model-View-Controller (MVC), Model-View-Presenter (MVP), Model-View-ViewModel (MVVM) y Model-View-Intent (MVI). Analizaremos su estructura, ventajas, desventajas y ejemplos pr√°cticos en Kotlin.\n1. Model-View-Controller (MVC) Definici√≥n:\nMVC divide una aplicaci√≥n en tres componentes:\n Model: Gestiona los datos y la l√≥gica de negocio. View: Muestra los datos al usuario, accediendo directamente al Model para actualizaciones. Controller: Maneja la entrada del usuario y actualiza el Model.  Ventajas:\n Simple de implementar y entender. Eficaz para aplicaciones peque√±as o prototipos.  Desventajas:\n Acoplamiento estrecho entre la View y el Model. Separaci√≥n limitada de preocupaciones; escalar puede ser desafiante.  Ejemplo en Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // Model data class User(var name: String, var age: Int) // View class UserView { fun displayUser(user: User) { println(\u0026#34;Name: ${user.name}, Age: ${user.age}\u0026#34;) } } // Controller class UserController(private val model: User, private val view: UserView) { fun handleUserInput() { println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; model.name = newName // Directly updates the model  view.displayUser(model) } } fun main() { val user = User(\u0026#34;Alice\u0026#34;, 30) val view = UserView() val controller = UserController(user, view) view.displayUser(user) controller.handleUserInput() }   2. Model-View-Presenter (MVP) Definici√≥n:\nEn MVP, el Presenter act√∫a como mediador entre el Model y la View. A diferencia de MVC, la View es pasiva y delega toda la l√≥gica de interacci√≥n al Presenter, quien obtiene datos del Model y actualiza la View.\nVentajas:\n Mejor separaci√≥n de preocupaciones en comparaci√≥n con MVC. M√°s f√°cil de probar, ya que el Presenter maneja toda la l√≥gica.  Desventajas:\n Las clases de Presenter pueden volverse grandes (\u0026ldquo;clases Dios\u0026rdquo;). Manejar eventos del ciclo de vida puede ser desafiante.  Ejemplo en Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // Model data class User(val name: String, val age: Int) // View Interface interface UserView { fun displayUser(name: String, age: Int) } // Presenter class UserPresenter(private val view: UserView) { private var user = User(\u0026#34;Bob\u0026#34;, 25) fun loadUser() { view.displayUser(user.name, user.age) } fun updateUser() { println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; user = user.copy(name = newName) view.displayUser(user.name, user.age) } } // View Implementation class ConsoleUserView : UserView { override fun displayUser(name: String, age: Int) { println(\u0026#34;Name: $name, Age: $age\u0026#34;) } } fun main() { val view = ConsoleUserView() val presenter = UserPresenter(view) presenter.loadUser() presenter.updateUser() }   3. Model-View-ViewModel (MVVM) Definici√≥n:\nMVVM promueve un enfoque reactivo. El ViewModel proporciona datos a la View y reacciona a los cambios en el Model. A menudo utiliza LiveData o StateFlow de Kotlin.\nVentajas:\n Fomenta una clara separaci√≥n de preocupaciones. Excelente para programaci√≥n reactiva utilizando corutinas o flujos.  Desventajas:\n Requiere familiaridad con paradigmas reactivos. El enlace de datos o la gesti√≥n de estados puede agregar complejidad.  Ejemplo en Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // Model data class User(val name: String, val age: Int) // ViewModel class UserViewModel { private val _user = MutableStateFlow(User(\u0026#34;Charlie\u0026#34;, 28)) val user = _user.asStateFlow() fun updateUser(name: String) { _user.value = _user.value.copy(name = name) } } // View class UserView(private val viewModel: UserViewModel) { fun render() { viewModel.user.collect { user -\u0026gt; println(\u0026#34;Name: ${user.name}, Age: ${user.age}\u0026#34;) } } fun getUserInput(): String { println(\u0026#34;Enter new name for the user:\u0026#34;) return readLine() ?: \u0026#34;\u0026#34; } fun updateUserName() { val newName = getUserInput() viewModel.updateUser(newName) } } fun main() = runBlocking { val viewModel = UserViewModel() val view = UserView(viewModel) view.render() view.updateUserName() }   4. Model-View-Intent (MVI) Definici√≥n:\nMVI utiliza un flujo de datos unidireccional. La View env√≠a intenciones del usuario, el Model las procesa, y el estado se actualiza y es renderizado por la View.\nVentajas:\n Gesti√≥n de estado predecible. Fomenta la inmutabilidad y un flujo de datos claro.  Desventajas:\n Curva de aprendizaje pronunciada. Sobrecarga para aplicaciones simples.  Ejemplo en Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  // Model data class UserState(val name: String = \u0026#34;\u0026#34;, val age: Int = 0) // Intent sealed class UserIntent { object LoadUser : UserIntent() data class UpdateUser(val name: String) : UserIntent() } // Reducer fun userReducer(currentState: UserState, intent: UserIntent): UserState { return when (intent) { is UserIntent.LoadUser -\u0026gt; UserState(name = \u0026#34;Dave\u0026#34;, age = 40) is UserIntent.UpdateUser -\u0026gt; currentState.copy(name = intent.name) } } // ViewModel class UserViewModel { private val _state = MutableStateFlow(UserState()) val state: StateFlow\u0026lt;UserState\u0026gt; = _state fun processIntent(intent: UserIntent) { _state.update { currentState -\u0026gt; userReducer(currentState, intent) } } } // View class UserView(private val viewModel: UserViewModel) { fun render() { viewModel.state.collect { state -\u0026gt; println(\u0026#34;Name: ${state.name}, Age: ${state.age}\u0026#34;) } } fun sendIntent(intent: UserIntent) { viewModel.processIntent(intent) } } fun main() = runBlocking { val viewModel = UserViewModel() val view = UserView(viewModel) view.sendIntent(UserIntent.LoadUser) view.render() println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; view.sendIntent(UserIntent.UpdateUser(newName)) }   Conclusi√≥n Cada arquitectura tiene sus fortalezas y compromisos:\n MVC: Mejor para aplicaciones peque√±as y simples. MVP: Equilibra estructura y simplicidad. MVVM: Ideal para programaci√≥n reactiva. MVI: Excelente para la gesti√≥n de estado predecible y escalable.  Considera la complejidad y los requisitos de tu proyecto al elegir una arquitectura. ¬øCu√°l prefieres t√∫?\n","description":"Explorando Arquitecturas de Apps en Kotlin: MVC, MVP, MVVM y MVI","id":15,"section":"es","tags":["kotlin","architecture"],"title":"Explorando Arquitecturas de Apps en Kotlin","uri":"https://carrion.dev/ko/es/posts/app-architecture/"},{"content":"Explorando M√°s Patrones de Dise√±o en Kotlin: Parte 3  Part 1 Part 2 Part 3  En esta tercera entrega, cubriremos los patrones Memento, Command, Visitor, Chain of Responsibility y Mediator. Estos patrones abordan desaf√≠os de construcci√≥n, comportamiento y estructura, mostrando la sintaxis expresiva y las caracter√≠sticas modernas de Kotlin.\n1. Patr√≥n Memento El Patr√≥n Memento captura y restaura el estado de un objeto sin exponer sus detalles internos.\nCu√°ndo Usar  Para implementar funcionalidad de deshacer/rehacer.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  class Editor { var content: String = \u0026#34;\u0026#34; fun createMemento(): Memento = Memento(content) fun restore(memento: Memento) { content = memento.state } data class Memento(val state: String) } class History { private val mementos = mutableListOf\u0026lt;Editor.Memento\u0026gt;() fun save(memento: Editor.Memento) { mementos.add(memento) } fun pop(): Editor.Memento? { if (mementos.isNotEmpty()) { return mementos.removeAt(mementos.lastIndex) } return null } } fun main() { val editor = Editor() val history = History() editor.content = \u0026#34;First Version\u0026#34; history.save(editor.createMemento()) editor.content = \u0026#34;Second Version\u0026#34; history.save(editor.createMemento()) editor.content = \u0026#34;Third Version\u0026#34; println(\u0026#34;Current Content: ${editor.content}\u0026#34;) editor.restore(history.pop()!!) println(\u0026#34;Restored Content: ${editor.content}\u0026#34;) editor.restore(history.pop()!!) println(\u0026#34;Restored Content: ${editor.content}\u0026#34;) }   Por Qu√© Kotlin? La sintaxis concisa de Kotlin facilita la captura y restauraci√≥n de estados.\n2. Patr√≥n Command El Patr√≥n Command encapsula una solicitud como un objeto, permitiendo la parametrizaci√≥n y el encolado.\nCu√°ndo Usar  Para implementar operaciones deshacibles o colas de comandos.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  interface Command { fun execute() } class Light { fun on() = println(\u0026#34;Light is ON\u0026#34;) fun off() = println(\u0026#34;Light is OFF\u0026#34;) } class LightOnCommand(private val light: Light) : Command { override fun execute() = light.on() } class LightOffCommand(private val light: Light) : Command { override fun execute() = light.off() } fun main() { val light = Light() val commands = listOf(LightOnCommand(light), LightOffCommand(light)) commands.forEach { it.execute() } }   Por Qu√© Kotlin? El enfoque funcional de Kotlin puede simplificar a√∫n m√°s la ejecuci√≥n de comandos.\n3. Patr√≥n Visitor El Patr√≥n Visitor separa un algoritmo de la estructura de objetos sobre la que opera, moviendo el algoritmo a un objeto visitante.\nCu√°ndo Usar  Cuando necesitas realizar operaciones en un conjunto de objetos con tipos variados.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  interface Shape { fun accept(visitor: ShapeVisitor) } class Circle(val radius: Double) : Shape { override fun accept(visitor: ShapeVisitor) { visitor.visit(this) } } class Rectangle(val width: Double, val height: Double) : Shape { override fun accept(visitor: ShapeVisitor) { visitor.visit(this) } } fun interface ShapeVisitor { fun visit(shape: Shape) } fun main() { val shapes: List\u0026lt;Shape\u0026gt; = listOf(Circle(5.0), Rectangle(4.0, 6.0)) val visitor = ShapeVisitor { shape -\u0026gt; when (shape) { is Circle -\u0026gt; println(\u0026#34;Circle with radius ${shape.radius}\u0026#34;) is Rectangle -\u0026gt; println(\u0026#34;Rectangle with width ${shape.width}and height ${shape.height}\u0026#34;) } } shapes.forEach { it.accept(visitor) } }   Por Qu√© Kotlin? Las fun interface y las clases selladas de Kotlin simplifican la implementaci√≥n del visitante.\n4. Patr√≥n Chain of Responsibility El Patr√≥n Chain of Responsibility pasa una solicitud a lo largo de una cadena de manejadores hasta que uno la procesa.\nCu√°ndo Usar  Cuando m√∫ltiples objetos pueden manejar una solicitud y el handler se determina en tiempo de ejecuci√≥n.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  interface Handler { fun handle(request: String): Boolean } class AuthHandler(private val next: Handler?) : Handler { override fun handle(request: String): Boolean { println(\u0026#34;AuthHandler processing...\u0026#34;) return next?.handle(request) ?: true } } class LoggingHandler(private val next: Handler?) : Handler { override fun handle(request: String): Boolean { println(\u0026#34;LoggingHandler processing...\u0026#34;) return next?.handle(request) ?: true } } fun main() { val chain = AuthHandler(LoggingHandler(null)) chain.handle(\u0026#34;Request\u0026#34;) }   Por Qu√© Kotlin? Los tipos nulos de Kotlin y su delegaci√≥n concisa simplifican el encadenamiento de handlers.\n5. Patr√≥n Mediator El Patr√≥n Mediator centraliza la comunicaci√≥n compleja entre m√∫ltiples objetos haciendo que se comuniquen a trav√©s de un mediador.\nCu√°ndo Usar  Cuando los objetos interact√∫an de manera compleja, lo que lleva a dependencias enredadas.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class Mediator { private val colleagues = mutableListOf\u0026lt;Colleague\u0026gt;() fun addColleague(colleague: Colleague) { colleagues.add(colleague) } fun broadcast(sender: Colleague, message: String) { colleagues.filter { it != sender } .forEach { it.receive(message) } } } interface Colleague { fun send(message: String) fun receive(message: String) } class ConcreteColleague(private val mediator: Mediator) : Colleague { override fun send(message: String) { println(\u0026#34;Sending message: $message\u0026#34;) mediator.broadcast(this, message) } override fun receive(message: String) { println(\u0026#34;Received message: $message\u0026#34;) } } fun main() { val mediator = Mediator() val colleague1 = ConcreteColleague(mediator) val colleague2 = ConcreteColleague(mediator) mediator.addColleague(colleague1) mediator.addColleague(colleague2) colleague1.send(\u0026#34;Hello from Colleague 1\u0026#34;) }   Por Qu√© Kotlin? Las funciones de primera clase y las colecciones de Kotlin simplifican la difusi√≥n y la interacci√≥n.\nConclusi√≥n Estos patrones‚ÄîMemento, Command, Visitor, Chain of Responsibility y Mediator‚Äîdemuestran la capacidad de Kotlin para mejorar patrones de dise√±o cl√°sicos con caracter√≠sticas modernas.\n¬øCu√°l de estos patrones encuentras m√°s interesante? ¬°H√°zmelo saber! üöÄ\n","description":"Kotlin Design Patterns - Part 3","id":16,"section":"es","tags":["kotlin","design-patterns","architecture"],"title":"Kotlin Design Patterns - Part 3","uri":"https://carrion.dev/ko/es/posts/design-patterns-3/"},{"content":"Entendiendo los principios SOLID con ejemplos en Kotlin Los principios SOLID son un conjunto de principios de dise√±o que hacen que los dise√±os de software sean m√°s comprensibles, flexibles y mantenibles. Introducidos por Robert C. Martin, estos principios son una piedra angular de la programaci√≥n orientada a objetos y son especialmente relevantes al construir sistemas complejos. En este blog, exploraremos cada principio con ejemplos escritos en Kotlin, un lenguaje que ofrece una sintaxis moderna y caracter√≠sticas poderosas.\n1. Principio de Responsabilidad √önica (SRP) Una clase debe tener una, y solo una, raz√≥n para cambiar.\nEste principio asegura que una clase tenga una √∫nica responsabilidad, lo que la hace m√°s f√°cil de mantener y menos propensa a errores.\nRompiendo SRP:\n1 2 3 4 5 6 7 8 9 10 11  class ReportManager { fun generateReport(data: String): String { // L√≥gica para generar reporte  return \u0026#34;Report: $data\u0026#34; } fun saveReport(report: String) { // L√≥gica para guardar reporte  println(\u0026#34;Report saved: $report\u0026#34;) } }   En este ejemplo, la clase ReportManager viola el SRP porque tiene dos responsabilidades: generar y guardar reportes. Cualquier cambio en la l√≥gica de generaci√≥n o de guardado requerir√≠a modificar la misma clase.\nCorrigiendo SRP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class ReportGenerator { fun generateReport(data: String): String { // L√≥gica para generar reporte  return \u0026#34;Report: $data\u0026#34; } } class ReportSaver { fun saveReport(report: String) { // L√≥gica para guardar reporte  println(\u0026#34;Report saved: $report\u0026#34;) } } fun main() { val generator = ReportGenerator() val saver = ReportSaver() val report = generator.generateReport(\u0026#34;Sales Data\u0026#34;) saver.saveReport(report) }   Separando responsabilidades, hacemos que cada clase est√© enfocada y sea m√°s f√°cil de probar de manera independiente.\n2. Principio Abierto/Cerrado (OCP) Las entidades de software deben estar abiertas para extensi√≥n, pero cerradas para modificaci√≥n.\nPuedes a√±adir nueva funcionalidad extendiendo clases sin cambiar el c√≥digo existente.\nRompiendo OCP:\n1 2 3 4 5 6 7 8 9  class Discount { fun calculate(price: Double, type: String): Double { return when (type) { \u0026#34;none\u0026#34; -\u0026gt; price \u0026#34;percentage\u0026#34; -\u0026gt; price * 0.9 else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unknown discount type\u0026#34;) } } }   Aqu√≠, a√±adir un nuevo tipo de descuento requiere modificar el m√©todo calculate, lo que viola el OCP.\nCorrigiendo OCP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  interface DiscountStrategy { fun calculate(price: Double): Double } class NoDiscount : DiscountStrategy { override fun calculate(price: Double): Double = price } class PercentageDiscount(private val percentage: Double) : DiscountStrategy { override fun calculate(price: Double): Double = price * (1 - percentage / 100) } class DiscountCalculator(private val strategy: DiscountStrategy) { fun calculate(price: Double): Double = strategy.calculate(price) } fun main() { val noDiscount = DiscountCalculator(NoDiscount()) println(\u0026#34;Price after no discount: ${noDiscount.calculate(100.0)}\u0026#34;) val percentageDiscount = DiscountCalculator(PercentageDiscount(10.0)) println(\u0026#34;Price after 10% discount: ${percentageDiscount.calculate(100.0)}\u0026#34;) }   Usando interfaces y composici√≥n, logramos un dise√±o que est√° abierto a la extensi√≥n (nuevas estrategias de descuento) y cerrado a la modificaci√≥n (sin cambios en las clases existentes).\n3. Principio de Sustituci√≥n de Liskov (LSP) Los objetos de una superclase deben poder ser reemplazados con objetos de una subclase sin afectar la correcci√≥n del programa.\nEste principio asegura que las clases derivadas respeten las expectativas establecidas por su clase base.\nRompiendo LSP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  open class Bird { open fun fly() { println(\u0026#34;Flying\u0026#34;) } } class Sparrow : Bird() class Penguin : Bird() { override fun fly() { throw UnsupportedOperationException(\u0026#34;Penguins can\u0026#39;t fly\u0026#34;) } } fun main() { val birds: List\u0026lt;Bird\u0026gt; = listOf(Sparrow(), Penguin()) for (bird in birds) { bird.fly() // Esto fallar√° para Penguin  } }   En este ejemplo, Penguin viola LSP porque no puede cumplir el contrato de Bird. Una mejor aproximaci√≥n es refactorizar el dise√±o:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  interface Flyable { fun fly() } class Sparrow : Flyable { override fun fly() { println(\u0026#34;Flying\u0026#34;) } } class Penguin { fun swim() { println(\u0026#34;Swimming\u0026#34;) } }   Ahora, los comportamientos est√°n segregados, y se respeta el LSP.\n4. Principio de Segregaci√≥n de Interfaces (ISP) Los clientes no deber√≠an estar obligados a depender de m√©todos que no utilizan.\nEste principio promueve la creaci√≥n de interfaces espec√≠ficas en lugar de una √∫nica interfaz inflada.\nRompiendo ISP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Machine { fun print() fun scan() fun fax() } class OldPrinter : Machine { override fun print() { println(\u0026#34;Printing\u0026#34;) } override fun scan() { throw UnsupportedOperationException(\u0026#34;Scan not supported\u0026#34;) } override fun fax() { throw UnsupportedOperationException(\u0026#34;Fax not supported\u0026#34;) } }   Esta implementaci√≥n fuerza a OldPrinter a implementar m√©todos que no soporta, violando ISP.\nCorrigiendo ISP:\n1 2 3 4 5 6 7 8 9 10 11 12 13  interface Printer { fun print() } interface Scanner { fun scan() } class SimplePrinter : Printer { override fun print() { println(\u0026#34;Printing\u0026#34;) } }   Dividiendo las funcionalidades en interfaces separadas, permitimos que los dispositivos implementen solo lo que necesitan.\n5. Principio de Inversi√≥n de Dependencias (DIP) Los m√≥dulos de alto nivel no deben depender de m√≥dulos de bajo nivel. Ambos deben depender de abstracciones.\nEste principio reduce el acoplamiento entre los m√≥dulos de alto y bajo nivel al introducir abstracciones.\nRompiendo DIP:\n1 2 3 4 5 6 7 8 9 10 11 12 13  class EmailService { fun sendEmail(message: String) { println(\u0026#34;Sending Email: $message\u0026#34;) } } class NotificationSender { private val emailService = EmailService() fun notifyUser(message: String) { emailService.sendEmail(message) } }   Aqu√≠, NotificationSender est√° fuertemente acoplado a EmailService, lo que dificulta cambiar a un servicio de notificaci√≥n diferente.\nCorrigiendo DIP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  interface NotificationService { fun sendNotification(message: String) } class EmailService : NotificationService { override fun sendNotification(message: String) { println(\u0026#34;Sending Email: $message\u0026#34;) } } class SMSService : NotificationService { override fun sendNotification(message: String) { println(\u0026#34;Sending SMS: $message\u0026#34;) } } class NotificationSender(private val service: NotificationService) { fun notifyUser(message: String) { service.sendNotification(message) } } fun main() { val emailSender = NotificationSender(EmailService()) emailSender.notifyUser(\u0026#34;Hello via Email\u0026#34;) val smsSender = NotificationSender(SMSService()) smsSender.notifyUser(\u0026#34;Hello via SMS\u0026#34;) }   Aqu√≠, NotificationSender depende de la abstracci√≥n NotificationService, haci√©ndolo flexible para trabajar con cualquier tipo de notificaci√≥n.\nConclusi√≥n Los principios SOLID forman la base para construir software robusto y escalable. Kotlin, con su sintaxis expresiva y caracter√≠sticas modernas, permite a los desarrolladores implementar estos principios de manera elegante. Al adherirse a estos principios, puedes crear c√≥digo que sea m√°s f√°cil de mantener, extender y adaptar a los cambios en los requisitos.\n","description":"Principios SOLID explicados con ejemplos de Kotlin.","id":17,"section":"es","tags":["kotlin","solid","architecture"],"title":"Entendiendo los principios SOLID con ejemplos en Kotlin","uri":"https://carrion.dev/ko/es/posts/solid-kotlin/"},{"content":"Explorando patrones de dise√±o en Kotlin: Parte2 Design Patterns Series  Part 1 Part 2 Part 3  Despu√©s de la gran acogida del primer art√≠culo Patrones de dise√±o en Kotlin, volvemos con m√°s! En esta segunda parte, revisaremos los patrones de Prototype, Composite, Proxy, Observer, y Strategy. Estos patrones resuelven una variedad de desafios de dise√±o y demuestran las capacidades expresivas de Kotlin.\n1. Patr√≥n Prototype El Patr√≥n Prototype es usado para crear nuevos objeto copiando una objeto existente, asegurando la creaci√≥n eficaz de objetos.\nCuando usarlo  Cuando crear una nueva instancia es complejo o costoso. Para evitar crear instancias de subclases de forma repetida.  Implementaci√≥n en Kotlin Usar las clases data de Kotlin y su funci√≥n copy simplifica este patr√≥n.\n1 2 3 4 5 6 7 8 9  data class Document(var title: String, var content: String, var author: String) fun main() { val original = Document(\u0026#34;Design Patterns\u0026#34;, \u0026#34;Content about patterns\u0026#34;, \u0026#34;John Doe\u0026#34;) val copy = original.copy(title = \u0026#34;Prototype Pattern\u0026#34;) println(\u0026#34;Original: $original\u0026#34;) println(\u0026#34;Copy: $copy\u0026#34;) }   Por qu√© Kotlin? Las clases data de Kotlin soportan de forma nativa copiar los objetos con c√≥digo m√≠nimo, haciendo que aplicar el patr√≥n Prototype sea muy sencillo.\n2. Patr√≥n Composite El Patr√≥n Composite es usado para tratar objetos individuales y grupos de forma uniforme.\nCuando usarlo  Cuando tienes una estructura en √°rbol y quieres manipularlo de una forma consistente.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  interface Logger { fun log(message: String) } class ConsoleLogger : Logger { override fun log(message: String) { println(message) } } class FileLogger(private val filePath: String) : Logger { override fun log(message: String) { // Implementation for writing logs to a file  } } class RootLogger(private val loggers: List\u0026lt;Logger\u0026gt;) : Logger { override fun log(message: String) { loggers.forEach { it.log(message) } } } fun main() { val consoleLogger = ConsoleLogger() val fileLogger = FileLogger(\u0026#34;/path/to/log.txt\u0026#34;) val rootLogger = RootLogger(listOf(consoleLogger, fileLogger)) rootLogger.log(\u0026#34;Composite Pattern Example\u0026#34;) }   3. Patr√≥n Proxy El Patr√≥n Proxy sirve de puerta de entrada para controlar el acceso a otro objeto.\nCuando utilizarlo  Para controlar el acceso a otro recurso. Para a√±adir funcionalidad sin modificar el objeto existente.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Service { fun fetchData(): String } class RealService : Service { override fun fetchData() = \u0026#34;Data from Real Service\u0026#34; } class ProxyService(private val realService: RealService) : Service { override fun fetchData(): String { println(\u0026#34;Proxy: Checking access before delegating.\u0026#34;) return realService.fetchData() } } fun main() { val proxy = ProxyService(RealService()) println(proxy.fetchData()) }   4. Patr√≥n Observer El Patr√≥n Observer define una dependencia de uno-a-muchos, por lo que cuando un objeto cambia su estado, todos los que dependen de el son notificados.\nCuando utilizarlo  Para sistemas dirigidos por eventos. Cuando m√∫ltiples componentes necesitan reaccionar a cambios de estado.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  fun interface StateChangeListener { fun onStateChanged(oldState: String, newState: String) } class Subject { private val listeners = mutableListOf\u0026lt;StateChangeListener\u0026gt;() var state: String by Delegates.observable(\u0026#34;Initial State\u0026#34;) { _, old, new -\u0026gt; listeners.forEach { it.onStateChanged(old, new) } } fun addListener(listener: StateChangeListener) { listeners.add(listener) } } fun main() { val subject = Subject() subject.addListener { oldState, newState -\u0026gt; println(\u0026#34;Listener 1: State changed from \u0026#39;$oldState\u0026#39; to \u0026#39;$newState\u0026#39;\u0026#34;) } subject.addListener { oldState, newState -\u0026gt; println(\u0026#34;Listener 2: State changed from \u0026#39;$oldState\u0026#39; to \u0026#39;$newState\u0026#39;\u0026#34;) } subject.state = \u0026#34;State 1\u0026#34; subject.state = \u0026#34;State 2\u0026#34; }   Por qu√© Kotlin? Usar fun interface simplifica la implementaci√≥n de interfaces con un s√≥lo m√©todo. De forma adicional, los Delegates.observable de Kotlin hace que observar cambios de estado sea m√°s directo, facilitando la implementaci√≥n del patr√≥n Observer.\n5. Patr√≥n Strategy El Patr√≥n Strategy define una seria de algoritmos, encapsula cada uno de ellos, y luego los hace intercambiables.\nCuando utilizar  Cuando necesitas vaerios algoritmos para una tarea en concreto.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  interface PaymentStrategy { fun pay(amount: Double) } class CreditCardPayment : PaymentStrategy { override fun pay(amount: Double) = println(\u0026#34;Paid $$amountusing Credit Card.\u0026#34;) } class PayPalPayment : PaymentStrategy { override fun pay(amount: Double) = println(\u0026#34;Paid $$amountusing PayPal.\u0026#34;) } class PaymentContext(private var strategy: PaymentStrategy) { fun setStrategy(strategy: PaymentStrategy) { this.strategy = strategy } fun executePayment(amount: Double) = strategy.pay(amount) } fun main() { val context = PaymentContext(CreditCardPayment()) context.executePayment(100.0) context.setStrategy(PayPalPayment()) context.executePayment(200.0) }   Conclusi√≥n Con Kotlin, los patrones de dise√±o como Prototype, Composite, Proxy, Observer, y Strategy se vuelven m√°s intuitivos. Estos patrones no son solo herramientas, son los fundamentos para un c√≥digo m√°s claro y mantenible.\n","description":"Kotlin Patrones de dise√±o - Parte 2","id":18,"section":"es","tags":["kotlin","design-patterns","architecture"],"title":"Patrones de dise√±o en Kotlin - Parte 2","uri":"https://carrion.dev/ko/es/posts/design-patterns-2/"},{"content":"Usando Koin en Compose Multiplatform La inyecci√≥n de dependencias es algo imprescindible para crear aplicaciones escalables, y Koin hace que sea muy sencillo, incluso en proyectos con Compose Multiplatform. Con la nueva funci√≥n composable KoinApplication, puedes inicializar Koin directamente desde el c√≥digo com√∫n, reduciendo la cantidad de c√≥digo necesario mientras se mantiene la flexibilidad de configurar cada plataforma por separado. Vamos a ver un ejemplo.\nProject Setup Empieza creando un proyecto de Compose Multiplatform usando el KMP Wizard, seleccionando Android, iOS, Desktop y Web como plataformas. Para este ejemplo no vamos a incluir Server como plataforma.\nA√±adiendo las dependencias Usa el version catalog de Gradle para incluir las dependencias necesarias de Koin en libs.versions.toml:\n1 2 3 4 5 6 7 8 9  [versions] koin-bom = \u0026#34;4.1.0-Beta1\u0026#34; [libraries] koin-bom = { module = \u0026#34;io.insert-koin:koin-bom\u0026#34;, version.ref = \u0026#34;koin-bom\u0026#34; } koin-core = { module = \u0026#34;io.insert-koin:koin-core\u0026#34; } koin-android = { module = \u0026#34;io.insert-koin:koin-android\u0026#34; } koin-compose = { module = \u0026#34;io.insert-koin:koin-compose\u0026#34; } koin-compose-viewModel = { module = \u0026#34;io.insert-koin:koin-compose-viewmodel\u0026#34; }   Definiendo los m√≥dulos de Koin Vamos a crear dos m√≥dulos de Koin: appModule y platformModule. El platformModule define las dependencias espec√≠ficas de cada plataforma.\nM√≥dulos compartidos 1 2 3 4 5 6 7 8 9 10 11 12  val appModule = module { viewModelOf(::MainViewModel) factoryOf(::GetJokeUseCase) singleOf(::DefaultJokeRepository) bind JokeRepository::class singleOf(::JokeJsonDataSource) bind JokeDataSource::class single { Json { ignoreUnknownKeys = true } } } val Module.localPreferencesDefinition get() = singleOf(::InMemoryLocalPreferences) bind LocalPreferences::class expect val platformModule: Module   M√≥dulos espec√≠ficos de cada plataforma Para Android vamos a usar una implementaci√≥n de la interfaz de LocalPreferences que depende del contexto de Android por lo que necesitamos un m√≥dulo distinto al resto de plataformas:\n1 2 3 4  actual val platformModule: Module get() = module { singleOf(::AndroidPreferences) bind LocalPreferences::class }   Para iOS, Desktop y Web, reutilizaremos la localPreferencesDefinition que se puede ver m√°s arriba:\n1 2 3 4  actual val platformModule: Module get() = module { localPreferencesDefinition }   Configurando la App En el archivo App.kt, podemos usar la funci√≥n composable KoinApplication. A√±adiendo el par√°metro KoinAppDeclaration como opcional y con valor por defecto a null.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Composable @Preview fun App(koinAppDeclaration: KoinAppDeclaration? = null) { KoinApplication( application = { koinAppDeclaration?.invoke(this) modules(appModule, platformModule) } ) { MaterialTheme { MainScreen() } } }   En Android, usamos la lambda para proveer el contexto y activar el logging:\n1 2 3 4 5 6 7 8 9 10 11  class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { App { androidLogger(Level.DEBUG) androidContext(this@MainActivity) } } } }   Esta flexibilidad nos asegura configuraciones espec√≠ficas por plataforma, como inyectar el contexto de Android, sin afectar al resto de plataformas.\nCorriendo la App Compila la aplicaci√≥n en cada plataforma. Podr√°s probar que todo est√° funcionando y cada plataforma recibe la configuraci√≥n que necesita para funcionar.\nConclusi√≥n La nueva funci√≥n composable KoinApplication simplifica la inyecci√≥n de dependencias en Compose Multiplatform permitiendo inizializar Koin de forma compartida manteniendo la posibilidad de configurar cada plataforma por separado si fuera necesario. Esta forma de proceder reduce el c√≥digo necesario y promueve la reusabilidad del c√≥digo entre plataformas.\nPuedes descargar el c√≥digo completo para este ejemplo en GitHub.\nTambi√©n si necesitas m√°s informaci√≥n acerca de las diferentes opciones para declarar dependencias en Koin puedes visitar un post que publiqu√© en LinkedIn: Koin DSL\n","description":"Usando Koin en Compose Multiplatform desde el c√≥digo com√∫n con posibilidad de configurar cada una de las plataformas.","id":19,"section":"es","tags":["kotlin","multiplatform","cmp","compose","koin"],"title":"Usando Koin en Compose Multiplatform","uri":"https://carrion.dev/ko/es/posts/koin-cmp/"},{"content":"Explorando patrones de dise√±o en Kotlin - Parte 1 Serie Patrones de dise√±o Design Patterns Series  Part 1 Part 2 Part 3  Los patrones de dise√±o son soluciones probadas a problemas comunes en el dise√±o de software. Con la sintaxis y funcionalidades modernas de Kotlin, implementar estos patrones normalmente resulta m√°s limpio y conciso. En este post, exploraremos los patrones de Singleton, Factory Method, Builder, Adapter and Decorator, profundizando en su prop√≥sito, casos de uso y implementaciones en Kotlin.\n1. Patr√≥n Singleton El Patr√≥n Singleton asegura que una clase tiene solo una instancia y provee un punto de acceso global a ella.\nCuando utilizar  Al manejar recursos compartidos como conexiones a bases de datos.  Implementaci√≥n en Kotlin La palabra reservada de Kotlin object provee una forma r√°pida de crear un Singleton.\n1 2 3 4 5  object DatabaseConnection { fun connect() { println(\u0026#34;Connecting to database...\u0026#34;) } }   Uso 1 2 3  fun main() { DatabaseConnection.connect() }   Ventajas en Kotlin  Por defecto es Thread-safe. Requiere un c√≥digo m√≠nimo comparado con implementaciones tradicionales en otros lenguajes.  2. Patr√≥n Factory Method El Patr√≥n Factory Method delega la creaci√≥n de objectos a clases o funciones, lo que provee de flexibilidad a la hora de instanciar los objetos.\nCuando utilizarlo  Cuando crear los objetos requiere de l√≥gica o tiene complejidad. Para desacoplar la creaci√≥n del objeto del c√≥digo del cliente.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Shape { fun draw() } class Circle : Shape { override fun draw() = println(\u0026#34;Drawing a Circle\u0026#34;) } class Rectangle : Shape { override fun draw() = println(\u0026#34;Drawing a Rectangle\u0026#34;) } object ShapeFactory { fun createShape(type: String): Shape = when (type) { \u0026#34;Circle\u0026#34; -\u0026gt; Circle() \u0026#34;Rectangle\u0026#34; -\u0026gt; Rectangle() else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unknown shape type\u0026#34;) } }   Uso 1 2 3 4  fun main() { val shape = ShapeFactory.createShape(\u0026#34;Circle\u0026#34;) shape.draw() }   3. Patr√≥n Builder El Patr√≥n Builder es usado para construir objetos complejos paso a paso. Es especialmente √∫til cuando un objeto tiene muchos par√°metros opcionales o configuraciones distintas.\nCuando utilizar  Para evitar constructores con demasiados par√°metros. Cuando el proceso de contrucci√≥n del objeto es complejo o incluye multiples pasos.  Implementaci√≥n en Kotlin En Kotlin el uso de apply o las capacidades de DSL simplifican el patr√≥n Builder.\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Car(val make: String, val model: String, val year: Int) { class Builder { private var make = \u0026#34;\u0026#34; private var model = \u0026#34;\u0026#34; private var year = 0 fun make(make: String) = apply { this.make = make } fun model(model: String) = apply { this.model = model } fun year(year: Int) = apply { this.year = year } fun build() = Car(make, model, year) } }   Uso 1 2 3 4 5 6 7 8 9  fun main() { val car = Car.Builder() .make(\u0026#34;Toyota\u0026#34;) .model(\u0026#34;Corolla\u0026#34;) .year(2022) .build() println(\u0026#34;${car.make}${car.model}, ${car.year}\u0026#34;) }   ** Por qu√© en Kotlin?** Enlazar m√©todos con apply permite una sintaxis m√°s concisa y expresiva cuando se construye objetos.\n4. Patr√≥n Adapter El Patr√≥n Adapter es usado para hacer de puente entre interfaces que no son compatibles traduciendo una interfaz a la otra.\nCuando utilizar  Cuando se integra nuevo c√≥digo con c√≥digo antiguo o librer√≠as externas. Cuando dos sistemas o componentes necesitan trabajar en conjunto pero tienen interfaces incompatibles.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // Existing integer provider interface interface OldProvider { fun provide(): Int } class RandomIntProvider : OldProvider { override fun provide(): Int = (1..100).random() } // Target string provider interface interface NewProvider { fun provide(): String } // Adapter class class OldToNewProviderAdapter(private val intProvider: OldProvider) : NewProvider { override fun provide(): String = \u0026#34;Provided number: ${intProvider.provide()}\u0026#34; }   Uso 1 2 3 4 5 6  fun main() { val intProvider = RandomIntProvider() val stringProvider: NewProvider = OldToNewProviderAdapter(intProvider) println(stringProvider.provideString()) }   Por qu√© en Kotlin? Los constructores primaries de Kotlin y la sintaxis concisa simplifican la implementaci√≥n de clases de tipo wrapper.\n5. Patr√≥n Decorator El Patr√≥n Decorator a√±ade din√°micamente comportamientos a los objetos sin alterar su estructura.\nCuando usarlo  Para extender la funcionalidad de una clase en tiempo de ejecuci√≥n. Cuando heredar llevar√≠a a una jerarqu√≠a sobrecargada.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14  interface Coffee { fun cost(): Double fun description(): String } class SimpleCoffee : Coffee { override fun cost() = 5.0 override fun description() = \u0026#34;Simple Coffee\u0026#34; } class MilkDecorator(private val coffee: Coffee) : Coffee { override fun cost() = coffee.cost() + 1.5 override fun description() = coffee.description() + \u0026#34;, Milk\u0026#34; }   Uso 1 2 3 4 5 6  fun main() { val coffee = SimpleCoffee() val coffeeWithMilk = MilkDecorator(coffee) println(\u0026#34;${coffeeWithMilk.description()}costs \\$${coffeeWithMilk.cost()}\u0026#34;) }   Conclusi√≥n Las funcionalidades modernas de Kotlin como object, when y apply hacen que implementar los patrones de dise√±o tradicionales sea m√°s f√°cil y expresivo. Estos patrones no solo resuelven desaf√≠os comunes de dise√±o si no que demuestran como Kotlin mejora su implementaci√≥n.\nHay otros patrones de dise√±o que te gustaria que cubriera en futuros posts?\n","description":"Kotlin Patrones de dise√±o - Parte 1","id":20,"section":"es","tags":["kotlin","design-patterns","architecture"],"title":"Patrones de dise√±o en Kotlin - Parte 1","uri":"https://carrion.dev/ko/es/posts/design-patterns-1/"},{"content":"Explorando Kotlin Symbol Processing (KSP) con ejemplos pr√°cticos Kotlin Symbol Processing (KSP) es una herramienta muy potente usada para simplificar el procesamiento de anotaciones en Kotlin. Comparado con kapt (Kotlin Annotation Processing Tool), KSP es m√°s r√°pido, ofrece mejor integraci√≥n con Kotlin y reduce los tiempos de compilaci√≥n de forma significativa. En este post, exploraremos los fundamentos de KSP, discutiremos c√≥mo funciona y mostraremos como su uso en librer√≠as populares como Koin y Room.\nQu√© es KSP? KSP es una API ligera y eficiente para procesar c√≥digo Kotlin. Permite crear procesadores de anotaciones que funcionan directamente con la sintaxis de Kotlin en lugar de depender de herramientas basadas en Java. Esto lo convierte en una opci√≥n ideal para proyectos orientados a Kotlin.\nBeneficios de KSP:  Velocidad: Procesa c√≥digo Kotlin m√°s r√°pido que kapt. Dise√±o centrado en Kotlin: Funciona directamente con los constructos del lenguaje Kotlin, evitando abstracciones basadas en Java. Ligero: Reduce el c√≥digo repetitivo y se integra perfectamente con Gradle. Compatibilidad: Muchas bibliotecas populares ahora son compatibles con KSP de manera nativa.  Setting Up KSP in Your Project Agrega el plugin de KSP a tu proyecto\nConfiguraci√≥n de Gradle 1 2 3 4 5 6 7 8 9 10 11 12 13  plugins { kotlin(\u0026#34;jvm\u0026#34;) version \u0026#34;\u0026lt;latest-kotlin-version\u0026gt;\u0026#34; id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;\u0026lt;latest-ksp-version\u0026gt;\u0026#34; } repositories { mavenCentral() } dependencies { implementation(kotlin(\u0026#34;stdlib\u0026#34;)) ksp(\u0026#34;\u0026lt;ksp-processor-library\u0026gt;\u0026#34;) }   Reemplaza \u0026lt;ksp-processor-library\u0026gt; con la dependencia del procesador espec√≠fico de la biblioteca, como se muestra en los ejemplos a continuaci√≥n.\nEjemplo 1: KSP con las anotaciones de Koin Koin desde la versi√≥n 3.4.0, permite definir dependencias a trav√©s de anotaciones, que luego son procesadas usando KSP para generar los m√≥dulos de Koin.\nConfiguraci√≥n de Koin con KSP A√±ade las siguientes dependencias:\n1 2 3 4 5  dependencies { implementation(\u0026#34;io.insert-koin:koin-core:\u0026lt;version\u0026gt;\u0026#34;) implementation(\u0026#34;io.insert-koin:koin-annotations:\u0026lt;version\u0026gt;\u0026#34;) ksp(\u0026#34;io.insert-koin:koin-ksp-compiler:\u0026lt;version\u0026gt;\u0026#34;) }   Anota las clases Usa las anotaciones de Koin para definir tu grafo de dependencias:\n1 2 3 4 5 6 7 8 9  @Module @ComponentScan class AppModule @Single class UserRepository @Factory class UserUseCase(private val userRepository: UserRepository)   M√≥dulo generado El procesador de KSP genera autom√°ticamente un m√≥dulo de Koin. Puedes incluirlo en la configuraci√≥n de tu aplicaci√≥n:\n1 2 3 4 5  fun main() { startKoin { modules(AppModuleModule().module) } }   Esto elimina la necesidad de escribir manualmente el m√≥dulo de Koin, ahorrando tiempo y reduciendo el c√≥digo repetitivo.\nExample 2: KSP con base de datos Room Room es un ORM ampliamente utilizado para Android. Con KSP, Room procesa anotaciones m√°s r√°pidamente, reduciendo significativamente los tiempos de compilaci√≥n\nConfiguraci√≥n de Room con KSP Agrega las siguientes dependencias:\n1 2 3 4  dependencies { implementation(\u0026#34;androidx.room:room-runtime:\u0026lt;version\u0026gt;\u0026#34;) ksp(\u0026#34;androidx.room:room-compiler:\u0026lt;version\u0026gt;\u0026#34;) }   Anota las entidades 1 2 3 4 5  @Entity data class User( @PrimaryKey val id: Int, val name: String )   Generar DAO y Base de Datos 1 2 3 4 5 6 7 8 9 10  @Dao interface UserDao { @Query(\u0026#34;SELECT * FROM User\u0026#34;) fun getAllUsers(): List\u0026lt;User\u0026gt; } @Database(entities = [User::class], version = 1) abstract class AppDatabase : RoomDatabase() { abstract fun userDao(): UserDao }   Usando KSP, Room genera el c√≥digo necesario de forma autom√°tica, reduciendo el c√≥digo repetitivo.\nComo crear un procesador KSP personalizado Construyamos un procesador KSP personalizado que genere una clase Builder para clases de datos anotadas con @GenerateBuilder.\nCrear el m√≥dulo Primero, debes crear un m√≥dulo con la API para KSP.\n1 2 3  dependencies { implementation(\u0026#34;com.google.devtools.ksp:symbol-processing-api:\u0026lt;version\u0026gt;\u0026#34;) }   Definir la anotaci√≥n 1 2 3  @Target(AnnotationTarget.CLASS) @Retention(AnnotationRetention.SOURCE) annotation class GenerateBuilder   L√≥gica del procesador KSP El procesador puede generar din√°micamente una clase Builder basada en las propiedades de la data class con la anotaci√≥n. Necesitas crear una clase que extienda SymbolProcessor donde todo el trabajo se realizar√° en la funci√≥n process, y una clase extendiendo SymbolProcessorProvider, que proveer√° de la implementaci√≥n del SymbolProcessor.\nAqu√≠ la implementaci√≥n de SymbolProcessor:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  class KspBuilderProcessor( private val codeGenerator: CodeGenerator ) : SymbolProcessor { override fun process(resolver: Resolver): List\u0026lt;KSAnnotated\u0026gt; { val symbols = resolver.getSymbolsWithAnnotation(GenerateBuilder::class.qualifiedName.toString()) .filterIsInstance\u0026lt;KSClassDeclaration\u0026gt;() symbols.forEach { symbol -\u0026gt; val className = symbol.simpleName.asString() val packageName = symbol.packageName.asString() val generatedClassName = \u0026#34;${className}Builder\u0026#34; val file = codeGenerator.createNewFile( dependencies = Dependencies(false, symbol.containingFile!!), packageName = packageName, fileName = generatedClassName ) val properties = symbol.getAllProperties() val builderProperties = mutableListOf\u0026lt;String\u0026gt;() val setters = mutableListOf\u0026lt;String\u0026gt;() val buildMethodParams = mutableListOf\u0026lt;String\u0026gt;() properties.forEach { property -\u0026gt; val propName = property.simpleName.asString() val propType = property.type.resolve().declaration.simpleName.asString() .let { if (property.type.resolve().isMarkedNullable) \u0026#34;$it?\u0026#34; else it } val defaultValue = getDefaultValueFromProperty(property) builderProperties.add(\u0026#34; private var $propName: $propType= $defaultValue\u0026#34;) setters.add(\u0026#34; fun set${propName.replaceFirstChar { it.uppercase() }}($propName: $propType) = apply { this.$propName= $propName}\u0026#34;) buildMethodParams.add(\u0026#34; $propName= this.$propName\u0026#34;) } val builderClass = buildString { appendLine(\u0026#34;package $packageName\u0026#34;) appendLine() appendLine(\u0026#34;class $generatedClassName{\u0026#34;) builderProperties.forEach { property -\u0026gt; appendLine(property) } appendLine() setters.forEach { setter -\u0026gt; appendLine(setter) } appendLine() appendLine(\u0026#34; fun build(): $className{\u0026#34;) appendLine(\u0026#34; return $className(\u0026#34;) buildMethodParams.forEach { methodParam -\u0026gt; appendLine(methodParam) } appendLine(\u0026#34; )\u0026#34;) appendLine(\u0026#34; }\u0026#34;) appendLine(\u0026#34;}\u0026#34;) appendLine() appendLine(\u0026#34;fun ${generatedClassName.replaceFirstChar { it.lowercase() }}(block: $generatedClassName.() -\u0026gt; Unit): $className{\u0026#34;) appendLine(\u0026#34; return $generatedClassName().apply(block).build()\u0026#34;) appendLine(\u0026#34;}\u0026#34;) } file.write(builderClass.toByteArray()) file.close() } return symbols.filterNot { it.validate() }.toList() } private fun getDefaultValueFromProperty(property: KSPropertyDeclaration): String { val propType = property.type.resolve().declaration.qualifiedName?.asString() ?: \u0026#34;Any\u0026#34; val isNullable = property.type.resolve().isMarkedNullable return if (isNullable) \u0026#34;null\u0026#34; else when (propType) { \u0026#34;kotlin.String\u0026#34; -\u0026gt; \u0026#34;\\\u0026#34;\\\u0026#34;\u0026#34; \u0026#34;kotlin.Int\u0026#34;, \u0026#34;kotlin.Long\u0026#34;, \u0026#34;kotlin.Short\u0026#34;, \u0026#34;kotlin.Byte\u0026#34; -\u0026gt; \u0026#34;0\u0026#34; \u0026#34;kotlin.Double\u0026#34;, \u0026#34;kotlin.Float\u0026#34; -\u0026gt; \u0026#34;0.0\u0026#34; \u0026#34;kotlin.Boolean\u0026#34; -\u0026gt; \u0026#34;false\u0026#34; else -\u0026gt; throw IllegalArgumentException(\u0026#34;Non-nullable type $propTyperequires a default value\u0026#34;) } } }   Y aqu√≠ la clase que extiende de SymbolProcessorProvider:\n1 2 3 4 5  class KspBuilderProvider : SymbolProcessorProvider { override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor { return KspBuilderProcessor(environment.codeGenerator) } }   Con estas dos clases ya solo falta crear un fichero con ruta src/main/resources/META-INF/services y nombre com.google.devtools.ksp.processing.SymbolProcessorProvider. Su contenido ser√° el nombre completo de la clase que extiende de SymbolProcessorProvider que acabas de crear. En este caso quedar√≠a as√≠:\ncom.example.kspbuilder.KspBuilderProvider Usando el procesador KSP personalizado Agregar el procesador personalizado A√±ade el plugin KSP al fichero build.gradle.kts en el m√≥dulo donde quieres utilizar la anotaci√≥n:\n1 2 3 4 5 6 7 8  plugins { id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;\u0026lt;version\u0026gt;\u0026#34; } dependencies { implementation(project(\u0026#34;:KspBuilder\u0026#34;)) ksp(project(\u0026#34;:KspBuilder\u0026#34;)) }   Anotar la clase Crea una data class con la anotaci√≥n:\n1 2 3 4 5  @GenerateBuilder class Person(val id: Int, val name: String, val age: Int, val address: Address?) @GenerateBuilder class Address(val id: Int, val name: String, val country: String)   C√≥digo generado Despu√©s de compilar el proyecto, el c√≥digo generado con KSP se localiza en el directorio build/generated/ksp.\nPara la data class Person, la clase builder generada se ve as√≠:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class PersonBuilder { private var id: Int = 0 private var name: String = \u0026#34;\u0026#34; private var age: Int = 0 private var address: Address? = null fun setId(id: Int) = apply { this.id = id } fun setName(name: String) = apply { this.name = name } fun setAge(age: Int) = apply { this.age = age } fun setAddress(address: Address?) = apply { this.address = address } fun build(): Person { return Person( id = this.id, name = this.name, age = this.age, address = this.address ) } } fun personBuilder(block: PersonBuilder.() -\u0026gt; Unit): Person { return PersonBuilder().apply(block).build() }   Para la data class Address, la clase builder generada ser√≠a as√≠:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class AddressBuilder { private var id: Int = 0 private var name: String = \u0026#34;\u0026#34; private var country: String = \u0026#34;\u0026#34; fun setId(id: Int) = apply { this.id = id } fun setName(name: String) = apply { this.name = name } fun setCountry(country: String) = apply { this.country = country } fun build(): Address { return Address( id = this.id, name = this.name, country = this.country ) } } fun addressBuilder(block: AddressBuilder.() -\u0026gt; Unit): Address { return AddressBuilder().apply(block).build() }   Ejemplo de uso 1 2 3 4 5 6 7 8 9 10 11 12  val person = personBuilder { setId(10) setName(\u0026#34;Test\u0026#34;) setAge(100) setAddress( addressBuilder { setId(10) setName(\u0026#34;AddressTest\u0026#34;) setCountry(\u0026#34;Spain\u0026#34;) } ) }   Conclusi√≥n KSp es una herramienta muy importante para los desarrolladores Kotlin. Su dise√±o ligero y centrado en Kotlin hace que sea un reemplazo perfecto de kapt, su habilidad para generar c√≥digo din√°micamente abre un gran abanico de posibilidades. Tanto si usas KSP con librer√≠as como Koin y Room o creas tu propio procesador para tu caso de uso, KSP brinda las herramientas necesarias para elevar tu desarrollo al siguiente nivel.\nIntenta integrar KSP en tu pr√≥ximo proyecto y observa los beneficios de primera mano!\nAqu√≠ dejo el repositorio con el c√≥digo utilizado para crear el procesador KSP personalizado Github Repo\n","description":"Kotlin Avanzado - Kotlin Symbol Processing (KSP)","id":21,"section":"es","tags":["kotlin","android","advanced"],"title":"Explorando Kotlin KSP","uri":"https://carrion.dev/ko/es/posts/kotlin-ksp/"},{"content":"Explorando las funciones Infix en Kotlin Kotlin, es un lenguaje de programaci√≥n moderno con funcionalidades que permiten escribir un c√≥digo m√°s expresivo y conciso. Una de estas funcionalidades son las infix functions, que permiten escribir c√≥digo m√°s limpio y legible. En este post, exploraremos que son las funciones infix, como usarlas y algunos ejemplo pr√°cticos.\nQu√© son las funciones Infix? Las funciones infix en Kotlin son un tipo especial de funci√≥n que pueden ser llamadas sin el uso de par√©ntesis o el punto. Esto puede hacer que ciertos patrones de c√≥digo se lean de forma m√°s natural, asemej√°ndose a la sintaxis tradicional relacionada con matem√°ticas o DSL.\nEste ser√≠a un ejemplo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Point(val x: Int, val y: Int) { infix fun moveBy(offset: Point): Point { return Point(this.x + offset.x, this.y + offset.y) } } fun main() { val point1 = Point(2, 3) val offset = Point(1, 1) // Using the infix notation  val newPoint = point1 moveBy offset println(\u0026#34;New Point: (\\${newPoint.x}, \\${newPoint.y})\u0026#34;) }   En este ejemplo, la funci√≥n moveBy se llama usando la notaci√≥n infix, mejorando la legibilidad.\nReglas y sintaxis Aqu√≠ estan unos puntos clave acerca de las funciones infix:\n Solo un par√°metro: La funci√≥n debe recibir ex√°ctamente un par√°metro. Miembros de clase o funciones de extensi√≥n: Debe estar definida como una funci√≥n de clase o una funci√≥n de extensi√≥n. No Varargs or argumentos por defecto: El par√°metro no puede tener valores por defecto o ser un vararg.  Ejemplo con una funci√≥n de extensi√≥n:\n1 2 3 4 5 6 7 8  infix fun String.concatWith(other: String): String { return this + other } fun main() { val result = \u0026#34;Hello\u0026#34; concatWith \u0026#34; World\u0026#34; println(result) // Outputs: Hello World }   Casos de uso pr√°cticos Las funciones infix son comunmente utilizadas en Kotlin para hacer el c√≥digo m√°s conciso y legible. Brillan en escenarios donde las operaciones intuitivas son necesarias, como cuando se trabaja con colecciones, rangos o expresiones de frameworks de testing o de inyecci√≥n de dependencias. Abajo de estas l√≠neas hay algunos ejemplos de como las funciones infix pueden simplificar el c√≥digo que escribimos diariamente:\n  Mapeando claves con valores: La funci√≥n to en la librer√≠a estandar de Kotlin es una funci√≥n infix que ayuda a crear pares, normalmente se usan en los mapas.\n1 2 3 4  fun main() { val map = mapOf(\u0026#34;key1\u0026#34; to \u0026#34;value1\u0026#34;, \u0026#34;key2\u0026#34; to 42) println(map) // Outputs: {key1=value1, key2=42} }     Definiendo rangos: La funci√≥n until es una funci√≥n infix que se usa para definir rangos donde se excluye el l√≠mite superior.\n1 2 3 4 5  fun main() { for (i in 1 until 5) { println(i) // Outputs: 1, 2, 3, 4  } }     Definiendo el comportamiento de mocks: Librer√≠as tales como MockK usan funciones infix para crear configuraciones de test m√°s expresivas y legibles.\n1 2 3 4 5 6 7 8 9 10  class Calculator { fun add(a: Int, b: Int): Int = a + b } fun test() { val calculator = mockk\u0026lt;Calculator\u0026gt;() every { calculator.add(1, 2) } returns 3 println(calculator.add(1, 2)) // Outputs: 3 }     Inyecci√≥n de dependencias con Koin: Koin, un framework de inyecci√≥n de dependencias para Kotlin, usa la funci√≥n infix bind para definir las relaciones entre clases e interfaces de una manera m√°s legible y limpia.\n1 2 3 4 5 6  interface MyInterface class MyImplementation : MyInterface val appModule = module { single { MyImplementation() } bind MyInterface::class }   La funci√≥n infix bind mejora la legibilidad cuando declaras que implementaci√≥n espec√≠fica debe usarse para inyectar una interfaz.\n  Cuando usar funciones Infix Mientras las funciones infix pueden hacer el c√≥digo m√°s limpio, deben usarse con cuidado:\n La operaci√≥n es intuitiva y f√°cilmente entendible. Cuando mejoran la legibilidad y el flujo. Encajan naturalmente dentro del DSL.  Evitar las funciones infix en los siguientes casos:\n Puede llevar a una sintaxis ambigua y confusa. El prop√≥sito de la funci√≥n no est√° claro con el nombre o uso.  Conclusi√≥n Las funciones infix de Kotlin son una herramienta poderosa para crear c√≥digo m√°s expresivo y legible. Definiendo un DSL, simplificando operaciones matem√°ticas, o mejorando expresiones l√≥gicas, las funciones infix pueden hacer tu c√≥digo m√°s eleganto. De todas formas, al igual que con cualquier otra funcionalidad, debe ser usadas con cuidado para mantener la claridad del c√≥digo y evitar sobrecomplicaciones.\nIntenta incorporar funciones infix en tu pr√≥ximo proyecto de Kotlin y f√≠jate como transforma tu c√≥digo! ¬øCuales son tus funciones infix favoritas o que formas creativas tienes de usarlas?\n","description":"Kotlin avanzado - Funciones Infix","id":22,"section":"es","tags":["kotlin","android","advanced"],"title":"Funciones Infix en Kotlin","uri":"https://carrion.dev/ko/es/posts/kotlin-infix/"},{"content":"‚ú® Entendiendo los Kotlin Delegates: La magia detr√°s de c√≥digo m√°s limpio ‚ú® Los Kotlin delegates son una funcionalidad muy √∫til que te permite delegar el comportamiento de una propiedad o incluso una implementaci√≥n de una interfaz a otro objecto. En lugar de escribir l√≥gica repetitiva o manejar el estado directamente, puedes delegar esta responsabilidad a clases especializadas y reusables.\nComo funcionan los Delegates Delegates en Kotlin funcionan usando la palabra reservada by, que redirecciona el comportamiento de una propiedad o interfaz al objeto delegado. Para propiedades, el objeto delegado provee una implementaci√≥n personalizada de los m√©todos get y o set. Para la delegaci√≥n de interfaces, la implementaci√≥n de esa interfaz es delegada al objecto.\nEsto es un ejemplo de una propiedad delegada:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class StringDelegate { private var value: String = \u0026#34;\u0026#34; operator fun getValue(thisRef: Any?, property: kotlin.reflect.KProperty\u0026lt;*\u0026gt;): String { println(\u0026#34;Getting value for \\${property.name}\u0026#34;) return value } operator fun setValue(thisRef: Any?, property: kotlin.reflect.KProperty\u0026lt;*\u0026gt;, newValue: String) { println(\u0026#34;Setting value for \\${property.name} to \\$newValue\u0026#34;) value = newValue } } class Example { var text: String by StringDelegate() } fun main() { val example = Example() example.text = \u0026#34;Hello, Kotlin!\u0026#34; println(example.text) }   Output Setting value for text to Hello, Kotlin! Getting value for text Hello, Kotlin! En este ejemplo:\n La clase StringDelegate define un comportamiento personalizado del acceso a la propiedad usando los operadores getValuey setValue. La propiedad text en la clase Exampledelega su comportamiento a la instancia de StringDelegate.  Aplicaciones reales de Kotlin Delegates 1Ô∏è‚É£ Inyecci√≥n de dependencias con Koin En #Koin, puedes usar el delegado by inject() para inyectar dependencias directamente en tus clases. Esto elimina la necesidad de instanciar manualmente:\n1 2 3 4 5 6 7 8 9 10  class DelegatesFragment : Fragment() { private val tracker: AnalyticsTracker by inject() } inline fun \u0026lt;reified T : Any\u0026gt; KoinComponent.inject( qualifier: Qualifier? = null, mode: LazyThreadSafetyMode = KoinPlatformTools.defaultLazyMode(), noinline parameters: ParametersDefinition? = null, ): Lazy\u0026lt;T\u0026gt; = lazy(mode) { get\u0026lt;T\u0026gt;(qualifier, parameters) }   El delegado by inject() autom√°ticamente resuelve la dependencia usando el contenedor de Koin. Esto abstrae la l√≥gica, resultando en c√≥digo m√°s limpio y testeable.\n2Ô∏è‚É£ Manejo de estados en Jetpack Compose En Jetpack Compose, la funci√≥n remember junto con mutableStateOf es un gran ejemplo de delegaci√≥n. Esto ayuda a manejar el estado de forma eficiente dentro de los composables:\n1 2 3 4 5 6 7 8 9 10 11  @Composable fun Counter() { var count by remember { mutableStateOf(0) } Column { Text(\u0026#34;Count: $count\u0026#34;) Button(onClick = { count++ }) { Text(\u0026#34;Increment\u0026#34;) } } }   3Ô∏è‚É£ Inicializaci√≥n Lazy El delegado lazy es perfecto para propiedades que necesitan ser inicializadas solo cuando se acceden por primera vez:\n1 2 3 4 5 6 7 8 9  val greeting: String by lazy { println(\u0026#34;Initializing...\u0026#34;) \u0026#34;Hello, Kotlin!\u0026#34; } fun main() { println(greeting) // Initializes here  println(greeting) // Uses cached value }   Output Initializing... Hello, Kotlin! Hello, Kotlin! 4Ô∏è‚É£ Delegaci√≥n de interfaces Kotlin permite delegar la implementaci√≥n de una interfaz a otro objeto.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  interface Logger { fun log(message: String) } class ConsoleLogger : Logger { override fun log(message: String) { println(\u0026#34;Log: $message\u0026#34;) } } class FileLogger : Logger { override fun log(message: String) { println(\u0026#34;Writing log to file: $message\u0026#34;) } } class Application(logger: Logger) : Logger by logger fun main() { val consoleApp = Application(ConsoleLogger()) consoleApp.log(\u0026#34;Starting console application\u0026#34;) val fileApp = Application(FileLogger()) fileApp.log(\u0026#34;Starting file application\u0026#34;) }   Output Log: Starting console application Writing log to file: Starting file application Esto es lo que est√° pasando:\n La clase Application no tiene que implementar los m√©todos Logger de forma directa. En su lugar, delega la implementaci√≥n de Logger al objeto pasado por constructor usando by. Esto hace m√°s sencillo cambiar las implementaciones sin necesidad de cambiar la clase Application.  Por qu√© usar Kotlin Delegates? Los Delegates encapsulan la l√≥gica que de otra manera cargar√≠an y desordenar√≠an tus clases. Ayudan a:\n Simplificar el c√≥digo al reutilizar l√≥gica, por ejemplo con la inicializaci√≥n lazy. Abstraen patrones repetitivos, por ejemplo con la inyecci√≥n de dependencias con #koin. Mejoran el manejo de los estados con la funci√≥n mutableStateOf de Compose. Provee implementaciones modulares y reutilizables de interfaces.  Conclusion El mecanismo de los delegados en Kotlin es un ejemplo de como este lenguaje combina simplicidad con funcionalidad. Los delegados est√°n en todas partes en el desarrollo de Kotlin. En qu√© otros casos los utilizas en tus proyectos?\n","description":"Kotlin avanzado - Delegates","id":23,"section":"es","tags":["kotlin","android","advanced"],"title":"Kotlin Delegates","uri":"https://carrion.dev/ko/es/posts/kotlin-delegates/"},{"content":"Kotlin Avanzado - Contracts: C√≥mo volver al compilador de Kotlin m√°s inteligente Kotlin nunca deja de impresionarme con sus funcionalidades. Una funci√≥n avanzada pero poco utilizada en el arsenal de Kotlin son los Contracts. Los contratos te permiten guiar al compilador de Kotlin para que tome mejores decisiones acerca de tu c√≥digo, resultando en mejor seguridad ante nulos, mejor rendimiento o incluso menores errores en tiempo de ejecuci√≥n.\nQu√© son los contratos de Kotlin? Los contratos de Kotlin te permiten definir reglas acerca de como se comporta tu c√≥digo, ayudando al compilador a hacer un an√°lisis est√°tico m√°s avanzado. Los contratos habilitan funcionalidades como smart-casts y comprobaciones teniendo en cuenta el contexto, superando las capacidades b√°sicas de Kotlin.\nPor qu√© usar contratos?  Mejora la seguridad ante nulos: Elimina las comprobaciones de nulos redundantes ayudando al compilador a saber cuando algo est√° garantizado que no sea nulo. Smart-casts optimizados: Hace que el compilador conozca el tipo de las variables en casos espec√≠ficos. Reduce la repetic√≥n de c√≥digo: Escribe c√≥digo m√°s limpio e intuitivo delegando las comprobaciones repetitivas al compilador.  Ejemplos de contratos en Kotlin 1. Simplificar las comprobaciones de nuloss Vamos a crear una funci√≥n para validar valores no nulos:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @OptIn(ExperimentalContracts::class) inline fun \u0026lt;T\u0026gt; requireNotNull(value: T?, message: String): T { contract { returns() implies (value != null) } if (value == null) { throw IllegalArgumentException(message) } return value } fun processName(name: String?) { val nonNullName = requireNotNull(name, \u0026#34;Name cannot be null\u0026#34;) // No need for additional null checks; compiler knows \u0026#39;nonNullName\u0026#39; is not null!  println(\u0026#34;Processing name: $nonNullName\u0026#34;) } fun main() { processName(\u0026#34;John\u0026#34;) // Works fine  // processName(null) // Throws an IllegalArgumentException }   C√≥mo los contratos nos ayudan aqu√≠?  La parte del contrato returns() implies (value != null) le dice al compilador:  Si la funci√≥n retorna de forma satisfactoria, entonces value est√° garantizado que no es nulo.\n  Esto habilita smart-casts, de manera que no tienes que volver a comprobar si es nulo manualmente una vez llamada esta funci√≥n.  Algo muy similar se hace en las funciones require y requireNotNull de la librer√≠a estandar de Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  /** * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false. * * @sample samples.misc.Preconditions.failRequireWithLazyMessage */ @kotlin.internal.InlineOnly public inline fun require(value: Boolean, lazyMessage: () -\u0026gt; Any): Unit { contract { returns() implies value } if (!value) { val message = lazyMessage() throw IllegalArgumentException(message.toString()) } } /** * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise * returns the not null value. * * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage */ @kotlin.internal.InlineOnly public inline fun \u0026lt;T : Any\u0026gt; requireNotNull(value: T?, lazyMessage: () -\u0026gt; Any): T { contract { returns() implies (value != null) } if (value == null) { val message = lazyMessage() throw IllegalArgumentException(message.toString()) } else { return value } }   2. Afirmaciones personalizadas Aqu√≠ se ve como los contratos pueden ser usados para definir afirmaciones personalizadas:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @OptIn(ExperimentalContracts::class) fun assertValidState(condition: Boolean, message: String) { contract { returns() implies condition } if (!condition) { throw IllegalStateException(message) } } fun performOperation(state: Boolean) { val state: Any? = \u0026#34;Hello\u0026#34; assertValidState(state is String, \u0026#34;Is String\u0026#34;) // Here the compiler knows that the state val is of type String so no need to other cast checks  println(\u0026#34;String length: ${assertion.length}\u0026#34;) } fun main() { performOperation(true) // Prints success  // performOperation(false) // Throws IllegalStateException }   3. Smart-Casts con condiciones personalizadas Vamos a crear una funcionalidad custom que comprueba si una valor coincide con un tipo espec√≠fico. Esto demostrar√° como los contratos pueden ayudar a mejorar las comprobaciones:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  @OptIn(ExperimentalContracts::class) inline fun \u0026lt;reified T\u0026gt; isOfType(value: Any?): Boolean { contract { returns(true) implies (value is T) } return value is T } fun main() { val input: Any? = \u0026#34;Hello, Kotlin!\u0026#34; if (isOfType\u0026lt;String\u0026gt;(input)) { println(\u0026#34;String length: ${input.length}\u0026#34;) } val inputInt: Any? = 10 if (isOfType\u0026lt;Int\u0026gt;(inputInt)) { println(\u0026#34;The value is an integer ${input.toUInt()}\u0026#34;) } }   Con esta implementaci√≥n, el compilador sabe que dentro del bloque if, input es un String, gracias al contrato definido en isOfType. The la misma manera, el compilador sabe que inputInt es de tipo Int y no hace falta comprobar el tipo de nuevo.\n4. Optimizando el control del flujo Los contratos pueden simplificar el control del flujo habilitando al compilador para entender las invariantes o condiciones. Por ejemplo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  inline fun isNotEmpty(list: List\u0026lt;*\u0026gt;?): Boolean { contract { returns(true) implies (list != null \u0026amp;\u0026amp; list.isNotEmpty()) } return list != null \u0026amp;\u0026amp; list.isNotEmpty() } fun processItems(items: List\u0026lt;String\u0026gt;?) { if (isNotEmpty(items)) { // Compiler knows items is non-null and not empty  println(\u0026#34;Processing ${items.size}items\u0026#34;) } else { println(\u0026#34;No items to process\u0026#34;) } } fun main() { processItems(listOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;)) processItems(null) processItems(emptyList()) }   Salida Processing 3 items No items to process No items to process Cuando usar contratos Los contratos son ideales para:\n Desarrollo de librer√≠as: Proteger APIs p√∫blicas forzando condiciones pre existentes. DSLs y Frameworks: Simplificando la comprobaci√≥n de tipos y validaci√≥n de estados en DSLs de Kotlin. Optimizaciones en tiempo de ejecuci√≥n: Reduce las comprobaciones en tiempo de ejecuci√≥n al permitir al compilador inferir las condiciones en tiempo de compilaci√≥n.  Conclusion Los contratos de Kotlin son una gema oculta que pueden perfeccionar tu c√≥digo mejorando la seguridad, reduciendo la repetici√≥n de c√≥digo, y permitiendo un an√°lisis por parte del compilador m√°s inteligente. Tanto si est√°s creando librer√≠as, escribiendo complejos DSLs, o simplemente optimizando c√≥digo del d√≠a a d√≠a, los contratos proveen una herramienta muy poderosa para guiar al compilador de Kotlin y asegurando un c√≥digo correcto.\nTener en cuenta que los contratos est√°n anotados como funcionalidad experimental pero est√°n implementados en Kotlin desde la versi√≥n 1.3 y se usan extensamente en la librer√≠a estandar de Kotlin as√≠ que son lo suficiente estables como para utilizarlos.\n","description":"Kotlin avanzado - Contracts","id":24,"section":"es","tags":["kotlin","android","advanced"],"title":"Kotlin contracts","uri":"https://carrion.dev/ko/es/posts/kotlin-contracts/"},{"content":"Exportar a Swift en KMP Empezando con la versi√≥n 2.1.0 podemos empezar a probar a exportar a Swift en Kotlin. Esta funcionalidad te permite exportar los m√≥dulos compartidos de Kotlin a Swift sin usar Objective-C. Esto mejorar√° la experiancia de los desarrolladores de iOS cuando usen m√≥dulos de KMP.\nActualmente el soporte b√°sico incluye:\n Exportar m√∫ltiples m√≥dulos de Gradle a swift. Definir los nombres de los m√≥dulos swift. Simplificar la estructura de paquetes.  Activar la funcionalidad Para empezar a probar esta funcionalidad debes activarla en el fichero gradle.properties:\nkotlin.experimental.swift-export.enabled=true Configuraci√≥n Despu√©s de a√±adir la l√≠nea mostrada arriba necesitas a√±adir esta configuraci√≥n al fichero build.gradle.kts:\n1 2 3 4 5 6 7 8 9 10 11  kotlin { iosX64() iosArm64() iosSimulatorArm64() @OptIn(ExperimentalSwiftExportDsl::class) swiftExport { moduleName = \u0026#34;shared\u0026#34; flattenPackage = \u0026#34;dev.carrion.kmpswiftexport\u0026#34; } }   El siguiente paso es configurar xcode para lanzar la nueva tarea embedSwiftExportForXcode en lugar de embedAndSignAppleFrameworkForXcode. Puedes realizar este cambio desde la configuraci√≥n de Build phases de la iosApp desde xcode o bien desde Android Studio modificando el fichero project.pbxproj.\nDebes cambiar esta l√≠nea:\nshellScript = \u0026quot;cd \\\u0026quot;$SRCROOT/..\\\u0026quot;\\n./gradlew :shared:embedAndSignAppleFrameworkForXcode\\n\u0026quot;; Por esta otra:\nshellScript = \u0026quot;cd \\\u0026quot;$SRCROOT/..\\\u0026quot;\\n./gradlew :shared:embedSwiftExportForXcode\\n\u0026quot;; Despu√©s de aplicar estos cambios deber√≠as ser capaz de lanzar la aplicaci√≥n de iOS desde Android Studio o desde xcode sin ning√∫n problema.\nAntes de activar la funcionalidad Si intentas navegar a la definici√≥n de una funci√≥n de Kotlin desde xcode en un archivo swift, se mostrar√° el c√≥digo Objective-C que se exporta del m√≥dulo compartido de Kotlin. Este fichero generado es enorme teniendo en cuenta la complejidad del projecto usado para este ejemplo.\nTe voy a mostrar a continuaci√≥n una peque√±a pieza del archivo de 175 l√≠neas generado desde el c√≥digo de Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;Greeting\u0026#34;))) @interface SharedGreeting : SharedBase - (instancetype)init __attribute__((swift_name(\u0026#34;init()\u0026#34;))) __attribute__((objc_designated_initializer)); + (instancetype)new __attribute__((availability(swift, unavailable, message=\u0026#34;use object initializers instead\u0026#34;))); - (NSString *)greet __attribute__((swift_name(\u0026#34;greet()\u0026#34;))); @end __attribute__((swift_name(\u0026#34;Platform\u0026#34;))) @protocol SharedPlatform @required @property (readonly) NSString *name __attribute__((swift_name(\u0026#34;name\u0026#34;))); @end __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;IOSPlatform\u0026#34;))) @interface SharedIOSPlatform : SharedBase \u0026lt;SharedPlatform\u0026gt; - (instancetype)init __attribute__((swift_name(\u0026#34;init()\u0026#34;))) __attribute__((objc_designated_initializer)); + (instancetype)new __attribute__((availability(swift, unavailable, message=\u0026#34;use object initializers instead\u0026#34;))); @property (readonly) NSString *name __attribute__((swift_name(\u0026#34;name\u0026#34;))); @end __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;Platform_iosKt\u0026#34;))) @interface SharedPlatform_iosKt : SharedBase + (id\u0026lt;SharedPlatform\u0026gt;)getPlatform __attribute__((swift_name(\u0026#34;getPlatform()\u0026#34;))); @end #pragma pop_macro(\u0026#34;_Nullable_result\u0026#34;) #pragma clang diagnostic pop NS_ASSUME_NONNULL_END   After enabling the feature Cuando activas al funcionalidad de exportar a Swift y compilas el proyecto, al intentar navegar a la definici√≥n de una funci√≥n del c√≥digo compartido de Kotlin, xcode te mostrar√° el c√≥digo exportado de Swift.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  @_exported import ExportedKotlinPackages @_implementationOnly import SharedBridge_shared import KotlinRuntime public typealias Greeting = ExportedKotlinPackages.dev.carrion.kmpswiftexport.Greeting public func getPlatform() -\u0026gt; Swift.Never { ExportedKotlinPackages.dev.carrion.kmpswiftexport.getPlatform() } public extension ExportedKotlinPackages.dev.carrion.kmpswiftexport { public final class Greeting : KotlinRuntime.KotlinBase { public override init() { let __kt = dev_carrion_kmpswiftexport_Greeting_init_allocate() super.init(__externalRCRef: __kt) dev_carrion_kmpswiftexport_Greeting_init_initialize__TypesOfArguments__Swift_UInt__(__kt) } public override init( __externalRCRef: Swift.UInt ) { super.init(__externalRCRef: __externalRCRef) } public func greet() -\u0026gt; Swift.String { return dev_carrion_kmpswiftexport_Greeting_greet(self.__externalRCRef()) } } public static func getPlatform() -\u0026gt; Swift.Never { fatalError() } }   El c√≥digo mostrado arriba es el fichero completo con 28 l√≠neas, una gran diferencia con las 175 l√≠neas del c√≥digo exportado en Objective-C. Tambi√©n es importante mencionar la menor complejidad y mayor legibilidad del c√≥digo swift.\nConclusion Despu√©s de probar esta nueva funcionalidad, estoy realmente impresionado con la mejora que supone para el desarrollo de iOS en los proyectos KMP. Tambi√©n me sorprende la diferencia en el c√≥digo exportado en Objective-C y swift. Estoy seguro que esta funcionalidad mejorar√° en las siguientes versiones y acercar√° la experiencia entre el desarrollo nativo y el desarrollo multiplataforma.\nPuedes encontrar el repositorio con el c√≥digo usado en este ejemplo en SwiftExport, con dos ramas, main, con la configuraci√≥n del t√≠pico iOS framework conf, y la rama swift-export con la nueva funcionalidad habilitada.\n","description":"Nueva funcionalidad en Kotlin 2.1.0, exportar directamente a swift desde Kotlin","id":25,"section":"es","tags":["kotlin","android","kmp"],"title":"Exportar a Swift en KMP","uri":"https://carrion.dev/ko/es/posts/swift-export/"},{"content":"Condiciones en las expresiones when en Kotlin 2.1.0 Una de las nuevas funcionalidades de Kotlin 2.1.0 es las condiciones en las expresiones when, lo que tendr√≠a varias ventajas entre las que se incluye:\n Reducir anidaciones Evita c√≥digo repetido Mejorar legibilidad  Activar la funcionalidad en Kotlin 2.1.0 Esta funcionalidad se encuentra en preview lo que es necesario activarla expl√≠citamente para poder usarla en Kotlin 2.1.0. En el fichero build.gradle.kts a√±adiremos el siguiente c√≥digo dentro del bloque de kotlin {}:\n1 2 3 4 5  kotlin { compilerOptions { freeCompilerArgs.add(\u0026#34;-Xwhen-guards\u0026#34;) } }   Uso de condicionales dentro de las ramas de la expresiones when Para este ejemplo usaremos una sealed interface para manejar respuestas de un servicio remoto:\n1 2 3 4 5  sealed interface Response\u0026lt;out T\u0026gt; { data object Loading : Response\u0026lt;Nothing\u0026gt; data class Content \u0026lt;out T\u0026gt; (val data: T?) : Response\u0026lt;T\u0026gt; data class Error(val error: Exception) : Response\u0026lt;Nothing\u0026gt; }   Esta interfaz la implementan Loading, Content y Error para gestionar los distintos estados de una respuesta.\nAntes de la nueva funcionalidad 1 2 3 4 5 6 7 8 9 10 11 12 13  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handleOld() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content -\u0026gt; if (data != null) { println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } is Response.Error -\u0026gt; if (error is IllegalStateException) { println(\u0026#34;Handled error\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } }   Como se puede ver en este caso se repite el c√≥digo que muestra por pantalla Unknown error adem√°s de a√±adir anidaciones que dificultan la lectura del c√≥digo.\nUsando los nuevos condicionales Se debe a√±adir el if justo despu√©s de la condici√≥n primaria de la rama, por ejemplo:\n1 2 3 4 5 6  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled error\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   De esta manera no se repite el c√≥digo que mostraba por pantalla el texto de Unknown error y adem√°s eliminamos las anidaciones facilitando la lectura del c√≥digo.\nEn caso de necesitar comprobar varias condiciones en la rama else se podr√≠a a√±adir una rama else if que controle el flujo de los casos que no cumplen las condiciones anteriores.\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) else if this is Response.Error \u0026amp;\u0026amp; this.error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   Esto √∫ltimo se puede simplificar usando dos ramas con la misma primera condici√≥n de is Response.Error que a mi parecer queda m√°s simple:\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) is Response.Error if error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   Conclusi√≥n Con esta nueva funcionalidad se podr√° a√±adir nuevas condiciones sin tener que repetir c√≥digo y permitir√° que las expresiones when sean m√°s concisas. En la versi√≥n 2.1.0 de Kotlin est√° en modo preview pero se espera que pronto esta nueva funcionalidad sea estable.\nAqu√≠ el enlace a la documentaci√≥n con las novedades de Kotlin 2.1.0 donde se explica la funcionalidad de condicionales en las expresiones when kotlinlang\n","description":"Nueva funcionalidad en Kotlin 2.1.0, condiciones en las expresiones when","id":26,"section":"es","tags":["kotlin","android","kmp"],"title":"Condiciones en las expresiones when para Kotlin 2.1.0.","uri":"https://carrion.dev/ko/es/posts/kotlin-guard-conditions-in-when/"},{"content":"Inyecci√≥n de valores en tiempo de ejecuci√≥n con Dagger-Hilt Desde que apareci√≥ Hilt para facilitar la inyecci√≥n de dependencias en aplicaciones Android, no era posible la inyecci√≥n de dependencias en tiempo de ejecuci√≥n sin utilizar librer√≠as ajenas a Dagger o Hilt. Desde la versi√≥n 2.31 se incorpora en Dagger la anotaci√≥n @AssistedInject. Con esta anotaci√≥n vamos a ser capaces de indicar a Dagger-Hilt que dependencias se tienen que resolver en tiempo de ejecuci√≥n y retrasar la inyecci√≥n de esos par√°metros hasta tener los valores.\nEsto era necesario para poder inyectar valores en los constructores de los ViewModel y poder ejecutar alguna operaci√≥n en el m√©todo init del mismo. Como puede ser una petici√≥n a una API externa o bien una consulta en la base de datos local.\nEn este art√≠culo veremos como implementar el @AssistedInject de Dagger para la inyecci√≥n de valores en tiempo de ejecuci√≥n en ViewModels con Hilt.\nInstalaci√≥n En el fichero build.gradle ra√≠z del proyecto, incluiremos el siguiente classpath:\n1  classpath \u0026#39;com.google.dagger:hilt-android-gradle-plugin:2.31.2-alpha\u0026#39;   Una vez a√±adido el classpath a√±adiremos el plugin de Hilt en el fichero build.gradle del m√≥dulo app.\n1  apply plugin: \u0026#39;dagger.hilt.android.plugin\u0026#39;   Y tambi√©n las siguientes l√≠neas a nuestras dependencias:\n1 2  implementation \u0026#39;com.google.dagger:hilt-android:2.31.2-alpha\u0026#39; kapt \u0026#39;com.google.dagger:hilt-android-compiler:2.31.2-alpha\u0026#39;   Tambi√©n hay que tener en cuenta tener a√±adido en nuestro build.gradle el plugin de kapt. Para ello a√±adiremos lo siguiente a nuestro archivo de build.gradle del m√≥dulo app junto al resto de plugins:\n1  apply plugin: \u0026#39;kotlin-kapt\u0026#39;   Esa son las dependencias necesarias para implementar Hilt en nuestro proyecto. A lo largo de este post se usan distintas librer√≠as como que no se definen en este art√≠culo.\nEn este enlace puedes ver un ejemplo de un archivo build.gradle completo: app/build.gradle\nImplementaci√≥n Para este ejemplo usaremos una clase repositorio encargada de recibir el nombre de usuario y devolver un mensaje de bienvenida. Para ello crearemos la siguiente interfaz:\n1 2 3  interface UserRepository { fun getMessage(name: String): String }   Y su implementaci√≥n:\n1 2 3 4 5  class UserRepositoryImpl @Inject constructor() : UserRepository { override fun getMessage(name: String): String { return \u0026#34;Hi $name\u0026#34; } }   Anotamos el constructor con @Inject para posteriormente poder declarar un @Binds en el m√≥dulo de Hilt e inyectar la implementaci√≥n cada vez que se pida una interfaz del tipo UserRepository.\nVamos a crear el siguiente ViewModel que ser√° el encargado de recibir el nombre del usuario desde el Activity o Fragment y llamar al repositorio para recibir el mensaje de bienvenida:\n1 2 3 4 5 6 7 8 9  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { ... }   En este ViewModel podemos ver como se anota el constructor con @AssistedInject para indicar a Dagger-Hilt que esta clase contiene dependencias que se deben inyectar en tiempo de ejecuci√≥n. Esas dependencias est√°n anotadas con @Assisted.\nPara poder crear el ViewModel con la extensi√≥n by viewModels() de la librer√≠a de AndroidX debemos crear la Factory que m√°s tarde pasaremos a la extensi√≥n:\n1 2 3 4 5 6 7 8  class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } }   Como puedes ver necesitamos la interfaz UserViewModelAssistedFactory que es la encargada de proveer los par√°metros en tiempo de ejecuci√≥n. Esta interfaz la implementamos de la siguiente forma:\n1 2 3 4 5 6  @AssistedFactory interface UserViewModelAssistedFactory { fun create(name: String): UserViewModel }   Se trata de una interfaz con una funci√≥n create que recibe los par√°metros a inyectar en tiempo de ejecuci√≥n. En nuestro caso solo necesitamos el name, pero en caso de necesitar inyectar m√°s par√°metros en tiempo de ejecuci√≥n, se pasar√≠an como par√°metro a esta funci√≥n.\nCon esto ya podemos completar nuestro ViewModel con la l√≥gica necesaria para pedir la respuesta al repositorio y exponer al Fragment o Activity a trav√©s de un StateFlow.\nEl ViewModel completo quedar√≠a:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } } private val _message: MutableStateFlow\u0026lt;String\u0026gt; = MutableStateFlow(\u0026#34;\u0026#34;) val message: StateFlow\u0026lt;String\u0026gt; get() = _message init { viewModelScope.launch(dispatcher) { _message.emit(repository.getMessage(name)) } } }   Relativo a Hilt solo nos faltar√≠a declarar el m√≥dulo indicando como proveer las dependencias. Para este ejemplo usaremos el siguiente m√≥dulo:\n1 2 3 4 5 6 7 8 9 10 11 12 13  @Module @InstallIn(ActivityComponent::class) abstract class MainModule { companion object { @Provides @Named(\u0026#34;UserDispatcher\u0026#34;) fun provideUserDispatcher(): CoroutineDispatcher = Dispatchers.IO } @Binds abstract fun provideUserRepository(repositoryImpl: UserRepositoryImpl): UserRepository }   En este m√≥dulo declaramos un Dispatcher para que sea m√°s sencillo testear este ViewModel en un futuro. Y hacemos @Binds de nuestra interfaz UserRepository con su implementaci√≥n UserRepositoryImpl.\nAhora podemos inyectar nuestro repositorio en una Activity o Fragment de la siguiente forma:\n1 2 3 4 5 6 7 8  private val navArgs: UserFragmentArgs by navArgs() @Inject lateinit var assistedFactory: UserViewModelAssistedFactory private val userViewModel: UserViewModel by viewModels { UserViewModel.Factory(assistedFactory, navArgs.name) }   Simplemente nos faltar√≠a observar los cambios en el StateFlow del ViewModel para poder actualizar nuestra UI. Eso se har√≠a de la siguiente manera en un Fragment aunque ser√≠a muy similar en un Activity\n1 2 3 4 5 6 7 8  override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycleScope.launchWhenStarted { userViewModel.message.collect { binding.name.text = it } } }    Recordar que es necesario anotar una clase que extienda de Application con @HiltAndroidApp y cada uno de las Activities o Fragments que usen inyecci√≥n con Hilt con la anotaci√≥n @AndroidEntryPoint.\n Conclusi√≥n Como hemos podido observar con @AssistedInject de Dagger podemos inyectar valores en tiempo de ejecuci√≥n de una forma sencilla y podemos seguir utilizando los navArgs de AndroidX.\nEn el siguiente repositorio teneis el ejemplo completo: HiltAssistedInject\n","description":"Como inyectar valores en tiempo de ejecuci√≥n a los ViewModel en Android.","id":27,"section":"es","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Hilt: Inyectar valores al ViewModel en tiempo de ejecuci√≥n.","uri":"https://carrion.dev/ko/es/posts/hilt-inject-parameters-runtime/"},{"content":"Bienvenido a Carrion.dev Saludos Androide!!\nBienvenido a mi nuevo blog de Kotlin y programaci√≥n Android. Me llamo Ignacio Carri√≥n y soy dessarrollador Android. Me encanta el lenguaje Kotlin por las facilidades que me aporta al programar para Android y las infinitas posibilidades que ofrece en otros √°mbitos (backend, web, nativo, multiplataforma).\nEn este blog espero poder publicar cosas interesantes acerca del lenguaje Kotlin y el ecosistema Android al menos cada dos semanas. Si quieres mantenerte al d√≠a no dudes en apuntarte a nuestra newsletter.\nSi tienes alguna duda, idea acerca de la que podemos hablar en un post o simplemente quieres contactar estoy disponible a trav√©s del correo: ignacio@carrion.dev.\nEspero que aprendamos mucho todos juntos!!\n","description":"Primer post en mi nuevo blog de Kotlin y Android.","id":28,"section":"es","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Bienvenido a mi nuevo blog sobre Kotlin y desarrollo Android","uri":"https://carrion.dev/ko/es/posts/welcome-to-my-new-kotlin-and-android-development-blog/"},{"content":"Sobre mi. Me llamo Ignacio Carri√≥n, vivo en Valencia (Espa√±a) y el que aparece en la foto es mi perro Wilfred. Me gusta cualquier cosa relacionada con la inform√°tica y los videojuegos. Actualmente trabajo como Senior Android Engineer para Tkww. Anteriormente he trabajado en otras empresas como desarrollador Android y tambi√©n he impartido clases de programaci√≥n. A raiz de mi trabajo como profesor me d√≠ cuenta de que realmente me encanta aprender y que la gente aprenda conmigo. De esa motivaci√≥n surge la idea de crear este blog, Carrion.dev.\nEspero poder ir publicando de forma as√≠dua cosas interesantes acerca del lenguaje Kotlin y el ecosistema Android. Cualquier cr√≠tica constructiva e ideas acerca de posibles temas para art√≠culos ser√°n bien recibidas. Abajo aparecen los enlaces a las redes sociales en las que podr√°s encontrarme y contactar conmigo.\nContactar Portfolio\nGithub\n","description":"Ignacio Carri√≥n, Desarrollador Android","id":33,"section":"es","tags":null,"title":"Sobre mi","uri":"https://carrion.dev/ko/es/about/"}]