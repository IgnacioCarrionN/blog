<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>Posts on Carrion.dev</title><link>https://carrion.dev/es/posts/</link><description>Recent content in Posts on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>es</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Tue, 01 Apr 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/es/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Gestión Avanzada de Estado en Compose: Effects y Flows</title><link>https://carrion.dev/es/posts/advanced-state-management-compose/</link><pubDate>Tue, 01 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 01 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/advanced-state-management-compose/</guid><description>Gestión Avanzada de Estado en Compose: Effects y Flows Este artículo explora patrones avanzados de gestión de estado en Jetpack Compose, centrándose en Effects e integración de Flows. Para conceptos fundamentales como mutableStateOf y state hoisting, consulta nuestro artículo complementario Gestión Básica de Estado en Jetpack Compose.
Entendiendo los Effects en Compose Los Effects en Compose son herramientas para manejar efectos secundarios y eventos del ciclo de vida de manera compatible con los composables.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/state-management-compose-advanced.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>state</category><category>flows</category><category>effects</category></item><item><title>Patrones de Gestión de Estado en Jetpack Compose</title><link>https://carrion.dev/es/posts/state-management-patterns-compose/</link><pubDate>Fri, 28 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 28 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/state-management-patterns-compose/</guid><description>Patrones de Gestión de Estado en Jetpack Compose La gestión del estado es un aspecto crucial en el desarrollo de aplicaciones robustas y mantenibles con Jetpack Compose. Este artículo explora patrones esenciales y mejores prácticas para gestionar el estado de manera efectiva en tu UI con Compose, incluyendo estado inmutable, actualizaciones basadas en eventos y estrategias de pruebas.
Entendiendo los Patrones de Gestión de Estado La gestión efectiva del estado en Compose requiere entender cómo estructurar y manejar los cambios de estado de una manera mantenible, testeable y escalable.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/state-management-compose.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>patrones</category><category>estado</category><category>pruebas</category></item><item><title>Construyendo DSLs Tipados con Kotlin: De lo Básico a Patrones Avanzados</title><link>https://carrion.dev/es/posts/building-type-safe-dsls/</link><pubDate>Tue, 25 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 25 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/building-type-safe-dsls/</guid><description>Construyendo DSLs Tipados con Kotlin: De lo Básico a Patrones Avanzados Los Lenguajes de Dominio Específico (DSLs) en Kotlin te permiten crear APIs expresivas, legibles y tipadas. Este artículo explora cómo construir DSLs efectivos usando las potentes características de Kotlin, centrándose en el control de ámbito con @DslMarker para prevenir errores comunes en DSLs anidados.
Al final de este artículo, entenderás:
Cómo diseñar APIs de DSL limpias e intuitivas Cuándo y cómo usar @DslMarker para un mejor control de ámbito Mejores prácticas para mantener el tipado seguro en tu DSL Errores comunes y cómo evitarlos Conceptos Básicos de DSL Exploremos los conceptos fundamentales de los DSLs en Kotlin construyendo un simple constructor de HTML:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/type-safe-dsls.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>dsl</category><category>type-safety</category><category>design-patterns</category></item><item><title>Características Avanzadas de Genéricos y Varianza en Kotlin: Una Guía Completa</title><link>https://carrion.dev/es/posts/advanced-kotlin-generics/</link><pubDate>Fri, 21 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 21 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/advanced-kotlin-generics/</guid><description>Características Avanzadas de Genéricos y Varianza en Kotlin: Una Guía Completa Entender los genéricos avanzados y la varianza en Kotlin es crucial para escribir código reutilizable y seguro en cuanto a tipos. Este artículo explora estos conceptos en profundidad, proporcionando ejemplos prácticos y aplicaciones del mundo real.
Entendiendo la Varianza La varianza en Kotlin determina cómo se relacionan los tipos genéricos con diferentes argumentos de tipo. Entender la varianza es más fácil cuando pensamos en términos de productores y consumidores:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/advanced-generics.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>generics</category><category>variance</category><category>type-safety</category></item><item><title>Patrones de Composición de Flows: Combinando Múltiples Flows de Manera Efectiva</title><link>https://carrion.dev/es/posts/flow-composition-patterns/</link><pubDate>Tue, 18 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 18 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/flow-composition-patterns/</guid><description>Patrones de Composición de Flows: Combinando Múltiples Flows de Manera Efectiva Cuando trabajamos con Kotlin Flows en aplicaciones del mundo real, a menudo necesitamos combinar múltiples flujos de datos para crear flujos de trabajo más complejos. Este artículo explora varios patrones de composición de Flows y las mejores prácticas para combinar múltiples Flows de manera efectiva.
Entendiendo la Composición de Flows La composición de Flows es el proceso de combinar múltiples Flows para crear un nuevo Flow que representa un flujo de datos más complejo.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/flow-composition.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>coroutines</category><category>flows</category><category>patterns</category></item><item><title>Entendiendo los Operadores de Flujo (Flow): Buffer, Conflate, Debounce y Sample</title><link>https://carrion.dev/es/posts/flow-operators-buffer-conflate/</link><pubDate>Fri, 14 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 14 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/flow-operators-buffer-conflate/</guid><description>Entendiendo los Operadores de Flujo (Flow): Buffer, Conflate, Debounce y Sample Cuando trabajamos con flujos de Kotlin (Flows), especialmente en escenarios que involucran productores que emiten rápidamente y colectores lentos, es crucial entender cómo gestionar el flujo de datos de manera efectiva. Este post explora cuatro operadores esenciales de Flow que ayudan a manejar estos escenarios: buffer, conflate, debounce y sample.
El Problema: Colectores Lentos Antes de profundizar en los operadores, entendamos el problema que resuelven.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev//images/kotlin/flow-operators.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>flows</category><category>coroutines</category></item><item><title>Convirtiendo Callbacks a Corrutinas y Flows en Kotlin</title><link>https://carrion.dev/es/posts/callback-to-flow-conversion/</link><pubDate>Tue, 11 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 11 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/callback-to-flow-conversion/</guid><description>Convirtiendo Callbacks a Coroutines y Flows en Kotlin Las APIs basadas en callbacks han sido un patrón común en la programación asíncrona durante muchos años. Sin embargo, con las corrutinas y flows de Kotlin, podemos transformar estos callbacks en código moderno y secuencial que es más fácil de leer y mantener. En este artículo, exploraremos cómo usar suspendCoroutine y callbackFlow para convertir APIs basadas en callbacks a corrutinas y flows.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/suspend-coroutine.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>coroutines</category><category>flows</category><category>callbacks</category></item><item><title>Entendiendo los Hot y Cold Flows en Kotlin</title><link>https://carrion.dev/es/posts/kotlin-flows-hot-cold/</link><pubDate>Fri, 07 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 07 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/kotlin-flows-hot-cold/</guid><description>Entendiendo los Hot y Cold Flows en Kotlin Kotlin Flow es una potente característica para manejar flows reactivos de datos. Uno de los conceptos fundamentales para entender cuando trabajamos con flows es la distinción entre hot y cold flows. Este artículo explicará las diferencias y proporcionará ejemplos prácticos de ambos tipos.
Cold Flows: El Comportamiento por Defecto Los cold flows son el tipo predeterminado en Kotlin Flow. Comienzan a producir valores solo cuando un collector empieza a recolectar de ellos.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/flows.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>coroutines</category><category>flows</category></item><item><title>Logrando Seguridad en Tiempo de Compilación con Koin: Una Guía Completa</title><link>https://carrion.dev/es/posts/koin-compile-safety/</link><pubDate>Tue, 04 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 04 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/koin-compile-safety/</guid><description>Logrando Seguridad en Tiempo de Compilación con Koin: Una Guía Completa La inyección de dependencias es un patrón fundamental en el desarrollo moderno de Android, pero ¿cómo podemos asegurarnos de que nuestra configuración de DI sea correcta antes de ejecutar la aplicación? En esta publicación, exploraremos dos poderosos enfoques para lograr la seguridad en tiempo de compilación con Koin: usando la función verify() del DSL y aprovechando las Anotaciones de Koin con KSP.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-ksp-config.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>koin</category></item><item><title>Gestión Confiable del Tiempo con la API TrustedTime en Android</title><link>https://carrion.dev/es/posts/trusted-time-api/</link><pubDate>Wed, 19 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 19 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/trusted-time-api/</guid><description>Gestión Confiable del Tiempo con la API TrustedTime en Android
La gestión precisa del tiempo es crucial para muchas funcionalidades de las aplicaciones, como la programación de tareas, el registro de transacciones y la seguridad. Sin embargo, depender del reloj del sistema de un dispositivo puede ser problemático, ya que los usuarios pueden modificar la configuración de la hora. Para abordar este problema, Google ha introducido la API TrustedTime, que proporciona una fuente de tiempo confiable y resistente a manipulaciones para las aplicaciones de Android.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/trusted-time-api.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>google</category></item><item><title>Mejores Prácticas de Arquitectura en Kotlin Multiplatform para Aplicaciones Móviles</title><link>https://carrion.dev/es/posts/kmp-architecture/</link><pubDate>Tue, 11 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 11 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/kmp-architecture/</guid><description>Mejores Prácticas de Arquitectura en Kotlin Multiplatform para Aplicaciones Móviles Kotlin Multiplatform (KMP) permite a los desarrolladores compartir la lógica de negocio entre Android y iOS mientras mantienen implementaciones específicas de cada plataforma cuando es necesario. Estructurar un proyecto KMP de manera eficiente es clave para mantener la escalabilidad, testabilidad y aplicar Clean Architecture. En esta guía, exploraremos las mejores prácticas para diseñar una aplicación móvil con Compose Multiplatform y Clean Architecture.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/expect-actual.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>compose</category><category>cmp</category><category>multiplatform</category><category>cleancode</category><category>architecture</category></item><item><title>Mocks, Fakes y Más</title><link>https://carrion.dev/es/posts/test-doubles/</link><pubDate>Thu, 06 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 06 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/test-doubles/</guid><description>Mocks, Fakes y Más: Entendiendo los Test Doubles en Kotlin Al escribir tests en Kotlin, especialmente para el desarrollo de Android, a menudo necesitamos reemplazar dependencias reales con test doubles. Sin embargo, no todos los test doubles son iguales: términos como mocks, fakes, stubs, spies y dummies aparecen con frecuencia. En esta publicación, desglosaremos sus diferencias con ejemplos en Kotlin utilizando solo Kotlin puro (sin bibliotecas de terceros).
1. Entendiendo los Test Doubles Los test doubles son objetos que sustituyen dependencias reales en las tests.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/mock.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>testing</category><category>mock</category><category>tdd</category></item><item><title>Tests en Compose Multiplatform (CMP) desde Código Común</title><link>https://carrion.dev/es/posts/cmp-ui-testing/</link><pubDate>Mon, 03 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 03 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/cmp-ui-testing/</guid><description>Tests en Compose Multiplatform (CMP) desde Código Común Compose Multiplatform (CMP) permite construir UI para múltiples plataformas utilizando Jetpack Compose. Afortunadamente, CMP también admite escribir y ejecutar tests de UI en el código común, lo que hace que los test sean más eficientes en todas las plataformas. En esta publicación, exploraremos cómo probar aplicaciones CMP utilizando compose.uiTest y ejecutarlas en Android, Desktop e iOS.
1. Configuración de Test de UI Comunes CMP proporciona compose.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/compose-test.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>compose</category><category>cmp</category><category>multiplatform</category></item><item><title>Explorando la Librería de Colecciones Inmutables de Kotlin</title><link>https://carrion.dev/es/posts/immutable-collections/</link><pubDate>Thu, 30 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 30 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/immutable-collections/</guid><description>Explorando la Librería de Colecciones Inmutables de Kotlin Las colecciones estándar de Kotlin (List, Set, Map) son mutables por defecto, lo que puede provocar modificaciones no deseadas. Para garantizar la inmutabilidad a nivel de API, JetBrains introdujo la librería de Colecciones Inmutables de Kotlin. Esta librería proporciona un conjunto de tipos de colección verdaderamente inmutables que evitan modificaciones accidentales y mejoran la seguridad en entornos concurrentes o de múltiples hilos.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/readonly-list.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>collections</category><category>compose</category></item><item><title>Mejorando el Rendimiento de las Aplicaciones Android con Baseline Profiles</title><link>https://carrion.dev/es/posts/baseline-profiles/</link><pubDate>Mon, 27 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 27 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/baseline-profiles/</guid><description>Mejorando el Rendimiento de las Aplicaciones Android con Baseline Profiles Introducción En el mundo móvil actual, los usuarios esperan que las aplicaciones se inicien al instante y funcionen sin problemas. La optimización del rendimiento es crucial, especialmente en lo que respecta al tiempo de inicio y la ejecución en tiempo de ejecución.
Los Baseline Profiles de Android ofrecen una forma eficaz de acelerar el inicio de la aplicación y mejorar el rendimiento en tiempo de ejecución al precompilar rutas de código críticas.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/baseline-profile.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Modularización en Proyectos Gradle con Kotlin</title><link>https://carrion.dev/es/posts/gradle-modularization/</link><pubDate>Thu, 23 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 23 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/gradle-modularization/</guid><description>Modularización en Proyectos Gradle con Kotlin: Una Guía Completa Introducción A medida que los proyectos crecen en complejidad, mantener una base de código monolítica se vuelve un desafío. La modularización es una técnica de diseño de software que divide una aplicación en módulos más pequeños e independientes, haciendo que el proyecto sea más escalable, mantenible y eficiente.
En esta guía, exploraremos por qué la modularización es esencial, los diferentes tipos de módulos y las mejores prácticas para configurar un proyecto modular en Gradle usando Kotlin.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/folder-structure.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Test-Driven Development (TDD) en Kotlin para Android</title><link>https://carrion.dev/es/posts/tdd-kotlin/</link><pubDate>Mon, 20 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 20 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/tdd-kotlin/</guid><description>Test-Driven Development (TDD) en Kotlin para Android El Test-Driven Development (TDD) es una práctica de desarrollo de software que enfatiza escribir pruebas antes de implementar la funcionalidad. Sigue un ciclo Rojo-Verde-Refactorización: primero, escribes una prueba que falla (Rojo), luego implementas el código mínimo para que pase (Verde), y finalmente, refactorizas el código manteniendo la prueba en verde (Refactorización). En esta publicación, exploraremos cómo aplicar TDD en Kotlin para el desarrollo de Android usando JUnit, MockK y Coroutines, con un ejemplo del mundo real.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/tdd-cycle.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category><category>TDD</category><category>testing</category></item><item><title>Clean Architecture en Kotlin &amp; Android</title><link>https://carrion.dev/es/posts/clean-architecture/</link><pubDate>Sat, 18 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Sat, 18 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/clean-architecture/</guid><description>Clean Architecture en Kotlin &amp;amp; Android Introducción Al desarrollar aplicaciones Android, mantener la escalabilidad y la legibilidad es crucial. Sin un enfoque arquitectónico claro, los proyectos pueden volverse difíciles de mantener a medida que crecen. Aquí es donde Clean Architecture, introducida por Uncle Bob (Robert C. Martin), se vuelve invaluable. Esta arquitectura enfatiza la separación de responsabilidades, haciendo que el código sea más modular, testeable y mantenible.
Entendiendo Clean Architecture Clean Architecture está estructurada en tres capas principales, cada una con un rol específico:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/domain-layer.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Explorando Arquitecturas de Apps en Kotlin</title><link>https://carrion.dev/es/posts/app-architecture/</link><pubDate>Wed, 15 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 15 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/app-architecture/</guid><description>Explorando Arquitecturas de Apps en Kotlin: MVC, MVP, MVVM y MVI Introducción En el desarrollo moderno de aplicaciones, elegir la arquitectura adecuada es esencial para crear aplicaciones mantenibles y escalables. Las arquitecturas definen cómo se organiza tu base de código y cómo interactúan los diferentes componentes. En este artículo, exploraremos cuatro arquitecturas populares: Model-View-Controller (MVC), Model-View-Presenter (MVP), Model-View-ViewModel (MVVM) y Model-View-Intent (MVI). Analizaremos su estructura, ventajas, desventajas y ejemplos prácticos en Kotlin.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/mvvm.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>architecture</category></item><item><title>Kotlin Design Patterns - Part 3</title><link>https://carrion.dev/es/posts/design-patterns-3/</link><pubDate>Mon, 13 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 13 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/design-patterns-3/</guid><description>Explorando Más Patrones de Diseño en Kotlin: Parte 3 Part 1 Part 2 Part 3 En esta tercera entrega, cubriremos los patrones Memento, Command, Visitor, Chain of Responsibility y Mediator. Estos patrones abordan desafíos de construcción, comportamiento y estructura, mostrando la sintaxis expresiva y las características modernas de Kotlin.
1. Patrón Memento El Patrón Memento captura y restaura el estado de un objeto sin exponer sus detalles internos.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/memento-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item><item><title>Entendiendo los principios SOLID con ejemplos en Kotlin</title><link>https://carrion.dev/es/posts/solid-kotlin/</link><pubDate>Wed, 08 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 08 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/solid-kotlin/</guid><description>Entendiendo los principios SOLID con ejemplos en Kotlin Los principios SOLID son un conjunto de principios de diseño que hacen que los diseños de software sean más comprensibles, flexibles y mantenibles. Introducidos por Robert C. Martin, estos principios son una piedra angular de la programación orientada a objetos y son especialmente relevantes al construir sistemas complejos. En este blog, exploraremos cada principio con ejemplos escritos en Kotlin, un lenguaje que ofrece una sintaxis moderna y características poderosas.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/di-fix.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>solid</category><category>architecture</category></item><item><title>Patrones de diseño en Kotlin - Parte 2</title><link>https://carrion.dev/es/posts/design-patterns-2/</link><pubDate>Mon, 06 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 06 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/design-patterns-2/</guid><description>Explorando patrones de diseño en Kotlin: Parte2 Design Patterns Series Part 1 Part 2 Part 3 Después de la gran acogida del primer artículo Patrones de diseño en Kotlin, volvemos con más! En esta segunda parte, revisaremos los patrones de Prototype, Composite, Proxy, Observer, y Strategy. Estos patrones resuelven una variedad de desafios de diseño y demuestran las capacidades expresivas de Kotlin.
1. Patrón Prototype El Patrón Prototype es usado para crear nuevos objeto copiando una objeto existente, asegurando la creación eficaz de objetos.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/proxy-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item><item><title>Usando Koin en Compose Multiplatform</title><link>https://carrion.dev/es/posts/koin-cmp/</link><pubDate>Thu, 02 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 02 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/koin-cmp/</guid><description>Usando Koin en Compose Multiplatform La inyección de dependencias es algo imprescindible para crear aplicaciones escalables, y Koin hace que sea muy sencillo, incluso en proyectos con Compose Multiplatform. Con la nueva función composable KoinApplication, puedes inicializar Koin directamente desde el código común, reduciendo la cantidad de código necesario mientras se mantiene la flexibilidad de configurar cada plataforma por separado. Vamos a ver un ejemplo.
Project Setup Empieza creando un proyecto de Compose Multiplatform usando el KMP Wizard, seleccionando Android, iOS, Desktop y Web como plataformas.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-cmp.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>multiplatform</category><category>cmp</category><category>compose</category><category>koin</category></item><item><title>Patrones de diseño en Kotlin - Parte 1</title><link>https://carrion.dev/es/posts/design-patterns-1/</link><pubDate>Mon, 30 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 30 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/design-patterns-1/</guid><description>Explorando patrones de diseño en Kotlin - Parte 1 Serie Patrones de diseño Design Patterns Series Part 1 Part 2 Part 3 Los patrones de diseño son soluciones probadas a problemas comunes en el diseño de software. Con la sintaxis y funcionalidades modernas de Kotlin, implementar estos patrones normalmente resulta más limpio y conciso. En este post, exploraremos los patrones de Singleton, Factory Method, Builder, Adapter and Decorator, profundizando en su propósito, casos de uso y implementaciones en Kotlin.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/singleton-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item><item><title>Explorando Kotlin KSP</title><link>https://carrion.dev/es/posts/kotlin-ksp/</link><pubDate>Fri, 27 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 27 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/kotlin-ksp/</guid><description>Explorando Kotlin Symbol Processing (KSP) con ejemplos prácticos Kotlin Symbol Processing (KSP) es una herramienta muy potente usada para simplificar el procesamiento de anotaciones en Kotlin. Comparado con kapt (Kotlin Annotation Processing Tool), KSP es más rápido, ofrece mejor integración con Kotlin y reduce los tiempos de compilación de forma significativa. En este post, exploraremos los fundamentos de KSP, discutiremos cómo funciona y mostraremos como su uso en librerías populares como Koin y Room.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-annotations.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Funciones Infix en Kotlin</title><link>https://carrion.dev/es/posts/kotlin-infix/</link><pubDate>Thu, 26 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 26 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/kotlin-infix/</guid><description>Explorando las funciones Infix en Kotlin Kotlin, es un lenguaje de programación moderno con funcionalidades que permiten escribir un código más expresivo y conciso. Una de estas funcionalidades son las infix functions, que permiten escribir código más limpio y legible. En este post, exploraremos que son las funciones infix, como usarlas y algunos ejemplo prácticos.
Qué son las funciones Infix? Las funciones infix en Kotlin son un tipo especial de función que pueden ser llamadas sin el uso de paréntesis o el punto.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-infix.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Kotlin Delegates</title><link>https://carrion.dev/es/posts/kotlin-delegates/</link><pubDate>Mon, 23 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 23 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/kotlin-delegates/</guid><description>✨ Entendiendo los Kotlin Delegates: La magia detrás de código más limpio ✨ Los Kotlin delegates son una funcionalidad muy útil que te permite delegar el comportamiento de una propiedad o incluso una implementación de una interfaz a otro objecto. En lugar de escribir lógica repetitiva o manejar el estado directamente, puedes delegar esta responsabilidad a clases especializadas y reusables.
Como funcionan los Delegates Delegates en Kotlin funcionan usando la palabra reservada by, que redirecciona el comportamiento de una propiedad o interfaz al objeto delegado.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-delegate.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Kotlin contracts</title><link>https://carrion.dev/es/posts/kotlin-contracts/</link><pubDate>Fri, 20 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 20 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/kotlin-contracts/</guid><description>Kotlin Avanzado - Contracts: Cómo volver al compilador de Kotlin más inteligente Kotlin nunca deja de impresionarme con sus funcionalidades. Una función avanzada pero poco utilizada en el arsenal de Kotlin son los Contracts. Los contratos te permiten guiar al compilador de Kotlin para que tome mejores decisiones acerca de tu código, resultando en mejor seguridad ante nulos, mejor rendimiento o incluso menores errores en tiempo de ejecución.
Qué son los contratos de Kotlin?</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/kotlin-contract.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Exportar a Swift en KMP</title><link>https://carrion.dev/es/posts/swift-export/</link><pubDate>Wed, 18 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 18 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/swift-export/</guid><description>Exportar a Swift en KMP Empezando con la versión 2.1.0 podemos empezar a probar a exportar a Swift en Kotlin. Esta funcionalidad te permite exportar los módulos compartidos de Kotlin a Swift sin usar Objective-C. Esto mejorará la experiancia de los desarrolladores de iOS cuando usen módulos de KMP.
Actualmente el soporte básico incluye:
Exportar múltiples módulos de Gradle a swift. Definir los nombres de los módulos swift. Simplificar la estructura de paquetes.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/swift-export.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>kmp</category></item><item><title>Condiciones en las expresiones when para Kotlin 2.1.0.</title><link>https://carrion.dev/es/posts/kotlin-guard-conditions-in-when/</link><pubDate>Tue, 17 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 17 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/kotlin-guard-conditions-in-when/</guid><description>Condiciones en las expresiones when en Kotlin 2.1.0 Una de las nuevas funcionalidades de Kotlin 2.1.0 es las condiciones en las expresiones when, lo que tendría varias ventajas entre las que se incluye:
Reducir anidaciones Evita código repetido Mejorar legibilidad Activar la funcionalidad en Kotlin 2.1.0 Esta funcionalidad se encuentra en preview lo que es necesario activarla explícitamente para poder usarla en Kotlin 2.1.0. En el fichero build.gradle.kts añadiremos el siguiente código dentro del bloque de kotlin {}:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/guard-when-new.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>kmp</category></item><item><title>Hilt: Inyectar valores al ViewModel en tiempo de ejecución.</title><link>https://carrion.dev/es/posts/hilt-inject-parameters-runtime/</link><pubDate>Wed, 24 Feb 2021 07:00:06 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 24 Feb 2021 07:00:06 +0100</atom:modified><guid>https://carrion.dev/es/posts/hilt-inject-parameters-runtime/</guid><description>Inyección de valores en tiempo de ejecución con Dagger-Hilt Desde que apareció Hilt para facilitar la inyección de dependencias en aplicaciones Android, no era posible la inyección de dependencias en tiempo de ejecución sin utilizar librerías ajenas a Dagger o Hilt. Desde la versión 2.31 se incorpora en Dagger la anotación @AssistedInject. Con esta anotación vamos a ser capaces de indicar a Dagger-Hilt que dependencias se tienen que resolver en tiempo de ejecución y retrasar la inyección de esos parámetros hasta tener los valores.</description><dc:creator>Ignacio</dc:creator><media:content url="https://carrion.dev/images/kotlin/kotlin-logo.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>jetpack</category><category>coroutines</category><category>androidx</category></item><item><title>Bienvenido a mi nuevo blog sobre Kotlin y desarrollo Android</title><link>https://carrion.dev/es/posts/welcome-to-my-new-kotlin-and-android-development-blog/</link><pubDate>Tue, 23 Feb 2021 10:00:06 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 23 Feb 2021 10:00:06 +0100</atom:modified><guid>https://carrion.dev/es/posts/welcome-to-my-new-kotlin-and-android-development-blog/</guid><description>Bienvenido a Carrion.dev Saludos Androide!!
Bienvenido a mi nuevo blog de Kotlin y programación Android. Me llamo Ignacio Carrión y soy dessarrollador Android. Me encanta el lenguaje Kotlin por las facilidades que me aporta al programar para Android y las infinitas posibilidades que ofrece en otros ámbitos (backend, web, nativo, multiplataforma).
En este blog espero poder publicar cosas interesantes acerca del lenguaje Kotlin y el ecosistema Android al menos cada dos semanas.</description><dc:creator>Ignacio</dc:creator><media:content url="https://carrion.dev/images/kotlin/kotlin-logo.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>jetpack</category><category>coroutines</category><category>androidx</category></item></channel></rss>