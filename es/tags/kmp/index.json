[{"content":"Condiciones en las expresiones when en Kotlin 2.1.0 Una de las nuevas funcionalidades de Kotlin 2.1.0 es las condiciones en las expresiones when, lo que tendría varias ventajas entre las que se incluye:\n Reducir anidaciones Evita código repetido Mejorar legibilidad  Activar la funcionalidad en Kotlin 2.1.0 Esta funcionalidad se encuentra en preview lo que es necesario activarla explícitamente para poder usarla en Kotlin 2.1.0. En el fichero build.gradle.kts añadiremos el siguiente código dentro del bloque de kotlin {}:\n1 2 3 4 5  kotlin { compilerOptions { freeCompilerArgs.add(\u0026#34;-Xwhen-guards\u0026#34;) } }   Uso de condicionales dentro de las ramas de la expresiones when Para este ejemplo usaremos una sealed interface para manejar respuestas de un servicio remoto:\n1 2 3 4 5  sealed interface Response\u0026lt;out T\u0026gt; { data object Loading : Response\u0026lt;Nothing\u0026gt; data class Content \u0026lt;out T\u0026gt; (val data: T?) : Response\u0026lt;T\u0026gt; data class Error(val error: Exception) : Response\u0026lt;Nothing\u0026gt; }   Esta interfaz la implementan Loading, Content y Error para gestionar los distintos estados de una respuesta.\nAntes de la nueva funcionalidad 1 2 3 4 5 6 7 8 9 10 11 12 13  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handleOld() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content -\u0026gt; if (data != null) { println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } is Response.Error -\u0026gt; if (error is IllegalStateException) { println(\u0026#34;Handled error\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } }   Como se puede ver en este caso se repite el código que muestra por pantalla Unknown error además de añadir anidaciones que dificultan la lectura del código.\nUsando los nuevos condicionales Se debe añadir el if justo después de la condición primaria de la rama, por ejemplo:\n1 2 3 4 5 6  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled error\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   De esta manera no se repite el código que mostraba por pantalla el texto de Unknown error y además eliminamos las anidaciones facilitando la lectura del código.\nEn caso de necesitar comprobar varias condiciones en la rama else se podría añadir una rama else if que controle el flujo de los casos que no cumplen las condiciones anteriores.\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) else if this is Response.Error \u0026amp;\u0026amp; this.error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   Esto último se puede simplificar usando dos ramas con la misma primera condición de is Response.Error que a mi parecer queda más simple:\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) is Response.Error if error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   Conclusión Con esta nueva funcionalidad se podrá añadir nuevas condiciones sin tener que repetir código y permitirá que las expresiones when sean más concisas. En la versión 2.1.0 de Kotlin está en modo preview pero se espera que pronto esta nueva funcionalidad sea estable.\nAquí el enlace a la documentación con las novedades de Kotlin 2.1.0 donde se explica la funcionalidad de condicionales en las expresiones when kotlinlang\n","description":"Nueva funcionalidad en Kotlin 2.1.0, condiciones en las expresiones when","id":0,"section":"posts","tags":["kotlin","android","kmp"],"title":"Condiciones en las expresiones `when` para Kotlin 2.1.0.","uri":"https://carrion.dev/es/posts/kotlin-guard-conditions-in-when/"},{"content":"Inyección de valores en tiempo de ejecución con Dagger-Hilt Desde que apareció Hilt para facilitar la inyección de dependencias en aplicaciones Android, no era posible la inyección de dependencias en tiempo de ejecución sin utilizar librerías ajenas a Dagger o Hilt. Desde la versión 2.31 se incorpora en Dagger la anotación @AssistedInject. Con esta anotación vamos a ser capaces de indicar a Dagger-Hilt que dependencias se tienen que resolver en tiempo de ejecución y retrasar la inyección de esos parámetros hasta tener los valores.\nEsto era necesario para poder inyectar valores en los constructores de los ViewModel y poder ejecutar alguna operación en el método init del mismo. Como puede ser una petición a una API externa o bien una consulta en la base de datos local.\nEn este artículo veremos como implementar el @AssistedInject de Dagger para la inyección de valores en tiempo de ejecución en ViewModels con Hilt.\nInstalación En el fichero build.gradle raíz del proyecto, incluiremos el siguiente classpath:\n1  classpath \u0026#39;com.google.dagger:hilt-android-gradle-plugin:2.31.2-alpha\u0026#39;   Una vez añadido el classpath añadiremos el plugin de Hilt en el fichero build.gradle del módulo app.\n1  apply plugin: \u0026#39;dagger.hilt.android.plugin\u0026#39;   Y también las siguientes líneas a nuestras dependencias:\n1 2  implementation \u0026#39;com.google.dagger:hilt-android:2.31.2-alpha\u0026#39; kapt \u0026#39;com.google.dagger:hilt-android-compiler:2.31.2-alpha\u0026#39;   También hay que tener en cuenta tener añadido en nuestro build.gradle el plugin de kapt. Para ello añadiremos lo siguiente a nuestro archivo de build.gradle del módulo app junto al resto de plugins:\n1  apply plugin: \u0026#39;kotlin-kapt\u0026#39;   Esa son las dependencias necesarias para implementar Hilt en nuestro proyecto. A lo largo de este post se usan distintas librerías como que no se definen en este artículo.\nEn este enlace puedes ver un ejemplo de un archivo build.gradle completo: app/build.gradle\nImplementación Para este ejemplo usaremos una clase repositorio encargada de recibir el nombre de usuario y devolver un mensaje de bienvenida. Para ello crearemos la siguiente interfaz:\n1 2 3  interface UserRepository { fun getMessage(name: String): String }   Y su implementación:\n1 2 3 4 5  class UserRepositoryImpl @Inject constructor() : UserRepository { override fun getMessage(name: String): String { return \u0026#34;Hi $name\u0026#34; } }   Anotamos el constructor con @Inject para posteriormente poder declarar un @Binds en el módulo de Hilt e inyectar la implementación cada vez que se pida una interfaz del tipo UserRepository.\nVamos a crear el siguiente ViewModel que será el encargado de recibir el nombre del usuario desde el Activity o Fragment y llamar al repositorio para recibir el mensaje de bienvenida:\n1 2 3 4 5 6 7 8 9  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { ... }   En este ViewModel podemos ver como se anota el constructor con @AssistedInject para indicar a Dagger-Hilt que esta clase contiene dependencias que se deben inyectar en tiempo de ejecución. Esas dependencias están anotadas con @Assisted.\nPara poder crear el ViewModel con la extensión by viewModels() de la librería de AndroidX debemos crear la Factory que más tarde pasaremos a la extensión:\n1 2 3 4 5 6 7 8  class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } }   Como puedes ver necesitamos la interfaz UserViewModelAssistedFactory que es la encargada de proveer los parámetros en tiempo de ejecución. Esta interfaz la implementamos de la siguiente forma:\n1 2 3 4 5 6  @AssistedFactory interface UserViewModelAssistedFactory { fun create(name: String): UserViewModel }   Se trata de una interfaz con una función create que recibe los parámetros a inyectar en tiempo de ejecución. En nuestro caso solo necesitamos el name, pero en caso de necesitar inyectar más parámetros en tiempo de ejecución, se pasarían como parámetro a esta función.\nCon esto ya podemos completar nuestro ViewModel con la lógica necesaria para pedir la respuesta al repositorio y exponer al Fragment o Activity a través de un StateFlow.\nEl ViewModel completo quedaría:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } } private val _message: MutableStateFlow\u0026lt;String\u0026gt; = MutableStateFlow(\u0026#34;\u0026#34;) val message: StateFlow\u0026lt;String\u0026gt; get() = _message init { viewModelScope.launch(dispatcher) { _message.emit(repository.getMessage(name)) } } }   Relativo a Hilt solo nos faltaría declarar el módulo indicando como proveer las dependencias. Para este ejemplo usaremos el siguiente módulo:\n1 2 3 4 5 6 7 8 9 10 11 12 13  @Module @InstallIn(ActivityComponent::class) abstract class MainModule { companion object { @Provides @Named(\u0026#34;UserDispatcher\u0026#34;) fun provideUserDispatcher(): CoroutineDispatcher = Dispatchers.IO } @Binds abstract fun provideUserRepository(repositoryImpl: UserRepositoryImpl): UserRepository }   En este módulo declaramos un Dispatcher para que sea más sencillo testear este ViewModel en un futuro. Y hacemos @Binds de nuestra interfaz UserRepository con su implementación UserRepositoryImpl.\nAhora podemos inyectar nuestro repositorio en una Activity o Fragment de la siguiente forma:\n1 2 3 4 5 6 7 8  private val navArgs: UserFragmentArgs by navArgs() @Inject lateinit var assistedFactory: UserViewModelAssistedFactory private val userViewModel: UserViewModel by viewModels { UserViewModel.Factory(assistedFactory, navArgs.name) }   Simplemente nos faltaría observar los cambios en el StateFlow del ViewModel para poder actualizar nuestra UI. Eso se haría de la siguiente manera en un Fragment aunque sería muy similar en un Activity\n1 2 3 4 5 6 7 8  override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycleScope.launchWhenStarted { userViewModel.message.collect { binding.name.text = it } } }    Recordar que es necesario anotar una clase que extienda de Application con @HiltAndroidApp y cada uno de las Activities o Fragments que usen inyección con Hilt con la anotación @AndroidEntryPoint.\n Conclusión Como hemos podido observar con @AssistedInject de Dagger podemos inyectar valores en tiempo de ejecución de una forma sencilla y podemos seguir utilizando los navArgs de AndroidX.\nEn el siguiente repositorio teneis el ejemplo completo: HiltAssistedInject\n","description":"Como inyectar valores en tiempo de ejecución a los ViewModel en Android.","id":1,"section":"posts","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Hilt: Inyectar valores al ViewModel en tiempo de ejecución.","uri":"https://carrion.dev/es/posts/hilt-inject-parameters-runtime/"},{"content":"Bienvenido a Carrion.dev Saludos Androide!!\nBienvenido a mi nuevo blog de Kotlin y programación Android. Me llamo Ignacio Carrión y soy dessarrollador Android. Me encanta el lenguaje Kotlin por las facilidades que me aporta al programar para Android y las infinitas posibilidades que ofrece en otros ámbitos (backend, web, nativo, multiplataforma).\nEn este blog espero poder publicar cosas interesantes acerca del lenguaje Kotlin y el ecosistema Android al menos cada dos semanas. Si quieres mantenerte al día no dudes en apuntarte a nuestra newsletter.\nSi tienes alguna duda, idea acerca de la que podemos hablar en un post o simplemente quieres contactar estoy disponible a través del correo: ignacio@carrion.dev.\nEspero que aprendamos mucho todos juntos!!\n","description":"Primer post en mi nuevo blog de Kotlin y Android.","id":2,"section":"posts","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Bienvenido a mi nuevo blog sobre Kotlin y desarrollo Android","uri":"https://carrion.dev/es/posts/welcome-to-my-new-kotlin-and-android-development-blog/"},{"content":"Sobre mi. Me llamo Ignacio Carrión, vivo en Valencia (España) y el que aparece en la foto es mi perro Wilfred. Me gusta cualquier cosa relacionada con la informática y los videojuegos. Actualmente trabajo como Senior Android Engineer para Tkww. Anteriormente he trabajado en otras empresas como desarrollador Android y también he impartido clases de programación. A raiz de mi trabajo como profesor me dí cuenta de que realmente me encanta aprender y que la gente aprenda conmigo. De esa motivación surge la idea de crear este blog, Carrion.dev.\nEspero poder ir publicando de forma asídua cosas interesantes acerca del lenguaje Kotlin y el ecosistema Android. Cualquier crítica constructiva e ideas acerca de posibles temas para artículos serán bien recibidas. Abajo aparecen los enlaces a las redes sociales en las que podrás encontrarme y contactar conmigo.\nContactar Portfolio\nGithub\n","description":"Ignacio Carrión, Desarrollador Android","id":6,"section":"","tags":null,"title":"Sobre mi","uri":"https://carrion.dev/es/about/"}]