[{"content":"Kotlin Mutex: Concurrencia Segura para Coroutines Al construir aplicaciones concurrentes con coroutines de Kotlin, proteger el estado mutable compartido es esencial. Aunque las herramientas tradicionales de sincronización de Java como bloques synchronized y ReentrantLock funcionan, bloquean hilos y no se integran bien con el modelo de suspensión de coroutines. Aquí es donde entra Mutex — una primitiva de sincronización compatible con coroutines que proporciona exclusión mutua sin bloquear hilos.\nEsta guía explora cuándo usar Mutex, mejores prácticas y cómo se compara con otros mecanismos de control de concurrencia.\nTL;DR: Recomendaciones Rápidas  Usa Mutex cuando necesites proteger estado mutable compartido al que acceden múltiples coroutines. Prefiere Mutex sobre synchronized en código con coroutines para evitar bloquear hilos. Usa mutex.withLock { } para adquisición y liberación automática del bloqueo. Considera Actor o StateFlow para escenarios de gestión de estado más complejos. Para contadores simples, usa AtomicInteger o AtomicReference en su lugar. Usa Semaphore cuando necesites limitar el acceso concurrente a múltiples permisos. Siempre libera los bloqueos en bloques finally si no usas withLock.  ¿Qué es Mutex? Mutex (exclusión mutua) es una primitiva de sincronización de kotlinx.coroutines que asegura que solo una coroutine pueda ejecutar una sección crítica a la vez. A diferencia de los bloqueos tradicionales que bloquean hilos, Mutex suspende coroutines, manteniendo los hilos libres para hacer otro trabajo.\nEstructura básica:\n1 2 3 4 5 6 7 8 9 10 11  import kotlinx.coroutines.sync.Mutex import kotlinx.coroutines.sync.withLock val mutex = Mutex() suspend fun protectedOperation() { mutex.withLock { // Sección crítica - solo una coroutine a la vez  // Modifica el estado compartido de forma segura aquí  } }   Características clave:\n No bloqueante: Suspende coroutines en lugar de bloquear hilos Justo: Otorga acceso en orden FIFO por defecto No reentrante: Una coroutine que mantiene el bloqueo no puede adquirirlo nuevamente (previene deadlock) Ligero: Más eficiente que los bloqueos que bloquean hilos  Casos de Uso Principales para Mutex 1. Proteger Estado Mutable Compartido El caso de uso más común — asegurar acceso seguro a variables compartidas:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class CounterService { private var counter = 0 private val mutex = Mutex() suspend fun increment() { mutex.withLock { counter++ } } suspend fun getCount(): Int { return mutex.withLock { counter } } }   2. Coordinar Acceso a Recursos Cuando múltiples coroutines necesitan acceso exclusivo a un recurso:\n1 2 3 4 5 6 7 8 9  class FileWriter(private val file: File) { private val mutex = Mutex() suspend fun appendLine(line: String) { mutex.withLock { file.appendText(\u0026#34;$line\\n\u0026#34;) } } }   3. Asegurar Ejecución Secuencial Cuando las operaciones deben ocurrir en orden, incluso si se activan concurrentemente:\n1 2 3 4 5 6 7 8 9 10 11 12 13  class OrderProcessor { private val mutex = Mutex() private val orders = mutableListOf\u0026lt;Order\u0026gt;() suspend fun processOrder(order: Order) { mutex.withLock { // Asegurar que los pedidos se procesan secuencialmente  orders.add(order) validateOrder(order) persistOrder(order) } } }   4. Inicialización Perezosa con Seguridad de Hilos Inicialización perezosa segura para hilos en contextos suspendidos:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class DatabaseConnection { private var connection: Connection? = null private val mutex = Mutex() suspend fun getConnection(): Connection { if (connection != null) return connection!! return mutex.withLock { // Verificación doble dentro del bloqueo  connection ?: createConnection().also { connection = it } } } private suspend fun createConnection(): Connection { delay(1000) // Simular configuración de conexión  return Connection() } }   Mejores Prácticas 1. Siempre Usa withLock withLock maneja automáticamente la adquisición y liberación del bloqueo, incluso si ocurren excepciones:\n1 2 3 4 5 6 7 8 9 10 11 12  // ✅ Bueno: Limpieza automática mutex.withLock { dangerousOperation() } // ❌ Malo: Gestión manual, propenso a errores mutex.lock() try { dangerousOperation() } finally { mutex.unlock() }   2. Mantén las Secciones Críticas Pequeñas Minimiza el tiempo manteniendo el bloqueo para reducir la contención:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // ✅ Bueno: Bloqueo solo para la sección crítica suspend fun updateUser(userId: String, name: String) { val validated = validateName(name) // Fuera del bloqueo  mutex.withLock { userCache[userId] = validated // Solo esto necesita protección  } notifyObservers(userId) // Fuera del bloqueo } // ❌ Malo: Mantener bloqueo durante operaciones lentas suspend fun updateUserSlow(userId: String, name: String) { mutex.withLock { val validated = validateName(name) // Operación lenta dentro del bloqueo  userCache[userId] = validated notifyObservers(userId) // I/O dentro del bloqueo  } }   3. Evita Bloqueos Anidados Mutex no es reentrante. Evita adquirir el mismo bloqueo dos veces:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // ❌ Malo: ¡Deadlock! suspend fun problematic() { mutex.withLock { helperFunction() // Intenta adquirir mutex nuevamente  } } suspend fun helperFunction() { mutex.withLock { // Se suspenderá para siempre  } } // ✅ Bueno: Reestructurar para evitar anidación suspend fun better() { mutex.withLock { helperFunctionUnsafe() // Sin adquisición de bloqueo  } } fun helperFunctionUnsafe() { // Asume que el llamador mantiene el bloqueo }   4. Considera Alternativas Sin Bloqueo Primero Para operaciones simples, los tipos atómicos son más rápidos:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // ✅ Mejor para contadores simples class AtomicCounter { private val counter = AtomicInteger(0) fun increment() = counter.incrementAndGet() fun get() = counter.get() } // ❌ Excesivo para un contador simple class MutexCounter { private var counter = 0 private val mutex = Mutex() suspend fun increment() { mutex.withLock { counter++ } } }   5. Documenta las Invariantes del Bloqueo Deja claro qué protege el bloqueo:\n1 2 3 4 5 6 7 8 9 10 11 12  class UserCache { private val mutex = Mutex() // Protege userMap y lastUpdate  private val userMap = mutableMapOf\u0026lt;String, User\u0026gt;() private var lastUpdate = 0L suspend fun updateUser(id: String, user: User) { mutex.withLock { userMap[id] = user lastUpdate = System.currentTimeMillis() } } }   Mutex vs. Otros Métodos de Sincronización Mutex vs. synchronized 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // synchronized tradicional (bloquea hilo) class SynchronizedCounter { private var count = 0 @Synchronized fun increment() { count++ // Hilo bloqueado mientras espera  } } // Mutex (suspende coroutine) class MutexCounter { private var count = 0 private val mutex = Mutex() suspend fun increment() { mutex.withLock { count++ // Coroutine suspendida, hilo libre  } } }   Cuándo usar cuál:\n Usa synchronized para código no suspendido e interoperabilidad con Java legado Usa Mutex para funciones suspendidas y código basado en coroutines Mutex es más eficiente en contextos de coroutines porque los hilos no se bloquean  Mutex vs. Semaphore 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // Mutex: Solo una coroutine a la vez val mutex = Mutex() // Semaphore: N coroutines a la vez val semaphore = Semaphore(permits = 3) // Ejemplo: Limitación de velocidad de llamadas API class ApiClient { private val semaphore = Semaphore(5) // Máximo 5 peticiones concurrentes  suspend fun makeRequest(endpoint: String): Response { semaphore.withPermit { return httpClient.get(endpoint) } } }   Cuándo usar cuál:\n Usa Mutex cuando necesites acceso exclusivo (un solo permiso) Usa Semaphore cuando necesites limitar la concurrencia a N operaciones  Mutex vs. Actor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // Mutex: Sincronización manual class MutexBasedCache { private val cache = mutableMapOf\u0026lt;String, Data\u0026gt;() private val mutex = Mutex() suspend fun get(key: String) = mutex.withLock { cache[key] } suspend fun put(key: String, value: Data) = mutex.withLock { cache[key] = value } } // Actor: Sincronización basada en mensajes sealed class CacheMessage data class Get(val key: String, val response: CompletableDeferred\u0026lt;Data?\u0026gt;) : CacheMessage() data class Put(val key: String, val value: Data) : CacheMessage() fun CoroutineScope.cacheActor() = actor\u0026lt;CacheMessage\u0026gt; { val cache = mutableMapOf\u0026lt;String, Data\u0026gt;() for (msg in channel) { when (msg) { is Get -\u0026gt; msg.response.complete(cache[msg.key]) is Put -\u0026gt; cache[msg.key] = msg.value } } }   Cuándo usar cuál:\n Usa Mutex para sincronización simple con llamadas directas a métodos Usa Actor para máquinas de estado complejas o cuando necesites encolamiento de mensajes Los actores proporcionan mejor encapsulación y pueden manejar contrapresión  Mutex vs. StateFlow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // Mutex: Gestión de estado imperativa class MutexState { private var state = 0 private val mutex = Mutex() suspend fun updateState(transform: (Int) -\u0026gt; Int) { mutex.withLock { state = transform(state) } } } // StateFlow: Gestión de estado reactiva class FlowState { private val _state = MutableStateFlow(0) val state: StateFlow\u0026lt;Int\u0026gt; = _state.asStateFlow() fun updateState(transform: (Int) -\u0026gt; Int) { _state.update(transform) // Seguridad de hilos integrada  } }   Cuándo usar cuál:\n Usa Mutex cuando necesites lógica de sincronización personalizada Usa StateFlow para estado observable con seguridad de hilos integrada StateFlow es mejor para estado de UI y arquitecturas reactivas  Mutex vs. Tipos Atómicos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // AtomicInteger: Sin bloqueo para operaciones simples class AtomicCounter { private val counter = AtomicInteger(0) fun increment() = counter.incrementAndGet() fun addAndGet(delta: Int) = counter.addAndGet(delta) } // Mutex: Para operaciones complejas class ComplexCounter { private var counter = 0 private var history = mutableListOf\u0026lt;Int\u0026gt;() private val mutex = Mutex() suspend fun increment() { mutex.withLock { counter++ history.add(counter) // Múltiples operaciones  } } }   Cuándo usar cuál:\n Usa tipos atómicos para operaciones de una sola variable (contadores, flags) Usa Mutex cuando necesites coordinar múltiples variables Los atómicos son más rápidos pero limitados a operaciones específicas  Errores Comunes 1. Olvidar Usar suspend Las operaciones de Mutex requieren suspensión:\n1 2 3 4 5 6 7 8 9  // ❌ No compilará fun broken() { mutex.withLock { } // Error: función suspend llamada en contexto no suspend } // ✅ Correcto suspend fun correct() { mutex.withLock { } }   2. Mantener el Bloqueo Durante Operaciones Largas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // ❌ Malo: Mantener bloqueo durante I/O suspend fun bad(url: String) { mutex.withLock { val data = httpClient.get(url) // Llamada de red dentro del bloqueo  cache[url] = data } } // ✅ Bueno: Obtener fuera del bloqueo suspend fun good(url: String) { val data = httpClient.get(url) mutex.withLock { cache[url] = data } }   3. Asumir Reentrancia 1 2 3 4 5 6 7 8 9 10 11 12  // ❌ Deadlock: Mutex no es reentrante suspend fun outer() { mutex.withLock { inner() // ¡Deadlock!  } } suspend fun inner() { mutex.withLock { // Nunca se alcanza  } }   4. No Manejar la Cancelación Siempre considera la cancelación al mantener bloqueos:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // ✅ Bueno: withLock maneja la cancelación suspend fun proper() { mutex.withLock { doWork() } // Bloqueo liberado incluso en cancelación } // ❌ Riesgoso: Gestión manual de bloqueos suspend fun risky() { mutex.lock() try { doWork() // Si se cancela aquí, el bloqueo permanece adquirido  } finally { mutex.unlock() } }   Consideraciones de Rendimiento  Mutex vs. synchronized: En código con muchas coroutines, Mutex es más eficiente porque los hilos no se bloquean Contención: Alta contención degrada el rendimiento; considera fragmentación (múltiples bloqueos para diferentes claves) Granularidad del bloqueo: Bloqueos de grano más fino (más bloqueos, cada uno protegiendo menos datos) reducen la contención Alternativas sin bloqueo: Para operaciones simples, los tipos atómicos y StateFlow son más rápidos  Ejemplo: Fragmentación para reducir contención:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class ShardedCache(private val shardCount: Int = 16) { private val mutexes = Array(shardCount) { Mutex() } private val caches = Array(shardCount) { mutableMapOf\u0026lt;String, Data\u0026gt;() } private fun shardIndex(key: String) = key.hashCode() and (shardCount - 1) suspend fun put(key: String, value: Data) { val index = shardIndex(key) mutexes[index].withLock { caches[index][key] = value } } suspend fun get(key: String): Data? { val index = shardIndex(key) return mutexes[index].withLock { caches[index][key] } } }   Ejemplo del Mundo Real: Repositorio Seguro para Hilos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  class UserRepository( private val api: UserApi, private val database: UserDatabase ) { private val cache = mutableMapOf\u0026lt;String, User\u0026gt;() private val mutex = Mutex() suspend fun getUser(userId: String): User? { // Verificar caché primero (bloqueo de lectura)  mutex.withLock { cache[userId]?.let { return it } } // Intentar base de datos (fuera del bloqueo)  database.getUser(userId)?.let { user -\u0026gt; mutex.withLock { cache[userId] = user } return user } // Obtener de API (fuera del bloqueo)  return try { val user = api.fetchUser(userId) mutex.withLock { cache[userId] = user database.insertUser(user) } user } catch (e: Exception) { null } } suspend fun updateUser(user: User) { mutex.withLock { cache[user.id] = user database.updateUser(user) } } suspend fun clearCache() { mutex.withLock { cache.clear() } } }   Testeando Código Protegido con Mutex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  @Test fun `concurrent increments should be thread-safe`() = runTest { val counter = CounterService() // Lanzar 1000 incrementos concurrentes  val jobs = List(1000) { launch { counter.increment() } } jobs.joinAll() // Debería ser exactamente 1000  assertEquals(1000, counter.getCount()) } @Test fun `mutex prevents race conditions`() = runTest { val cache = mutableMapOf\u0026lt;String, Int\u0026gt;() val mutex = Mutex() // Simular condición de carrera  coroutineScope { repeat(100) { launch { mutex.withLock { val current = cache[\u0026#34;key\u0026#34;] ?: 0 delay(1) // Simular trabajo  cache[\u0026#34;key\u0026#34;] = current + 1 } } } } assertEquals(100, cache[\u0026#34;key\u0026#34;]) }   Reflexiones Finales Mutex es una herramienta poderosa para proteger estado mutable compartido en aplicaciones basadas en coroutines. Proporciona sincronización segura para hilos sin bloquear hilos, haciéndola ideal para código concurrente con coroutines.\nPuntos clave:\n Usa withLock para gestión automática de bloqueos Mantén las secciones críticas pequeñas y rápidas Considera alternativas más simples (atómicos, StateFlow) cuando sea apropiado Entiende cuándo usar Mutex vs. otras primitivas de sincronización Siempre maneja la cancelación adecuadamente  Recuerda: la mejor sincronización es ninguna sincronización. Cuando sea posible, diseña tu sistema para evitar estado mutable compartido por completo usando estructuras de datos inmutables, paso de mensajes (Actores/Canales), o flujos reactivos (Flow/StateFlow). Pero cuando sí necesites exclusión mutua en código con coroutines, Mutex es tu mejor amigo.\n","description":"Una guía completa para usar Mutex en coroutines de Kotlin — entendiendo casos de uso, mejores prácticas y cómo se compara con métodos de sincronización tradicionales.","id":2,"section":"posts","tags":["kotlin","coroutines","concurrency","mutex","thread-safety"],"title":"Kotlin Mutex: Concurrencia Segura para Coroutines","uri":"https://carrion.dev/es/posts/kotlin-mutex-concurrency-guide/"},{"content":"De Retrofit/OkHttp a Ktor en Kotlin Multiplatform: una primera migración práctica Si quieres comenzar a migrar una app Android existente a Kotlin Multiplatform (KMP), la capa de red es un excelente primer paso. Ktor Client funciona en múltiples plataformas y te permite mantener una sola pila HTTP para Android, iOS, Desktop y más. Esta guía muestra cómo migrar de Retrofit/OkHttp a Ktor con motores CIO u OkHttp, manteniendo el impacto limitado a la capa remota cuando tu arquitectura está bien diseñada.\n¿Por qué empezar por red? ¿Y qué debería cambiar? Con una arquitectura modular limpia (por ejemplo, Clean Architecture + Repository/DataSources), solo deberían cambiar tus implementaciones de DataSources remotas:\n La capa de dominio (entidades, casos de uso) permanece intacta Los contratos de repositorio permanecen iguales Las fuentes de datos locales (por ejemplo, Room/SQLDelight) permanecen iguales Solo la implementación remota cambia de Retrofit → Ktor  Esto reduce el riesgo y permite una migración incremental.\nDependencias y configuración (Módulo compartido KMP) Añade Ktor Client y Kotlinx Serialization a tu módulo compartido. Usa el motor CIO u OkHttp en Android; usa CIO o Darwin en iOS (CIO permite compartir el mismo motor en móviles). Mantén las versiones alineadas con tu configuración de Kotlin/AGP.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // build.gradle.kts del módulo compartido plugins { kotlin(\u0026#34;multiplatform\u0026#34;) id(\u0026#34;com.android.library\u0026#34;) kotlin(\u0026#34;plugin.serialization\u0026#34;) // para kotlinx.serialization } kotlin { androidTarget() iosX64(); iosArm64(); iosSimulatorArm64() sourceSets { val ktorVersion = \u0026#34;2.3.12\u0026#34; val commonMain by getting { dependencies { implementation(\u0026#34;io.ktor:ktor-client-core:$ktorVersion\u0026#34;) implementation(\u0026#34;io.ktor:ktor-client-content-negotiation:$ktorVersion\u0026#34;) implementation(\u0026#34;io.ktor:ktor-serialization-kotlinx-json:$ktorVersion\u0026#34;) implementation(\u0026#34;io.ktor:ktor-client-logging:$ktorVersion\u0026#34;) // Opcional: Resources, Auth, etc.  // implementation(\u0026#34;io.ktor:ktor-client-auth:$ktorVersion\u0026#34;)  } } val androidMain by getting { dependencies { // Elige UNO: OkHttp o CIO  implementation(\u0026#34;io.ktor:ktor-client-okhttp:$ktorVersion\u0026#34;) // implementation(\u0026#34;io.ktor:ktor-client-cio:$ktorVersion\u0026#34;)  } } val iosMain by getting { dependencies { implementation(\u0026#34;io.ktor:ktor-client-cio:$ktorVersion\u0026#34;) // o usa Darwin para la pila nativa  // implementation(\u0026#34;io.ktor:ktor-client-darwin:$ktorVersion\u0026#34;)  } } } }   Consejo: Prefiere CIO tanto en Android como en iOS para compartir el mismo motor: usa ktor-client-cio en ambos. Alternativamente, mantén OkHttp en Android (ktor-client-okhttp) y Darwin en iOS (ktor-client-darwin).\nFactoría de HttpClient con motores (CIO u OkHttp) Crea un único lugar donde configuras tu HttpClient. Usa expect/actual para proporcionar el motor por plataforma y mantener el resto del código en común.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // commonMain (imports omitidos en el snippet) expect fun provideEngine(): HttpClientEngineFactory\u0026lt;*\u0026gt; fun createHttpClient(baseUrl: String, enableLogs: Boolean = true): HttpClient = HttpClient(provideEngine()) { expectSuccess = false // gestionaremos manualmente las respuestas no 2xx  install(ContentNegotiation) { json( Json { ignoreUnknownKeys = true isLenient = true encodeDefaults = true } ) } install(HttpTimeout) { requestTimeoutMillis = 15_000 connectTimeoutMillis = 10_000 socketTimeoutMillis = 15_000 } if (enableLogs) { install(Logging) { logger = Logger.DEFAULT level = LogLevel.INFO } } // Cabeceras por defecto o base URL se pueden manejar por petición o con un helper  }   Motores por plataforma:\n1 2  // androidMain (imports omitidos) actual fun provideEngine(): HttpClientEngineFactory\u0026lt;*\u0026gt; = OkHttp   1 2  // jvmMain (si aplica) (imports omitidos) actual fun provideEngine(): HttpClientEngineFactory\u0026lt;*\u0026gt; = CIO   1 2  // iosMain (imports omitidos) actual fun provideEngine(): HttpClientEngineFactory\u0026lt;*\u0026gt; = CIO // o Darwin si prefieres la pila nativa   Configuración específica de OkHttp (opcional):\n1 2 3 4 5 6 7 8 9 10 11 12 13  // androidMain - dentro de HttpClient(OkHttp) { engine { ... } } si lo incrustas engine { config { followRedirects(true) retryOnConnectionFailure(true) } addInterceptor { chain -\u0026gt; val request = chain.request().newBuilder() .header(\u0026#34;X-App-Version\u0026#34;, \u0026#34;1.0\u0026#34;) .build() chain.proceed(request) } }   Ajustes de CIO:\n1 2 3 4 5 6  // jvmMain - con CIO engine { requestTimeout = 15_000 threadsCount = 4 pipelining = true }   De servicios de Retrofit a llamadas con Ktor Servicio típico de Retrofit:\n1 2 3 4 5 6 7 8  // Retrofit interface UserService { @GET(\u0026#34;users/{id}\u0026#34;) suspend fun getUser(@Path(\u0026#34;id\u0026#34;) id: String): UserDto @POST(\u0026#34;users\u0026#34;) suspend fun createUser(@Body body: CreateUserRequest): UserDto }   Sustitución con Ktor en la implementación remota (mantén la interfaz que ya usa tu repositorio):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // Contrato remoto común usado por el Repositorio data class CreateUserRequest(val name: String) interface UserRemote { suspend fun getUser(id: String): UserDto suspend fun createUser(body: CreateUserRequest): UserDto } class UserRemoteImpl( private val client: HttpClient, private val baseUrl: String, ) : UserRemote { override suspend fun getUser(id: String): UserDto = client.get(\u0026#34;$baseUrl/users/$id\u0026#34;).body() override suspend fun createUser(body: CreateUserRequest): UserDto = client.post(\u0026#34;$baseUrl/users\u0026#34;) { contentType(io.ktor.http.ContentType.Application.Json) setBody(body) }.body() }   Parámetros de query y cabeceras mapean directamente:\n1 2 3 4 5 6 7  client.get(\u0026#34;$baseUrl/search\u0026#34;) { url { parameters.append(\u0026#34;q\u0026#34;, \u0026#34;john\u0026#34;) parameters.append(\u0026#34;page\u0026#34;, \u0026#34;1\u0026#34;) } headers.append(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer $token\u0026#34;) }   Gestión de errores y mapeo A diferencia de Retrofit, Ktor no lanza excepción para códigos no-2xx si expectSuccess = false. Maneja las respuestas explícitamente o captura excepciones de cliente/servidor.\n1 2 3 4 5 6 7 8  suspend fun \u0026lt;T\u0026gt; HttpResponse.safeBody(): T { if (status.isSuccess()) return body() val raw = bodyAsText() // Parsea el error de dominio si tu backend devuelve JSON estructurado  throw ApiException(status, raw) } class ApiException(val status: HttpStatusCode, message: String) : Exception(message)   Uso:\n1 2  val response = client.get(\u0026#34;$baseUrl/users/$id\u0026#34;) val user: UserDto = response.safeBody()   Alternativamente, configura expectSuccess = true y captura ClientRequestException/ServerResponseException.\nAutenticación, interceptores y logging  DefaultRequest: cabeceras aplicadas a cada petición Auth plugin: flujos Bearer/Basic si lo prefieres Logging plugin: logs de request/response (evita PII en producción)  1 2 3 4 5 6 7 8 9  HttpClient(provideEngine()) { install(DefaultRequest) { headers.append(\u0026#34;Accept\u0026#34;, \u0026#34;application/json\u0026#34;) // headers.append(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer $token\u0026#34;) // inyecta el token vía DI  } install(Logging) { level = LogLevel.HEADERS } }   Con el motor OkHttp, también puedes reutilizar Interceptors existentes (p. ej., inspección de red, reintentos personalizados), como se mostró antes.\nMantén intactos los límites de arquitectura  Mantén tu interfaz UserRemote (o similar) en commonMain Migra solo la implementación de Retrofit → Ktor Los repositorios dependen de la interfaz, por lo que el resto de la app no cambia  1 2 3  class UserRepository(private val remote: UserRemote) { suspend fun getUser(id: String) = remote.getUser(id) }   Testear con MockEngine de Ktor Puedes testear tu implementación remota sin tocar la red usando MockEngine.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  fun testClient(): HttpClient = HttpClient(MockEngine) { engine { addHandler { request -\u0026gt; if (request.url.fullPath == \u0026#34;/users/123\u0026#34;) { respond( content = \u0026#34;\u0026#34;\u0026#34;{\u0026#34;id\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Jane\u0026#34;}\u0026#34;\u0026#34;\u0026#34;, headers = headersOf(HttpHeaders.ContentType, \u0026#34;application/json\u0026#34;), status = HttpStatusCode.OK ) } else respondError(HttpStatusCode.NotFound) } } install(ContentNegotiation) { json() } }   Checklist de migración  Añade dependencias de Ktor y kotlinx-serialization al módulo compartido Crea una factoría de HttpClient con motor por plataforma (Android: OkHttp o CIO; iOS: CIO o Darwin) Instala ContentNegotiation(Json), HttpTimeout, Logging Porta tus servicios de Retrofit a una implementación remota basada en Ktor Mantén repositorio/dominio sin cambios; intercambia solo la implementación remota en el DI Maneja errores de forma consistente; considera un wrapper Result/Either Escribe tests con MockEngine para casos de éxito y error  Decisiones frecuentes  ¿CIO vs OkHttp en Android?  OkHttp: reutiliza interceptors/TLS/pinning existentes; depuración familiar CIO: motor Ktor/JVM puro, menos dependencias externas   Serialización: kotlinx-serialization es idiomática en KMP; migra tus DTOs a @Serializable Caché: impleméntala en la capa de repositorio; Ktor no impone políticas  Conclusión Migrar de Retrofit/OkHttp a Ktor es un primer paso enfocado y de bajo riesgo hacia KMP. Con una arquitectura limpia, solo cambias las interfaces/implementaciones remotas mientras el resto de la app permanece estable. Empieza con una funcionalidad, valida con tests y expande con confianza en tu base de código.\n","description":"Guía paso a paso para migrar tu capa de red de Android desde Retrofit/OkHttp a Ktor en un proyecto Kotlin Multiplatform, con motores CIO u OkHttp y mínimo impacto fuera de la capa remota.","id":3,"section":"posts","tags":["kotlin","multiplatform","kmp","ktor","retrofit","okhttp","android","networking","migration"],"title":"De Retrofit/OkHttp a Ktor en Kotlin Multiplatform: una primera migración práctica","uri":"https://carrion.dev/es/posts/migrating-retrofit-okhttp-to-ktor-kmp/"},{"content":"Estructuras de Datos en Kotlin: Qué usar y cuándo Elegir bien la estructura de datos es una de las decisiones de rendimiento más influyentes. Kotlin ofrece APIs expresivas y seguras en tipos sobre las colecciones del JVM, además de opciones específicas como ArrayDeque y colecciones inmutables vía kotlinx.collections.immutable.\nEsta guía se centra en la elección práctica: qué usar, cuándo usarlo y qué esperar en términos de complejidad temporal.\nTL;DR: Recomendaciones rápidas  ¿Necesitas una secuencia ordenada, indexable, redimensionable y con acceso aleatorio rápido? Usa MutableList (respaldada por ArrayList). ¿Necesitas comprobaciones de pertenencia rápidas sin duplicados y sin orden específico? Usa HashSet. ¿Necesitas búsquedas clave→valor sin orden específico? Usa HashMap. ¿Necesitas preservar el orden de inserción? Usa LinkedHashSet / LinkedHashMap. ¿Necesitas prioridad por una puntuación? Usa PriorityQueue. ¿Necesitas operaciones rápidas de cola/deque (en los extremos)? Usa ArrayDeque. ¿Necesitas ordenación y consultas por rango? Usa TreeSet / TreeMap (Java). ¿Necesitas colecciones persistentes/inmutables para compartir entre hilos o capas? Considera kotlinx.collections.immutable.  Colecciones en Kotlin 101  Interfaces: List, Set, Map\u0026lt;K, V\u0026gt; con contrapartes mutables MutableList, MutableSet, MutableMap. Implementaciones por defecto del JVM empleadas por Kotlin:  MutableList → ArrayList MutableSet → LinkedHashSet por defecto con mutableSetOf(), HashSet cuando se solicita explícitamente MutableMap → LinkedHashMap por defecto con mutableMapOf(), HashMap cuando se solicita explícitamente   Arrays: Array de Kotlin es de tamaño fijo y boxea los elementos; los arrays primitivos (IntArray, LongArray, etc.) evitan boxing y son muy eficientes.  Consejo: Programa contra interfaces (List, Set, Map) y elige el tipo concreto solo donde construyes la colección.\nListas: List y MutableList (ArrayList, LinkedList)   ArrayList (implementación por defecto de MutableList)\n Acceso por índice: O(1) Añadir al final: O(1) amortizado Insertar/eliminar en índice arbitrario: O(n) (desplaza elementos) Contiene (por equals): O(n) Iteración: O(n) Memoria: array contiguo; puede sobreasignar para crecer    LinkedList (LinkedList de Java si la eliges deliberadamente)\n Acceso por índice: O(n) Añadir/eliminar en extremos: O(1) Insertar/eliminar en posición del iterador: O(1) tras navegar Contiene: O(n) Mayor sobrecarga de memoria por elemento; peor localidad de caché    Cuándo elegir cada una:\n Prefiere ArrayList en la mayoría de casos: acceso aleatorio, appends, iteración. Considera LinkedList solo cuando haces muchas inserciones/eliminaciones en mitad mediante iteradores y rara vez accedes por índice.  Consejos Kotlin:\n Usa buildList para construcción conveniente. Para exponer solo lectura sobre una lista mutable, expón List no MutableList.  Arrays vs Listas  Array  Tamaño fijo, get/set O(1) por índice Ideal cuando el tamaño se conoce y necesitas máximo rendimiento, o con arrays primitivos (IntArray, etc.) para evitar boxing   MutableList  Redimensionable, APIs más cómodas para inserción/eliminación    Regla general: prefiere MutableList salvo que necesites arrays primitivos o tamaño fijo.\nConjuntos: HashSet, LinkedHashSet, TreeSet  HashSet  add/remove/contains: Promedio O(1), Peor O(n) Sin garantías de orden   LinkedHashSet  add/remove/contains: Promedio O(1) Preserva el orden de inserción; algo más de memoria que HashSet   TreeSet (Java)  add/remove/contains: O(log n) Mantiene ordenación por Comparable o Comparator    Cuándo usar:\n Usa HashSet para pertenencia rápida cuando el orden no importa. Usa LinkedHashSet cuando necesitas orden de iteración estable (p. ej., para UI consistente). Usa TreeSet para conjuntos ordenados y consultas por rango (headSet/tailSet/subSet).  Mapas: HashMap, LinkedHashMap, TreeMap  HashMap  put/get/remove: Promedio O(1), Peor O(n) Sin orden   LinkedHashMap  put/get/remove: Promedio O(1) Preserva el orden de inserción (también soporta orden por acceso con APIs de Java)   TreeMap (Java)  put/get/remove: O(log n) Claves ordenadas; soporta operaciones por rango    Cuándo usar:\n Usa HashMap para búsquedas rápidas generales. Usa LinkedHashMap cuando necesitas orden de iteración predecible. Usa TreeMap para claves ordenadas, ceiling/floor, rangos.  Colas, Deques, Pilas   ArrayDeque (stdlib de Kotlin)\n addFirst/addLast/removeFirst/removeLast/peek: O(1) amortizado Excelente para colas (FIFO) y deques; también mejor pila que java.util.Stack    PriorityQueue (Java)\n push/pop/peek: O(log n) Recupera por prioridad mínima/máxima (min-heap por defecto)    Consejo Kotlin: Usa ArrayDeque para semánticas de pila/cola salvo que necesites orden por prioridad.\nColecciones Ordenadas  Prefiere TreeSet/TreeMap para colecciones siempre ordenadas con actualizaciones. Para ordenar una lista puntualmente, usa sorted(), sortedBy(), sortedWith() que son O(n log n).  Colecciones Inmutables y Persistentes  Las interfaces List/Set/Map de Kotlin tienen variantes de solo lectura (p. ej., List) pero no son profundamente inmutables — la instancia subyacente puede ser mutable. Para inmutabilidad real y persistencia con sharing estructural, usa kotlinx.collections.immutable:  PersistentList, PersistentSet, PersistentMap Operaciones típicas O(log n) con constantes pequeñas; excelentes para compartir entre hilos y modelos de deshacer/rehacer.    Ejemplo:\n1 2  val pl: PersistentList\u0026lt;Int\u0026gt; = persistentListOf(1, 2, 3) val pl2 = pl.add(4) // devuelve una nueva lista; la original no cambia   Hoja de Trucos de Complejidad Temporal   ArrayList (MutableList por defecto)\n get/set: O(1) addLast: O(1) amortizado add/remove en índice: O(n) contains: O(n)    LinkedList\n get/set por índice: O(n) add/remove en extremos: O(1) contains: O(n)    HashSet / HashMap\n add/remove/contains (set), put/get/remove (map): Promedio O(1), Peor O(n)    LinkedHashSet / LinkedHashMap\n Igual que las variantes hash con orden de iteración estable    TreeSet / TreeMap\n add/remove/contains / put/get/remove: O(log n)    ArrayDeque\n add/remove en extremos: O(1) amortizado    PriorityQueue\n offer/poll/peek: O(log n)    Colecciones persistentes (inmutables)\n add/remove/update: Típicamente O(log n)    Elegir la Estructura Correcta: Escenarios Prácticos  Necesitas deduplicar y comprobar pertenencia rápido → HashSet. Necesitas mantener el orden de inserción para renderizar UI → LinkedHashMap o LinkedHashSet. Necesitas claves ordenadas con operaciones por rango → TreeMap. Necesitas acceso aleatorio frecuente por índice → ArrayList. Necesitas una cola FIFO o pila LIFO de alto rendimiento → ArrayDeque. Necesitas extraer repetidamente el menor/mayor → PriorityQueue con Comparator. Necesitas compartir estado entre hilos sin bloqueos y con flujo claro → kotlinx.collections.immutable.  Consejos de Rendimiento Específicos de Kotlin  Prefiere interfaces en APIs públicas (List, Set, Map) para poder cambiar la implementación. Pre-dimensiona cuando conozcas el tamaño aproximado (p. ej., ArrayList(capacity)) para reducir realocaciones. Usa arrays primitivos (IntArray, etc.) para bucles intensivos y datos numéricos grandes. Prefiere sequence para pipelines grandes cuando quieras pereza; prefiere listas cuando quieras materialización y acceso aleatorio. Ojo con el boxing al usar colecciones genéricas de primitivos.  Errores Comunes  Exponer MutableList/MutableMap en APIs filtra mutabilidad; expón interfaces de solo lectura. Asumir que List es inmutable en Kotlin — es solo una vista de solo lectura. Ignorar necesidades de orden de iteración; HashMap/HashSet no lo garantizan. Usar LinkedList para cargas de trabajo de acceso aleatorio — será lenta.  Reflexión Final Elige la estructura más simple que cumpla tus necesidades semánticas (orden, unicidad, búsqueda por clave) y optimiza más solo cuando el perfilado lo justifique. Las colecciones estándar de Kotlin, junto con extras como ArrayDeque y las colecciones persistentes, cubren la mayoría de escenarios con gran ergonomía y rendimiento.\n","description":"Guía práctica de colecciones y estructuras de datos en Kotlin: cómo se comportan, cuándo usarlas y sus complejidades de tiempo.","id":4,"section":"posts","tags":["kotlin","colecciones","estructuras-de-datos","algoritmos","complejidad"],"title":"Estructuras de Datos en Kotlin: Qué usar y cuándo","uri":"https://carrion.dev/es/posts/kotlin-data-structures-guide/"},{"content":"Kotlin 2.4 Rich Errors: Qué son y cómo prepararte Kotlin 2.4 introduce “Rich errors” (errores enriquecidos): una forma más expresiva y estructurada de representar y propagar fallos. El objetivo es claro: hacer que los flujos de error sean visibles y componibles en toda tu base de código y en múltiples plataformas, sin perder la ergonomía de Kotlin ni su gran historia de interoperabilidad.\nEste artículo explica los problemas que Rich errors resuelven, cómo se relacionan con las excepciones y Result actuales, qué implican en cuanto a modelo mental e interop, y cómo preparar tu base de código para adoptarlos sin fricciones.\n¿Por qué Rich Errors? El manejo de errores basado en excepciones es potente, pero tiene inconvenientes:\n Flujo de control oculto: las excepciones no aparecen en las firmas de las funciones Mezcla de preocupaciones: los tipos lanzados no siempre son explícitos o estructurados Fricción en la composición: componer resultados entre capas suele requerir try/catch Matices multiplataforma: mapear excepciones entre plataformas puede ser desigual  Kotlin ya ofrece Result\u0026lt;T\u0026gt; y utilidades funcionales que cubren parte de esto. Rich errors amplían la idea: hacer explícito, tipado y componible el canal de fallo, manteniendo una excelente interop con el código existente.\nModelo mental A alto nivel, Rich errors aspira a:\n Hacer explícitos y de primera clase los tipos de error (p. ej., jerarquías de error de dominio) Componer limpiamente a través de límites suspend/async Interoperar con excepciones (p. ej., mapear de/para excepciones cuando sea necesario) Preservar tipado estructurado en módulos multiplataforma  Piensa en ello como llevar la claridad de los tipos de error sellados junto con la ergonomía de las herramientas estándar de Kotlin al lenguaje y su ecosistema. Los siguientes patrones ilustran cómo se ve en la práctica.\nSintaxis real: Errores con tipo unión Kotlin 2.4 introduce retornos con tipo unión. Una función puede declarar su tipo de éxito y el conjunto de variantes de error que puede producir, todo en el tipo de retorno:\n1 2 3 4 5 6 7 8  // API básica con retorno unión fun obtenerUsuario(id: UserId): Usuario | NoEncontrado | FallaDeRed // API suspend con varios errores de dominio suspend fun subirAvatar(archivo: Imagen): Url | FormatoNoSoportado | CuotaExcedida | FallaDeRed // Propagación de uniones entre capas fun cargarPerfil(id: UserId): Perfil | NoEncontrado | FallaDeRed | ErrorDeDecodificacion   En el sitio de llamada, manejas la unión con when y smart‑casts:\n1 2 3 4 5  when (val r = obtenerUsuario(idActual)) { is Usuario -\u0026gt; mostrarPerfil(r) is NoEncontrado -\u0026gt; mostrarUsuarioInexistente() is FallaDeRed -\u0026gt; mostrarMensajeSinConexion(r) }   También puedes mapear una unión a estado de UI (u otra unión), preservando exhaustividad:\n1 2 3 4 5  fun aUi(resultado: Token | CredencialesInvalidas | FallaDeRed): Ui = when (resultado) { is Token -\u0026gt; Ui.Autenticado(resultado) is CredencialesInvalidas -\u0026gt; Ui.Error(\u0026#34;Credenciales inválidas\u0026#34;) is FallaDeRed -\u0026gt; Ui.Error(\u0026#34;Revisa tu conexión\u0026#34;) }   Nota: Los nombres de estos ejemplos son ilustrativos; la idea clave es que el canal de error es de primera clase en el tipo de la función, habilitando mejor tooling, chequeo de exhaustividad y composición.\nComparativa: Result vs Rich Errors Aquí tienes dos comparativas pequeñas y realistas que muestran el mismo flujo con Result de Kotlin hoy y con Rich errors.\n Ejemplo A — Leer y parsear configuración  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // Result hoy fun cargarConfig(ruta: Path): Result\u0026lt;Config\u0026gt; = runCatching { fs.readBytes(ruta) } .mapCatching { bytes -\u0026gt; parsearConfig(bytes) } .recover { e -\u0026gt; if (e is NoSuchFileException) configPorDefecto() else throw e } fun usarConfig(ruta: Path) { cargarConfig(ruta) .onSuccess { cfg -\u0026gt; iniciarApp(cfg) } .onFailure { e -\u0026gt; when (e) { is NoSuchFileException -\u0026gt; mostrarAvisoConfigInexistente() is ConfigFormatException -\u0026gt; mostrarErrorParseoConfig(e) else -\u0026gt; mostrarErrorGenerico(e) } } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  // Rich errors // Variantes de error (objetos/clases de dominio) data object FallaIO data class FallaParseo(val detalle: String) fun cargarConfig(ruta: Path): Config | FallaIO | FallaParseo fun usarConfigRico(ruta: Path) { when (val r = cargarConfig(ruta)) { is Config -\u0026gt; iniciarApp(r) is FallaIO -\u0026gt; mostrarAvisoConfigInexistente() is FallaParseo -\u0026gt; mostrarErrorParseoConfigMensaje(r.detalle) } }    Ejemplo B — Componer dos llamadas (sesión -\u0026gt; panel)  1 2 3 4 5 6 7 8 9  // Result hoy suspend fun obtenerSesionResult(usuario: UserId): Result\u0026lt;Sesion\u0026gt; suspend fun obtenerPanelResult(sesion: Sesion): Result\u0026lt;Panel\u0026gt; inline fun \u0026lt;T, R\u0026gt; Result\u0026lt;T\u0026gt;.flatMap(transform: (T) -\u0026gt; Result\u0026lt;R\u0026gt;): Result\u0026lt;R\u0026gt; = fold(onSuccess = transform, onFailure = { Result.failure(it) }) suspend fun cargarInicioResult(usuario: UserId): Result\u0026lt;Panel\u0026gt; = obtenerSesionResult(usuario).flatMap { s -\u0026gt; obtenerPanelResult(s) }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // Rich errors // Variantes de error de dominio data object FallaAutenticacion data object FallaDeRed data object FallaBackend suspend fun obtenerSesion(usuario: UserId): Sesion | FallaAutenticacion | FallaDeRed suspend fun obtenerPanel(sesion: Sesion): Panel | FallaDeRed | FallaBackend suspend fun cargarInicio(usuario: UserId): Panel | FallaAutenticacion | FallaDeRed | FallaBackend = when (val s = obtenerSesion(usuario)) { is Sesion -\u0026gt; when (val p = obtenerPanel(s)) { is Panel -\u0026gt; p is FallaDeRed -\u0026gt; p is FallaBackend -\u0026gt; p } is FallaAutenticacion -\u0026gt; s is FallaDeRed -\u0026gt; s }   Interop: Excepciones, Result, Coroutines y Multiplatform  Excepciones: Las librerías y APIs de plataforma que lanzan siguen funcionando. Rich errors provee mapeo en ambas direcciones, para trabajar con errores tipados internamente y convertir a excepciones en los bordes (o viceversa). Result: Es sencillo adaptar entre Result\u0026lt;T\u0026gt; y una representación de error tipado más rica al cruzar capas. Coroutines: La cancelación es especial y no debe tragarse; trata CancellationException como una señal de flujo de control, no un error. Multiplatform: Mantén los dominios de error en commonMain como interfaces selladas; proporciona mapeos específicos de plataforma cuando te enfrentes a excepciones de plataforma.  Estrategia de migración que puedes empezar hoy  Modela jerarquías de error pragmáticas donde aporten valor (sin sobre‑modelar) Lanza excepciones solo en los bordes; internamente prefiere canales de error tipados Añade mapeadores ligeros para convertir excepciones \u0026lt;-\u0026gt; errores tipados  Trampas y gotchas  Sobre-modelado: Mantén los tipos de error pragmáticos; no explotes la jerarquía Claridad en los bordes: Decide dónde conviertes entre excepciones y errores tipados Cancelación: Vuelve a lanzar siempre CancellationException Logging: Centraliza el logging; evita el doble log en múltiples capas  Conclusiones  Rich errors buscan hacer los fallos explícitos, tipados y componibles Hoy puedes obtener el 80% del beneficio usando tipos de error sellados + Result/Outcome Modela errores en commonMain para KMP y convierte en los bordes de plataforma  ","description":"Una visión general de los Rich Errors en Kotlin 2.4: objetivos, modelo mental, ejemplos, interop con excepciones y Result, y cómo preparar tu base de código desde hoy.","id":5,"section":"posts","tags":["kotlin","manejo-de-errores","excepciones","result","kotlin-2-4"],"title":"Kotlin 2.4 Rich Errors: Qué son y cómo prepararte","uri":"https://carrion.dev/es/posts/kotlin-24-rich-errors/"},{"content":"Inyección de Dependencias + Inversión de Dependencias: Código más Robusto y Testeable Las aplicaciones modernas evolucionan rápido: se añaden funcionalidades, se multiplican las plataformas y los equipos crecen. En este contexto, el acoplamiento fuerte se convierte en un freno al cambio y en una fuente de tests frágiles. Dos ideas clave nos ayudan a combatir esta complejidad:\n Principio de Inversión de Dependencias (DIP) de SOLID: los módulos de alto nivel no deben depender de los de bajo nivel. Ambos deben depender de abstracciones. Inyección de Dependencias (DI): técnica y conjunto de herramientas para proveer esas dependencias desde fuera en lugar de construirlas internamente.  En este artículo veremos por qué importa DIP, cómo DI lo hace cumplir y cómo usar un framework de DI vuelve tu código más robusto y fácil de testear, con ejemplos en Kotlin aplicables a otros lenguajes.\nInversión de Dependencias en pocas palabras (la “D” de SOLID) DIP promueve diseñar alrededor de abstracciones (interfaces) en lugar de implementaciones concretas. El objetivo es desacoplar la lógica de negocio (alto nivel) de los detalles de infraestructura (bajo nivel):\n Los módulos de alto nivel dependen de interfaces que definen o controlan Los módulos de bajo nivel implementan esas interfaces La composición ocurre en los bordes (inicio de la app, contenedor DI, fábricas)  Esto reduce el efecto dominó de los cambios y facilita la sustitución y las pruebas.\n1 2 3 4 5 6 7 8 9  // Política de alto nivel interface PaymentProcessor { suspend fun charge(amount: Money): Result\u0026lt;Unit\u0026gt; } // Implementación de bajo nivel class StripePaymentProcessor(private val api: StripeApi) : PaymentProcessor { override suspend fun charge(amount: Money): Result\u0026lt;Unit\u0026gt; = api.charge(amount) }   Qué aporta la Inyección de Dependencias DI es la práctica de proveer implementaciones concretas a los componentes desde fuera. En lugar de construir dependencias con new (o dentro del constructor) en una clase, las aceptamos por parámetros de constructor (o setters), y una raíz de composición (a menudo un framework de DI) cablea el grafo. Beneficios:\n Desacoplo: las clases dependen de interfaces, no de cómo crearlas Testeabilidad: las dependencias se reemplazan fácilmente con fakes/mocks Responsabilidad Única: las clases se enfocan en comportamiento, no en construcción Reemplazabilidad: intercambiar implementaciones sin tocar los consumidores  1 2 3 4 5 6  class CheckoutService(private val paymentProcessor: PaymentProcessor) { suspend fun checkout(cart: Cart): Result\u0026lt;Unit\u0026gt; { // solo lógica de negocio  return paymentProcessor.charge(cart.total()) } }   CheckoutService no conoce Stripe, PayPal ni clientes HTTP: solo la abstracción.\nAntes vs Después: Un ejemplo concreto Sin DIP/DI (fuertemente acoplado):\n1 2 3 4 5 6 7 8 9  class CheckoutService { private val api = StripeApi(httpClient = HttpClient()) private val processor = StripePaymentProcessor(api) suspend fun checkout(cart: Cart): Result\u0026lt;Unit\u0026gt; { // Difícil de testear: se cuelan red y detalles de Stripe  return processor.charge(cart.total()) } }   Problemas:\n Difícil de testear unitariamente (requiere red o herramientas de mockeo pesadas) Cambiar proveedor (Stripe -\u0026gt; PayPal) obliga a tocar esta clase Viola SRP al mezclar construcción y reglas de negocio  Con DIP + DI:\n1 2 3  class CheckoutService(private val paymentProcessor: PaymentProcessor) { suspend fun checkout(cart: Cart): Result\u0026lt;Unit\u0026gt; = paymentProcessor.charge(cart.total()) }   Composición (con cualquier estilo de DI):\n1 2 3  val api = StripeApi(HttpClient()) val processor: PaymentProcessor = StripePaymentProcessor(api) val service = CheckoutService(processor)   El test se vuelve trivial:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class FakePaymentProcessor : PaymentProcessor { var lastAmount: Money? = null override suspend fun charge(amount: Money): Result\u0026lt;Unit\u0026gt; { lastAmount = amount return Result.success(Unit) } } @Test fun `checkout cobra el total del carrito`() = runTest { val fake = FakePaymentProcessor() val service = CheckoutService(fake) val result = service.checkout(cart = Cart(listOf(Line(\u0026#34;abc\u0026#34;, 100)))) assertTrue(result.isSuccess) assertEquals(Money(100), fake.lastAmount) }   Usar un framework de DI: por qué ayuda A medida que la aplicación crece, el cableado manual se vuelve propenso a errores. Los frameworks de DI actúan como motor de composición:\n Centralizan grafos de objetos y ciclos de vida (singleton, scoped, transient) Fuerzan dependencias explícitas (inyección por constructor) Aportan validación en compilación o en tiempo de ejecución  Opciones comunes según ecosistema:\n Kotlin/Android: Hilt/Dagger (tiempo de compilación, anotaciones), Koin (DSL), Kodein JVM/backend: Spring Framework/Spring Boot (anotaciones), Guice Multiplataforma: Koin funciona en KMP; muchos usan composición manual o Service Locator en el código compartido  Ejemplo con Koin (DSL simple):\n1 2 3 4 5 6 7 8 9 10  val appModule = module { single { HttpClient() } single { StripeApi(get()) } single\u0026lt;PaymentProcessor\u0026gt; { StripePaymentProcessor(get()) } factory { CheckoutService(get()) } } startKoin { modules(appModule) } val service: CheckoutService = get()   Ejemplo con Hilt (Android):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Module @InstallIn(SingletonComponent::class) object PaymentsModule { @Provides fun provideHttpClient(): HttpClient = HttpClient() @Provides fun provideStripeApi(client: HttpClient) = StripeApi(client) @Provides fun provideProcessor(api: StripeApi): PaymentProcessor = StripePaymentProcessor(api) } @HiltViewModel class CheckoutViewModel @Inject constructor( private val service: CheckoutService ) : ViewModel() { // ... }   Robustez y Testeabilidad en la práctica  Menor radio de impacto: cambios de infraestructura no se propagan a la lógica de negocio Tests deterministas: inyecta fakes; sin singletons ocultos ni estado global Fronteras claras: las interfaces modelan las costuras del sistema Mantenimiento más fácil: los constructores hacen visibles y revisables las dependencias  Checklist:\n ¿Mis módulos de alto nivel dependen solo de abstracciones que controlan? ¿Puedo intercambiar implementaciones sin editar los consumidores? ¿Los constructores son la única vía de entrada de dependencias? ¿Puedo testear sin red, disco o hilos?  Errores comunes y cómo evitarlos  Antipatrón Service Locator: evita obtener dependencias de un registro global dentro de las clases; prefiere inyección por constructor Módulos “Dios”: divide módulos de DI por feature/límite para evitar grafos gigantes Sobre-abstracción: no crees interfaces sin implementaciones alternativas o valor de test Estado oculto: evita singletons estáticos; prefiere ciclos de vida gestionados por DI  Conclusión Aplicar el Principio de Inversión de Dependencias y adoptar la Inyección de Dependencias produce un código más mantenible, extensible y testeable. Empieza pequeño: define interfaces en tus fronteras, inyecta dependencias por constructor y, conforme crezca tu grafo, introduce un framework de DI. La recompensa es notable: arquitectura más limpia, tests más rápidos y cambios más seguros.\n","description":"Cómo aplicar el Principio de Inversión de Dependencias de SOLID junto con un framework de Inyección de Dependencias conduce a código desacoplado, robusto y altamente testeable.","id":6,"section":"posts","tags":["architecture","solid","dependency-injection","testing"],"title":"Inyección de Dependencias + Inversión de Dependencias: Código más Robusto y Testeable","uri":"https://carrion.dev/es/posts/dependency-injection-benefits/"},{"content":"Reducción del Tamaño de Aplicaciones: Proguard, R8, App Bundles y Reducción de Recursos A medida que las aplicaciones móviles crecen en complejidad y funcionalidades, gestionar su tamaño se vuelve cada vez más importante. Las aplicaciones grandes provocan mayores tasas de abandono durante la instalación, consumen más almacenamiento del dispositivo y a menudo resultan en un rendimiento más lento. Esta guía completa explora varias técnicas para reducir el tamaño de tu aplicación Android, incluyendo la reducción de código con Proguard y R8, distribución moderna con App Bundles, y estrategias de optimización de recursos.\nEntendiendo los Componentes del Tamaño de una Aplicación Antes de adentrarnos en las técnicas de optimización, es importante entender qué contribuye al tamaño de tu aplicación:\n Código: Bytecode de Java/Kotlin, incluyendo el código de tu aplicación y bibliotecas Recursos: Imágenes, layouts, animaciones y otros assets Bibliotecas nativas: Código C/C++ compilado para diferentes arquitecturas Assets: Archivos sin procesar incluidos en tu aplicación  Cada componente requiere diferentes estrategias de optimización, y un enfoque integral aborda todas estas áreas.\n// Un desglose típico del tamaño de una aplicación podría ser: // - Código (DEX): 30-40% // - Recursos: 30-40% // - Bibliotecas nativas: 15-25% // - Assets: 5-15% Reducción de Código con Proguard y R8 La reducción de código es una de las formas más efectivas de reducir el tamaño de la aplicación al eliminar código no utilizado y optimizar lo que queda.\nProguard: El Enfoque Tradicional Proguard ha sido la herramienta estándar para la reducción de código en Android durante muchos años. Realiza varias optimizaciones:\n Reducción: Elimina clases, campos, métodos y atributos no utilizados Optimización: Optimiza el bytecode y elimina rutas de código no utilizadas Ofuscación: Renombra clases, campos y métodos con nombres más cortos Preverificación: Añade información de preverificación para simplificar el proceso de verificación en tiempo de ejecución  Para habilitar Proguard en el archivo build.gradle de tu aplicación, necesitas establecer minifyEnabled a true y especificar los archivos de reglas de Proguard:\nandroid { buildTypes { release { minifyEnabled true proguardFiles getDefaultProguardFile(\u0026quot;proguard-android-optimize.txt\u0026quot;), \u0026quot;proguard-rules.pro\u0026quot; } } } Un archivo de configuración básico de Proguard podría incluir:\n# Mantener la clase de aplicación -keep public class com.example.MyApplication # Mantener todas las clases en el paquete androidx -keep class androidx.** { *; } # Mantener todas las clases que tienen la anotación @Keep -keep class * { @androidx.annotation.Keep *; } -keepclasseswithmembers class * { @androidx.annotation.Keep \u0026lt;methods\u0026gt;; } -keepclasseswithmembers class * { @androidx.annotation.Keep \u0026lt;fields\u0026gt;; } Reglas Comunes de Proguard para Bibliotecas Populares Cuando utilizas bibliotecas de terceros, a menudo necesitas reglas específicas de Proguard para asegurar que funcionen correctamente después de la reducción. Aquí hay ejemplos para algunas bibliotecas populares:\nRetrofit y OkHttp:\n# Retrofit -keepattributes Signature -keepattributes *Annotation* -keep class retrofit2.** { *; } -keepclasseswithmembers class * { @retrofit2.http.* \u0026lt;methods\u0026gt;; } # OkHttp -keepattributes Signature -keepattributes *Annotation* -keep class okhttp3.** { *; } -keep interface okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Gson:\n# Gson -keepattributes Signature -keepattributes *Annotation* -keep class com.google.gson.** { *; } -keep class * implements com.google.gson.TypeAdapter -keep class * implements com.google.gson.TypeAdapterFactory -keep class * implements com.google.gson.JsonSerializer -keep class * implements com.google.gson.JsonDeserializer -keepclassmembers,allowobfuscation class * { @com.google.gson.annotations.SerializedName \u0026lt;fields\u0026gt;; } Glide:\n# Glide -keep public class * implements com.bumptech.glide.module.GlideModule -keep class * extends com.bumptech.glide.module.AppGlideModule { \u0026lt;init\u0026gt;(...); } -keep public enum com.bumptech.glide.load.ImageHeaderParser$** { **[] $VALUES; public *; } Solución de Problemas Comunes con Proguard Cuando utilizas Proguard, podrías encontrarte con algunos problemas comunes:\n  ClassNotFoundException o NoSuchMethodError: Esto suele ocurrir cuando una clase o método utilizado a través de reflexión es eliminado o renombrado. Solución: Añade reglas keep para las clases afectadas.\n  Falta de serialización/deserialización: Las bibliotecas de análisis JSON como Gson dependen de los nombres de clases y campos. Solución: Añade reglas para preservar los nombres de las clases del modelo.\n  Fallos en bibliotecas de terceros: Algunas bibliotecas no son totalmente compatibles con la ofuscación. Solución: Consulta la documentación de la biblioteca para conocer las reglas de Proguard recomendadas.\n  Depuración de fallos ofuscados: Utiliza el archivo mapping.txt generado durante la compilación para desofuscar los rastros de pila:\n  // Añade esto a tu build.gradle para mantener el archivo de mapeo android { buildTypes { release { minifyEnabled true proguardFiles getDefaultProguardFile(\u0026quot;proguard-android-optimize.txt\u0026quot;), \u0026quot;proguard-rules.pro\u0026quot; testProguardFiles getDefaultProguardFile(\u0026quot;proguard-android-optimize.txt\u0026quot;), \u0026quot;proguard-rules.pro\u0026quot; } } } R8: El Sucesor Moderno R8 es el compilador predeterminado actual de Android que combina las capacidades de Proguard con optimizaciones adicionales:\n Inlining más agresivo: Integra más métodos para reducir el recuento de métodos Fusión de clases: Combina clases con funcionalidad similar Optimización de enumeraciones: Convierte enumeraciones a enteros cuando es posible Optimizaciones específicas de Kotlin: Mejor manejo de características específicas de Kotlin Tree shaking: Eliminación más agresiva de código no utilizado Desazucarización: Permite usar características más nuevas del lenguaje Java en versiones antiguas de Android  R8 está habilitado por defecto en Android Gradle Plugin 3.4.0 y versiones superiores. Puedes habilitar la optimización de R8 en modo completo configurando la desazucarización de la biblioteca principal en tu archivo build.gradle:\nandroid { compileOptions { // Habilitar la desazucarización de la biblioteca principal coreLibraryDesugaringEnabled true sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } buildTypes { release { // Habilitar R8 en modo completo minifyEnabled true proguardFiles getDefaultProguardFile(\u0026quot;proguard-android-optimize.txt\u0026quot;), \u0026quot;proguard-rules.pro\u0026quot; } } } dependencies { // Añadir la dependencia de desazucarización coreLibraryDesugaring \u0026quot;com.android.tools:desugar_jdk_libs:1.1.5\u0026quot; } Comparando Proguard y R8 Aunque R8 está diseñado para ser un reemplazo directo de Proguard, hay algunas diferencias clave:\n   Característica Proguard R8     Reducción de código Sí Sí (más agresivo)   Ofuscación Sí Sí   Optimización Sí Sí (más agresivo)   Soporte para Kotlin Limitado Mejorado   Velocidad de compilación Más lento Más rápido   Características de Java 8+ No Sí (con desazucarización)   Configuración Compleja Más simple (usa reglas de Proguard)    Reglas Específicas de R8 Aunque R8 utiliza reglas de Proguard, hay algunas reglas específicas de R8 que puedes usar:\n# Mantener la clase pero permitir que sus métodos sean eliminados si no se usan -keepclassmembers class com.example.MyClass { *; } # Mantener la clase y todos sus miembros, pero permitir la optimización -keepclasseswithmembers class com.example.MyClass { *; } # Específico de R8: Permitir inlining agresivo de un método -alwaysinline class com.example.MyClass { void myMethod(); } # Específico de R8: Prevenir inlining de un método -neverinline class com.example.MyClass { void myMethod(); } Depuración de Problemas con R8 Al solucionar problemas con R8, estos enfoques pueden ser útiles:\n Inspeccionar la salida de R8: Usa la bandera --debug para ver qué está haciendo R8:  android.buildTypes.release.proguardFiles += file(\u0026quot;debug-rules.pro\u0026quot;) Con debug-rules.pro conteniendo:\n-printusage unused.txt -printseeds seeds.txt -printmapping mapping.txt -verbose Deshabilitar optimizaciones específicas: Si sospechas que una optimización particular está causando problemas:  -optimizations !class/merging/vertical,!field/*,!method/inlining/* Usar la herramienta de reescritura de R8: Para desofuscar rastros de pila de fallos en producción:  java -jar r8.jar retrace --mapping mapping.txt obfuscated_stacktrace.txt Reducción y Optimización de Recursos Los recursos a menudo representan una parte significativa del tamaño de la aplicación. Aquí hay estrategias para optimizarlos:\nHabilitar la Reducción de Recursos La reducción de recursos elimina los recursos no utilizados de tu aplicación empaquetada. Puedes habilitarla en tu archivo build.gradle estableciendo shrinkResources a true junto con minifyEnabled.\nOptimización de Imágenes   Usar formato WebP: Convierte imágenes PNG a WebP para una mejor compresión\nWebP proporciona una compresión superior en comparación con PNG y JPEG mientras mantiene buena calidad. Puedes convertir tus imágenes usando Android Studio:\n Haz clic derecho en un recurso drawable Selecciona \u0026ldquo;Convert to WebP\u0026rdquo; Configura las opciones de codificación (con pérdida o sin pérdida) Revisa el ahorro de tamaño y la calidad  Para conversión por lotes, puedes usar la herramienta de línea de comandos:\ncwebp -q 80 input.png -o output.webp   Drawables vectoriales: Usa drawables vectoriales en lugar de múltiples archivos PNG para diferentes densidades:\n  1 2 3 4 5 6 7 8 9 10  \u0026lt;!-- vector_drawable.xml --\u0026gt; \u0026lt;vector xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:width=\u0026#34;24dp\u0026#34; android:height=\u0026#34;24dp\u0026#34; android:viewportWidth=\u0026#34;24\u0026#34; android:viewportHeight=\u0026#34;24\u0026#34;\u0026gt; \u0026lt;path android:fillColor=\u0026#34;#FF000000\u0026#34; android:pathData=\u0026#34;M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2z\u0026#34;/\u0026gt; \u0026lt;/vector\u0026gt;   Los drawables vectoriales son independientes de la resolución y típicamente mucho más pequeños que sus contrapartes bitmap. Para asegurar la compatibilidad con versiones antiguas de Android, añade esto a tu build.gradle:\nandroid { defaultConfig { vectorDrawables.useSupportLibrary = true } }  Recursos específicos de densidad: Proporciona solo los recursos de densidad necesarios configurando resConfigs en tu archivo build.gradle\nandroid { defaultConfig { // Incluye solo los buckets de densidad que necesitas resConfigs \u0026quot;nodpi\u0026quot;, \u0026quot;hdpi\u0026quot;, \u0026quot;xhdpi\u0026quot;, \u0026quot;xxhdpi\u0026quot; } }   Comprimir archivos PNG: Usa herramientas como pngquant o TinyPNG para optimizar archivos PNG sin pérdida significativa de calidad:\npngquant --quality=65-80 image.png   Carga diferida para imágenes grandes: En lugar de incluir imágenes grandes en tu aplicación, considera cargarlas bajo demanda desde un servidor.\n  Tintado de drawables: Usa una sola imagen en escala de grises y aplica tintes programáticamente en lugar de incluir múltiples versiones coloreadas.\n1 2 3 4 5 6 7  \u0026lt;!-- En archivo de layout --\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/icon\u0026#34; android:layout_width=\u0026#34;24dp\u0026#34; android:layout_height=\u0026#34;24dp\u0026#34; android:src=\u0026#34;@drawable/icon_grayscale\u0026#34; app:tint=\u0026#34;@color/colorPrimary\u0026#34; /\u0026gt;     Recursos de Idioma Limita los idiomas incluidos para reducir el tamaño del APK configurando resConfigs en tu archivo build.gradle para incluir solo los idiomas que tu aplicación soporta:\nandroid { defaultConfig { // Incluye solo los idiomas que soportas resConfigs \u0026quot;en\u0026quot;, \u0026quot;es\u0026quot;, \u0026quot;fr\u0026quot;, \u0026quot;de\u0026quot; } } Esta configuración elimina los archivos de recursos para idiomas no soportados, lo que puede reducir significativamente el tamaño de la aplicación, especialmente para aplicaciones con muchos recursos de cadenas.\nOptimización de Layouts   Aplanar jerarquías de vistas: Simplifica tus layouts para reducir el número de ViewGroups anidados:\n Usa ConstraintLayout en lugar de LinearLayouts anidados Evita vistas contenedoras innecesarias Usa el Layout Inspector para identificar jerarquías de vistas excesivamente complejas    Reutiliza layouts con : Extrae componentes UI comunes en archivos de layout separados e inclúyelos:\n1  \u0026lt;include layout=\u0026#34;@layout/common_header\u0026#34; /\u0026gt;     Usa estilos y temas: Define estilos para atributos de vista comunes en lugar de repetirlos:\n1 2 3 4 5  \u0026lt;style name=\u0026#34;AppButton\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:background\u0026#34;\u0026gt;@drawable/button_bg\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:textColor\u0026#34;\u0026gt;@color/button_text\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:padding\u0026#34;\u0026gt;8dp\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt;     Elimina recursos no utilizados: Usa la herramienta Lint para identificar recursos no utilizados:\n En Android Studio, ve a Analyze \u0026gt; Inspect Code Busca \u0026ldquo;Unused resources\u0026rdquo; en los resultados Elimina o marca los recursos como tools:keep si es necesario    Técnicas Avanzadas App Bundles y Entrega Dinámica Los Android App Bundles (AAB) representan una mejora significativa sobre los APKs tradicionales para la distribución de aplicaciones. Optimizan la entrega proporcionando solo el código y los recursos necesarios para cada dispositivo. Aquí te explicamos por qué deberías considerar usar App Bundles en lugar de APKs:\n  Tamaños de descarga más pequeños: Los App Bundles generan APKs optimizados para cada configuración de dispositivo, reduciendo los tamaños de descarga hasta en un 15% en comparación con un APK universal. Los usuarios solo descargan el código y los recursos que necesitan para su dispositivo específico.\n  Optimización automática de recursos de idioma: Los App Bundles entregan solo los recursos de idioma que coinciden con la configuración del dispositivo del usuario, eliminando traducciones innecesarias.\n  Optimización de densidad de pantalla: Solo se entregan los recursos de densidad de pantalla apropiados a cada dispositivo, evitando la inclusión de recursos gráficos no utilizados.\n  Entrega de código específico para cada arquitectura: Los usuarios reciben solo las bibliotecas nativas que coinciden con la arquitectura de CPU de su dispositivo (ARM, ARM64, x86, etc.) en lugar de todas las arquitecturas.\n  Entrega dinámica de características: Los App Bundles permiten la entrega bajo demanda de características que no son necesarias para el lanzamiento inicial de la aplicación, reduciendo aún más el tamaño de descarga inicial.\n  Publicación simplificada de aplicaciones: Los desarrolladores mantienen un solo artefacto para todas las configuraciones de dispositivos, y Google Play se encarga de la generación de APKs optimizados.\n  Play Feature Delivery: Permite opciones avanzadas de entrega como entrega condicional, entrega instantánea y entrega bajo demanda de características de la aplicación.\n  Actualizaciones más sencillas: Paquetes de actualización más pequeños, ya que los usuarios solo necesitan descargar los cambios relevantes para la configuración de su dispositivo.\n  Puedes configurar divisiones de idioma, densidad y ABI en tu archivo build.gradle para aprovechar al máximo los App Bundles:\nCaracterísticas bajo Demanda con Módulos de Características Dinámicas Divide tu aplicación en módulos base y de características que pueden descargarse bajo demanda. Esto requiere configurar módulos de características dinámicas en tu proyecto.\nOptimización de Bibliotecas Nativas Reduce el tamaño de las bibliotecas nativas incluyendo solo ABIs específicos y habilitando la compresión de bibliotecas nativas en tu archivo build.gradle.\nMedición y Monitoreo del Tamaño de la Aplicación Para optimizar eficazmente el tamaño de la aplicación, necesitas medirlo y monitorearlo durante todo el desarrollo:\n APK Analyzer: Utiliza el APK Analyzer integrado en Android Studio para inspeccionar los contenidos de tu APK Tarea personalizada de Gradle: Crea una tarea para informar sobre el tamaño de la aplicación después de cada compilación Integración CI: Añade comprobaciones de tamaño de aplicación a tu pipeline de CI  Puedes crear una tarea personalizada de Gradle para informar sobre el tamaño de la aplicación después de cada compilación, lo que ayuda a rastrear los cambios de tamaño a lo largo del tiempo.\nConclusión Reducir el tamaño de la aplicación es un desafío multifacético que requiere atención al código, los recursos y los mecanismos de entrega. Al implementar las técnicas discutidas en esta publicación—reducción de código con Proguard y R8, optimización de recursos, App Bundles y otros mecanismos de entrega avanzados—puedes reducir significativamente el tamaño de tu aplicación mientras mantienes o incluso mejoras su rendimiento.\nRecuerda que la optimización del tamaño de la aplicación es un proceso continuo. Analiza regularmente la composición de tu aplicación, monitorea los cambios de tamaño con cada versión y refina continuamente tus estrategias de optimización. Migrar de APKs tradicionales a App Bundles puede proporcionar beneficios inmediatos con un esfuerzo mínimo, convirtiéndolo en uno de los pasos más efectivos que puedes tomar. El resultado será una aplicación más eficiente que proporciona una mejor experiencia de usuario a través de descargas más rápidas, requisitos de almacenamiento reducidos y un mejor rendimiento en tiempo de ejecución.\n","description":"Una guía completa para reducir el tamaño de aplicaciones Android utilizando Proguard, R8, App Bundles y técnicas de reducción de recursos para un mejor rendimiento y experiencia de usuario.","id":7,"section":"posts","tags":["android","optimización","proguard","r8","app-bundles"],"title":"Reducción del Tamaño de Aplicaciones: Proguard, R8, App Bundles y Reducción de Recursos","uri":"https://carrion.dev/es/posts/reducing-app-size/"},{"content":"Manejo Elegante de Errores en Kotlin: Usando runCatching y Result El manejo de excepciones es un aspecto crítico para escribir aplicaciones robustas, pero los bloques tradicionales try/catch pueden llevar a código verboso y anidado que es difícil de leer y mantener. Kotlin ofrece un enfoque más elegante con la función runCatching y el tipo Result, que permiten manejar excepciones de manera funcional mientras se mantiene la legibilidad del código y se previenen fallos. Este artículo explora cómo utilizar efectivamente estas características para mejorar tu estrategia de manejo de errores.\nEntendiendo Result y runCatching La clase Result en Kotlin es una unión discriminada que encapsula un resultado exitoso con un valor de tipo T o un fallo con una excepción. Es similar al patrón Either que se encuentra en lenguajes de programación funcional.\nrunCatching es una función de la biblioteca estándar que ejecuta un bloque de código dado y envuelve el resultado en un objeto Result, capturando cualquier excepción que pueda ocurrir durante la ejecución.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Enfoque tradicional con try/catch fun getUserData(userId: String): UserData { try { val response = api.fetchUser(userId) return response.toUserData() } catch (e: NetworkException) { logger.error(\u0026#34;Error de red\u0026#34;, e) } } // Usando runCatching fun getUserData(userId: String): Result\u0026lt;UserData\u0026gt; { return runCatching { val response = api.fetchUser(userId) response.toUserData() } }   Aunque este ejemplo no muestra completamente los beneficios todavía, exploraremos patrones más poderosos a medida que avancemos.\nEl Poder de Result: Más Allá de try/catch El verdadero poder de Result proviene de su capacidad para ser pasado y transformado, permitiendo un enfoque más funcional para el manejo de errores.\nBeneficios Clave de Usar Result  Tipos de Error Explícitos: Hace visible el manejo de errores en las firmas de funciones Composición: Encadena fácilmente operaciones que podrían fallar Manejo de Errores Diferido: Separa la lógica de qué hacer del manejo de errores Flujo de Control Predecible: Evita que las excepciones interrumpan el flujo normal  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // Función que devuelve un Result fun fetchUserResult(userId: String): Result\u0026lt;UserData\u0026gt; { return runCatching { val response = api.fetchUser(userId) response.toUserData() } } // Usando el Result fun processUser(userId: String) { val userResult = fetchUserResult(userId) userResult.onSuccess { userData -\u0026gt; displayUserProfile(userData) analyticsTracker.logUserFetch(userData.id) }.onFailure { exception -\u0026gt; when (exception) { is NetworkException -\u0026gt; showOfflineMessage() is UserNotFoundException -\u0026gt; showUserNotFoundMessage() else -\u0026gt; showGenericErrorMessage() } } }   Transformando y Encadenando Results Uno de los aspectos más poderosos del tipo Result es la capacidad de transformar y encadenar operaciones, similar a cómo trabajarías con otros tipos monádicos como Optional o Stream en Java.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  fun getUserSettings(userId: String): Result\u0026lt;UserSettings\u0026gt; { return fetchUserResult(userId) .map { userData -\u0026gt; userData.settings } .recover { exception -\u0026gt; when (exception) { is UserNotFoundException -\u0026gt; UserSettings.createDefault() else -\u0026gt; throw exception } } } fun synchronizeUserData(userId: String): Result\u0026lt;SyncStatus\u0026gt; { return fetchUserResult(userId) .flatMap { userData -\u0026gt; runCatching { val cloudData = cloudService.fetchUserData(userId) syncService.merge(userData, cloudData) } } .map { mergedData -\u0026gt; saveUserData(mergedData) SyncStatus.Success(timestamp = System.currentTimeMillis()) } .recoverCatching { exception -\u0026gt; logger.warn(\u0026#34;Sincronización fallida\u0026#34;, exception) SyncStatus.Failed(reason = exception.message ?: \u0026#34;Error desconocido\u0026#34;) } }   Las funciones map, flatMap y recover te permiten transformar el valor de éxito o manejar excepciones específicas sin romper la cadena.\nPatrones Prácticos con Result Exploremos algunos patrones prácticos para usar Result en escenarios del mundo real.\n1. Patrón Repositorio con Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  interface UserRepository { fun getUser(id: String): Result\u0026lt;User\u0026gt; fun saveUser(user: User): Result\u0026lt;Unit\u0026gt; fun deleteUser(id: String): Result\u0026lt;Boolean\u0026gt; } class UserRepositoryImpl( private val remoteDataSource: UserRemoteDataSource, private val localDataSource: UserLocalDataSource ) : UserRepository { override fun getUser(id: String): Result\u0026lt;User\u0026gt; { return runCatching { val localUser = localDataSource.getUser(id) if (localUser != null) { return@runCatching localUser } val remoteUser = remoteDataSource.getUser(id) localDataSource.saveUser(remoteUser) remoteUser } } override fun saveUser(user: User): Result\u0026lt;Unit\u0026gt; { return runCatching { localDataSource.saveUser(user) remoteDataSource.saveUser(user) } } override fun deleteUser(id: String): Result\u0026lt;Boolean\u0026gt; { return runCatching { val localResult = localDataSource.deleteUser(id) val remoteResult = remoteDataSource.deleteUser(id) localResult \u0026amp;\u0026amp; remoteResult } } }   2. Capa de Servicio API con Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class ApiService(private val httpClient: HttpClient) { fun fetchData(endpoint: String): Result\u0026lt;ApiResponse\u0026gt; { return runCatching { val response = httpClient.get(endpoint) if (response.isSuccessful) { parseResponse(response.body) } else { throw HttpException(response.code, response.message) } } } private fun parseResponse(body: String): ApiResponse { return runCatching { jsonParser.fromJson(body, ApiResponse::class.java) }.getOrElse { e -\u0026gt; throw ParseException(\u0026#34;Error al analizar la respuesta\u0026#34;, e) } } }   3. Combinando Múltiples Results 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  fun loadDashboardData(userId: String): Result\u0026lt;DashboardData\u0026gt; { val userResult = userRepository.getUser(userId) val statsResult = statsRepository.getUserStats(userId) val notificationsResult = notificationService.getNotifications(userId) return runCatching { val user = userResult.getOrThrow() val stats = statsResult.getOrThrow() val notifications = notificationsResult.getOrNull() ?: emptyList() DashboardData( user = user, stats = stats, notifications = notifications ) } }   Técnicas Avanzadas 1. Extensiones Personalizadas de Result Puedes extender la clase Result con tus propias funciones de utilidad:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // Extensión para convertir Result a un tipo Either personalizado fun \u0026lt;T\u0026gt; Result\u0026lt;T\u0026gt;.toEither(): Either\u0026lt;Throwable, T\u0026gt; { return fold( onSuccess = { Either.Right(it) }, onFailure = { Either.Left(it) } ) } // Extensión para manejar tipos de error específicos inline fun \u0026lt;T, reified E : Throwable\u0026gt; Result\u0026lt;T\u0026gt;.onSpecificError( crossinline action: (E) -\u0026gt; Unit ): Result\u0026lt;T\u0026gt; { return onFailure { if (it is E) { action(it) } } } // Uso fetchUserResult(userId) .onSpecificError\u0026lt;User, NetworkException\u0026gt; { connectivityManager.retryConnection() } .onSuccess { user -\u0026gt; // Procesar usuario  }   2. Integración con Coroutines Result funciona perfectamente con coroutines:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  suspend fun fetchUserDataAsync(userId: String): Result\u0026lt;UserData\u0026gt; { return runCatching { val response = api.fetchUserAsync(userId).await() response.toUserData() } } // En un ámbito de coroutine viewModelScope.launch { val result = fetchUserDataAsync(userId) result.onSuccess { userData -\u0026gt; _uiState.value = SuccessState(userData) }.onFailure { error -\u0026gt; _uiState.value = ErrorState(error.message ?: \u0026#34;Error desconocido\u0026#34;) } }   Mejores Prácticas para Usar Result  Sé Consistente: Elige si usar Result o excepciones en todo tu código Documenta los Casos de Error: Deja claro qué tipos de errores pueden ser devueltos No Mezcles Enfoques: Evita mezclar Result con el manejo tradicional de excepciones Usa Transformaciones Significativas: Aprovecha map, flatMap y recover para código limpio Maneja Todos los Casos: Siempre maneja tanto los casos de éxito como los de fallo Evita el Anidamiento: Usa flatMap en lugar de anidar llamadas a runCatching Considera el Rendimiento: Result crea objetos, así que úsalo juiciosamente en código crítico para el rendimiento Pruebas: Escribe pruebas tanto para escenarios de éxito como de fallo  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // Buena práctica: Manejo claro de errores con transformación fun getUserProfile(userId: String): Result\u0026lt;UserProfile\u0026gt; { return userRepository.getUser(userId) .map { user -\u0026gt; profileMapper.toProfile(user) } .recover { error -\u0026gt; when (error) { is UserNotFoundException -\u0026gt; UserProfile.createGuestProfile() else -\u0026gt; throw error } } } // Mala práctica: Mezclando enfoques fun getUserProfile(userId: String): UserProfile { val result = userRepository.getUser(userId) if (result.isSuccess) { return profileMapper.toProfile(result.getOrNull()!!) } else { try { throw result.exceptionOrNull()!! } catch (e: UserNotFoundException) { return UserProfile.createGuestProfile() } } }   Conclusión La función runCatching y el tipo Result de Kotlin proporcionan un enfoque funcional y poderoso para el manejo de errores que puede mejorar significativamente la legibilidad y mantenibilidad del código. Al hacer explícitos los posibles fallos y permitir transformaciones funcionales, te permiten escribir código más robusto con un manejo de errores más limpio.\nAunque este enfoque puede no ser adecuado para todas las situaciones, es particularmente valioso en escenarios donde necesitas encadenar operaciones que podrían fallar o cuando quieres diferir el manejo de errores a un nivel superior en tu aplicación. Siguiendo los patrones y mejores prácticas descritos en este artículo, puedes aprovechar estas características para crear aplicaciones más elegantes, confiables y libres de fallos.\nYa sea que estés construyendo una nueva aplicación o refactorizando una existente, considera incorporar Result y runCatching en tu estrategia de manejo de errores para crear código que sea tanto más funcional como más resistente.\n","description":"Una guía completa sobre el uso de runCatching y Result de Kotlin para un manejo de errores más elegante sin bloques try/catch, con ejemplos prácticos y mejores prácticas.","id":8,"section":"posts","tags":["kotlin","manejo-de-errores","programacion-funcional","patron-result","manejo-de-excepciones"],"title":"Manejo Elegante de Errores en Kotlin: Usando runCatching y Result","uri":"https://carrion.dev/es/posts/runcatching-result-pattern/"},{"content":"Patrones DataSource y Repository: Construyendo una Capa de Datos Robusta En el desarrollo de aplicaciones modernas, gestionar el acceso a datos de manera eficiente es crucial para crear software mantenible y escalable. Dos patrones arquitectónicos que mejoran significativamente la gestión de datos son los patrones DataSource y Repository. Este artículo explora qué son estos patrones, cómo funcionan juntos y cómo implementarlos de manera efectiva con ejemplos prácticos.\n¿Qué Son los DataSources? Los DataSources son componentes responsables de manejar operaciones de datos con un origen específico. Abstraen los detalles de cómo se obtienen, almacenan o manipulan los datos de una fuente particular, como:\n DataSources Remotos: Manejan llamadas a API, peticiones de red y almacenamiento en la nube DataSources Locales: Gestionan operaciones de base de datos, acceso al sistema de archivos o caché en memoria DataSources de Servicios de Terceros: Interactúan con servicios externos como procesadores de pago o plataformas de análisis  Algunas características clave de los DataSources:\n Responsabilidad Única: Cada DataSource se enfoca en un solo origen de datos Detalles de Implementación: Contienen los detalles técnicos del acceso a datos Operaciones de Bajo Nivel: Realizan operaciones primitivas como CRUD (Crear, Leer, Actualizar, Eliminar)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // Ejemplo de un DataSource Remoto class UserRemoteDataSource(private val apiService: ApiService) { suspend fun getUser(userId: String): UserDto { return apiService.getUser(userId) } suspend fun updateUser(userDto: UserDto): UserDto { return apiService.updateUser(userDto) } suspend fun deleteUser(userId: String): Boolean { return apiService.deleteUser(userId) } } // Ejemplo de un DataSource Local class UserLocalDataSource(private val userDao: UserDao) { suspend fun getUser(userId: String): UserEntity? { return userDao.getUserById(userId) } suspend fun saveUser(userEntity: UserEntity) { userDao.insertOrUpdate(userEntity) } suspend fun deleteUser(userId: String) { userDao.deleteUserById(userId) } suspend fun getAllUsers(): List\u0026lt;UserEntity\u0026gt; { return userDao.getAllUsers() } }   ¿Qué Es el Patrón Repository? El patrón Repository actúa como una capa de abstracción entre tu lógica de negocio y las fuentes de datos. Proporciona una API limpia para el acceso a datos y oculta la complejidad de obtener, combinar y gestionar datos de múltiples fuentes.\nCaracterísticas clave de los Repositories:\n Abstracción: Ocultan los detalles de las operaciones de datos Coordinación: Orquestan el acceso a datos a través de múltiples DataSources Enfoque en el Dominio: Trabajan con modelos de dominio en lugar de modelos de datos Reglas de Negocio: Pueden aplicar reglas de negocio relacionadas con el acceso a datos  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  // Interfaz del Repository interface UserRepository { suspend fun getUser(userId: String): User suspend fun updateUser(user: User): User suspend fun deleteUser(userId: String): Boolean suspend fun syncUserData(userId: String): User } // Implementación del Repository class UserRepositoryImpl( private val remoteDataSource: UserRemoteDataSource, private val localDataSource: UserLocalDataSource, private val userMapper: UserMapper ) : UserRepository { override suspend fun getUser(userId: String): User { // Intentar obtener primero de la caché local  val localUser = localDataSource.getUser(userId) // Si se encuentra localmente, devolverlo  if (localUser != null) { return userMapper.mapEntityToDomain(localUser) } // De lo contrario, obtener del remoto y guardarlo en caché  val remoteUser = remoteDataSource.getUser(userId) val userEntity = userMapper.mapDtoToEntity(remoteUser) localDataSource.saveUser(userEntity) return userMapper.mapDtoToDomain(remoteUser) } override suspend fun updateUser(user: User): User { // Actualizar primero en remoto  val userDto = userMapper.mapDomainToDto(user) val updatedDto = remoteDataSource.updateUser(userDto) // Luego actualizar la caché local  val userEntity = userMapper.mapDtoToEntity(updatedDto) localDataSource.saveUser(userEntity) return userMapper.mapDtoToDomain(updatedDto) } override suspend fun deleteUser(userId: String): Boolean { // Eliminar del remoto  val success = remoteDataSource.deleteUser(userId) // Si tiene éxito, también eliminar del local  if (success) { localDataSource.deleteUser(userId) } return success } override suspend fun syncUserData(userId: String): User { // Forzar una actualización desde el remoto  val remoteUser = remoteDataSource.getUser(userId) val userEntity = userMapper.mapDtoToEntity(remoteUser) localDataSource.saveUser(userEntity) return userMapper.mapDtoToDomain(remoteUser) } }   Cómo Funcionan Juntos los DataSources y Repositories La relación entre DataSources y Repositories crea un sistema de gestión de datos potente:\n DataSources manejan el \u0026ldquo;cómo\u0026rdquo; del acceso a datos (detalles de implementación) Repositories manejan el \u0026ldquo;qué\u0026rdquo; del acceso a datos (requisitos de negocio)  Esta separación proporciona varios beneficios:\n1. Separación Limpia de Responsabilidades 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  // Sin separación adecuada - Todo mezclado class UserViewModel(private val apiService: ApiService, private val userDao: UserDao) { fun getUser(userId: String) { viewModelScope.launch { try { // Intentar primero local  var user = userDao.getUserById(userId) if (user == null) { // Obtener de la red  val networkUser = apiService.getUser(userId) // Convertir DTO a entidad  user = convertDtoToEntity(networkUser) // Guardar en base de datos  userDao.insertOrUpdate(user) } // Convertir a modelo UI  val uiModel = convertEntityToUiModel(user) _userState.value = UserState.Success(uiModel) } catch (e: Exception) { _userState.value = UserState.Error(\u0026#34;Error al cargar usuario\u0026#34;) } } } } // Con separación adecuada class UserViewModel(private val userRepository: UserRepository) { fun getUser(userId: String) { viewModelScope.launch { try { val user = userRepository.getUser(userId) _userState.value = UserState.Success(user) } catch (e: Exception) { _userState.value = UserState.Error(\u0026#34;Error al cargar usuario\u0026#34;) } } } }   2. Mejor Testabilidad Con este patrón, puedes simular fácilmente repositories para probar tu lógica de negocio, y simular data sources para probar tus repositories:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  // Probando un ViewModel con un Repository simulado class UserViewModelTest { @Test fun `getUser devuelve estado de éxito cuando el repository devuelve usuario`() = runTest { // Arrange  val mockRepository = mockk\u0026lt;UserRepository\u0026gt;() val user = User(\u0026#34;1\u0026#34;, \u0026#34;Juan Pérez\u0026#34;, \u0026#34;juan@ejemplo.com\u0026#34;) coEvery { mockRepository.getUser(\u0026#34;1\u0026#34;) } returns user val viewModel = UserViewModel(mockRepository) // Act  viewModel.getUser(\u0026#34;1\u0026#34;) // Assert  assertEquals(UserState.Success(user), viewModel.userState.value) } } // Probando un Repository con DataSources simulados class UserRepositoryTest { @Test fun `getUser devuelve datos de la fuente local cuando están disponibles`() = runTest { // Arrange  val mockLocalDataSource = mockk\u0026lt;UserLocalDataSource\u0026gt;() val mockRemoteDataSource = mockk\u0026lt;UserRemoteDataSource\u0026gt;() val mockMapper = mockk\u0026lt;UserMapper\u0026gt;() val userEntity = UserEntity(\u0026#34;1\u0026#34;, \u0026#34;Juan\u0026#34;, \u0026#34;Pérez\u0026#34;, \u0026#34;juan@ejemplo.com\u0026#34;) val user = User(\u0026#34;1\u0026#34;, \u0026#34;Juan Pérez\u0026#34;, \u0026#34;juan@ejemplo.com\u0026#34;) coEvery { mockLocalDataSource.getUser(\u0026#34;1\u0026#34;) } returns userEntity coEvery { mockMapper.mapEntityToDomain(userEntity) } returns user val repository = UserRepositoryImpl(mockRemoteDataSource, mockLocalDataSource, mockMapper) // Act  val result = repository.getUser(\u0026#34;1\u0026#34;) // Assert  assertEquals(user, result) coVerify(exactly = 1) { mockLocalDataSource.getUser(\u0026#34;1\u0026#34;) } coVerify(exactly = 0) { mockRemoteDataSource.getUser(any()) } } }   3. Flexibilidad y Adaptabilidad Este patrón facilita el cambio de fuentes de datos sin afectar al resto de tu aplicación:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // Cambiar de REST API a GraphQL solo requiere cambiar la implementación del DataSource class UserRemoteDataSourceRest(private val restApiService: RestApiService) : UserRemoteDataSource { override suspend fun getUser(userId: String): UserDto { return restApiService.getUser(userId) } // Otras implementaciones } class UserRemoteDataSourceGraphQL(private val graphQLClient: GraphQLClient) : UserRemoteDataSource { override suspend fun getUser(userId: String): UserDto { val response = graphQLClient.execute(UserQueries.GET_USER, mapOf(\u0026#34;id\u0026#34; to userId)) return response.data.user } // Otras implementaciones } // El Repository no necesita cambiar class UserRepositoryImpl( private val remoteDataSource: UserRemoteDataSource, // Interfaz, no implementación concreta  private val localDataSource: UserLocalDataSource, private val userMapper: UserMapper ) : UserRepository { // La implementación sigue siendo la misma }   Mejores Prácticas para DataSources y Repositories  Responsabilidad Única: Mantén los DataSources enfocados en un solo origen de datos Diseño Basado en Interfaces: Define los repositories como interfaces para mejor testabilidad Manejo de Errores: Implementa un manejo robusto de errores en los repositories Estrategia de Caché: Desarrolla una estrategia clara de caché (basada en tiempo, eventos, etc.) Soporte Offline: Usa repositories para proporcionar funcionalidad offline Inyección de Dependencias: Usa DI para proporcionar DataSources a los Repositories Nomenclatura Consistente: Usa convenciones de nomenclatura consistentes en toda tu capa de datos Paginación: Implementa paginación para conjuntos grandes de datos Patrones Reactivos: Considera usar Flow o LiveData para observar cambios en los datos Soporte de Transacciones: Implementa transacciones para operaciones que modifican múltiples entidades  Conclusión Los patrones DataSource y Repository proporcionan un enfoque potente para construir una capa de datos robusta en tus aplicaciones. Al separar las preocupaciones del acceso a datos y la lógica de negocio, estos patrones te ayudan a crear código que es más mantenible, testeable y adaptable al cambio.\nImplementar estos patrones requiere alguna inversión inicial en arquitectura, pero los beneficios se hacen evidentes rápidamente a medida que tu aplicación crece en complejidad. Con una capa de datos bien diseñada, puedes añadir características más fácilmente, cambiar fuentes de datos, implementar estrategias de caché y proporcionar soporte offline.\nYa sea que estés construyendo una pequeña aplicación o un gran sistema empresarial, los principios de los patrones DataSource y Repository pueden ayudarte a crear una base sólida para tus necesidades de gestión de datos, llevando a un proyecto más exitoso y sostenible.\n","description":"Una guía completa para implementar los patrones DataSource y Repository para crear una capa de datos limpia, mantenible y testeable en tus aplicaciones.","id":9,"section":"posts","tags":["architecture","clean-architecture","repository-pattern","datasources","software-design"],"title":"Patrones DataSource y Repository: Construyendo una Capa de Datos Robusta","uri":"https://carrion.dev/es/posts/datasources-repository-patterns/"},{"content":"Casos de Uso: Mejorando la Arquitectura de tu Proyecto En el desarrollo de software moderno, crear aplicaciones mantenibles, testables y escalables es un desafío constante. Un patrón arquitectónico que ha ganado una tracción significativa es el uso de Casos de Uso (también conocidos como Interactores en algunos contextos). Este artículo explora qué son los Casos de Uso, por qué mejoran la arquitectura de tu proyecto y cómo implementarlos de manera efectiva con ejemplos sencillos.\n¿Qué Son los Casos de Uso? Los Casos de Uso representan la lógica de negocio o las reglas específicas de la aplicación en tu software. Encapsulan una acción única y específica que se puede realizar en tu aplicación. Piensa en un Caso de Uso como la respuesta a la pregunta: \u0026ldquo;¿Qué puede hacer el usuario con esta aplicación?\u0026rdquo;\nAlgunas características clave de los Casos de Uso:\n Responsabilidad Única: Cada Caso de Uso debe hacer una cosa y hacerla bien Independencia: Los Casos de Uso deben ser independientes de la UI, frameworks y agencias externas Testabilidad: Deben ser fáciles de probar de forma aislada Reutilizables: El mismo Caso de Uso puede ser activado desde diferentes partes de tu aplicación  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // Una clase simple de Caso de Uso class LoginUseCase(private val userRepository: UserRepository) { suspend operator fun invoke(username: String, password: String): Result\u0026lt;User\u0026gt; { // Detalles de implementación  return Result.success(User(\u0026#34;ejemplo\u0026#34;, \u0026#34;Usuario Ejemplo\u0026#34;)) } } // Un Caso de Uso que no requiere parámetros class GetCurrentUserUseCase(private val userRepository: UserRepository) { suspend operator fun invoke(): User? { // Detalles de implementación  return User(\u0026#34;actual\u0026#34;, \u0026#34;Usuario Actual\u0026#34;) } }   Por Qué los Casos de Uso Mejoran Tu Arquitectura 1. Separación de Responsabilidades Los Casos de Uso crean un límite claro entre tu lógica de negocio y otras capas de tu aplicación. Esta separación hace que tu código sea más organizado y fácil de entender.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  // Sin Casos de Uso - Lógica de negocio mezclada con lógica de UI class UserViewModel(private val userRepository: UserRepository) { fun loginUser(username: String, password: String) { viewModelScope.launch { try { // Lógica de validación  if (username.isEmpty() || password.isEmpty()) { _uiState.value = UiState.Error(\u0026#34;El nombre de usuario y la contraseña no pueden estar vacíos\u0026#34;) return@launch } // Lógica de negocio  val user = userRepository.login(username, password) if (user != null) { userRepository.saveUserLocally(user) _uiState.value = UiState.Success(user) } else { _uiState.value = UiState.Error(\u0026#34;Credenciales inválidas\u0026#34;) } } catch (e: Exception) { _uiState.value = UiState.Error(\u0026#34;Error de inicio de sesión: ${e.message}\u0026#34;) } } } } // Con Casos de Uso - Separación limpia class LoginUseCase(private val userRepository: UserRepository) { suspend operator fun invoke(username: String, password: String): Result\u0026lt;User\u0026gt; { if (username.isEmpty() || password.isEmpty()) { return Result.failure(IllegalArgumentException(\u0026#34;El nombre de usuario y la contraseña no pueden estar vacíos\u0026#34;)) } return try { val user = userRepository.login(username, password) if (user != null) { userRepository.saveUserLocally(user) Result.success(user) } else { Result.failure(InvalidCredentialsException()) } } catch (e: Exception) { Result.failure(e) } } } class UserViewModel(private val loginUseCase: LoginUseCase) { fun loginUser(username: String, password: String) { viewModelScope.launch { _uiState.value = UiState.Loading val result = loginUseCase(username, password) _uiState.value = result.fold( onSuccess = { UiState.Success(it) }, onFailure = { UiState.Error(it.message ?: \u0026#34;Error desconocido\u0026#34;) } ) } } }   2. Mejor Testabilidad Los Casos de Uso hacen que tu lógica de negocio sea altamente testable porque están aislados de dependencias externas.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // Probando un Caso de Uso class LoginUseCaseTest { @Test fun `login con credenciales válidas devuelve éxito`() = runTest { // Arrange  val mockRepository = mockk\u0026lt;UserRepository\u0026gt;() val user = User(\u0026#34;john\u0026#34;, \u0026#34;John Doe\u0026#34;) coEvery { mockRepository.login(\u0026#34;john\u0026#34;, \u0026#34;password123\u0026#34;) } returns user coEvery { mockRepository.saveUserLocally(user) } just Runs val loginUseCase = LoginUseCase(mockRepository) // Act  val result = loginUseCase(\u0026#34;john\u0026#34;, \u0026#34;password123\u0026#34;) // Assert  assertTrue(result.isSuccess) assertEquals(user, result.getOrNull()) } @Test fun `login con credenciales vacías devuelve fallo`() = runTest { // Arrange  val mockRepository = mockk\u0026lt;UserRepository\u0026gt;() val loginUseCase = LoginUseCase(mockRepository) // Act  val result = loginUseCase(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) // Assert  assertTrue(result.isFailure) assertTrue(result.exceptionOrNull() is IllegalArgumentException) } }   3. Reutilización Los Casos de Uso pueden ser reutilizados en diferentes partes de tu aplicación, promoviendo la reutilización de código y la consistencia.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // Reutilizando el mismo Caso de Uso en diferentes ViewModels class LoginViewModel(private val loginUseCase: LoginUseCase) { fun login(username: String, password: String) { viewModelScope.launch { val result = loginUseCase(username, password) // Manejar resultado  } } } class AutoLoginViewModel(private val loginUseCase: LoginUseCase) { fun attemptAutoLogin(savedCredentials: SavedCredentials) { viewModelScope.launch { val result = loginUseCase(savedCredentials.username, savedCredentials.password) // Manejar resultado  } } }   4. Lógica de Negocio Más Fácil de Entender Los Casos de Uso hacen que tu lógica de negocio sea explícita y más fácil de entender. Al mirar tus clases de Caso de Uso, cualquiera puede comprender rápidamente lo que hace tu aplicación.\n1 2 3 4 5 6 7  // Una lista de Casos de Uso describe claramente las capacidades de la aplicación class GetUserProfileUseCase(private val userRepository: UserRepository) class UpdateUserProfileUseCase(private val userRepository: UserRepository) class ChangePasswordUseCase(private val userRepository: UserRepository) class LogoutUserUseCase(private val userRepository: UserRepository) class GetUserPostsUseCase(private val postRepository: PostRepository) class CreatePostUseCase(private val postRepository: PostRepository)   5. Inyección de Dependencias Simplificada Los Casos de Uso simplifican la inyección de dependencias al reducir el número de dependencias que cada componente necesita.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Sin Casos de Uso - ViewModel necesita múltiples repositorios class UserProfileViewModel( private val userRepository: UserRepository, private val postRepository: PostRepository, private val notificationRepository: NotificationRepository ) { // Métodos usando todos los repositorios } // Con Casos de Uso - ViewModel solo necesita los Casos de Uso relevantes class UserProfileViewModel( private val getUserProfileUseCase: GetUserProfileUseCase, private val getUserPostsUseCase: GetUserPostsUseCase, private val updateProfileUseCase: UpdateProfileUseCase ) { // Métodos usando Casos de Uso }   Implementando Casos de Uso en Tu Proyecto Veamos un ejemplo práctico de implementación de Casos de Uso en una aplicación simple:\n1. Implementa Casos de Uso Concretos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  // Modelos de dominio data class User(val id: String, val name: String, val email: String) data class Post(val id: String, val userId: String, val title: String, val content: String) // Interfaces de repositorio interface UserRepository { suspend fun getUser(id: String): User? suspend fun updateUser(user: User): Boolean } interface PostRepository { suspend fun getPostsByUser(userId: String): List\u0026lt;Post\u0026gt; suspend fun createPost(post: Post): Post } // Implementaciones de Casos de Uso class GetUserUseCase(private val userRepository: UserRepository) { suspend fun invoke(userId: String): User? { return userRepository.getUser(userId) } } class GetUserPostsUseCase(private val postRepository: PostRepository) { suspend fun invoke(userId: String): List\u0026lt;Post\u0026gt; { return postRepository.getPostsByUser(userId) } } class CreatePostUseCase(private val postRepository: PostRepository) { suspend fun invoke(post: Post): Post { return postRepository.createPost(post) } } class UpdateUserUseCase(private val userRepository: UserRepository) { suspend fun invoke(user: User): Boolean { return userRepository.updateUser(user) } }   2. Usa los Casos de Uso en Tu Aplicación 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  // En un ViewModel class UserProfileViewModel( private val getUserUseCase: GetUserUseCase, private val getUserPostsUseCase: GetUserPostsUseCase, private val updateUserUseCase: UpdateUserUseCase ) : ViewModel() { private val _userState = MutableStateFlow\u0026lt;UserState\u0026gt;(UserState.Loading) val userState: StateFlow\u0026lt;UserState\u0026gt; = _userState private val _postsState = MutableStateFlow\u0026lt;PostsState\u0026gt;(PostsState.Loading) val postsState: StateFlow\u0026lt;PostsState\u0026gt; = _postsState fun loadUserProfile(userId: String) { viewModelScope.launch { _userState.value = UserState.Loading try { val user = getUserUseCase(userId) if (user != null) { _userState.value = UserState.Success(user) loadUserPosts(userId) } else { _userState.value = UserState.Error(\u0026#34;Usuario no encontrado\u0026#34;) } } catch (e: Exception) { _userState.value = UserState.Error(\u0026#34;Error al cargar usuario: ${e.message}\u0026#34;) } } } private fun loadUserPosts(userId: String) { viewModelScope.launch { _postsState.value = PostsState.Loading try { val posts = getUserPostsUseCase(userId) _postsState.value = PostsState.Success(posts) } catch (e: Exception) { _postsState.value = PostsState.Error(\u0026#34;Error al cargar publicaciones: ${e.message}\u0026#34;) } } } fun updateUserProfile(user: User) { viewModelScope.launch { _userState.value = UserState.Loading try { val success = updateUserUseCase(user) if (success) { _userState.value = UserState.Success(user) } else { _userState.value = UserState.Error(\u0026#34;Error al actualizar usuario\u0026#34;) } } catch (e: Exception) { _userState.value = UserState.Error(\u0026#34;Error al actualizar usuario: ${e.message}\u0026#34;) } } } } // Clases de estado sealed class UserState { object Loading : UserState() data class Success(val user: User) : UserState() data class Error(val message: String) : UserState() } sealed class PostsState { object Loading : PostsState() data class Success(val posts: List\u0026lt;Post\u0026gt;) : PostsState() data class Error(val message: String) : PostsState() }   Mejores Prácticas para Casos de Uso  Mantén los Casos de Uso Enfocados: Cada Caso de Uso debe hacer solo una cosa Usa Nombres Significativos: Nombra tus Casos de Uso basándote en la acción que realizan (por ejemplo, GetUserUseCase, UpdateProfileUseCase) Devuelve Modelos de Dominio: Los Casos de Uso deben devolver modelos de dominio, no modelos de capa de datos o UI Maneja Errores Apropiadamente: Considera usar tipos Result o excepciones para el manejo de errores Haz que los Casos de Uso sean Testables: Asegúrate de que tus Casos de Uso puedan ser fácilmente probados de forma aislada Considera el Rendimiento: Para operaciones críticas en rendimiento, considera implementar Casos de Uso síncronos Evita Dependencias Circulares: Los Casos de Uso no deben depender directamente unos de otros  Conclusión Los Casos de Uso proporcionan una forma poderosa de organizar tu lógica de negocio y mejorar la arquitectura de tu aplicación. Al separar responsabilidades, mejorar la testabilidad y hacer que tu código sea más mantenible, los Casos de Uso te ayudan a construir mejor software que puede evolucionar con el tiempo.\nLos ejemplos en este artículo demuestran cómo los Casos de Uso pueden ser implementados en una aplicación simple, pero los principios se aplican a proyectos de cualquier tamaño. Ya sea que estés construyendo una pequeña aplicación o un gran sistema empresarial, incorporar Casos de Uso en tu arquitectura puede llevar a un código más limpio y mantenible.\nAl centrarte en lo que hace tu aplicación en lugar de cómo lo hace, los Casos de Uso te ayudan a crear software que es más fácil de entender, probar y modificar, lo que en última instancia conduce a un proyecto más exitoso.\n","description":"Una guía completa para entender los Casos de Uso y cómo pueden mejorar la arquitectura de tus proyectos de software con ejemplos prácticos.","id":10,"section":"posts","tags":["architecture","clean-architecture","usecases","software-design"],"title":"Casos de Uso: Mejorando la Arquitectura de tu Proyecto","uri":"https://carrion.dev/es/posts/usecases-architecture/"},{"content":"Implementando Navegación en Proyectos Compose Multiplatform Con la última versión de Compose Multiplatform (1.8.0), el soporte para iOS ha sido declarado estable, marcando un hito significativo para el desarrollo de interfaces de usuario multiplataforma con Kotlin. Uno de los componentes clave para construir aplicaciones robustas es la navegación, y la biblioteca org.jetbrains.androidx.navigation proporciona una solución potente que puede integrarse en proyectos Compose Multiplatform. Este artículo explora cómo implementar la navegación en un entorno Compose Multiplatform, permitiéndote compartir la lógica de navegación entre las plataformas Android e iOS.\nEntendiendo la Navegación en Compose Multiplatform La navegación en Compose Multiplatform sigue los mismos principios que la navegación en Jetpack Compose para Android, pero con adaptaciones para funcionar en múltiples plataformas. La arquitectura de navegación consiste en:\n NavController: La API central para la navegación que mantiene un registro de las entradas en la pila de retroceso y maneja las operaciones de navegación NavHost: Un componible que muestra el destino actual de un NavController NavGraph: Una colección de destinos que define posibles rutas de navegación  En un contexto de Compose Multiplatform, la navegación:\n Permite compartir la lógica de navegación entre plataformas Admite requisitos de navegación específicos de cada plataforma cuando es necesario  Este enfoque nos permite definir nuestra estructura de navegación en código común, mientras acomodamos comportamientos específicos de plataforma cuando sea necesario.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // En commonMain - Configuración básica de navegación @Composable fun AppNavigation() { val navController = rememberNavController() NavHost(navController = navController, startDestination = \u0026#34;home\u0026#34;) { composable(\u0026#34;home\u0026#34;) { HomeScreen( onNavigateToDetails = { itemId -\u0026gt; navController.navigate(\u0026#34;details/$itemId\u0026#34;) } ) } composable( route = \u0026#34;details/{itemId}\u0026#34;, arguments = listOf(navArgument(\u0026#34;itemId\u0026#34;) { type = NavType.StringType }) ) { backStackEntry -\u0026gt; val itemId = backStackEntry.arguments?.getString(\u0026#34;itemId\u0026#34;) ?: \u0026#34;\u0026#34; DetailsScreen( itemId = itemId, onNavigateBack = { navController.popBackStack() } ) } } }   Configurando la Navegación en un Proyecto Compose Multiplatform Para integrar la navegación en tu proyecto Compose Multiplatform, sigue estos pasos:\n1. Configurar el archivo build.gradle.kts en tu módulo compartido 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  plugins { kotlin(\u0026#34;multiplatform\u0026#34;) id(\u0026#34;com.android.library\u0026#34;) id(\u0026#34;org.jetbrains.compose\u0026#34;) } kotlin { androidTarget() iosX64() iosArm64() iosSimulatorArm64() sourceSets { val commonMain by getting { dependencies { // Compose Multiplatform  implementation(compose.runtime) implementation(compose.foundation) implementation(compose.material) // Navegación para Compose  implementation(\u0026#34;org.jetbrains.androidx.navigation:navigation-compose:2.8.0\u0026#34;) } } } }   2. Crear un NavHost compartido en código común 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  // En commonMain/kotlin/navigation/AppNavigation.kt  @Composable fun AppNavigation() { val navController = rememberNavController() NavHost( navController = navController, startDestination = \u0026#34;home\u0026#34; ) { // Define tu grafo de navegación aquí  composable(\u0026#34;home\u0026#34;) { HomeScreen( onNavigateToProfile = { navController.navigate(\u0026#34;profile\u0026#34;) }, onNavigateToSettings = { navController.navigate(\u0026#34;settings\u0026#34;) } ) } composable(\u0026#34;profile\u0026#34;) { ProfileScreen( onNavigateBack = { navController.popBackStack() } ) } composable(\u0026#34;settings\u0026#34;) { SettingsScreen( onNavigateBack = { navController.popBackStack() } ) } } }   Consideraciones Específicas por Plataforma Implementación en Android En Android, la navegación se integra perfectamente con el ciclo de vida de la plataforma:\n1 2 3 4 5 6 7 8 9 10 11 12 13  // En androidMain/kotlin/MainActivity.kt  class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { AppTheme { AppNavigation() } } } }   Implementación en iOS Con Compose Multiplatform 1.8.0, el soporte para iOS ahora es estable, haciendo que la implementación de navegación sea más confiable:\n1 2 3 4 5 6 7  // En iosMain/kotlin/MainViewController.kt  fun MainViewController() = ComposeUIViewController { AppTheme { AppNavigation() } }   Técnicas Avanzadas de Navegación 1. Grafos de Navegación Anidados Para aplicaciones más complejas, puedes organizar tu navegación con grafos anidados:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  @Composable fun AppNavigation() { val navController = rememberNavController() NavHost(navController = navController, startDestination = \u0026#34;home\u0026#34;) { composable(\u0026#34;home\u0026#34;) { HomeScreen(navController) } // Grafo de navegación anidado para el flujo de autenticación  navigation(startDestination = \u0026#34;login\u0026#34;, route = \u0026#34;auth\u0026#34;) { composable(\u0026#34;login\u0026#34;) { LoginScreen(navController) } composable(\u0026#34;register\u0026#34;) { RegisterScreen(navController) } composable(\u0026#34;forgot_password\u0026#34;) { ForgotPasswordScreen(navController) } } // Grafo de navegación anidado para configuraciones  navigation(startDestination = \u0026#34;settings_main\u0026#34;, route = \u0026#34;settings\u0026#34;) { composable(\u0026#34;settings_main\u0026#34;) { SettingsMainScreen(navController) } composable(\u0026#34;appearance\u0026#34;) { AppearanceSettingsScreen(navController) } composable(\u0026#34;notifications\u0026#34;) { NotificationSettingsScreen(navController) } } } }   2. Pasando Argumentos Entre Destinos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // Definir rutas con argumentos private object Routes { const val ITEM_DETAILS = \u0026#34;item_details/{itemId}\u0026#34; fun itemDetails(itemId: String) = \u0026#34;item_details/$itemId\u0026#34; } // En tu NavHost NavHost(navController = navController, startDestination = \u0026#34;items_list\u0026#34;) { composable(\u0026#34;items_list\u0026#34;) { ItemsListScreen( onItemClick = { itemId -\u0026gt; navController.navigate(Routes.itemDetails(itemId)) } ) } composable( route = Routes.ITEM_DETAILS, arguments = listOf(navArgument(\u0026#34;itemId\u0026#34;) { type = NavType.StringType }) ) { backStackEntry -\u0026gt; val itemId = backStackEntry.arguments?.getString(\u0026#34;itemId\u0026#34;) ?: \u0026#34;\u0026#34; ItemDetailsScreen(itemId = itemId) } }   3. Manejando Enlaces Profundos (Deep Links) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  NavHost( navController = navController, startDestination = \u0026#34;home\u0026#34; ) { composable( route = \u0026#34;home\u0026#34;, deepLinks = listOf( navDeepLink { uriPattern = \u0026#34;https://example.com/home\u0026#34; } ) ) { HomeScreen() } composable( route = \u0026#34;product/{productId}\u0026#34;, arguments = listOf(navArgument(\u0026#34;productId\u0026#34;) { type = NavType.StringType }), deepLinks = listOf( navDeepLink { uriPattern = \u0026#34;https://example.com/product/{productId}\u0026#34; } ) ) { backStackEntry -\u0026gt; val productId = backStackEntry.arguments?.getString(\u0026#34;productId\u0026#34;) ?: \u0026#34;\u0026#34; ProductScreen(productId = productId) } }   4. Seguridad de Tipos con Kotlin DSL (Navigation 2.8.0+) A partir de Navigation 2.8.0, puedes usar un DSL de Kotlin con seguridad de tipos para definir tu grafo de navegación utilizando anotaciones @Serializable y clases de datos, lo que proporciona seguridad en tiempo de compilación para rutas y argumentos sin necesidad de definir rutas como cadenas de texto:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // Define tus destinos con argumentos tipados @Serializable object Home // Define una ruta de perfil que toma un ID @Serializable data class Profile(val id: String) // Crea un grafo de navegación con seguridad de tipos @Composable fun TypeSafeNavigation() { val navController = rememberNavController() NavHost(navController = navController, startDestination = Home) { composable\u0026lt;Home\u0026gt; { HomeScreen(onNavigateToProfile = { id -\u0026gt; navController.navigate(Profile(id)) }) } composable\u0026lt;Profile\u0026gt; { backStackEntry -\u0026gt; val profile: Profile = backStackEntry.toRoute() ProfileScreen(profile.id) } } } // Navega con seguridad de tipos navController.navigate(Profile(id = \u0026#34;123\u0026#34;))   Beneficios de usar el DSL con seguridad de tipos y @Serializable:\n Sin rutas de texto: No es necesario definir cadenas de ruta o plantillas de cadenas Completamente tipado: Los argumentos son parte de la estructura de datos de la ruta Seguridad en tiempo de compilación: Los errores tipográficos y de tipo se detectan durante la compilación Acceso directo a objetos: Accede a los parámetros de ruta directamente como propiedades del objeto de ruta Navegación simplificada: Navega pasando objetos directamente a la función navigate  Para habilitar el DSL con seguridad de tipos, asegúrate de usar Navigation 2.8.0 o superior:\n1  implementation(\u0026#34;org.jetbrains.androidx.navigation:navigation-compose:2.8.0\u0026#34;)   Mejores Prácticas para Navegación en Compose Multiplatform   Crear una capa de abstracción de navegación\n Definir una interfaz común para acciones de navegación Implementar detalles específicos de plataforma detrás de esta interfaz Esto facilita el manejo de diferencias entre plataformas    Usar navegación con seguridad de tipos con @Serializable\n Aprovechar el DSL con seguridad de tipos y anotaciones @Serializable en lugar de rutas basadas en cadenas de texto Definir destinos como clases de datos y objetos para seguridad en tiempo de compilación Acceder a los parámetros de ruta directamente como propiedades de objetos de ruta Esto elimina las rutas basadas en texto, previene errores tipográficos y facilita la refactorización    Gestionar el estado de navegación adecuadamente\n Considerar usar una solución de gestión de estado como ViewModel Mantener la lógica de navegación separada de la lógica de UI Esto hace que tu código sea más testeable y mantenible    Probar tus flujos de navegación\n Escribir pruebas para tu lógica de navegación Verificar que los argumentos se pasen correctamente Asegurar que los enlaces profundos funcionen según lo esperado    Conclusión Con Compose Multiplatform 1.8.0 declarando el soporte para iOS como estable, implementar navegación en aplicaciones multiplataforma se ha vuelto más confiable y sencillo. El enfoque descrito en este artículo proporciona una forma práctica de compartir lógica de navegación entre plataformas mientras se acomodan requisitos específicos de cada plataforma.\nSiguiendo los pasos de configuración, consideraciones específicas de plataforma y mejores prácticas descritas en este artículo, puedes implementar con éxito la navegación en tus proyectos Compose Multiplatform y crear experiencias de usuario consistentes e intuitivas en las plataformas Android e iOS.\nPara información más detallada, consulta la documentación oficial de navegación en Compose Multiplatform.\n","description":"Una guía completa para implementar org.jetbrains.androidx.navigation en proyectos Compose Multiplatform, con enfoque en el soporte estable para iOS en Compose Multiplatform 1.8.0.","id":11,"section":"posts","tags":["kotlin","multiplatform","kmp","compose","navigation"],"title":"Implementando Navegación en Proyectos Compose Multiplatform","uri":"https://carrion.dev/es/posts/compose-navigation-kmp/"},{"content":"Implementando DataStore en Proyectos Kotlin Multiplatform DataStore es una solución moderna de almacenamiento de datos desarrollada por Google como reemplazo de SharedPreferences. Proporciona una API consistente y segura en cuanto a tipos para almacenar pares clave-valor y objetos tipados con soporte para coroutines y Flow de Kotlin. Con los recientes avances en Kotlin Multiplatform (KMP), ahora podemos integrar DataStore en nuestros proyectos KMP, permitiéndonos compartir código de preferencias y almacenamiento de datos entre plataformas. Este artículo explora cómo configurar, implementar y optimizar DataStore en un entorno KMP.\nEntendiendo DataStore en el Contexto de Kotlin Multiplatform DataStore en KMP está diseñado para proporcionar una API consistente entre plataformas mientras aprovecha los mecanismos de almacenamiento específicos de cada plataforma. Hay dos tipos de DataStore:\n Preferences DataStore: Para almacenar pares clave-valor Proto DataStore: Para almacenar objetos tipados utilizando Protocol Buffers  En un contexto KMP, DataStore sigue el patrón expect/actual donde:\n El código común define las interfaces esperadas y los modelos de datos Las implementaciones específicas de plataforma proporcionan los mecanismos de almacenamiento reales La API se mantiene consistente entre plataformas, utilizando coroutines y Flow  Este enfoque nos permite definir nuestros patrones de acceso a datos en código común, mientras que las operaciones de almacenamiento subyacentes son manejadas por implementaciones específicas de plataforma.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // En commonMain - Interfaz DataStore interface UserPreferences { val userData: Flow\u0026lt;UserData\u0026gt; suspend fun updateUsername(name: String) suspend fun updateEmail(email: String) suspend fun clearData() } // En commonMain - Modelo de datos data class UserData( val username: String = \u0026#34;\u0026#34;, val email: String = \u0026#34;\u0026#34;, val isLoggedIn: Boolean = false )   Configurando DataStore en un Proyecto KMP Para integrar DataStore en tu proyecto KMP, necesitarás configurar tus archivos de build apropiadamente. Aquí hay una guía paso a paso:\n1. Configurar el archivo build.gradle.kts en tu módulo compartido 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  plugins { kotlin(\u0026#34;multiplatform\u0026#34;) id(\u0026#34;com.android.library\u0026#34;) id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;2.1.20-2.0.1\u0026#34; // Para Proto DataStore } kotlin { androidTarget() iosX64() iosArm64() iosSimulatorArm64() sourceSets { val commonMain by getting { dependencies { // Para Preferences DataStore  implementation(\u0026#34;androidx.datastore:datastore-preferences-core:1.1.0\u0026#34;) // Para coroutines  implementation(\u0026#34;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3\u0026#34;) } } } }   2. Crear la instancia de DataStore desde el código común 1 2 3 4 5 6 7 8 9  /** * Gets the singleton DataStore instance, creating it if necessary. */ fun createDataStore(producePath: () -\u0026gt; String): DataStore\u0026lt;Preferences\u0026gt; = PreferenceDataStoreFactory.createWithPath( produceFile = { producePath().toPath() } ) internal const val dataStoreFileName = \u0026#34;dice.preferences_pb\u0026#34;   Consideraciones Específicas por Plataforma Implementación en Android 1 2 3 4 5  // shared/src/androidMain/kotlin/DataStore.kt  fun createDataStoreAndroid(context: Context): DataStore\u0026lt;Preferences\u0026gt; = createDataStore( producePath = { context.filesDir.resolve(dataStoreFileName).absolutePath } )   Implementación en iOS 1 2 3 4 5 6 7 8 9 10 11 12 13 14  // shared/src/iosMain/kotlin/DataStore.kt  fun createDataStoreIOS(): DataStore\u0026lt;Preferences\u0026gt; = createDataStore( producePath = { val documentDirectory: NSURL? = NSFileManager.defaultManager.URLForDirectory( directory = NSDocumentDirectory, inDomain = NSUserDomainMask, appropriateForURL = null, create = false, error = null, ) requireNotNull(documentDirectory).path + \u0026#34;/$dataStoreFileName\u0026#34; } )   Ejemplo Práctico: Implementando un Repositorio de Preferencias de Usuario Para demostrar una implementación completa, vamos a crear un repositorio que utilice nuestro DataStore:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83  // En commonMain class UserPreferencesRepository(private val dataStore: PreferencesDataStore) { // Definir claves de preferencias  private object PreferenceKeys { val USERNAME = stringPreferencesKey(\u0026#34;username\u0026#34;) val EMAIL = stringPreferencesKey(\u0026#34;email\u0026#34;) val IS_LOGGED_IN = booleanPreferencesKey(\u0026#34;is_logged_in\u0026#34;) } // Obtener datos de usuario como un Flow  val userData: Flow\u0026lt;UserData\u0026gt; = dataStore.data.map { preferences -\u0026gt; UserData( username = preferences[PreferenceKeys.USERNAME] ?: \u0026#34;\u0026#34;, email = preferences[PreferenceKeys.EMAIL] ?: \u0026#34;\u0026#34;, isLoggedIn = preferences[PreferenceKeys.IS_LOGGED_IN] ?: false ) } // Actualizar nombre de usuario  suspend fun updateUsername(name: String) { dataStore.updateData { preferences -\u0026gt; preferences.toMutablePreferences().apply { this[PreferenceKeys.USERNAME] = name } } } // Actualizar email  suspend fun updateEmail(email: String) { dataStore.updateData { preferences -\u0026gt; preferences.toMutablePreferences().apply { this[PreferenceKeys.EMAIL] = email } } } // Establecer estado de inicio de sesión  suspend fun setLoggedIn(isLoggedIn: Boolean) { dataStore.updateData { preferences -\u0026gt; preferences.toMutablePreferences().apply { this[PreferenceKeys.IS_LOGGED_IN] = isLoggedIn } } } // Borrar todos los datos  suspend fun clearData() { dataStore.updateData { preferences -\u0026gt; preferences.toMutablePreferences().apply { remove(PreferenceKeys.USERNAME) remove(PreferenceKeys.EMAIL) remove(PreferenceKeys.IS_LOGGED_IN) } } } } // En commonMain - ViewModel o Presenter class UserViewModel(private val userPreferencesRepository: UserPreferencesRepository) { val userData: Flow\u0026lt;UserData\u0026gt; = userPreferencesRepository.userData suspend fun updateUserProfile(username: String, email: String) { if (username.isNotBlank()) { userPreferencesRepository.updateUsername(username) } if (email.isNotBlank()) { userPreferencesRepository.updateEmail(email) } } suspend fun login() { userPreferencesRepository.setLoggedIn(true) } suspend fun logout() { userPreferencesRepository.setLoggedIn(false) } suspend fun clearUserData() { userPreferencesRepository.clearData() } }   Características Avanzadas de DataStore en KMP DataStore ofrece varias características avanzadas que pueden aprovecharse en un entorno KMP:\n1. Proto DataStore para Objetos Tipados Si necesitas almacenar objetos complejos, Proto DataStore proporciona una solución segura en cuanto a tipos:\n1 2 3 4 5 6 7 8 9 10 11  // Define tu estructura de datos en un archivo .proto syntax = \u0026#34;proto3\u0026#34;;option java_package = \u0026#34;com.example.app\u0026#34;;option java_multiple_files = true;message UserPreferences { string username = 1; string email = 2; bool is_logged_in = 3;}  1 2 3 4 5 6 7 8 9 10 11 12 13 14  // En commonMain - Crear un serializador class UserPreferencesSerializer : Serializer\u0026lt;UserPreferences\u0026gt; { override val defaultValue: UserPreferences = UserPreferences.getDefaultInstance() override suspend fun readFrom(input: InputStream): UserPreferences { return UserPreferences.parseFrom(input) } override suspend fun writeTo(t: UserPreferences, output: OutputStream) { t.writeTo(output) } } // Implementación específica de plataforma para Proto DataStore   2. Migración de Datos 1 2 3 4 5 6 7 8 9 10 11 12  // En androidMain - Migrando de SharedPreferences a DataStore val dataStore = context.createDataStore( name = \u0026#34;user_preferences\u0026#34;, produceMigrations = { context -\u0026gt; listOf( SharedPreferencesMigration( context = context, sharedPreferencesName = \u0026#34;legacy_preferences\u0026#34; ) ) } )   3. Manejo de Excepciones 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // En commonMain - Manejo de excepciones durante operaciones de datos val userData = dataStore.data .catch { exception -\u0026gt; // Manejar excepción (por ejemplo, corrupción de datos)  if (exception is IOException) { emit(emptyPreferences()) } else { throw exception } } .map { preferences -\u0026gt; // Mapear preferencias a tu modelo de datos  UserData( username = preferences[USERNAME] ?: \u0026#34;\u0026#34;, email = preferences[EMAIL] ?: \u0026#34;\u0026#34; ) }   Mejores Prácticas para DataStore en KMP   Usar el patrón expect/actual de manera efectiva\n Definir interfaces claras en el código común Implementar detalles específicos de plataforma en clases actual Mantener la API consistente entre plataformas    Aprovechar coroutines y Flow para operaciones asíncronas\n Las operaciones de DataStore son asíncronas por diseño Usar Flow para observar cambios en tus datos almacenados Aplicar operadores de Flow como map, filter y combine para transformaciones de datos    Crear una capa de repositorio\n Abstraer las operaciones de DataStore detrás de un repositorio Esto facilita cambiar implementaciones si es necesario Proporciona una API limpia para tu lógica de negocio    Manejar errores con elegancia\n Usar el operador catch para manejar excepciones en tu Flow Proporcionar valores predeterminados cuando los datos no se pueden leer Considerar implementar mecanismos de reintento para operaciones críticas    Optimizar para el rendimiento\n Minimizar el número de actualizaciones de DataStore Agrupar cambios relacionados Usar distinctUntilChanged() para evitar emisiones innecesarias    Probar tu código de DataStore exhaustivamente\n Escribir pruebas para tus repositorios en commonTest Usar dobles de prueba para simular diferentes escenarios    Conclusión Integrar DataStore en un proyecto Kotlin Multiplatform proporciona una forma moderna y segura en cuanto a tipos para almacenar y acceder a datos entre plataformas.\nEl enfoque descrito en este artículo proporciona una forma práctica de compartir lógica de preferencias y almacenamiento de datos entre plataformas con un mínimo de código específico de plataforma. El soporte de DataStore para coroutines y Flow lo convierte en una opción natural para proyectos KMP, permitiendo operaciones de datos reactivas y asíncronas con una API consistente.\nSiguiendo los pasos de configuración, consideraciones específicas de plataforma y mejores prácticas descritas en este artículo, puedes implementar con éxito DataStore en tus proyectos KMP y crear soluciones de almacenamiento de datos robustas y eficientes que funcionen en múltiples plataformas con un mínimo de código específico de plataforma.\n","description":"Una guía completa para configurar y utilizar DataStore en proyectos Kotlin Multiplatform, incluyendo configuración específica por plataforma y ejemplos prácticos.","id":12,"section":"posts","tags":["kotlin","multiplatform","kmp","datastore","preferences"],"title":"Implementando DataStore en Proyectos Kotlin Multiplatform","uri":"https://carrion.dev/es/posts/datastore-in-kmp/"},{"content":"Implementando Room Database en Proyectos Kotlin Multiplatform La biblioteca de persistencia Room se ha convertido en el estándar para operaciones de base de datos en el desarrollo Android, ofreciendo una capa de abstracción sobre SQLite que permite un acceso robusto a la base de datos mientras aprovecha todo el poder de SQL. Con el lanzamiento de Room 2.7.1, ahora podemos integrar esta potente biblioteca en proyectos Kotlin Multiplatform (KMP), permitiéndonos compartir código de base de datos entre plataformas mientras aprovechamos las optimizaciones específicas de cada plataforma. Este artículo explora cómo configurar, implementar y optimizar Room en un entorno KMP.\nEntendiendo Room en el Contexto de Kotlin Multiplatform Room en KMP no es un puerto directo de la biblioteca Room específica de Android a otras plataformas. En su lugar, es una implementación estratégica donde:\n Las anotaciones de Room y la funcionalidad principal se utilizan en el código común La anotación @ConstructedBy y el patrón RoomDatabaseConstructor permiten la inicialización de la base de datos específica de cada plataforma El compilador de Room genera automáticamente las implementaciones específicas de plataforma necesarias  Este enfoque nos permite definir nuestro esquema de base de datos, DAOs (Objetos de Acceso a Datos) y entidades en el código común, mientras que las operaciones subyacentes de la base de datos son manejadas por el compilador de Room para cada plataforma.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // En commonMain - Definición de entidad @Entity(tableName = \u0026#34;users\u0026#34;) data class User( @PrimaryKey val id: String, val name: String, val email: String, val createdAt: Long ) // En commonMain - Interfaz DAO @Dao interface UserDao { @Query(\u0026#34;SELECT * FROM users\u0026#34;) fun getAllUsers(): Flow\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; @Insert(onConflict = OnConflictStrategy.REPLACE) suspend fun insertUser(user: User) @Delete suspend fun deleteUser(user: User) }   Configurando Room 2.7.1 en un Proyecto KMP Para integrar Room 2.7.1 en tu proyecto KMP, necesitarás configurar tus archivos de build apropiadamente. Aquí hay una guía paso a paso:\n1. Configurar el archivo build.gradle.kts en tu módulo compartido 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  plugins { kotlin(\u0026#34;multiplatform\u0026#34;) id(\u0026#34;com.android.library\u0026#34;) id(\u0026#34;androidx.room\u0026#34;) id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;2.1.20-2.0.1\u0026#34; // KSP para procesamiento de anotaciones } kotlin { androidTarget() iosX64() iosArm64() iosSimulatorArm64() sourceSets { val commonMain by getting { dependencies { implementation(\u0026#34;androidx.room:room-runtime:2.7.1\u0026#34;) } } } } room { schemaDirectory(\u0026#34;$projectDir/schemas\u0026#34;) } // Configuración de KSP para Room dependencies { add(\u0026#34;kspAndroid\u0026#34;, \u0026#34;androidx.room:room-compiler:2.7.1\u0026#34;) add(\u0026#34;kspIosX64\u0026#34;, \u0026#34;androidx.room:room-compiler:2.7.1\u0026#34;) add(\u0026#34;kspIosArm64\u0026#34;, \u0026#34;androidx.room:room-compiler:2.7.1\u0026#34;) add(\u0026#34;kspIosSimulatorArm64\u0026#34;, \u0026#34;androidx.room:room-compiler:2.7.1\u0026#34;) }   2. Configurar la clase de base de datos usando @ConstructedBy y RoomDatabaseConstructor 1 2 3 4 5 6 7 8 9 10 11 12  // En commonMain @Database(entities = [User::class], version = 1) @ConstructedBy(AppDatabaseConstructor::class) abstract class AppDatabase : RoomDatabase() { abstract fun userDao(): UserDao } // El compilador de Room genera las implementaciones `actual`. @Suppress(\u0026#34;NO_ACTUAL_FOR_EXPECT\u0026#34;) expect object AppDatabaseConstructor : RoomDatabaseConstructor\u0026lt;AppDatabase\u0026gt; { override fun initialize(): AppDatabase }   Consideraciones Específicas por Plataforma Implementación en Android En Android, Room funciona de forma nativa ya que está diseñado para la plataforma. La implementación es sencilla:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // shared/src/androidMain/kotlin/Database.kt  fun getDatabaseBuilder(ctx: Context): RoomDatabase.Builder\u0026lt;AppDatabase\u0026gt; { val appContext = ctx.applicationContext val dbFile = appContext.getDatabasePath(\u0026#34;my_room.db\u0026#34;) return Room.databaseBuilder\u0026lt;AppDatabase\u0026gt;( context = appContext, name = dbFile.absolutePath ) } // En androidMain class DatabaseProvider(private val context: Context) { val database: AppDatabase by lazy { getDatabaseBuilder(context) .fallbackToDestructiveMigration() // Opcional: para desarrollo  .build() } } // Uso en la aplicación Android val databaseProvider = DatabaseProvider(applicationContext) val userDao = databaseProvider.database.userDao() // Recolectar usuarios como un Flow lifecycleScope.launch { userDao.getAllUsers().collect { users -\u0026gt; // Actualizar UI con usuarios  } }   Implementación en iOS Para iOS, Room ahora genera automáticamente las implementaciones necesarias. Necesitas proporcionar una función de constructor de base de datos que especifique la ruta de la base de datos:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // shared/src/iosMain/kotlin/Database.kt  fun getDatabaseBuilder(): RoomDatabase.Builder\u0026lt;AppDatabase\u0026gt; { val dbFilePath = documentDirectory() + \u0026#34;/my_room.db\u0026#34; return Room.databaseBuilder\u0026lt;AppDatabase\u0026gt;( name = dbFilePath, ) } private fun documentDirectory(): String { val documentDirectory = NSFileManager.defaultManager.URLForDirectory( directory = NSDocumentDirectory, inDomain = NSUserDomainMask, appropriateForURL = null, create = false, error = null, ) return requireNotNull(documentDirectory?.path) } // En iosMain class DatabaseProvider { val database: AppDatabase by lazy { // Inicializar la base de datos usando la función de constructor  getDatabaseBuilder().build() } } // No es necesario crear implementaciones personalizadas de AppDatabase o DAO para iOS // El compilador de Room genera automáticamente todo el código necesario // La interfaz DAO definida en commonMain se usa directamente   Ejemplo Práctico: Implementando un Patrón Repositorio Para demostrar una implementación completa, vamos a crear un repositorio que utilice nuestra base de datos Room:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // En commonMain class UserRepository(private val userDao: UserDao) { fun getAllUsers(): Flow\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; = userDao.getAllUsers() suspend fun addUser(name: String, email: String) { val user = User( id = UUID.randomUUID().toString(), name = name, email = email, createdAt = Clock.System.now().toEpochMilliseconds() ) userDao.insertUser(user) } suspend fun deleteUser(user: User) { userDao.deleteUser(user) } } // En commonMain - ViewModel o Presenter class UserViewModel(private val userRepository: UserRepository) { val users: Flow\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; = userRepository.getAllUsers() suspend fun addUser(name: String, email: String) { if (name.isNotBlank() \u0026amp;\u0026amp; email.isNotBlank()) { userRepository.addUser(name, email) } } suspend fun deleteUser(user: User) { userRepository.deleteUser(user) } }   Características Avanzadas de Room en KMP Room ofrece varias características avanzadas que pueden aprovecharse en un entorno KMP:\n1. Migraciones 1 2 3 4 5 6 7 8 9 10 11  // En androidMain val MIGRATION_1_2 = object : Migration(1, 2) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL(\u0026#34;ALTER TABLE users ADD COLUMN age INTEGER DEFAULT 0 NOT NULL\u0026#34;) } } // En el constructor de la base de datos Room.databaseBuilder(context, AppDatabase::class.java, \u0026#34;app-database\u0026#34;) .addMigrations(MIGRATION_1_2) .build()   2. Conversores de Tipo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // En commonMain class Converters { @TypeConverter fun fromTimestamp(value: Long?): Date? { return value?.let { Date(it) } } @TypeConverter fun dateToTimestamp(date: Date?): Long? { return date?.time } } // Añadir a la anotación de la base de datos @Database(entities = [User::class], version = 1) @TypeConverters(Converters::class) @ConstructedBy(AppDatabaseConstructor::class) abstract class AppDatabase : RoomDatabase() { abstract fun userDao(): UserDao }   3. Relaciones Entre Entidades 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // En commonMain @Entity(tableName = \u0026#34;posts\u0026#34;) data class Post( @PrimaryKey val id: String, val userId: String, // Clave foránea a User  val title: String, val content: String, val createdAt: Long ) data class UserWithPosts( @Embedded val user: User, @Relation( parentColumn = \u0026#34;id\u0026#34;, entityColumn = \u0026#34;userId\u0026#34; ) val posts: List\u0026lt;Post\u0026gt; ) @Dao interface UserPostDao { @Transaction @Query(\u0026#34;SELECT * FROM users\u0026#34;) fun getUsersWithPosts(): Flow\u0026lt;List\u0026lt;UserWithPosts\u0026gt;\u0026gt; }   Mejores Prácticas para Room en KMP   Mantén las entidades simples y neutrales respecto a la plataforma\n Evita usar tipos específicos de plataforma en tus entidades Usa tipos primitivos y strings donde sea posible Usa conversores de tipo para tipos complejos    Usa coroutines y Flow para operaciones asíncronas\n El soporte de Flow de Room funciona bien con coroutines de Kotlin Esto proporciona una API consistente entre plataformas    Implementa una capa de repositorio\n Abstrae las operaciones de base de datos detrás de un repositorio Esto facilita cambiar implementaciones si es necesario    Maneja la inicialización de base de datos específica de plataforma\n Usa inyección de dependencias para proporcionar la implementación correcta de la base de datos Considera usar un patrón de fábrica para la creación de la base de datos    Prueba tu código de base de datos exhaustivamente\n Escribe pruebas para tus DAOs en commonTest Crea pruebas específicas de plataforma para implementaciones reales    Conclusión Integrar Room 2.7.1 en un proyecto Kotlin Multiplatform proporciona una forma poderosa de compartir código de base de datos entre plataformas mientras se aprovechan las fortalezas de las capacidades nativas de base de datos de cada plataforma. Mediante el uso de la anotación @ConstructedBy y el patrón RoomDatabaseConstructor, podemos definir nuestro esquema de base de datos, DAOs y entidades en código común, mientras que el compilador de Room genera automáticamente las implementaciones específicas de plataforma.\nEl enfoque descrito en este artículo proporciona una forma práctica de compartir lógica de base de datos entre plataformas con un mínimo de código específico de plataforma. El compilador de Room hace la mayor parte del trabajo pesado, generando automáticamente las implementaciones necesarias para cada plataforma. Esto reduce significativamente la cantidad de código repetitivo que necesitas escribir y mantener.\nSiguiendo los pasos de configuración, consideraciones específicas de plataforma y mejores prácticas descritas en este artículo, puedes implementar con éxito Room en tus proyectos KMP y crear soluciones de base de datos robustas y eficientes que funcionen en múltiples plataformas con un mínimo de código específico de plataforma.\n","description":"Una guía completa para configurar y utilizar Room 2.7.1 en proyectos Kotlin Multiplatform, incluyendo configuración específica por plataforma y ejemplos prácticos.","id":13,"section":"posts","tags":["kotlin","multiplatform","kmp","room","database"],"title":"Implementando Room Database en Proyectos Kotlin Multiplatform","uri":"https://carrion.dev/es/posts/room-in-kmp/"},{"content":"Patrones de Testing para Coroutines: Estrategias Efectivas para Testear Código Asíncrono en Kotlin Testear código asíncrono siempre ha sido un desafío, y las coroutines y flows de Kotlin no son una excepción. Sin embargo, el equipo de Kotlin ha proporcionado potentes utilidades de test que hacen que este proceso sea más manejable y confiable. En este artículo, exploraremos patrones efectivos para testear coroutines y flows, desde tests unitarios básicos hasta escenarios de integración complejos.\nLa Base: kotlinx-coroutines-test Antes de profundizar en patrones específicos, establezcamos la base. La biblioteca kotlinx-coroutines-test proporciona herramientas esenciales para testear coroutines:\n1 2 3  dependencies { testImplementation(\u0026#34;org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3\u0026#34;) }   Esta biblioteca ofrece varios componentes clave:\n TestCoroutineScheduler: Controla el tiempo virtual para las coroutines StandardTestDispatcher: Un dispatcher que utiliza el scheduler de test UnconfinedTestDispatcher: Un dispatcher que ejecuta coroutines de manera inmediata TestScope: Un scope de coroutine con funcionalidad específica para tests  Veamos cómo configurar un entorno de test básico:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import kotlinx.coroutines.test.* import org.junit.jupiter.api.Test import kotlin.test.assertEquals class BasicCoroutineTest { @Test fun `basic coroutine test`() = runTest { // runTest crea un TestScope con un StandardTestDispatcher  val result = fetchData() // función suspend llamada dentro de un scope de coroutine  assertEquals(\u0026#34;Data\u0026#34;, result) } private suspend fun fetchData(): String { // Simular retraso de red  delay(1000) return \u0026#34;Data\u0026#34; } }   La función runTest crea un entorno de test de coroutine que:\n Ejecuta tu test en un TestScope Utiliza un StandardTestDispatcher por defecto Avanza automáticamente el tiempo virtual para completar coroutines suspendidas Falla el test si alguna coroutine lanza una excepción  Testeando Operadores de Flow Personalizados Los operadores de Flow personalizados son una forma poderosa de encapsular lógica de procesamiento de flujos reutilizable. Testearlos a fondo es esencial para garantizar que se comporten según lo esperado en diversas condiciones.\nConsideremos un operador personalizado que filtra y transforma elementos:\n1 2 3 4 5 6 7 8 9 10  fun \u0026lt;T, R\u0026gt; Flow\u0026lt;T\u0026gt;.filterAndMap( predicate: suspend (T) -\u0026gt; Boolean, transform: suspend (T) -\u0026gt; R ): Flow\u0026lt;R\u0026gt; = flow\u0026lt;R\u0026gt; { collect { value -\u0026gt; if (predicate(value)) { emit(transform(value)) } } }   Así es cómo testear este operador:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Test fun `filterAndMap should filter and transform items`() = runTest { // Given  val sourceFlow = flowOf(1, 2, 3, 4, 5) val isEven: suspend (Int) -\u0026gt; Boolean = { it % 2 == 0 } val double: suspend (Int) -\u0026gt; Int = { it * 2 } // When  val resultFlow = sourceFlow.filterAndMap(isEven, double) // Then  val result = resultFlow.toList() assertEquals(listOf(4, 8), result) }   Para operadores más complejos, testea diferentes casos extremos:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  @Test fun `filterAndMap should handle empty flows`() = runTest { // Given  val emptyFlow = emptyFlow\u0026lt;Int\u0026gt;() // When  val resultFlow = emptyFlow.filterAndMap( predicate = { true }, transform = { it * 2 } ) // Then  val result = resultFlow.toList() assertEquals(emptyList(), result) } @Test fun `filterAndMap should propagate exceptions from predicate`() = runTest { // Given  val sourceFlow = flowOf(1, 2, 3) val throwingPredicate: suspend (Int) -\u0026gt; Boolean = { if (it == 2) throw RuntimeException(\u0026#34;Test exception\u0026#34;) true } // When/Then  assertThrows\u0026lt;RuntimeException\u0026gt; { runBlocking { sourceFlow.filterAndMap( predicate = throwingPredicate, transform = { it } ).toList() } } }   Al testear operadores que involucran temporización, usa el scheduler de test para controlar el tiempo virtual:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  @Test fun `debounce operator should emit only after specified delay`() = runTest { // Given  val testScope = this val flow = flow\u0026lt;String\u0026gt; { emit(\u0026#34;A\u0026#34;) testScope.advanceTimeBy(90) emit(\u0026#34;B\u0026#34;) testScope.advanceTimeBy(90) emit(\u0026#34;C\u0026#34;) testScope.advanceTimeBy(200) emit(\u0026#34;D\u0026#34;) } // When  val results = mutableListOf\u0026lt;String\u0026gt;() val job = launch { flow.debounce(100).collect { results.add(it) } } // Avanzar el tiempo para completar todas las operaciones  advanceUntilIdle() job.cancel() // Then  assertEquals(listOf(\u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;), results) }   Testeando Timeout y Cancelación El manejo adecuado de timeouts y cancelaciones es crucial para un código de coroutine robusto. Así es cómo testear estos escenarios:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class TimeoutService { suspend fun fetchWithTimeout(id: String, api: Api): Result\u0026lt;Data\u0026gt; { return try { // Usar withTimeout para limitar el tiempo de ejecución  val data = withTimeout(1000) { api.fetchData(id) } Result.success(data) } catch (e: TimeoutCancellationException) { Result.failure(e) } } fun processWithCancellationCheck(input: Flow\u0026lt;Int\u0026gt;): Flow\u0026lt;Int\u0026gt; = input .map\u0026lt;Int, Int\u0026gt; { value -\u0026gt; ensureActive() // Verificar cancelación  value * 2 } .onCompletion\u0026lt;Int\u0026gt; { cause -\u0026gt; if (cause is CancellationException) { // Registrar o manejar la cancelación  } } }   Testeando el comportamiento de timeout:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  @Test fun `fetchWithTimeout should return success when API responds in time`() = runTest { // Given  val mockApi = mock\u0026lt;Api\u0026gt; { onBlocking { fetchData(\u0026#34;123\u0026#34;) } doAnswer { delay(500) // Responder dentro del timeout  Data(\u0026#34;test\u0026#34;) } } val service = TimeoutService() // When  val result = service.fetchWithTimeout(\u0026#34;123\u0026#34;, mockApi) // Then  assertTrue(result.isSuccess) assertEquals(Data(\u0026#34;test\u0026#34;), result.getOrNull()) } @Test fun `fetchWithTimeout should return failure when API times out`() = runTest { // Given  val mockApi = mock\u0026lt;Api\u0026gt; { onBlocking { fetchData(\u0026#34;123\u0026#34;) } doAnswer { delay(2000) // Exceder el timeout  Data(\u0026#34;test\u0026#34;) } } val service = TimeoutService() // When  val result = service.fetchWithTimeout(\u0026#34;123\u0026#34;, mockApi) // Then  assertTrue(result.isFailure) assertTrue(result.exceptionOrNull() is TimeoutCancellationException) }   Testeando el manejo de cancelación:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  @Test fun `processWithCancellationCheck should handle cancellation properly`() = runTest { // Given  val service = TimeoutService() val flow = flow { repeat(10) { emit(it) delay(100) } } // When  val results = mutableListOf\u0026lt;Int\u0026gt;() val job = launch { service.processWithCancellationCheck(flow).collect { results.add(it) if (results.size \u0026gt;= 5) { cancel() // Cancelar después de recolectar 5 elementos  } } } // Then  advanceUntilIdle() assertEquals(5, results.size) assertEquals(listOf(0, 2, 4, 6, 8), results) }   Conclusión Testear coroutines y flows de manera efectiva requiere comprender tanto las utilidades de test proporcionadas por el equipo de Kotlin como los patrones que funcionan mejor para diferentes escenarios. Utilizando las técnicas descritas en este artículo, puedes crear tests confiables incluso para el código asíncrono más complejo:\n Usa kotlinx-coroutines-test como base para testear coroutines Testea operadores de Flow personalizados a fondo con diferentes entradas y casos extremos Simula varios escenarios de dispatch para asegurar que tu código funcione en diferentes modelos de threading Verifica el manejo adecuado de timeouts y cancelaciones Crea dispatchers de test personalizados cuando necesites más control Construye tests de integración completos que verifiquen todo el flujo de datos  Recuerda que los buenos tests no solo verifican que tu código funcione correctamente, sino que también sirven como documentación sobre cómo debe usarse. Al invertir tiempo en escribir tests exhaustivos para tu código de coroutines, crearás aplicaciones más robustas y facilitarás el mantenimiento futuro.\nA medida que las coroutines y flows continúan evolucionando, mantente actualizado con las últimas utilidades de test y mejores prácticas. El equipo de Kotlin mejora regularmente las bibliotecas de test para hacer nuestras vidas como desarrolladores más fáciles y nuestro código más confiable.\n","description":"Aprende patrones y técnicas esenciales para testear coroutines y flows de Kotlin de manera efectiva, desde tests unitarios básicos hasta escenarios de integración complejos.","id":14,"section":"posts","tags":["kotlin","coroutines","testing","flows"],"title":"Patrones de Testing para Coroutines: Estrategias Efectivas para Testear Código Asíncrono en Kotlin","uri":"https://carrion.dev/es/posts/coroutine-testing-patterns/"},{"content":"Entendiendo los Context parameters en Kotlin 2.2.0 Kotlin 2.2.0 introduce una emocionante nueva característica del lenguaje llamada \u0026ldquo;Context parameters\u0026rdquo; que promete hacer tu código más conciso, legible y mantenible. Esta característica aborda el desafío común de pasar información contextual a través de jerarquías de llamadas profundas sin sobrecargar las firmas de las funciones. En este artículo, exploraremos qué son los Context parameters, cómo funcionan y cómo puedes aprovecharlos en tus proyectos Kotlin.\n¿Qué Son los Context parameters? Los Context parameters son una nueva forma de declarar dependencias en las firmas de funciones que se pasan implícitamente de los llamadores a los receptores. Sirven como una alternativa a pasar explícitamente parámetros a través de cada función en una cadena de llamadas, reduciendo el código repetitivo mientras se mantiene la seguridad de tipos.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // Función con un Context parameter context(logger: Logger) fun processData(data: Data) { // Usar el contexto Logger directamente  logger.info(\u0026#34;Procesando datos: $data\u0026#34;) // Procesar los datos...  val result = data.transform() logger.debug(\u0026#34;Procesamiento completo, resultado: $result\u0026#34;) } // Llamando a la función con un contexto with(ConsoleLogger()) { processData(myData) }   En este ejemplo, Logger es un Context parameter para la función processData. La función puede usar directamente métodos de Logger sin recibirlo explícitamente como parámetro. El llamador proporciona el contexto usando funciones de ámbito estándar de Kotlin como with, run o apply.\nCómo los Context parameters Difieren de los Extension Receivers Los desarrolladores de Kotlin podrían inicialmente confundir los Context parameters con los Extension Receivers, pero sirven para propósitos diferentes y tienen capacidades distintas:\n1 2 3 4 5 6 7 8 9 10 11 12  // Función de extensión fun Logger.processDataAsExtension(data: Data) { info(\u0026#34;Procesando datos: $data\u0026#34;) // ... } // Función con Context parameter context(logger: Logger) fun processDataWithContext(data: Data) { logger.info(\u0026#34;Procesando datos: $data\u0026#34;) // ... }   Las diferencias clave incluyen:\n  Múltiples Contextos: Puedes especificar múltiples Context parameters, a diferencia de los receptores de extensión.\n1 2 3 4  context(logger: Logger, txManager: TransactionManager, auth: UserAuthorization) fun performComplexOperation(data: Data) { // Usar métodos de los tres contextos }     Composición: Los Context parameters se componen mejor con funciones de extensión.\n1 2 3 4  context(txManager: TransactionManager) fun List\u0026lt;Transaction\u0026gt;.processAll() { // Tanto el contexto TransactionManager como el receptor List\u0026lt;Transaction\u0026gt; están disponibles }     Propagación Implícita: Los Context parameters se pasan implícitamente a lo largo de la cadena de llamadas.\n  Context receivers vs. Context parameters: Actualización Importante Es importante destacar que los Context parameters son la evolución de una característica experimental anterior llamada \u0026ldquo;Context receivers\u0026rdquo;. Los Context receivers están siendo deprecados en favor de los Context parameters. Estas son las diferencias clave:\n Parámetros Nombrados: Los Context parameters requieren un nombre (context(logger: Logger)), mientras que los Context receivers solo especificaban el tipo (context(Logger)). Uso Explícito: Con los Context parameters, debes usar el nombre del parámetro para acceder a los métodos (logger.info()), mientras que los Context receivers permitían el acceso directo a los métodos (info()). Claridad y Mantenibilidad: Los Context parameters nombrados proporcionan mejor claridad sobre qué contexto se está utilizando, especialmente cuando hay múltiples contextos involucrados. Soporte de IDE: Los Context parameters nombrados permiten un mejor soporte del IDE, incluyendo autocompletado y navegación.  Este cambio se alinea con la filosofía de Kotlin de preferir lo explícito sobre lo implícito cuando mejora la claridad y mantenibilidad del código. Si has estado utilizando Context receivers en código experimental, deberías migrar a Context parameters ya que son la característica oficialmente soportada de ahora en adelante.\nVentajas de Usar Context parameters Los Context parameters ofrecen varios beneficios que pueden mejorar significativamente tu base de código:\n  Reducción de Código Repetitivo\n Elimina la necesidad de pasar los mismos parámetros a través de múltiples capas de llamadas a funciones Hace que las firmas de funciones sean más limpias y más enfocadas en su propósito principal Reduce la verbosidad del código que trata con preocupaciones transversales    Mejora de la Legibilidad\n Las llamadas a funciones se centran en los parámetros esenciales Las operaciones dependientes del contexto se vuelven más intuitivas El código se lee más como lenguaje natural con menos interrupciones    Mejor Mantenibilidad\n Los cambios en los requisitos contextuales no se propagan a través de toda la jerarquía de llamadas Agregar nuevas dependencias contextuales tiene un impacto mínimo en el código existente Las pruebas se vuelven más fáciles con límites de contexto explícitos    Seguridad de Tipos\n A diferencia de las variables globales o singletons, los Context parameters mantienen la seguridad de tipos en tiempo de compilación El compilador asegura que se proporcionen los contextos requeridos El soporte del IDE para autocompletado y navegación funciona con Context parameters    Ejemplos Prácticos de Context parameters Exploremos algunos escenarios del mundo real donde los Context parameters brillan:\nEjemplo 1: Framework de Logging 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  interface Logger { fun debug(message: String) fun info(message: String) fun warn(message: String) fun error(message: String, throwable: Throwable? = null) } class ConsoleLogger : Logger { override fun debug(message: String) = println(\u0026#34;[DEBUG] $message\u0026#34;) override fun info(message: String) = println(\u0026#34;[INFO] $message\u0026#34;) override fun warn(message: String) = println(\u0026#34;[WARN] $message\u0026#34;) override fun error(message: String, throwable: Throwable?) { println(\u0026#34;[ERROR] $message\u0026#34;) throwable?.printStackTrace() } } // Usando Context parameters para logging context(logger: Logger) fun processUserData(user: User) { logger.info(\u0026#34;Procesando datos para usuario: ${user.id}\u0026#34;) try { val result = user.processProfile() logger.debug(\u0026#34;Perfil procesado: $result\u0026#34;) val permissions = user.calculatePermissions() logger.debug(\u0026#34;Permisos calculados: $permissions\u0026#34;) } catch (e: Exception) { logger.error(\u0026#34;Error al procesar datos de usuario\u0026#34;, e) } } // Uso fun main() { val user = User(id = \u0026#34;12345\u0026#34;, name = \u0026#34;John Doe\u0026#34;) with(ConsoleLogger()) { processUserData(user) } }   Este ejemplo demuestra cómo los Context parameters pueden simplificar el logging en toda una base de código sin pasar explícitamente una instancia de logger a cada función.\nEjemplo 2: Inyección de Dependencias 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  class UserRepository { fun getUser(id: String): User = // implementación  fun saveUser(user: User): Boolean = // implementación } class TransactionManager { fun beginTransaction() { /* implementación */ } fun commitTransaction() { /* implementación */ } fun rollbackTransaction() { /* implementación */ } } class NotificationService { fun sendNotification(userId: String, message: String) { /* implementación */ } } // Usando múltiples Context parameters context(repo: UserRepository, txManager: TransactionManager, notificationService: NotificationService) fun updateUserProfile(userId: String, profileUpdate: ProfileUpdate): Boolean { txManager.beginTransaction() try { val user = repo.getUser(userId) user.applyProfileUpdate(profileUpdate) val success = repo.saveUser(user) if (success) { txManager.commitTransaction() notificationService.sendNotification(userId, \u0026#34;Tu perfil ha sido actualizado\u0026#34;) } else { txManager.rollbackTransaction() } return success } catch (e: Exception) { txManager.rollbackTransaction() throw e } } // Uso fun main() { val userRepo = UserRepository() val txManager = TransactionManager() val notificationService = NotificationService() with(userRepo) { with(txManager) { with(notificationService) { updateUserProfile(\u0026#34;12345\u0026#34;, ProfileUpdate(name = \u0026#34;Jane Doe\u0026#34;)) } } } // O de forma más concisa con la función run de Kotlin:  run { context(userRepo, txManager, notificationService) updateUserProfile(\u0026#34;12345\u0026#34;, ProfileUpdate(name = \u0026#34;Jane Doe\u0026#34;)) } }   Este ejemplo muestra cómo los Context parameters pueden simplificar los patrones de inyección de dependencias al hacer que las dependencias estén disponibles implícitamente.\nMejores Prácticas para Usar Context parameters Para aprovechar al máximo los Context parameters, considera estas mejores prácticas:\n  Usar para Preocupaciones Transversales\n Logging, trazado y monitoreo Gestión de transacciones Seguridad y autorización Configuración y ajustes de entorno    Mantener las Interfaces de Contexto Enfocadas\n Definir interfaces pequeñas y cohesivas para los contextos Evitar contextos grandes con muchos métodos no relacionados Considerar la composición de múltiples contextos en su lugar    Ser Consciente del Anidamiento y Ámbito\n Definir claramente dónde comienzan y terminan los contextos Evitar bloques de contexto profundamente anidados Considerar el uso de funciones de extensión en Context parameters para una mejor organización    Documentar los Requisitos de Contexto\n Documentar claramente para qué se utiliza cada Context parameter Explicar el comportamiento esperado de las implementaciones de contexto Proporcionar ejemplos de cómo suministrar los contextos requeridos    Pruebas con Context parameters\n Crear implementaciones específicas de prueba de interfaces de contexto Usar frameworks de mock que soporten Context parameters Considerar la creación de utilidades de prueba para simplificar la provisión de contextos de prueba    Combinación con Funciones de Extensión 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Función de extensión con Context parameter context(txManager: TransactionManager) fun List\u0026lt;Transaction\u0026gt;.processAllInTransaction() { txManager.beginTransaction() try { forEach { it.process() } txManager.commitTransaction() } catch (e: Exception) { txManager.rollbackTransaction() throw e } } // Uso with(transactionManager) { transactions.processAllInTransaction() }   Conclusión Los Context parameters en Kotlin 2.2.0 representan una mejora significativa al lenguaje, ofreciendo una forma poderosa de gestionar dependencias contextuales con menos código repetitivo. Al permitir el paso implícito de parámetros a través de cadenas de llamadas, abordan un punto de dolor común en el desarrollo de software mientras mantienen el compromiso de Kotlin con la seguridad de tipos y la legibilidad.\nA medida que incorporas Context parameters en tu base de código, comienza con casos de uso claros y enfocados como logging o inyección de dependencias. Con el tiempo, descubrirás más oportunidades para aprovechar esta característica para hacer tu código más conciso y mantenible.\nRecuerda que los Context parameters son una herramienta en tu kit de herramientas de Kotlin—úsalos juiciosamente junto con otras características del lenguaje para crear código limpio, expresivo y mantenible. Con el enfoque correcto, los Context parameters pueden mejorar significativamente la forma en que estructuras y organizas tus aplicaciones Kotlin.\n","description":"Explorando la nueva característica de Context parameters de Kotlin 2.2.0 y cómo puede mejorar la legibilidad y mantenibilidad de tu código.","id":15,"section":"posts","tags":["kotlin","language-features"],"title":"Entendiendo los Context parameters en Kotlin 2.2.0","uri":"https://carrion.dev/es/posts/context-parameters-kotlin/"},{"content":"Aprovechando expect/actual en Kotlin Multiplatform para Implementaciones Nativas Kotlin Multiplatform (KMP) ha surgido como una poderosa solución para compartir código entre diferentes plataformas, permitiendo al mismo tiempo implementaciones específicas de plataforma cuando sea necesario. En el centro de esta capacidad está el mecanismo expect/actual, que permite a los desarrolladores definir una API común en código compartido y proporcionar implementaciones específicas de plataforma. Este artículo explora cómo utilizar eficazmente expect/actual para crear aplicaciones multiplataforma robustas con implementaciones nativas.\nEntendiendo expect/actual en Kotlin Multiplatform El mecanismo expect/actual es el enfoque de Kotlin para manejar código específico de plataforma en un proyecto multiplataforma. Consta de dos componentes clave:\n Declaraciones expect: Definen qué funcionalidad se requiere en el código común Implementaciones actual: Proporcionan implementaciones específicas de plataforma de esa funcionalidad  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // En código común expect class PlatformDateFormatter() { fun format(date: Long): String } // En código específico de Android actual class PlatformDateFormatter { actual fun format(date: Long): String { val dateFormat = SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;, Locale.getDefault()) return dateFormat.format(Date(date)) } } // En código específico de iOS actual class PlatformDateFormatter { actual fun format(date: Long): String { val dateFormatter = NSDateFormatter() dateFormatter.dateFormat = \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34; return dateFormatter.stringFromDate(NSDate(timeIntervalSince1970 = date / 1000.0)) } }   La declaración expect sirve como un contrato que debe ser cumplido por cada implementación específica de plataforma. Esto asegura que el código común pueda confiar en que cierta funcionalidad estará disponible, independientemente de la plataforma.\nVentajas de Usar expect/actual en KMP El mecanismo expect/actual ofrece varios beneficios significativos para el desarrollo multiplataforma:\n  Compartir Código con Optimizaciones Específicas de Plataforma\n Compartir lógica de negocio, modelos y algoritmos entre plataformas Implementar optimizaciones específicas de plataforma donde sea necesario Aprovechar las APIs nativas de la plataforma para un mejor rendimiento y experiencia de usuario    Seguridad de Tipos Entre Plataformas\n El compilador asegura que todas las declaraciones expect tengan implementaciones actual correspondientes La comprobación de tipos funciona a través de los límites de la plataforma La refactorización es más segura ya que los cambios en las declaraciones expect deben reflejarse en todas las implementaciones actual    Mejor Experiencia de Desarrollo\n Clara separación entre interfaces compartidas e implementaciones específicas de plataforma Soporte del IDE para navegar entre declaraciones expect y actual Mantenimiento más fácil ya que la API común se define en un solo lugar    Camino de Adopción Gradual\n Comenzar con código específico de plataforma y gradualmente pasar a implementaciones compartidas Elegir selectivamente qué componentes compartir y cuáles mantener específicos de plataforma Integrar con bases de código existentes sin reescrituras completas    Ejemplos Prácticos de expect/actual en Acción Exploremos algunos ejemplos prácticos de cómo se puede utilizar expect/actual en aplicaciones del mundo real.\nEjemplo 1: Almacenamiento Específico de Plataforma 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // En commonMain expect class LocalStorage { fun saveString(key: String, value: String) fun getString(key: String): String? fun clear() } // En androidMain actual class LocalStorage { private val sharedPreferences = context.getSharedPreferences(\u0026#34;app_prefs\u0026#34;, Context.MODE_PRIVATE) actual fun saveString(key: String, value: String) { sharedPreferences.edit().putString(key, value).apply() } actual fun getString(key: String): String? { return sharedPreferences.getString(key, null) } actual fun clear() { sharedPreferences.edit().clear().apply() } } // En iosMain actual class LocalStorage { private val userDefaults = NSUserDefaults.standardUserDefaults actual fun saveString(key: String, value: String) { userDefaults.setObject(value, key) } actual fun getString(key: String): String? { return userDefaults.stringForKey(key) } actual fun clear() { userDefaults.dictionaryRepresentation().keys.forEach { userDefaults.removeObjectForKey(it) } } }   Este ejemplo demuestra cómo crear una interfaz de almacenamiento común mientras se aprovechan los mecanismos de almacenamiento específicos de plataforma (SharedPreferences en Android y NSUserDefaults en iOS).\nEjemplo 2: Monitoreo de Conectividad de Red 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  // En commonMain expect class NetworkMonitor() { fun startMonitoring(onConnectivityChange: (Boolean) -\u0026gt; Unit) fun stopMonitoring() } // En androidMain actual class NetworkMonitor { private var connectivityManager: ConnectivityManager? = null private var networkCallback: ConnectivityManager.NetworkCallback? = null actual fun startMonitoring(onConnectivityChange: (Boolean) -\u0026gt; Unit) { connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager networkCallback = object : ConnectivityManager.NetworkCallback() { override fun onAvailable(network: Network) { onConnectivityChange(true) } override fun onLost(network: Network) { onConnectivityChange(false) } } val networkRequest = NetworkRequest.Builder().build() connectivityManager?.registerNetworkCallback(networkRequest, networkCallback!!) } actual fun stopMonitoring() { networkCallback?.let { callback -\u0026gt; connectivityManager?.unregisterNetworkCallback(callback) } } } // En iosMain actual class NetworkMonitor { private var reachability: SCNetworkReachability? = null actual fun startMonitoring(onConnectivityChange: (Boolean) -\u0026gt; Unit) { reachability = SCNetworkReachabilityCreateWithName(null, \u0026#34;www.apple.com\u0026#34;) SCNetworkReachabilitySetCallback(reachability) { _, flags, _ -\u0026gt; val isReachable = flags.contains(SCNetworkReachabilityFlags.Reachable) onConnectivityChange(isReachable) } SCNetworkReachabilityScheduleWithRunLoop(reachability, CFRunLoopGetMain(), kCFRunLoopCommonModes) } actual fun stopMonitoring() { reachability?.let { reach -\u0026gt; SCNetworkReachabilityUnscheduleFromRunLoop(reach, CFRunLoopGetMain(), kCFRunLoopCommonModes) } } }   Este ejemplo muestra cómo monitorear la conectividad de red utilizando APIs específicas de plataforma mientras se mantiene una interfaz consistente en el código compartido.\nMejores Prácticas para Usar expect/actual Para aprovechar al máximo el mecanismo expect/actual, considera estas mejores prácticas:\n  Mantén las declaraciones expect mínimas\n Define solo lo que es necesario para que el código común funcione Evita exponer detalles específicos de plataforma en la declaración expect Usa interfaces cuando sea posible para definir comportamiento en lugar de implementación    Usa expect/actual estratégicamente\n No todo necesita ser una declaración expect/actual Considera alternativas como implementaciones de interfaces para casos más simples Reserva expect/actual para casos donde necesites integración profunda con la plataforma    Organiza tu código efectivamente\n Sigue la estructura estándar de conjuntos de fuentes de KMP (commonMain, androidMain, iosMain, etc.) Agrupa declaraciones expect/actual relacionadas Considera usar archivos separados para implementaciones expect/actual complejas    Maneja características específicas de plataforma con elegancia\n Usa expect/actual para proporcionar alternativas para características no disponibles en todas las plataformas Considera funcionalidad opcional que se degrade con elegancia Documenta claramente las limitaciones específicas de plataforma    Prueba tanto el código común como el específico de plataforma\n Escribe pruebas para la interfaz común en commonTest Crea pruebas específicas de plataforma para implementaciones actual Usa mocks o dobles de prueba cuando sea apropiado    Patrones Avanzados con expect/actual A medida que te sientas más cómodo con expect/actual, puedes aprovechar patrones más avanzados:\nDelegación a Bibliotecas Específicas de Plataforma 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // En commonMain expect class JsonParser() { fun parse(jsonString: String): Map\u0026lt;String, Any?\u0026gt; fun stringify(map: Map\u0026lt;String, Any?\u0026gt;): String } // En androidMain actual class JsonParser { private val gson = Gson() actual fun parse(jsonString: String): Map\u0026lt;String, Any?\u0026gt; { val type = object : TypeToken\u0026lt;Map\u0026lt;String, Any?\u0026gt;\u0026gt;() {}.type return gson.fromJson(jsonString, type) } actual fun stringify(map: Map\u0026lt;String, Any?\u0026gt;): String { return gson.toJson(map) } } // En iosMain actual class JsonParser { actual fun parse(jsonString: String): Map\u0026lt;String, Any?\u0026gt; { val nsString = NSString.create(string = jsonString) val data = nsString.dataUsingEncoding(NSUTF8StringEncoding) val nsObject = NSJSONSerialization.JSONObjectWithData(data!!, 0, null) return nsObject as Map\u0026lt;String, Any?\u0026gt; } actual fun stringify(map: Map\u0026lt;String, Any?\u0026gt;): String { val nsData = NSJSONSerialization.dataWithJSONObject(map, 0, null) return NSString.create(data = nsData!!, encoding = NSUTF8StringEncoding) as String } }   Este patrón te permite aprovechar bibliotecas específicas de plataforma (Gson para Android y NSJSONSerialization para iOS) mientras mantienes una API consistente.\nConclusión El mecanismo expect/actual es una piedra angular del desarrollo de Kotlin Multiplatform, permitiendo a los desarrolladores escribir código compartido mientras aprovechan las capacidades específicas de plataforma. Al definir una interfaz común con declaraciones expect y proporcionar implementaciones específicas de plataforma con declaraciones actual, puedes crear aplicaciones que comparten lógica de negocio mientras aprovechan las características nativas de la plataforma.\nA medida que construyes aplicaciones multiplataforma, recuerda que expect/actual es solo una herramienta en tu kit de herramientas de KMP. Úsalo juiciosamente, junto con otros enfoques como interfaces y clases abstractas, para crear el equilibrio adecuado entre compartir código y optimización específica de plataforma.\nCon el enfoque correcto para expect/actual, puedes reducir significativamente la duplicación de código, mejorar la mantenibilidad y entregar aplicaciones de alta calidad en múltiples plataformas sin sacrificar la experiencia nativa que los usuarios esperan.\n","description":"Cómo utilizar el mecanismo expect/actual de Kotlin Multiplatform para crear implementaciones específicas de plataforma con interfaces compartidas.","id":16,"section":"posts","tags":["kotlin","multiplatform","kmp"],"title":"Aprovechando expect/actual en Kotlin Multiplatform para Implementaciones Nativas","uri":"https://carrion.dev/es/posts/expect-actual-kmp/"},{"content":"Aprovechando las Sealed Classes e Interfaces para un Mejor Modelado de Dominio El modelado de dominio es un aspecto crucial del desarrollo de software, representando los conceptos y reglas de negocio fundamentales en tu aplicación. Kotlin proporciona potentes características de lenguaje que pueden ayudar a crear modelos de dominio más expresivos, con seguridad de tipos y mantenibles. Entre estas características, las sealed classes e interfaces destacan como herramientas particularmente valiosas. Este artículo explora cómo aprovechar estas características de Kotlin para construir mejores modelos de dominio.\nEntendiendo las Sealed Classes e Interfaces Las sealed classes e interfaces en Kotlin son construcciones especiales que restringen la jerarquía de un tipo. Cuando una clase o interfaz se marca como sealed, todas sus subclases deben definirse dentro del mismo archivo (o, desde Kotlin 1.5, dentro del mismo módulo como subclases directas).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  sealed class Result\u0026lt;out T\u0026gt; { data class Success\u0026lt;T\u0026gt;(val data: T) : Result\u0026lt;T\u0026gt;() data class Error(val message: String, val cause: Exception? = null) : Result\u0026lt;Nothing\u0026gt;() object Loading : Result\u0026lt;Nothing\u0026gt;() } fun main() { val result: Result\u0026lt;String\u0026gt; = Result.Success(\u0026#34;Data loaded successfully\u0026#34;) val message = when (result) { is Result.Success -\u0026gt; \u0026#34;Success: ${result.data}\u0026#34; is Result.Error -\u0026gt; \u0026#34;Error: ${result.message}\u0026#34; is Result.Loading -\u0026gt; \u0026#34;Loading...\u0026#34; } println(message) // Output: Success: Data loaded successfully }   Los beneficios clave de las sealed classes incluyen:\n Expresiones when exhaustivas: El compilador asegura que todas las posibles subclases sean manejadas en una expresión when Jerarquía restringida: Todas las subclases deben ser conocidas en tiempo de compilación Seguridad de tipos: El compilador puede verificar que todos los casos sean manejados Expresividad: Comunican claramente que un tipo tiene un conjunto limitado de subtipos  Modelado de Dominio con Sealed Classes Exploremos cómo las sealed classes pueden mejorar el modelado de dominio a través de ejemplos prácticos.\nEjemplo 1: Modelando Métodos de Pago Considera una aplicación de comercio electrónico que necesita manejar diferentes métodos de pago:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  sealed class PaymentMethod { data class CreditCard( val cardNumber: String, val expiryDate: String, val cvv: String ) : PaymentMethod() data class PayPal(val email: String) : PaymentMethod() data class BankTransfer( val accountNumber: String, val bankCode: String ) : PaymentMethod() object Cash : PaymentMethod() } class PaymentProcessor { fun process(payment: Payment) { val message = when (payment.method) { is PaymentMethod.CreditCard -\u0026gt; { val card = payment.method \u0026#34;Processing credit card payment with card ending with ${card.cardNumber.takeLast(4)}\u0026#34; } is PaymentMethod.PayPal -\u0026gt; { \u0026#34;Processing PayPal payment for ${payment.method.email}\u0026#34; } is PaymentMethod.BankTransfer -\u0026gt; { \u0026#34;Processing bank transfer from account ${payment.method.accountNumber}\u0026#34; } PaymentMethod.Cash -\u0026gt; { \u0026#34;Processing cash payment\u0026#34; } } println(message) } } data class Payment( val amount: Double, val currency: String, val method: PaymentMethod )   Este enfoque ofrece varias ventajas:\n Seguridad de tipos: El compilador asegura que manejemos todos los métodos de pago Código autodocumentado: La sealed class muestra claramente todos los posibles métodos de pago Extensibilidad: Añadir un nuevo método de pago es tan simple como añadir una nueva subclase Pattern matching: La expresión when proporciona una forma limpia de manejar diferentes métodos de pago  Ejemplo 2: Modelando Respuestas de API Las sealed classes son particularmente útiles para modelar respuestas de API:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  sealed class ApiResponse\u0026lt;out T\u0026gt; { data class Success\u0026lt;T\u0026gt;(val data: T) : ApiResponse\u0026lt;T\u0026gt;() data class Error(val code: Int, val message: String) : ApiResponse\u0026lt;Nothing\u0026gt;() object Loading : ApiResponse\u0026lt;Nothing\u0026gt;() object Empty : ApiResponse\u0026lt;Nothing\u0026gt;() } class UserRepository { fun getUser(id: String): ApiResponse\u0026lt;User\u0026gt; { return try { // Simulate API call  if (id == \u0026#34;123\u0026#34;) { ApiResponse.Success(User(\u0026#34;123\u0026#34;, \u0026#34;John Doe\u0026#34;)) } else { ApiResponse.Error(404, \u0026#34;User not found\u0026#34;) } } catch (e: Exception) { ApiResponse.Error(500, e.message ?: \u0026#34;Unknown error\u0026#34;) } } } data class User(val id: String, val name: String) fun main() { val repository = UserRepository() val response = repository.getUser(\u0026#34;123\u0026#34;) val result = when (response) { is ApiResponse.Success -\u0026gt; \u0026#34;User found: ${response.data.name}\u0026#34; is ApiResponse.Error -\u0026gt; \u0026#34;Error: ${response.message}(${response.code})\u0026#34; ApiResponse.Loading -\u0026gt; \u0026#34;Loading...\u0026#34; ApiResponse.Empty -\u0026gt; \u0026#34;No user data available\u0026#34; } println(result) // Output: User found: John Doe }   Este patrón es ampliamente utilizado en el desarrollo de Android con arquitecturas como MVI (Model-View-Intent) y ayuda a crear una clara separación entre diferentes estados de datos.\nInterfaces Selladas para Jerarquías Más Flexibles Kotlin 1.5 introdujo interfaces selladas, que proporcionan más flexibilidad que las sealed classes porque una clase puede implementar múltiples interfaces:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  sealed interface Error { val message: String } sealed interface NetworkError : Error data class ServerError(override val message: String) : NetworkError data class ConnectionError(override val message: String) : NetworkError sealed interface DatabaseError : Error data class QueryError(override val message: String) : DatabaseError data class TransactionError(override val message: String) : DatabaseError class ErrorHandler { fun handle(error: Error) { val action = when (error) { is ServerError -\u0026gt; \u0026#34;Retry server request\u0026#34; is ConnectionError -\u0026gt; \u0026#34;Check internet connection\u0026#34; is QueryError -\u0026gt; \u0026#34;Fix database query\u0026#34; is TransactionError -\u0026gt; \u0026#34;Rollback transaction\u0026#34; } println(\u0026#34;Error: ${error.message}. Action: $action\u0026#34;) } }   Las interfaces selladas permiten jerarquías más complejas mientras mantienen los beneficios de exhaustividad y seguridad de tipos.\nPatrones Avanzados de Modelado de Dominio Exploremos algunos patrones avanzados usando sealed classes e interfaces.\nMáquinas de Estado con Sealed Classes Las sealed classes son excelentes para implementar máquinas de estado:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  sealed class OrderState { object Created : OrderState() data class Processing(val startTime: Long) : OrderState() data class Shipped(val trackingNumber: String) : OrderState() data class Delivered(val deliveryTime: Long) : OrderState() data class Cancelled(val reason: String) : OrderState() } class OrderStateMachine { fun transition(currentState: OrderState, event: OrderEvent): OrderState { return when (currentState) { is OrderState.Created -\u0026gt; handleCreatedState(event) is OrderState.Processing -\u0026gt; handleProcessingState(event) is OrderState.Shipped -\u0026gt; handleShippedState(event) is OrderState.Delivered -\u0026gt; currentState // Terminal state  is OrderState.Cancelled -\u0026gt; currentState // Terminal state  } } private fun handleCreatedState(event: OrderEvent): OrderState { return when (event) { is OrderEvent.StartProcessing -\u0026gt; OrderState.Processing(System.currentTimeMillis()) is OrderEvent.CancelOrder -\u0026gt; OrderState.Cancelled(event.reason) else -\u0026gt; throw IllegalStateException(\u0026#34;Invalid event $eventfor Created state\u0026#34;) } } private fun handleProcessingState(event: OrderEvent): OrderState { return when (event) { is OrderEvent.ShipOrder -\u0026gt; OrderState.Shipped(event.trackingNumber) is OrderEvent.CancelOrder -\u0026gt; OrderState.Cancelled(event.reason) else -\u0026gt; throw IllegalStateException(\u0026#34;Invalid event $eventfor Processing state\u0026#34;) } } private fun handleShippedState(event: OrderEvent): OrderState { return when (event) { is OrderEvent.DeliverOrder -\u0026gt; OrderState.Delivered(System.currentTimeMillis()) else -\u0026gt; throw IllegalStateException(\u0026#34;Invalid event $eventfor Shipped state\u0026#34;) } } } sealed class OrderEvent { object StartProcessing : OrderEvent() data class ShipOrder(val trackingNumber: String) : OrderEvent() object DeliverOrder : OrderEvent() data class CancelOrder(val reason: String) : OrderEvent() }   Este patrón asegura que:\n Todos los posibles estados estén explícitamente definidos Las transiciones de estado estén controladas y validadas El compilador ayude a asegurar que todos los estados sean manejados El código sea autodocumentado respecto a los posibles estados y transiciones  Mejores Prácticas para Usar Sealed Classes en el Modelado de Dominio   Usa sealed classes para representar conjuntos finitos de posibilidades\n Respuestas de API (Éxito, Error, Cargando) Máquinas de estado (Creado, Procesando, Completado) Patrones de comando (Añadir, Eliminar, Actualizar)    Prefiere interfaces selladas cuando las clases necesiten implementar múltiples interfaces\n Jerarquías de error Capacidades de características Preocupaciones transversales    Combina con data classes para objetos de valor inmutables\n Hace tu modelo de dominio más predecible Proporciona implementaciones de equals(), hashCode() y toString() Permite declaraciones de desestructuración    Aprovecha las expresiones when exhaustivas\n Deja que el compilador asegure que todos los casos sean manejados Usa la declaración when sin una rama else para forzar el manejo de todos los casos    Mantén la jerarquía poco profunda\n Las jerarquías profundas pueden volverse difíciles de entender Considera la composición sobre la herencia para comportamientos complejos    Usa sealed classes anidadas para conceptos relacionados\n Ayuda a organizar el código y mantener el contexto Reduce la contaminación del espacio de nombres    Conclusión Las sealed classes e interfaces son herramientas poderosas para el modelado de dominio en Kotlin. Proporcionan seguridad de tipos, verificación de exhaustividad y expresión clara de conceptos de negocio. Al aprovechar estas características, puedes crear modelos de dominio más robustos, mantenibles y autodocumentados.\nRecuerda que un buen modelado de dominio consiste en expresar claramente los conceptos y reglas de negocio en tu código. Las sealed classes e interfaces ayudan a lograr este objetivo proporcionando una forma de modelar conjuntos finitos de posibilidades de manera segura en cuanto a tipos. Ya sea que estés construyendo una plataforma de comercio electrónico, un sistema de gestión de contenido o una aplicación móvil, estas características de Kotlin pueden mejorar significativamente la calidad de tu modelo de dominio.\nComo con cualquier herramienta, la clave está en saber cuándo y cómo aplicarla. Usa sealed classes e interfaces cuando necesites representar un conjunto cerrado de posibilidades, y combínalas con otras características de Kotlin como data classes y funciones de extensión para crear modelos de dominio expresivos y mantenibles.\n","description":"Cómo utilizar las sealed classes e interfaces de Kotlin para crear modelos de dominio más robustos y con seguridad de tipos.","id":17,"section":"posts","tags":["kotlin","architecture","domain modeling","type safety"],"title":"Aprovechando las Sealed Classes e Interfaces para un Mejor Modelado de Dominio","uri":"https://carrion.dev/es/posts/sealed-classes-domain-modeling/"},{"content":"Composición sobre Herencia: Una Perspectiva de Kotlin En la programación orientada a objetos, existen dos formas principales de reutilizar código y establecer relaciones entre clases: herencia y composición. Aunque ambos enfoques tienen su lugar, el principio de \u0026ldquo;composición sobre herencia\u0026rdquo; ha ganado una tracción significativa en el diseño de software moderno. Esta entrada de blog explora ambos enfoques, sus compensaciones, y por qué la composición es a menudo la opción preferida, con ejemplos en Kotlin.\nEntendiendo la Herencia La herencia es un mecanismo donde una clase (subclase) puede heredar propiedades y comportamientos de otra clase (superclase). Establece una relación \u0026ldquo;es-un\u0026rdquo; entre clases.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // Clase base open class Animal { open fun makeSound() { println(\u0026#34;Some generic animal sound\u0026#34;) } fun eat() { println(\u0026#34;Eating...\u0026#34;) } } // Clase derivada class Dog : Animal() { override fun makeSound() { println(\u0026#34;Woof!\u0026#34;) } fun fetch() { println(\u0026#34;Fetching...\u0026#34;) } } fun main() { val dog = Dog() dog.makeSound() // Salida: Woof!  dog.eat() // Salida: Eating...  dog.fetch() // Salida: Fetching... }   En este ejemplo, Dog hereda de Animal y puede usar sus métodos mientras también añade su propio comportamiento.\nVentajas de la Herencia:\n Reutilización de código - Las subclases heredan automáticamente métodos y propiedades Sobrescritura de métodos - Permite la personalización del comportamiento heredado Polimorfismo - Permite tratar objetos de diferentes subclases como objetos de la superclase  Desventajas de la Herencia:\n Acoplamiento fuerte - Los cambios en la superclase pueden romper las subclases Problema de la clase base frágil - Las modificaciones a la clase base pueden tener efectos inesperados Inflexibilidad - La jerarquía de herencia se fija en tiempo de compilación Limitada a herencia simple en muchos lenguajes (incluyendo Kotlin)  Entendiendo la Composición La composición es un principio de diseño donde las clases logran comportamiento polimórfico y reutilización de código conteniendo instancias de otras clases en lugar de heredar de ellas. Establece una relación \u0026ldquo;tiene-un\u0026rdquo;.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  interface SoundBehavior { fun makeSound() } class BarkSound : SoundBehavior { override fun makeSound() { println(\u0026#34;Woof!\u0026#34;) } } class MeowSound : SoundBehavior { override fun makeSound() { println(\u0026#34;Meow!\u0026#34;) } } class EatingBehavior { fun eat() { println(\u0026#34;Eating...\u0026#34;) } } class Dog( private val soundBehavior: SoundBehavior, private val eatingBehavior: EatingBehavior ) { fun makeSound() { soundBehavior.makeSound() } fun eat() { eatingBehavior.eat() } fun fetch() { println(\u0026#34;Fetching...\u0026#34;) } } class Cat( private val soundBehavior: SoundBehavior, private val eatingBehavior: EatingBehavior ) { fun makeSound() { soundBehavior.makeSound() } fun eat() { eatingBehavior.eat() } fun purr() { println(\u0026#34;Purring...\u0026#34;) } } fun main() { val eatingBehavior = EatingBehavior() val dog = Dog(BarkSound(), eatingBehavior) val cat = Cat(MeowSound(), eatingBehavior) dog.makeSound() // Salida: Woof!  cat.makeSound() // Salida: Meow! }   En este ejemplo, en lugar de heredar comportamiento, las clases Dog y Cat componen su comportamiento conteniendo instancias de SoundBehavior y EatingBehavior.\nVentajas de la Composición:\n Flexibilidad - Los comportamientos pueden cambiarse en tiempo de ejecución Desacoplamiento - Las clases son menos dependientes entre sí No hay problema de clase base frágil - Los cambios en un componente no afectan a otros Múltiples comportamientos - Puede incorporar múltiples comportamientos sin herencia múltiple  El Problema del Diamante y Por Qué Importa Uno de los problemas clásicos con la herencia es el \u0026ldquo;problema del diamante\u0026rdquo;, que ocurre en escenarios de herencia múltiple:\n A / \\ B C \\ / D Si tanto B como C sobrescriben un método de A, ¿qué versión debería heredar D?\nAunque Kotlin no soporta herencia múltiple de clases, sí soporta implementación múltiple de interfaces, lo que puede llevar a problemas similares:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  interface A { fun doSomething() { println(\u0026#34;A\u0026#39;s implementation\u0026#34;) } } interface B : A { override fun doSomething() { println(\u0026#34;B\u0026#39;s implementation\u0026#34;) } } interface C : A { override fun doSomething() { println(\u0026#34;C\u0026#39;s implementation\u0026#34;) } } // Esto no compilará sin sobrescribir explícitamente doSomething class D : B, C { override fun doSomething() { super\u0026lt;B\u0026gt;.doSomething() // Debemos elegir cuál llamar  } }   La composición evita este problema por completo haciendo las relaciones explícitas:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class ComponentA { fun doSomething() { println(\u0026#34;A\u0026#39;s implementation\u0026#34;) } } class ComponentB { fun doSomething() { println(\u0026#34;B\u0026#39;s implementation\u0026#34;) } } class ComponentC { fun doSomething() { println(\u0026#34;C\u0026#39;s implementation\u0026#34;) } } class D( private val componentB: ComponentB, private val componentC: ComponentC ) { fun doSomethingB() { componentB.doSomething() } fun doSomethingC() { componentC.doSomething() } }   Ejemplo del Mundo Real: Componentes de UI Veamos un ejemplo más práctico que involucra componentes de UI:\nEnfoque de Herencia:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  open class UIComponent { open fun render() { println(\u0026#34;Rendering component\u0026#34;) } open fun handleClick() { println(\u0026#34;Component clicked\u0026#34;) } } open class Button : UIComponent() { override fun render() { println(\u0026#34;Rendering button\u0026#34;) } override fun handleClick() { println(\u0026#34;Button clicked\u0026#34;) } } class AnimatedButton : Button() { override fun render() { println(\u0026#34;Rendering animated button\u0026#34;) } }   Enfoque de Composición:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  interface Renderer { fun render() } interface ClickHandler { fun handleClick() } class StandardRenderer : Renderer { override fun render() { println(\u0026#34;Standard rendering\u0026#34;) } } class AnimatedRenderer : Renderer { override fun render() { println(\u0026#34;Animated rendering\u0026#34;) } } class StandardClickHandler : ClickHandler { override fun handleClick() { println(\u0026#34;Standard click handling\u0026#34;) } } class UIComponent( private val renderer: Renderer, private val clickHandler: ClickHandler ) { fun render() { renderer.render() } fun handleClick() { clickHandler.handleClick() } } // Uso fun main() { val standardButton = UIComponent(StandardRenderer(), StandardClickHandler()) val animatedButton = UIComponent(AnimatedRenderer(), StandardClickHandler()) standardButton.render() // Salida: Standard rendering  animatedButton.render() // Salida: Animated rendering }   Con la composición, podemos mezclar y combinar comportamientos sin crear una jerarquía de herencia compleja. Incluso podemos cambiar comportamientos en tiempo de ejecución:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class DynamicButton( private var renderer: Renderer, private var clickHandler: ClickHandler ) { fun render() { renderer.render() } fun handleClick() { clickHandler.handleClick() } fun setRenderer(newRenderer: Renderer) { renderer = newRenderer } fun setClickHandler(newClickHandler: ClickHandler) { clickHandler = newClickHandler } }   Cuándo Usar Herencia A pesar de las ventajas de la composición, la herencia todavía tiene su lugar:\n Cuando hay una clara relación \u0026ldquo;es-un\u0026rdquo; que es poco probable que cambie Cuando quieres aprovechar el polimorfismo de manera directa Cuando la clase base es estable y es poco probable que cambie frecuentemente Para el diseño de frameworks donde los puntos de extensión están bien definidos  Por ejemplo, en la biblioteca estándar de Kotlin, ArrayList hereda de AbstractList, lo que tiene sentido porque un ArrayList es fundamentalmente una lista y esta relación no cambiará.\nMejores Prácticas  Favorece la composición sobre la herencia como regla general Usa herencia cuando hay una verdadera relación \u0026ldquo;es-un\u0026rdquo; que sea estable Diseña para la composición creando interfaces y clases pequeñas y enfocadas Considera la delegación como un punto intermedio (Kotlin tiene soporte incorporado con la palabra clave by) Evita jerarquías de herencia profundas ya que se vuelven difíciles de entender y mantener Programa hacia interfaces, no implementaciones para facilitar la composición  La característica de delegación de Kotlin proporciona una forma conveniente de implementar la composición:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface SoundMaker { fun makeSound() } class Barker : SoundMaker { override fun makeSound() = println(\u0026#34;Woof!\u0026#34;) } // Usando delegación con la palabra clave \u0026#39;by\u0026#39; class Dog(soundMaker: SoundMaker) : SoundMaker by soundMaker { // Métodos adicionales específicos de perro  fun fetch() = println(\u0026#34;Fetching...\u0026#34;) } fun main() { val dog = Dog(Barker()) dog.makeSound() // Salida: Woof!  dog.fetch() // Salida: Fetching... }   Conclusión Aunque la herencia es una característica poderosa de la programación orientada a objetos, la composición a menudo proporciona un enfoque más flexible y mantenible para la reutilización de código y las relaciones entre clases. Al entender las compensaciones entre estos enfoques, puedes tomar mejores decisiones de diseño en tus proyectos de Kotlin.\nRecuerda que un buen diseño no se trata de seguir reglas dogmáticamente, sino de elegir la herramienta adecuada para el trabajo. En muchos casos, esa herramienta será la composición, pero todavía hay casos de uso válidos para la herencia. La clave es entender las implicaciones de tu elección y diseñar tu código para que sea lo más flexible y mantenible posible.\n","description":"Entendiendo las ventajas de la composición sobre la herencia con ejemplos prácticos en Kotlin.","id":18,"section":"posts","tags":["kotlin","arquitectura","patrones de diseño","programación orientada a objetos"],"title":"Composición sobre Herencia: Una Perspectiva de Kotlin","uri":"https://carrion.dev/es/posts/composition-over-inheritance/"},{"content":"Optimización de Rendimiento en Jetpack Compose La optimización del rendimiento es crucial para ofrecer una experiencia de usuario fluida en aplicaciones con Jetpack Compose. Este artículo explora técnicas clave y mejores prácticas para asegurar que tus funciones composables sean eficientes y tengan un buen rendimiento.\nEntendiendo la Composición y Recomposición Uno de los aspectos fundamentales del rendimiento en Compose es entender cómo funcionan la composición y recomposición:\nRecomposición Inteligente Compose utiliza recomposición inteligente para actualizar solo las partes de la UI que necesitan cambiar. Entender qué dispara la recomposición y cómo minimizar su alcance es crucial para la optimización del rendimiento.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  @Composable fun ExpensiveCalculation(numbers: List\u0026lt;Int\u0026gt;) { // Mal: Operación costosa realizada en cada recomposición  val average = numbers.takeIf { it.isNotEmpty() } ?.average() ?: 0.0 // Bien: Operación costosa cacheada y recalculada solo cuando cambia el input  val cachedAverage = remember(numbers) { numbers.takeIf { it.isNotEmpty() } ?.average() ?: 0.0 } Column { // Esto se recalculará en cada recomposición  Text(\u0026#34;Promedio Actual: ${\u0026#34;%.2f\u0026#34;.format(average)}\u0026#34;) // Esto usará el valor cacheado  Text(\u0026#34;Promedio Cacheado: ${\u0026#34;%.2f\u0026#34;.format(cachedAverage)}\u0026#34;) } }   Tipos Estables e Inmutabilidad Los tipos estables son cruciales para el sistema de recomposición inteligente de Compose. Un tipo se considera estable cuando Compose puede garantizar que su método equals() es consistente con sus propiedades y que las propiedades mismas no cambiarán sin disparar una recomposición.\n1 2 3 4 5 6 7 8 9 10 11 12  // Mal: Tipo inestable - propiedades mutables pueden cambiar sin notificar a Compose data class UserState( var name: String, // Propiedad mutable puede cambiar silenciosamente  var age: Int // Los cambios no dispararán recomposición ) // Bien: Tipo estable - propiedades inmutables y estabilidad explícita @Stable // Indica a Compose que este tipo tiene una igualdad predecible data class UserState( val name: String, // Propiedad inmutable  val age: Int // Los cambios requieren crear una nueva instancia )   El uso de tipos estables proporciona varios beneficios:\n Recomposición más eficiente - Compose puede omitir la recomposición de partes de la UI cuando sabe que los datos no han cambiado Comportamiento predecible - Los cambios en los datos siempre disparan actualizaciones apropiadas de la UI Seguridad entre hilos - Los datos inmutables son seguros para compartir entre corrutinas  Optimizaciones Clave de Rendimiento 1. Gestión de Estado con remember y derivedStateOf Las funciones remember y derivedStateOf sirven diferentes propósitos en la gestión de estado:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  @Composable fun UserProfile(user: User, items: List\u0026lt;Item\u0026gt;) { // Mal: Recalculando en cada recomposición  val filteredItems = items.filter { it.userId == user.id } // Bien: Cacheando cálculo con remember  val cachedItems = remember(items, user.id) { items.filter { it.userId == user.id } } // Mejor: Usando derivedStateOf para computaciones reactivas  val reactiveItems by remember(items) { derivedStateOf { items.filter { it.userId == user.id } } } // reactiveItems se actualizará automáticamente cuando items cambie  // y solo disparará recomposición cuando el resultado filtrado cambie  LazyColumn { itemsIndexed( items = reactiveItems, key = { _: Int, item: Item -\u0026gt; item.id } ) { _: Int, item: Item -\u0026gt; ItemRow(item) } } }   2. Uso de Composition Local 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  // Mal: Cada componente hijo accede a CompositionLocal @Composable fun DeepNestedContent() { val theme = LocalTheme.current // Accedido directamente  val strings = LocalStrings.current // Múltiples accesos a CompositionLocal  val dimensions = LocalDimensions.current Column { Text( text = strings.title, style = theme.textStyle, modifier = Modifier.padding(dimensions.padding) ) // Más contenido anidado con accesos repetidos a CompositionLocal  } } // Bien: Elevando valores de CompositionLocal para minimizar búsquedas @Composable fun ParentContent() { // Acceso único a valores de CompositionLocal  val theme = LocalTheme.current val strings = LocalStrings.current val dimensions = LocalDimensions.current DeepNestedContent( theme = theme, strings = strings, dimensions = dimensions ) } @Composable fun DeepNestedContent( theme: Theme, strings: Strings, dimensions: Dimensions ) { // Usar parámetros pasados en lugar de buscar valores de CompositionLocal  Column { Text( text = strings.title, style = theme.textStyle, modifier = Modifier.padding(dimensions.padding) ) // Más contenido anidado usando parámetros pasados  } }   3. Optimizaciones de LazyList El renderizado eficiente de listas es crucial para un desplazamiento suave. Aquí hay optimizaciones clave para componentes LazyList:\n1 2 3 4 5 6 7 8 9 10 11 12  @Composable fun \u0026lt;T : Any\u0026gt; OptimizedList(items: List\u0026lt;T\u0026gt;) { LazyColumn { itemsIndexed( items = items, // Las claves estables ayudan a Compose a rastrear items a través de actualizaciones  key = { _: Int, item: T -\u0026gt; item.hashCode() } ) { _: Int, item: T -\u0026gt; // Contenido para cada item  } } }   Optimizaciones clave para LazyList:\n Proporcionar claves estables para ayudar a Compose a rastrear items a través de actualizaciones Usar tamaños fijos cuando sea posible para evitar remedición Mantener los composables de items ligeros Evitar asignaciones innecesarias en el contenido de items Usar remember para cachear computaciones costosas por item  Medición y Monitoreo del Rendimiento Layout Inspector y Trazas de Composición El Layout Inspector en Android Studio es una herramienta poderosa para depurar el rendimiento de UI en Compose. Proporciona información sobre la jerarquía de vistas de tu app, conteos de recomposición y modificadores aplicados a cada composable.\nPara usar Layout Inspector con Compose:\n Ejecuta tu app en modo debug En la ventana de Dispositivos en Ejecución encontrarás un botón para Alternar Layout Inspector Inspecciona la jerarquía de Compose:  Ver árbol de componentes Verificar conteos de recomposición Analizar cadenas de modificadores Inspeccionar parámetros de composables    Métricas clave para monitorear en Layout Inspector:\n Conteos de recomposición - Números altos indican oportunidades potenciales de optimización Conteos de omisión - Verifica que tus Composables estén omitiendo recomposición cuando deberían Complejidad de cadena de modificadores - Cadenas largas pueden afectar el rendimiento de medición/layout  Pruebas de Rendimiento 1 2 3 4 5 6 7 8 9 10 11 12  @Test fun performanceTest() { benchmarkRule.measureRepeated( packageName = \u0026#34;com.example.app\u0026#34;, metrics = listOf(FrameTimingMetric()), iterations = 5 ) { composeTestRule.setContent { YourComposable() } } }   Resumen de Mejores Prácticas  Usar tipos estables y estructuras de datos inmutables Elevar computaciones costosas con remember Implementar claves apropiadas en listas lazy Minimizar el alcance de la recomposición Perfilar y medir el rendimiento regularmente  Seguir estas técnicas de optimización ayudará a asegurar que tu UI en Compose permanezca responsiva y eficiente, proporcionando una mejor experiencia de usuario para tus aplicaciones.\n","description":"Aprende técnicas esenciales y mejores prácticas para optimizar el rendimiento en aplicaciones con Jetpack Compose, incluyendo optimización de composición, control de recomposición y gestión de memoria","id":19,"section":"posts","tags":["android","compose","performance","optimization"],"title":"Optimización de Rendimiento en Jetpack Compose","uri":"https://carrion.dev/es/posts/performance-optimization-compose/"},{"content":"Animaciones y Transiciones Personalizadas en Jetpack Compose Crear animaciones fluidas y significativas es crucial para ofrecer una experiencia de usuario pulida. Este artículo explora cómo crear animaciones y transiciones personalizadas en Jetpack Compose, desde animaciones básicas hasta implementaciones personalizadas complejas.\nCreando Animaciones Personalizadas Las animaciones personalizadas permiten efectos visuales más complejos y únicos:\nEspecificaciones de Animación Personalizadas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  @Composable fun CustomAnimatedButton( onClick: () -\u0026gt; Unit, content: @Composable () -\u0026gt; Unit ) { var isPressed by remember { mutableStateOf(false) } val scope = rememberCoroutineScope() val scale by animateFloatAsState( targetValue = if (isPressed) 0.95f else 1f, animationSpec = spring( dampingRatio = 0.4f, stiffness = Spring.StiffnessLow ) ) Box( modifier = Modifier .scale(scale) .clickable( interactionSource = remember { MutableInteractionSource() }, indication = null ) { isPressed = true onClick() // Restablecer después de la animación usando un scope consciente del ciclo de vida  scope.launch { delay(100) isPressed = false } } ) { content() } }   Animaciones Infinitas Para animaciones continuas como indicadores de carga:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  @Composable fun PulsatingDot( color: Color, size: Dp = 20.dp ) { val infiniteTransition = rememberInfiniteTransition(label = \u0026#34;pulsating\u0026#34;) val scale by infiniteTransition.animateFloat( initialValue = 0.6f, targetValue = 1f, animationSpec = infiniteRepeatable( animation = tween(1000), repeatMode = RepeatMode.Reverse ), label = \u0026#34;scale\u0026#34; ) Box( modifier = Modifier .size(size) .scale(scale) .background(color, CircleShape) ) }   Implementando Transiciones Personalizadas Las transiciones ayudan a crear cambios suaves entre diferentes estados de la UI:\nTransiciones de Contenido 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @Composable fun AnimatedContent( content: @Composable () -\u0026gt; Unit, modifier: Modifier = Modifier ) { AnimatedVisibility( visible = true, enter = fadeIn() + expandVertically(), exit = fadeOut() + shrinkVertically() ) { Box(modifier = modifier) { content() } } }   Especificaciones de Transición Personalizadas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  @Composable fun CustomTransitionCard( expanded: Boolean, modifier: Modifier = Modifier, content: @Composable () -\u0026gt; Unit ) { val transition = updateTransition( targetState = expanded, label = \u0026#34;card_transition\u0026#34; ) val cardElevation by transition.animateDp( label = \u0026#34;elevation\u0026#34;, targetValueByState = { isExpanded: Boolean -\u0026gt; if (isExpanded) 8.dp else 2.dp } ) val cardRoundedCorners by transition.animateDp( label = \u0026#34;corner_radius\u0026#34;, targetValueByState = { isExpanded: Boolean -\u0026gt; if (isExpanded) 0.dp else 16.dp } ) Card( modifier = modifier, elevation = CardDefaults.cardElevation(defaultElevation = cardElevation), shape = RoundedCornerShape(cardRoundedCorners) ) { content() } }   Mejores Prácticas y Optimización de Rendimiento Al implementar animaciones personalizadas, ten en cuenta estas mejores prácticas:\n1. Gestión del Estado de Animación Mantén el estado de la animación cerca de donde se usa:\n1 2 3 4 5 6 7 8 9 10 11  @Composable fun OptimizedAnimation() { // ❌ No almacenes valores de animación a nivel de composable  // var scale by remember { mutableStateOf(1f) }  // ✅ Usa AnimationState o APIs animate*  val scale by animateFloatAsState( targetValue = 1f, label = \u0026#34;scale\u0026#34; ) }   2. Consideraciones de Rendimiento  Usa remember para cálculos costosos Evita animar parámetros de layout cuando sea posible Considera usar LaunchedEffect para animaciones complejas  Conclusión Las animaciones y transiciones personalizadas en Jetpack Compose proporcionan herramientas poderosas para crear experiencias de usuario atractivas. Al comprender los conceptos fundamentales y seguir las mejores prácticas, puedes crear animaciones fluidas y eficientes que mejoren la interfaz de usuario de tu aplicación.\nRecuerda:\n Comienza con animaciones simples y aumenta gradualmente la complejidad Prueba las animaciones en diferentes dispositivos y tamaños de pantalla Considera las implicaciones de accesibilidad Monitoriza el impacto en el rendimiento Usa principios de animación para crear transiciones significativas  Para temas más avanzados, consulta nuestros otros artículos sobre optimización de rendimiento y gestión de estado en Compose.\nPuedes encontrar todos los ejemplos de este post en el siguiente repositorio de GitHub: ComposeAnimations\n","description":"Análisis profundo sobre la creación de animaciones y transiciones personalizadas en Jetpack Compose, cubriendo APIs de animación, transiciones personalizadas y optimización de rendimiento","id":20,"section":"posts","tags":["android","compose","animation","transitions"],"title":"Animaciones y Transiciones Personalizadas en Jetpack Compose","uri":"https://carrion.dev/es/posts/custom-animations-transitions-compose/"},{"content":"Gestión Avanzada de Estado en Compose: Effects y Flows Este artículo explora patrones avanzados de gestión de estado en Jetpack Compose, centrándose en Effects e integración de Flows. Para conceptos fundamentales como mutableStateOf y state hoisting, consulta nuestro artículo complementario Gestión Básica de Estado en Jetpack Compose.\nEntendiendo los Effects en Compose Los Effects en Compose son herramientas para manejar efectos secundarios y eventos del ciclo de vida de manera compatible con los composables. Exploremos los diferentes tipos de effects y sus casos de uso:\nLaunchedEffect: Efectos Secundarios Basados en Corrutinas LaunchedEffect lanza una corrutina que se cancela automáticamente cuando el composable sale de la composición:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @Composable fun AutoRefreshingList(viewModel: ListViewModel) { // Inicia una corrutina que actualiza datos cada 30 segundos  LaunchedEffect(Unit) { while(true) { viewModel.refreshData() delay(30_000) } } // El parámetro key controla cuándo debe reiniciarse el efecto  LaunchedEffect(viewModel.searchQuery) { viewModel.performSearch() } }   SideEffect: Sincronización con Código No-Compose SideEffect se llama en cada recomposición exitosa para sincronizar el estado de Compose con código no-Compose:\n1 2 3 4 5 6 7  @Composable fun AnalyticsScreen(screenName: String) { SideEffect { // Se llama después de cada recomposición exitosa  AnalyticsTracker.trackScreen(screenName) } }   DisposableEffect: Operaciones de Limpieza DisposableEffect maneja la limpieza cuando un composable sale de la composición:\n1 2 3 4 5 6 7 8 9 10 11  @Composable fun NetworkMonitor(onConnectionChange: (Boolean) -\u0026gt; Unit) { DisposableEffect(Unit) { val listener = NetworkListener(onConnectionChange) listener.register() onDispose { listener.unregister() } } }   derivedStateOf: Estado Computado derivedStateOf crea un estado que se actualiza automáticamente cuando sus dependencias cambian. Es particularmente útil para cálculos basados en umbrales y derivaciones de estado de UI que no deberían disparar recomposiciones en cada pequeño cambio:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  import androidx.compose.foundation.lazy.LazyListState import androidx.compose.foundation.lazy.rememberLazyListState import androidx.compose.runtime.getValue import androidx.compose.runtime.remember import androidx.compose.runtime.derivedStateOf // Ejemplo que muestra cómo derivedStateOf ayuda a prevenir // recomposiciones innecesarias al trabajar con estado de scroll @Composable fun ScrollableNewsScreen() { val listState = rememberLazyListState() // ❌ Sin derivedStateOf  // Estas propiedades se recalcularían en cada cambio de píxel del scroll,  // causando recomposiciones innecesarias de cualquier composable que las lea  // val showScrollToTop = listState.firstVisibleItemIndex \u0026gt; 0  // val isScrollInProgress = listState.isScrollInProgress  // ✅ Con derivedStateOf  // Estos cálculos solo se disparan al cruzar umbrales específicos,  // reduciendo significativamente las recomposiciones innecesarias  val showScrollToTop by remember { derivedStateOf { // Solo muestra el botón cuando se ha desplazado más allá del primer elemento  listState.firstVisibleItemIndex \u0026gt; 0 } } val shouldLoadMore by remember { derivedStateOf { val lastVisibleItem = listState.layoutInfo.visibleItemsInfo.lastOrNull() // Dispara la paginación cuando el usuario está cerca del final  lastVisibleItem?.index != null \u0026amp;\u0026amp; lastVisibleItem.index \u0026gt;= listState.layoutInfo.totalItemsCount - 3 } } val isScrollingUp by remember { derivedStateOf { // Rastrea la dirección del scroll basado en el primer elemento visible  listState.firstVisibleItemScrollOffset \u0026lt; 100 } } // Usa estos estados derivados para controlar elementos de UI como:  // - Visibilidad del botón de scroll hacia arriba (showScrollToTop)  // - Carga de paginación (shouldLoadMore)  // - Barra superior colapsable/expandible (isScrollingUp)  NewsScreenContent( showScrollButton = showScrollToTop, isScrollingUp = isScrollingUp, shouldLoadMore = shouldLoadMore ) } // Nota: Implementación de NewsScreenContent y otros componentes UI omitidos por brevedad   produceState: Convirtiendo Estado No-Compose a State produceState convierte fuentes de estado no-Compose en estado de Compose:\n1 2 3 4 5 6 7 8 9 10  @Composable fun UserProfile(userId: String) { val user by produceState\u0026lt;User?\u0026gt;(initialValue = null, userId) { value = userRepository.fetchUser(userId) awaitDispose { // Limpieza si es necesaria  } } }   Integración de Flows con Compose Cuando trabajamos con Flows en Compose, necesitamos convertirlos en estado de Compose. Jetpack Compose proporciona dos funciones principales para este propósito: collectAsState y collectAsStateWithLifecycle.\ncollectAsState: Recolección Básica de Flow collectAsState convierte un Flow en un State de Compose:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @Composable fun UserProfile(viewModel: UserViewModel) { // Recolección básica  val name by viewModel.nameFlow.collectAsState() // Con valor inicial  val count by viewModel.countFlow.collectAsState(initial = 0) // Manejando flows nulables  val user by viewModel.userFlow.collectAsState(initial = null) Text(\u0026#34;Nombre: $name\u0026#34;) Text(\u0026#34;Contador: $count\u0026#34;) user?.let { Text(\u0026#34;Usuario: ${it.name}\u0026#34;) } }   collectAsStateWithLifecycle: Recolección Consciente del Ciclo de Vida collectAsStateWithLifecycle es la forma recomendada de recolectar flows en Compose ya que respeta el ciclo de vida del composable. Proporciona varios beneficios sobre collectAsState:\n Detiene automáticamente la recolección cuando el composable no está visible Reanuda la recolección cuando el composable vuelve a ser visible Reduce el procesamiento innecesario y el consumo de batería Previene fugas de memoria limpiando adecuadamente los recursos Permite un control preciso sobre cuándo debe ocurrir la recolección  Aquí te mostramos cómo usarlo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // Tipos de datos para el ejemplo data class UserUpdate( val id: String, val message: String, val timestamp: Long ) @Composable fun UserUpdates(viewModel: UserViewModel) { // Recolección básica consciente del ciclo de vida  val updates by viewModel.userUpdatesFlow .collectAsStateWithLifecycle(initialValue = emptyList()) // Estado de ciclo de vida personalizado  val notifications by viewModel.notificationsFlow .collectAsStateWithLifecycle( initialValue = emptyList(), lifecycle = lifecycle, minActiveState = Lifecycle.State.RESUMED // Solo recolecta cuando está RESUMED  ) LazyColumn { items(updates) { update: UserUpdate -\u0026gt; UpdateItem(update) } } }   Conclusión La gestión avanzada de estado en Compose requiere entender tanto los Effects como la integración de Flows. Los Effects ayudan a manejar efectos secundarios y eventos del ciclo de vida, mientras que la integración adecuada de Flows asegura una recolección eficiente de estado que respeta el ciclo de vida de Android.\nRecuerda:\n Elegir el Effect apropiado para tu caso de uso Usar collectAsStateWithLifecycle para la integración de Flows al recolectar de flows Probar exhaustivamente tu implementación de gestión de estado  Para conceptos fundamentales de gestión de estado, consulta nuestro artículo complementario Gestión Básica de Estado en Jetpack Compose.\n","description":"Análisis profundo de la gestión avanzada de estado en Jetpack Compose, incluyendo Effects, integración de Flows y recolección de estado consciente del ciclo de vida","id":21,"section":"posts","tags":["android","compose","state","flows","effects"],"title":"Gestión Avanzada de Estado en Compose: Effects y Flows","uri":"https://carrion.dev/es/posts/advanced-state-management-compose/"},{"content":"Patrones de Gestión de Estado en Jetpack Compose La gestión del estado es un aspecto crucial en el desarrollo de aplicaciones robustas y mantenibles con Jetpack Compose. Este artículo explora patrones esenciales y mejores prácticas para gestionar el estado de manera efectiva en tu UI con Compose, incluyendo estado inmutable, actualizaciones basadas en eventos y estrategias de pruebas.\nEntendiendo los Patrones de Gestión de Estado La gestión efectiva del estado en Compose requiere entender cómo estructurar y manejar los cambios de estado de una manera mantenible, testeable y escalable. Esto involucra varios patrones clave:\n Clases de Estado Inmutable: Define límites claros de estado y previene modificaciones no intencionadas Actualizaciones Basadas en Eventos: Centraliza las modificaciones de estado a través de eventos bien definidos Flujo de Estado Predecible: Asegura que los cambios de estado sigan un patrón consistente Arquitectura Testeable: Estructura el código para facilitar pruebas exhaustivas  Veamos cada uno de estos patrones en detalle.\n1. Fuente Única de la Verdad La base de una gestión efectiva del estado es mantener una fuente única de la verdad para el estado de tu aplicación. Este patrón ayuda a prevenir inconsistencias y hace que los cambios de estado sean más predecibles.\nEl patrón de Fuente Única de la Verdad implica usar una interfaz/clase sellada para representar todos los posibles estados de tu UI. Este enfoque proporciona varios beneficios:\n Seguridad de tipos: El compilador asegura que manejes todos los estados posibles Consistencia: Todo el estado de la UI proviene de una fuente autoritativa Predecibilidad: Las transiciones de estado son explícitas y rastreables Mantenibilidad: Cada estado es una instantánea completa de la UI Testeable: Los cambios de estado pueden ser fácilmente verificados  Aquí te mostramos cómo implementar este patrón:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // Ejemplo del patrón Fuente Única de la Verdad sealed interface UserUiState { object Loading : UserUiState data class Error(val message: String) : UserUiState data class Success(val user: User) : UserUiState } class UserViewModel : ViewModel() { private val _uiState = MutableStateFlow\u0026lt;UserUiState\u0026gt;(UserUiState.Loading) val uiState: StateFlow\u0026lt;UserUiState\u0026gt; = _uiState.asStateFlow() fun loadUser(userId: String) { viewModelScope.launch { _uiState.emit(UserUiState.Loading) try { val user = userRepository.getUser(userId) _uiState.emit(UserUiState.Success(user)) } catch (e: Exception) { _uiState.emit(UserUiState.Error(e.message ?: \u0026#34;Error desconocido\u0026#34;)) } } } } // El Composable puede manejar fácilmente todos los estados en un solo lugar @Composable fun UserScreen(viewModel: UserViewModel) { val uiState by viewModel.uiState.collectAsStateWithLifecycle() when (val state = uiState) { is UserUiState.Loading -\u0026gt; LoadingSpinner() is UserUiState.Error -\u0026gt; ErrorMessage(state.message) is UserUiState.Success -\u0026gt; { UserContent(state.user) } } }   2. Inmutabilidad del Estado El segundo patrón clave es mantener objetos de estado inmutables. Este enfoque es crucial para:\n Prevenir condiciones de carrera en operaciones concurrentes Hacer que los cambios de estado sean explícitos y rastreables Permitir una detección eficiente de cambios en Compose Simplificar la depuración y el testing  Aquí te mostramos cómo implementar la gestión de estado inmutable:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  // Define los modelos de dominio data class SearchResult( val id: String, val title: String, val description: String ) // Define una clase de estado inmutable data class SearchState( val query: String = \u0026#34;\u0026#34;, val results: List\u0026lt;SearchResult\u0026gt; = emptyList(), val selectedResult: SearchResult? = null, val isLoading: Boolean = false ) class SearchViewModel : ViewModel() { private val _uiState = MutableStateFlow(SearchState()) val uiState: StateFlow\u0026lt;SearchState\u0026gt; = _uiState.asStateFlow() fun onQueryChange(query: String) { _uiState.update { it.copy( query = query, isLoading = query.isNotEmpty() ) } searchResults(query) } fun onResultSelected(result: SearchResult) { _uiState.update { it.copy(selectedResult = result) } } private fun searchResults(query: String) { viewModelScope.launch { try { val results = searchRepository.search(query) _uiState.update { it.copy( results = results, isLoading = false ) } } catch (e: Exception) { _uiState.update { it.copy( results = emptyList(), isLoading = false ) } } } } } @Composable fun SearchScreen(viewModel: SearchViewModel) { val state by viewModel.uiState.collectAsStateWithLifecycle() Column(modifier = Modifier.padding(16.dp)) { SearchBar( query = state.query, onQueryChange = viewModel::onQueryChange ) if (state.isLoading) { CircularProgressIndicator() } else { LazyColumn { items( items = state.results, key = { it.id } ) { result: SearchResult -\u0026gt; SearchResultItem( result = result, isSelected = result == state.selectedResult, onClick = { viewModel.onResultSelected(result) } ) } } } } }   3. Actualizaciones Basadas en Eventos El tercer patrón clave es usar eventos para hacer que las actualizaciones de estado sean predecibles. Este enfoque ayuda a:\n Centralizar la lógica de modificación de estado Hacer que las transiciones de estado sean explícitas y rastreables Asegurar que todas las actualizaciones de estado sigan un patrón consistente Simplificar el testing mediante la verificación del manejo de eventos  Aquí te mostramos cómo implementar actualizaciones basadas en eventos:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130  // Los eventos representan todas las formas posibles de modificar el estado // Beneficios: // 1. Seguridad de tipos: El compilador asegura que todos los eventos sean manejados // 2. Centralizado: Todas las modificaciones de estado pasan por un único punto // 3. Rastreable: Fácil de registrar y depurar cambios de estado // 4. Testeable: Los eventos pueden ser fácilmente simulados y verificados sealed interface ProfileEvent { object LoadProfile : ProfileEvent data class UpdateBio(val newBio: String) : ProfileEvent data class UpdateName(val newName: String) : ProfileEvent object SaveProfile : ProfileEvent } data class ProfileState( val name: String = \u0026#34;\u0026#34;, val bio: String = \u0026#34;\u0026#34;, val isLoading: Boolean = false, val isSaving: Boolean = false, val error: String? = null ) class ProfileViewModel : ViewModel() { private val _uiState = MutableStateFlow(ProfileState()) val uiState: StateFlow\u0026lt;ProfileState\u0026gt; = _uiState.asStateFlow() // Punto único de entrada para todas las modificaciones de estado  // Esto asegura que:  // 1. Todos los cambios de estado se manejen consistentemente  // 2. Las modificaciones de estado sean fáciles de rastrear  // 3. Los efectos secundarios se manejen adecuadamente  fun onEvent(event: ProfileEvent) { when (event) { is ProfileEvent.LoadProfile -\u0026gt; loadProfile() is ProfileEvent.UpdateBio -\u0026gt; updateBio(event.newBio) is ProfileEvent.UpdateName -\u0026gt; updateName(event.newName) is ProfileEvent.SaveProfile -\u0026gt; saveProfile() } } // Cada manejador de eventos sigue el mismo patrón:  // 1. Actualizar el estado para mostrar la operación en progreso  // 2. Realizar la operación  // 3. Actualizar el estado con el resultado o error  private fun loadProfile() { viewModelScope.launch { _uiState.update { it.copy(isLoading = true, error = null) } try { val profile = profileRepository.getProfile() _uiState.update { it.copy( name = profile.name, bio = profile.bio, isLoading = false ) } } catch (e: Exception) { _uiState.update { it.copy( isLoading = false, error = e.message ) } } } } private fun updateBio(newBio: String) { _uiState.update { it.copy(bio = newBio) } } private fun updateName(newName: String) { _uiState.update { it.copy(name = newName) } } // Para operaciones asíncronas, manejamos los estados de carga y errores consistentemente  private fun saveProfile() { viewModelScope.launch { _uiState.update { it.copy(isSaving = true, error = null) } try { profileRepository.saveProfile( name = uiState.value.name, bio = uiState.value.bio ) _uiState.update { it.copy(isSaving = false) } } catch (e: Exception) { _uiState.update { it.copy( isSaving = false, error = e.message ) } } } } } @Composable fun ProfileScreen(viewModel: ProfileViewModel) { // La capa UI solo necesita:  // 1. Observar cambios de estado  // 2. Enviar eventos al ViewModel  // Esto crea una clara separación de responsabilidades  val state by viewModel.uiState.collectAsStateWithLifecycle() Column(modifier = Modifier.padding(16.dp)) { OutlinedTextField( value = state.name, onValueChange = { viewModel.onEvent(ProfileEvent.UpdateName(it)) }, label = { Text(\u0026#34;Nombre\u0026#34;) } ) OutlinedTextField( value = state.bio, onValueChange = { viewModel.onEvent(ProfileEvent.UpdateBio(it)) }, label = { Text(\u0026#34;Biografía\u0026#34;) } ) Button( onClick = { viewModel.onEvent(ProfileEvent.SaveProfile) }, enabled = !state.isLoading \u0026amp;\u0026amp; !state.isSaving ) { Text(\u0026#34;Guardar Perfil\u0026#34;) } state.error?.let { error: String -\u0026gt; Text( text = error, color = MaterialTheme.colorScheme.error ) } if (state.isLoading) { CircularProgressIndicator(Modifier.align(Alignment.CenterHorizontally)) } } }   4. Estrategia de Pruebas El cuarto patrón clave es implementar una estrategia de pruebas integral. Las pruebas de la gestión de estado en Compose involucran tres aspectos principales:\n Pruebas de actualizaciones y transiciones de estado del ViewModel Verificación del manejo de eventos y efectos secundarios Asegurar que la UI refleje correctamente los cambios de estado  Aquí te mostramos cómo implementar una estrategia de pruebas completa:\nPara pruebas de ViewModel:\n El estado inicial es correcto Los eventos producen las actualizaciones de estado esperadas Las operaciones asíncronas manejan estados de carga y error Las actualizaciones de estado son atómicas y consistentes  Para pruebas de UI:\n Los componentes reflejan el estado actual Las interacciones del usuario disparan los eventos correctos Los estados de carga y error se muestran adecuadamente  Aquí tienes un ejemplo completo mostrando estos patrones de testing:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98  // La clase de prueba demuestra: // 1. Configuración adecuada de pruebas con dependencias // 2. Pruebas de diferentes flujos (éxito, error, actualizaciones inmediatas) // 3. Verificación de transiciones de estado class ProfileViewModelTest { private lateinit var viewModel: ProfileViewModel private lateinit var testRepository: TestProfileRepository @Before fun setup() { testRepository = TestProfileRepository() viewModel = ProfileViewModel(testRepository) } @Test fun `cargar perfil - flujo exitoso`() = runTest { // Dado  val testProfile = Profile(name = \u0026#34;Usuario Test\u0026#34;, bio = \u0026#34;Bio Test\u0026#34;) testRepository.setProfile(testProfile) // Estado inicial  assertThat(viewModel.uiState.value) .isEqualTo(ProfileState()) // Cuando  viewModel.onEvent(ProfileEvent.LoadProfile) // Entonces - Estado de carga  assertThat(viewModel.uiState.value.isLoading).isTrue() assertThat(viewModel.uiState.value.error).isNull() // Completar trabajo asíncrono  advanceUntilIdle() // Entonces - Estado de éxito  with(viewModel.uiState.value) { assertThat(isLoading).isFalse() assertThat(name).isEqualTo(testProfile.name) assertThat(bio).isEqualTo(testProfile.bio) assertThat(error).isNull() } } @Test fun `cargar perfil - flujo de error`() = runTest { // Dado  testRepository.setShouldError(true) // Cuando  viewModel.onEvent(ProfileEvent.LoadProfile) advanceUntilIdle() // Entonces  with(viewModel.uiState.value) { assertThat(isLoading).isFalse() assertThat(error).isNotNull() } } @Test fun `actualizar nombre actualiza el estado inmediatamente`() = runTest { // Cuando  viewModel.onEvent(ProfileEvent.UpdateName(\u0026#34;Nuevo Nombre\u0026#34;)) // Entonces  assertThat(viewModel.uiState.value.name).isEqualTo(\u0026#34;Nuevo Nombre\u0026#34;) } } // Tests de UI verifican el flujo completo: // 1. Renderizado del estado inicial // 2. Actualización de la UI con cambios de estado // 3. Manejo de interacciones del usuario @Test fun `pantalla de perfil muestra indicador de carga y luego contenido`() { // Crear regla de test  composeTestRule.setContent { ProfileScreen(viewModel = viewModel) } // Verificar estado inicial de carga  composeTestRule.onNode(hasTestTag(\u0026#34;loading\u0026#34;)).assertIsDisplayed() // Completar la carga  runTest { advanceUntilIdle() } // Verificar contenido  composeTestRule.onNode(hasText(\u0026#34;Usuario Test\u0026#34;)).assertIsDisplayed() composeTestRule.onNode(hasText(\u0026#34;Bio Test\u0026#34;)).assertIsDisplayed() // Probar interacción  composeTestRule.onNode(hasText(\u0026#34;Guardar Perfil\u0026#34;)).performClick() // Verificar que el evento de guardado fue manejado  verify(viewModel).onEvent(ProfileEvent.SaveProfile) }   La combinación de gestión de estado basada en eventos y estados inmutables hace que las pruebas sean sencillas:\n Los eventos proporcionan puntos de entrada claros para probar cambios de estado Los estados inmutables hacen que las aserciones sean simples y confiables Las transiciones de estado son fáciles de verificar Las pruebas de UI pueden centrarse en reflejar el estado y las interacciones del usuario  Conclusión La gestión efectiva del estado en Jetpack Compose requiere una combinación de patrones y mejores prácticas:\n  Fuente Única de la Verdad\n Usa clases de estado inmutable para representar todos los estados posibles Mantén la gestión de estado centralizada y predecible Haz que los cambios de estado sean explícitos y rastreables    Inmutabilidad del Estado\n Previene modificaciones no intencionadas con estado inmutable Usa data classes con copy para actualizaciones de estado Mantén la seguridad de hilos y la predecibilidad    Actualizaciones Basadas en Eventos\n Define eventos claros para todas las modificaciones de estado Centraliza la lógica de actualización de estado Haz que las transiciones de estado sean explícitas y verificables    Estrategia de Pruebas\n Prueba las transiciones de estado exhaustivamente Verifica que las actualizaciones de UI reflejen los cambios de estado Asegura el manejo adecuado de eventos    Siguiendo estos patrones, construirás aplicaciones Compose que son:\n Más mantenibles y fáciles de depurar Menos propensas a errores relacionados con el estado Más fáciles de probar y verificar Más escalables a medida que crece la complejidad  ","description":"Aprende patrones esenciales para gestionar el estado en aplicaciones Jetpack Compose, incluyendo estado inmutable, actualizaciones basadas en eventos y estrategias de testing","id":22,"section":"posts","tags":["android","compose","patrones","estado","pruebas"],"title":"Patrones de Gestión de Estado en Jetpack Compose","uri":"https://carrion.dev/es/posts/state-management-patterns-compose/"},{"content":"Construyendo DSLs Tipados con Kotlin: De lo Básico a Patrones Avanzados Los Lenguajes de Dominio Específico (DSLs) en Kotlin te permiten crear APIs expresivas, legibles y tipadas. Este artículo explora cómo construir DSLs efectivos usando las potentes características de Kotlin, centrándose en el control de ámbito con @DslMarker para prevenir errores comunes en DSLs anidados.\nAl final de este artículo, entenderás:\n Cómo diseñar APIs de DSL limpias e intuitivas Cuándo y cómo usar @DslMarker para un mejor control de ámbito Mejores prácticas para mantener el tipado seguro en tu DSL Errores comunes y cómo evitarlos  Conceptos Básicos de DSL Exploremos los conceptos fundamentales de los DSLs en Kotlin construyendo un simple constructor de HTML:\nConstructor DSL de HTML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  // Forma tradicional: construcción manual de cadenas val sb = StringBuilder() sb.append(\u0026#34;\u0026lt;div\u0026gt;\u0026#34;) sb.append(\u0026#34;\u0026lt;span\u0026gt;Hello\u0026lt;/span\u0026gt;\u0026#34;) sb.append(\u0026#34;\u0026lt;div\u0026gt;\u0026#34;) // Fácil de cometer errores sb.append(\u0026#34;\u0026lt;span\u0026gt;Nested content\u0026lt;/span\u0026gt;\u0026#34;) sb.append(\u0026#34;\u0026lt;/div\u0026gt;\u0026#34;) // ¿Qué div estamos cerrando? sb.append(\u0026#34;\u0026lt;/div\u0026gt;\u0026#34;) // ¿Es correcto el anidamiento?  // Usando un DSL: la estructura refleja el anidamiento natural de HTML val html = buildHtml { div { span { +\u0026#34;Hello\u0026#34; } div { span { +\u0026#34;Nested content\u0026#34; } } // El anidamiento es claro y forzado por el compilador  } } // La implementación del DSL usando características de Kotlin class HtmlBuilder { private val content = StringBuilder() // Función de extensión con receptor: crea bloques div { }  fun div(block: HtmlBuilder.() -\u0026gt; Unit) { content.append(\u0026#34;\u0026lt;div\u0026gt;\u0026#34;) this.block() // \u0026#39;this\u0026#39; es el receptor (HtmlBuilder)  content.append(\u0026#34;\u0026lt;/div\u0026gt;\u0026#34;) } // Similar a div, crea bloques span { }  fun span(block: HtmlBuilder.() -\u0026gt; Unit) { content.append(\u0026#34;\u0026lt;span\u0026gt;\u0026#34;) this.block() content.append(\u0026#34;\u0026lt;/span\u0026gt;\u0026#34;) } // Sobrecarga de operadores: permite la sintaxis +\u0026#34;texto\u0026#34;  operator fun String.unaryPlus() { content.append(this) } override fun toString() = content.toString() } // Función de entrada que crea el contexto DSL fun buildHtml(block: HtmlBuilder.() -\u0026gt; Unit): String = HtmlBuilder().apply(block).toString()   Este constructor de HTML demuestra los conceptos fundamentales que hacen poderosos a los DSLs de Kotlin:\n Las funciones de extensión crean una sintaxis natural y fluida Los receptores lambda proporcionan un ámbito y contexto claros La sobrecarga de operadores permite una sintaxis más conveniente El tipado seguro previene errores comunes en tiempo de compilación  Seguridad de Ámbito con @DslMarker Cuando construimos DSLs con ámbitos anidados, necesitamos asegurar que las llamadas a métodos no sean ambiguas. Sin un control de ámbito adecuado, puede no estar claro qué método se está llamando en contextos anidados. Aquí hay un ejemplo de este problema:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class MenuDsl { fun item(text: String) { println(\u0026#34;Menu item: $text\u0026#34;) } fun submenu(block: MenuDsl.() -\u0026gt; Unit) { println(\u0026#34;Submenu start\u0026#34;) MenuDsl().block() println(\u0026#34;Submenu end\u0026#34;) } } fun menu(block: MenuDsl.() -\u0026gt; Unit) = MenuDsl().apply(block) // Este código es ambiguo: menu { item(\u0026#34;Home\u0026#34;) submenu { item(\u0026#34;Settings\u0026#34;) // ¿Qué item() se está llamando?  // ¡Podría ser del MenuDsl externo o interno!  } }   Kotlin proporciona la anotación @DslMarker para resolver este problema:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  @DslMarker annotation class MenuMarker @MenuMarker class MenuDsl { fun item(text: String) { println(\u0026#34;Menu item: $text\u0026#34;) } fun submenu(block: MenuDsl.() -\u0026gt; Unit) { println(\u0026#34;Submenu start\u0026#34;) MenuDsl().block() println(\u0026#34;Submenu end\u0026#34;) } } // Ahora el código no es ambiguo: menu { item(\u0026#34;Home\u0026#34;) // Llama al item() del ámbito externo  submenu { item(\u0026#34;Settings\u0026#34;) // Llama al item() del ámbito interno  // El item() del ámbito externo no es accesible aquí  } }   La anotación @DslMarker es una herramienta poderosa que nos ayuda a construir DSLs más seguros al prevenir la ambigüedad relacionada con el ámbito. Ahora que entendemos los conceptos básicos y las características de seguridad, veamos cómo se aplican en la práctica.\nEjemplos del Mundo Real El ecosistema de Kotlin proporciona excelentes ejemplos de cómo los DSLs pueden simplificar APIs complejas mientras mantienen la seguridad de tipos y ámbito. Veamos dos enfoques diferentes:\nFunción buildString de Kotlin La biblioteca estándar comienza con lo básico: manipulación de cadenas. Aunque es una tarea simple, buildString muestra cómo un DSL bien diseñado puede hacer que incluso las operaciones comunes sean más elegantes y menos propensas a errores:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // Sin DSL: gestión explícita de StringBuilder val sb = StringBuilder() sb.append(\u0026#34;Hello, \u0026#34;) sb.appendLine(\u0026#34;World!\u0026#34;) sb.append(\u0026#34;The time is \u0026#34;) sb.append(System.currentTimeMillis()) val message = sb.toString() // Con DSL: métodos de StringBuilder disponibles directamente val messageDsl = buildString { append(\u0026#34;Hello, \u0026#34;) appendLine(\u0026#34;World!\u0026#34;) append(\u0026#34;The time is \u0026#34;) append(System.currentTimeMillis()) }   El DSL está habilitado por esta función simple pero poderosa en la biblioteca estándar:\n1 2 3 4 5 6 7  // La implementación real de la biblioteca estándar de Kotlin public inline fun buildString(builderAction: StringBuilder.() -\u0026gt; Unit): String { contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) } return StringBuilder().apply(builderAction).toString() } // El contrato ayuda al compilador a asegurar la seguridad de tipos en el DSL // garantizando que la acción del constructor se llama exactamente una vez   Finalmente, veamos cómo estos conceptos de DSL pueden aplicarse a problemas complejos del mundo real. LazyColumn de Jetpack Compose es un excelente ejemplo de cómo un DSL bien diseñado puede transformar un componente UI complejo en una API intuitiva y declarativa:\nLazyColumn de Jetpack Compose Mientras que nuestros ejemplos anteriores trataban con manipulación de texto, LazyColumn aborda un problema más desafiante: listas de desplazamiento eficientes con diseños complejos y reciclaje. A pesar de esta complejidad, el DSL lo hace notablemente simple de usar:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  // La firma real de LazyColumn muestra su complejidad @Composable fun LazyColumn( modifier: Modifier = Modifier, state: LazyListState = rememberLazyListState(), contentPadding: PaddingValues = PaddingValues(0.dp), reverseLayout: Boolean = false, verticalArrangement: Arrangement.Vertical = if (!reverseLayout) Arrangement.Top else Arrangement.Bottom, horizontalAlignment: Alignment.Horizontal = Alignment.Start, flingBehavior: FlingBehavior = ScrollableDefaults.flingBehavior(), userScrollEnabled: Boolean = true, content: LazyListScope.() -\u0026gt; Unit // ¡Pero el DSL lo hace fácil de usar! ) { // Implementación compleja con reciclaje, diseño, animaciones... } // ...pero el DSL lo simplifica a través de esta interfaz interface LazyListScope { // Añade un solo elemento a la lista  fun item( key: Any? = null, contentType: Any? = null, content: @Composable () -\u0026gt; Unit ) // Añade múltiples elementos de una lista  fun \u0026lt;T\u0026gt; items( items: List\u0026lt;T\u0026gt;, key: ((item: T) -\u0026gt; Any)? = null, contentType: (item: T) -\u0026gt; Any? = { null }, itemContent: @Composable (item: T) -\u0026gt; Unit ) } // Ejemplo: Usando el DSL para crear una lista compleja @Composable fun CategoryList(categories: List\u0026lt;String\u0026gt;) { LazyColumn { // Sección de encabezado  item { Text(\u0026#34;Categories\u0026#34;) } // Elementos dinámicos con claves personalizadas  items\u0026lt;String\u0026gt;( items = categories, key = { category: String -\u0026gt; category } // Identidad estable para animaciones  ) { category: String -\u0026gt; Text(\u0026#34;Category: $category\u0026#34;) } // Sección de pie  item { Text(\u0026#34;End of list\u0026#34;) } } } // El DSL de LazyColumn demuestra cómo Kotlin puede: // - Ocultar configuración compleja detrás de valores predeterminados sensatos // - Transformar APIs verbosas en interfaces simples y enfocadas // - Hacer que características poderosas (reciclaje, animaciones) sean fáciles de usar // - Convertir la complejidad de implementación en APIs amigables para el desarrollador   Conclusión La construcción de DSLs en Kotlin te permite crear APIs poderosas y expresivas que son tanto seguras como intuitivas de usar. Como hemos visto a través de nuestros ejemplos, desde un simple constructor de HTML hasta los sofisticados componentes UI de Jetpack Compose, los DSLs bien diseñados pueden:\n  Mejorar la Calidad del Código\n Transformar código imperativo verboso en expresiones declarativas claras Hacer que los patrones comunes sean más legibles y mantenibles Ocultar la complejidad de implementación detrás de interfaces intuitivas    Garantizar la Seguridad\n Aprovechar el sistema de tipos de Kotlin para prevenir errores en tiempo de compilación Usar @DslMarker para prevenir ambigüedad de ámbito Hacer imposibles los estados inválidos y operaciones inseguras    Escalar con la Complejidad\n Comenzar simple con constructores básicos como buildString Manejar escenarios complejos como el reciclaje de LazyColumn Mantener la claridad incluso cuando la funcionalidad crece    El éxito de los DSLs en Kotlin muestra su versatilidad a través de diferentes dominios:\n Utilidades básicas (buildString) Frameworks UI (Compose) Sistemas de configuración Cualquier API donde la claridad y la seguridad importan  Al entender estos patrones y herramientas, desde funciones de extensión hasta @DslMarker, puedes crear APIs que no solo son poderosas y seguras, sino también un placer de usar.\n","description":"Aprende a crear Lenguajes de Dominio Específico (DSLs) tipados en Kotlin usando @DslMarker para un mejor control de ámbito","id":23,"section":"posts","tags":["kotlin","dsl","type-safety","design-patterns"],"title":"Construyendo DSLs Tipados con Kotlin: De lo Básico a Patrones Avanzados","uri":"https://carrion.dev/es/posts/building-type-safe-dsls/"},{"content":"Características Avanzadas de Genéricos y Varianza en Kotlin: Una Guía Completa Entender los genéricos avanzados y la varianza en Kotlin es crucial para escribir código reutilizable y seguro en cuanto a tipos. Este artículo explora estos conceptos en profundidad, proporcionando ejemplos prácticos y aplicaciones del mundo real.\nEntendiendo la Varianza La varianza en Kotlin determina cómo se relacionan los tipos genéricos con diferentes argumentos de tipo. Entender la varianza es más fácil cuando pensamos en términos de productores y consumidores:\n Productor: Solo produce/proporciona valores de tipo T (salida) Consumidor: Solo consume/acepta valores de tipo T (entrada)  Esta relación productor/consumidor se mapea directamente a los dos tipos de varianza:\n Covarianza (out): Se usa para productores - solo produce valores Contravarianza (in): Se usa para consumidores - solo consume valores  Así es como funcionan los productores y consumidores con tipos:\nType Hierarchy: Producer\u0026lt;T\u0026gt; Consumer\u0026lt;T\u0026gt; Any ▲ can produce ▼ can consume └── Number │ more specific │ more general └── Int │ types │ types Por ejemplo:\n Un Producer\u0026lt;Int\u0026gt; puede usarse como Producer\u0026lt;Number\u0026gt; porque cualquier Int que produzca también es un Number Un Consumer\u0026lt;Number\u0026gt; puede usarse como Consumer\u0026lt;Int\u0026gt; porque cualquier cosa que pueda manejar Numbers puede manejar Ints  Una forma sencilla de recordarlo:\n Si una clase solo produce/devuelve T, hazla covariante con out T (puede usar tipos más específicos) Si una clase solo consume/acepta T, hazla contravariante con in T (puede usar tipos más generales) Si una clase produce y consume T, debe permanecer invariante (el tipo debe coincidir exactamente)  Covarianza con out La covarianza permite usar un tipo más derivado (específico) en lugar de un tipo menos derivado (general). En Kotlin, usamos el modificador out para indicar covarianza.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // Simple producer implementation class IntProducer(private val value: Int) : Producer\u0026lt;Int\u0026gt; { override fun get(): Int = value } // Type safety with covariance: // 1. IntProducer.get() returns Int // 2. Int is a subtype of Number // 3. Therefore, it\u0026#39;s safe to use Producer\u0026lt;Int\u0026gt; as Producer\u0026lt;Number\u0026gt; val intProducer: Producer\u0026lt;Int\u0026gt; = IntProducer(42) val numberProducer: Producer\u0026lt;Number\u0026gt; = intProducer // Safe: Int is always a Number  // Without \u0026#39;out\u0026#39; modifier, this wouldn\u0026#39;t compile: // class RegularBox\u0026lt;T\u0026gt;(val item: T) // invariant // val intBox: RegularBox\u0026lt;Int\u0026gt; = RegularBox(42) // val numBox: RegularBox\u0026lt;Number\u0026gt; = intBox // Error: Type mismatch  // We can use the numberProducer wherever a Number is expected fun printNumber(producer: Producer\u0026lt;Number\u0026gt;) { println(\u0026#34;Number: ${producer.get()}\u0026#34;) // Safe: we know we\u0026#39;ll get a Number } printNumber(intProducer) // Works because Producer is covariant (out)   Contravarianza con in La contravarianza es lo opuesto a la covarianza. Permite usar un tipo más general donde se espera un tipo más específico. En Kotlin, usamos el modificador in para la contravarianza.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // Simple consumer implementation class NumberProcessor : Consumer\u0026lt;Number\u0026gt; { override fun set(item: Number) { println(\u0026#34;Processing number: ${item.toDouble()}\u0026#34;) } } // Type safety with contravariance: // 1. NumberProcessor.set() accepts any Number // 2. Int is a subtype of Number // 3. Therefore, it\u0026#39;s safe to use Consumer\u0026lt;Number\u0026gt; as Consumer\u0026lt;Int\u0026gt; val numberConsumer: Consumer\u0026lt;Number\u0026gt; = NumberProcessor() val intConsumer: Consumer\u0026lt;Int\u0026gt; = numberConsumer // Safe: anything that can handle Number can handle Int  // Without \u0026#39;in\u0026#39; modifier, this wouldn\u0026#39;t compile: // class Processor\u0026lt;T\u0026gt;(val process: (T) -\u0026gt; Unit) // invariant // val numProcessor: Processor\u0026lt;Number\u0026gt; = Processor { println(it) } // val intProcessor: Processor\u0026lt;Int\u0026gt; = numProcessor // Error: Type mismatch  // We can use the intConsumer with Int values fun processInt(consumer: Consumer\u0026lt;Int\u0026gt;) { consumer.set(42) // Safe: we know the consumer can handle any Number, including Int } processInt(numberConsumer) // Works because Consumer is contravariant (in)   Las restricciones tienen sentido porque:\n Un productor de Ints puede producirlos de forma segura donde se necesitan Numbers (cada Int es un Number) Un consumidor de Numbers puede consumir Ints de forma segura (sabe cómo manejar cualquier Number)  Varianza en el Sitio de Declaración vs Varianza en el Sitio de Uso Kotlin admite dos formas de especificar la varianza: varianza en el sitio de declaración (usando in o out en la declaración de clase/interfaz) y varianza en el sitio de uso (usando proyecciones de tipo). Cada enfoque tiene sus propios casos de uso y beneficios.\nVarianza en el Sitio de Declaración La varianza en el sitio de declaración se especifica en la declaración del parámetro de tipo de una clase o interfaz. Este enfoque es preferible cuando una clase solo puede usar el parámetro de tipo de una manera en toda su implementación.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Declaration-site variance example interface Producer\u0026lt;out T\u0026gt; { fun produce(): T // Can only produce/return T  // fun consume(item: T) {} // Error: Can\u0026#39;t consume T in an out position } interface Consumer\u0026lt;in T\u0026gt; { fun consume(item: T) // Can only consume T  // fun produce(): T {} // Error: Can\u0026#39;t produce T in an in position } // Usage is straightforward - variance is handled automatically class StringProducer : Producer\u0026lt;String\u0026gt; { override fun produce(): String = \u0026#34;Hello\u0026#34; } val producer: Producer\u0026lt;Any\u0026gt; = StringProducer() // OK: String is more specific than Any   Varianza en el Sitio de Uso La varianza en el sitio de uso (también conocida como proyección de tipo) se especifica en el punto de uso. Esto es útil cuando un tipo puede usarse tanto como productor como consumidor, pero en un uso específico, deseas restringirlo a un rol.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // Class with invariant type parameter class Box\u0026lt;T\u0026gt;(var value: T) { fun get(): T = value fun set(value: T) { this.value = value } } // Use-site variance examples fun copyOut(from: Box\u0026lt;out Number\u0026gt;, to: MutableList\u0026lt;Number\u0026gt;) { // \u0026#39;from\u0026#39; is projected to be covariant (producer)  // Can only call methods that return Number  to.add(from.get()) // OK  // from.set(42) // Error: Can\u0026#39;t call set on projected type } fun copyIn(to: Box\u0026lt;in Number\u0026gt;, from: List\u0026lt;Int\u0026gt;) { // \u0026#39;to\u0026#39; is projected to be contravariant (consumer)  // Can only call methods that accept Number  to.set(from.first()) // OK  // val x: Number = to.get() // Error: Return type is projected to Nothing }   Cuándo Usar Cada Enfoque  Usa Varianza en el Sitio de Declaración Cuando:  La clase solo puede usar el parámetro de tipo de una manera (solo producir o solo consumir) Quieres forzar el patrón de uso en todos los usos de la clase El diseño de la API es claro sobre sus requisitos de varianza    1 2 3 4 5 6  // Good candidate for declaration-site variance interface EventStream\u0026lt;out T\u0026gt; { fun next(): T fun peek(): T // Natural producer - only returns T }   Usa Varianza en el Sitio de Uso Cuando:  La clase necesita tanto producir como consumir el tipo en general Quieres restringir la varianza en puntos de uso específicos Necesitas flexibilidad en cómo se usa el tipo en diferentes contextos    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  // Good candidate for use-site variance class Stack\u0026lt;T\u0026gt; { private val items = mutableListOf\u0026lt;T\u0026gt;() // General implementation can both produce and consume T  fun push(item: T) { items.add(item) } fun pop(): T { if (items.isEmpty()) throw NoSuchElementException(\u0026#34;Stack is empty\u0026#34;) return items.removeAt(items.lastIndex) } fun isEmpty(): Boolean = items.isEmpty() // But specific usages might want to restrict it:  fun copyTo(other: Stack\u0026lt;in T\u0026gt;) { items.forEach { other.push(it) } } fun copyFrom(other: Stack\u0026lt;out T\u0026gt;) { // More efficient implementation using a temporary list  val tempList = mutableListOf\u0026lt;T\u0026gt;() while (!other.isEmpty()) { tempList.add(other.pop()) } tempList.asReversed().forEach { push(it) } } } // Usage examples demonstrating variance fun main() { // Create stacks of different types  val numberStack = Stack\u0026lt;Number\u0026gt;() val intStack = Stack\u0026lt;Int\u0026gt;() val doubleStack = Stack\u0026lt;Double\u0026gt;() // Fill stacks with values  intStack.push(1) intStack.push(2) doubleStack.push(3.14) // Demonstrate contravariant usage with copyTo  // Can copy from more specific type (Int) to more general type (Number)  intStack.copyTo(numberStack) // OK: Int is more specific than Number  doubleStack.copyTo(numberStack) // OK: Double is more specific than Number  // Demonstrate covariant usage with copyFrom  val intStack2 = Stack\u0026lt;Int\u0026gt;() val intStack3 = Stack\u0026lt;Int\u0026gt;() intStack2.push(42) intStack2.push(43) // Can copy from same type  intStack3.copyFrom(intStack2) // OK: same type  // Can copy from more specific type to more general type  val anyStack = Stack\u0026lt;Any\u0026gt;() anyStack.copyFrom(intStack) // OK: Int is more specific than Any  anyStack.copyFrom(doubleStack) // OK: Double is more specific than Any  // This demonstrates how use-site variance gives us flexibility:  // - Stack\u0026lt;T\u0026gt; itself is invariant (can both read and write T)  // - copyTo uses contravariance (in) to allow writing to more general types  // - copyFrom uses covariance (out) to allow reading from more general types }   Proyecciones de Tipo Las proyecciones de tipo son una forma de varianza en el sitio de uso que proporciona flexibilidad adicional al trabajar con tipos genéricos. Aquí hay una mirada más profunda a cómo funcionan:\n1 2 3 4 5 6 7 8 9  fun copyElements(source: Array\u0026lt;out Number\u0026gt;, destination: Array\u0026lt;Number\u0026gt;) { for (i in source.indices) { destination[i] = source[i] } } val ints = arrayOf(1, 2, 3) val numbers = Array\u0026lt;Number\u0026gt;(3) { 0.0 } copyElements(ints, numbers) // Works thanks to out projection   Restricciones Genéricas Kotlin permite especificar límites superiores para los parámetros de tipo, restringiendo qué tipos se pueden usar.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  interface Drawable { fun draw() } class Canvas\u0026lt;T : Drawable\u0026gt; { fun drawAll(elements: List\u0026lt;T\u0026gt;) { elements.forEach { it.draw() } } } class Circle : Drawable { override fun draw() = println(\u0026#34;Drawing Circle\u0026#34;) } val canvas = Canvas\u0026lt;Circle\u0026gt;() canvas.drawAll(listOf(Circle(), Circle()))   Restricciones Múltiples Puedes especificar múltiples restricciones usando la cláusula where:\n1 2 3 4 5 6 7 8 9  fun \u0026lt;T\u0026gt; copyWhenBothValid( source: T, destination: T ) where T : Drawable, T : Comparable\u0026lt;T\u0026gt; { if (source \u0026gt; destination) { destination.draw() } }   Mejores Prácticas y Directrices  Usa out cuando tu clase solo produce valores de tipo T Usa in cuando tu clase solo consume valores de tipo T Usa invarianza cuando tu clase produce y consume valores de tipo T Prefiere la varianza en el sitio de declaración (out/in en la clase) sobre la varianza en el sitio de uso cuando sea posible Usa proyecciones de estrella con moderación y solo cuando los argumentos de tipo son verdaderamente irrelevantes  Errores Comunes y Soluciones Evitando Problemas de Borrado de Tipos 1 2 3 4 5 6 7 8 9 10 11 12  // Type erasure example class TypeChecker { // Wrong way - won\u0026#39;t compile due to type erasure  fun isStringList(list: List\u0026lt;*\u0026gt;): Boolean { // return list is List\u0026lt;String\u0026gt; // This won\u0026#39;t compile  return list.all { it is String } // This is the correct way  } // Correct way using reified type parameters  inline fun \u0026lt;reified T\u0026gt; isListOf(list: List\u0026lt;*\u0026gt;): Boolean = list.all { it is T } }   Manejando Tipos Genéricos Nulables 1 2 3 4 5 6 7 8  // Explicitly handle nullable generic types class Box\u0026lt;T : Any\u0026gt;(private var value: T?) { fun set(newValue: T) { value = newValue } fun get(): T? = value }   Conclusión Los genéricos avanzados y la varianza en Kotlin proporcionan herramientas poderosas para construir abstracciones seguras y reutilizables. Al entender estos conceptos y aplicarlos apropiadamente, puedes escribir código más robusto y mantenible. Recuerda:\n Usar modificadores de varianza (out/in) cuando sea apropiado Aplicar restricciones genéricas para garantizar la seguridad de tipos Considerar tanto la varianza en el sitio de declaración como en el sitio de uso Ser consciente del borrado de tipos y la nulabilidad  El uso adecuado de estas características conduce a un código más elegante y seguro, reduciendo la probabilidad de errores en tiempo de ejecución y haciendo que tu base de código sea más mantenible.\n","description":"Domina los tipos genéricos avanzados y los conceptos de varianza en Kotlin con ejemplos prácticos y aplicaciones del mundo real","id":24,"section":"posts","tags":["kotlin","generics","variance","type-safety"],"title":"Características Avanzadas de Genéricos y Varianza en Kotlin: Una Guía Completa","uri":"https://carrion.dev/es/posts/advanced-kotlin-generics/"},{"content":"Patrones de Composición de Flows: Combinando Múltiples Flows de Manera Efectiva Cuando trabajamos con Kotlin Flows en aplicaciones del mundo real, a menudo necesitamos combinar múltiples flujos de datos para crear flujos de trabajo más complejos. Este artículo explora varios patrones de composición de Flows y las mejores prácticas para combinar múltiples Flows de manera efectiva.\nEntendiendo la Composición de Flows La composición de Flows es el proceso de combinar múltiples Flows para crear un nuevo Flow que representa un flujo de datos más complejo. Kotlin proporciona varios operadores para la composición de Flows, cada uno sirviendo diferentes casos de uso.\nOperadores Básicos de Composición de Flows Comencemos con los operadores fundamentales de composición de Flows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Sample data sources val priceUpdates = flow { emit(10.0) delay(100) emit(11.0) } val quantityUpdates = flow { emit(5) delay(200) emit(6) } // Combining latest values from both flows val totalValueFlow = combine(priceUpdates, quantityUpdates) { price: Double, quantity: Int -\u0026gt; price * quantity }   Output:\n50.0 // 10.0 * 5 66.0 // 11.0 * 6 Zip vs Combine Los operadores zip y combine sirven para diferentes propósitos y tienen comportamientos distintos cuando trabajan con múltiples flows:\nOperador Zip  Empareja valores estrictamente uno a uno de cada flow Espera a que todos los flows emitan antes de producir un resultado Si un flow emite más lento, crea back-pressure (contrapresión) Útil cuando necesitas emparejar valores correspondientes de diferentes flows Si un flow se completa, el flow resultante también se completa  Operador Combine  Utiliza el último valor de cada flow para producir resultados Emite cada vez que cualquier flow produce un nuevo valor Sin back-pressure - usa el valor más reciente de otros flows Útil para actualizaciones en tiempo real donde necesitas el último estado Continúa hasta que todos los flows se completen  Aquí hay un ejemplo práctico que muestra la diferencia:\n1 2 3 4 5 6 7 8 9  // zip: Pairs corresponding values (one-to-one) val zippedFlow = priceUpdates.zip(quantityUpdates) { price: Double, quantity: Int -\u0026gt; \u0026#34;Price: $price, Quantity: $quantity\u0026#34; } // combine: Emits when either flow emits (using latest values) val combinedFlow = combine(priceUpdates, quantityUpdates) { price: Double, quantity: Int -\u0026gt; \u0026#34;Latest Price: $price, Latest Quantity: $quantity\u0026#34; }   Veamos cómo se comportan con diferentes tiempos:\n1 2 3 4 5 6 7 8 9 10 11 12 13  val prices = flow { emit(10.0) // t=0ms  delay(100) emit(11.0) // t=100ms  delay(100) emit(12.0) // t=200ms } val quantities = flow { emit(5) // t=0ms  delay(150) emit(6) // t=150ms }   Output for zippedFlow (empareja valores en orden):\n\u0026quot;Price: 10.0, Quantity: 5\u0026quot; // Primer par \u0026quot;Price: 11.0, Quantity: 6\u0026quot; // Segundo par // 12.0 nunca se emite porque quantities no tiene más valores Output for combinedFlow (reacciona a cada cambio):\n\u0026quot;Latest Price: 10.0, Latest Quantity: 5\u0026quot; // Valores iniciales \u0026quot;Latest Price: 11.0, Latest Quantity: 5\u0026quot; // Precio actualizado en t=100ms \u0026quot;Latest Price: 11.0, Latest Quantity: 6\u0026quot; // Cantidad actualizada en t=150ms \u0026quot;Latest Price: 12.0, Latest Quantity: 6\u0026quot; // Precio actualizado en t=200ms Este ejemplo muestra cómo:\n zip empareja valores en secuencia y requiere que ambos flows emitan combine reacciona a cambios en cualquier flow y usa los últimos valores disponibles zip puede omitir valores si los flows emiten a diferentes velocidades combine asegura que siempre trabajas con los datos más recientes  Patrones de Composición Avanzados Fusionando Múltiples Flows El operador merge combina múltiples flows en un único flow, preservando el tiempo relativo de emisión de cada fuente. A diferencia de zip o combine, merge simplemente reenvía los valores según llegan, sin intentar emparejarlos o combinarlos.\nCaracterísticas Principales de Merge  Emite valores tan pronto como llegan de cualquier flow fuente Mantiene el orden de emisiones dentro de cada flow fuente No espera ni combina valores de diferentes flows Se completa solo cuando todos los flows fuente se completan Útil para manejar eventos independientes de múltiples fuentes  Aquí vemos cómo funciona merge con múltiples fuentes de eventos:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  val userActions = merge( buttonClicks, menuSelections, gestureEvents ) // Alternative using Flow builder val mergedFlow = flow { coroutineScope { launch { buttonClicks.collect { emit(it) } } launch { menuSelections.collect { emit(it) } } launch { gestureEvents.collect { emit(it) } } } }   Veamos cómo merge maneja eventos con diferentes tiempos:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  val clickEvents = flow { emit(\u0026#34;Click 1\u0026#34;) // t=0ms  delay(100) emit(\u0026#34;Click 2\u0026#34;) // t=100ms } val keyEvents = flow { delay(50) emit(\u0026#34;Key A\u0026#34;) // t=50ms  delay(100) emit(\u0026#34;Key B\u0026#34;) // t=150ms } val gestureEvents = flow { delay(75) emit(\u0026#34;Swipe\u0026#34;) // t=75ms } val allEvents = merge(clickEvents, keyEvents, gestureEvents)   Output (eventos en orden de llegada):\n\u0026quot;Click 1\u0026quot; // t=0ms (desde clickEvents) \u0026quot;Key A\u0026quot; // t=50ms (desde keyEvents) \u0026quot;Swipe\u0026quot; // t=75ms (desde gestureEvents) \u0026quot;Click 2\u0026quot; // t=100ms (desde clickEvents) \u0026quot;Key B\u0026quot; // t=150ms (desde keyEvents) Casos de Uso Comunes para Merge:\n Manejo de Eventos: Combinación de interacciones de usuario desde diferentes fuentes Actualizaciones Multi-fuente: Monitoreo de cambios desde múltiples fuentes de datos independientes Procesamiento Paralelo: Recolección de resultados de operaciones paralelas Monitoreo de Sistema: Agregación de logs o métricas desde múltiples componentes  La implementación alternativa usando un Flow builder muestra cómo funciona merge internamente:\nManejo de Errores en Flows Compuestos Cuando trabajamos con flows compuestos, el manejo de errores se vuelve particularmente importante ya que los errores pueden propagarse a través de la cadena de flows y afectar múltiples fuentes de datos. Existen varias estrategias para manejar errores en flows compuestos:\n1. Manejo de Errores Individual por Flow Cada flow puede manejar sus propios errores antes de la composición:\n1 2 3 4 5 6 7 8 9 10 11  val safeFlow1 = flow1.catch { error: Throwable -\u0026gt; emit(fallbackValue) // o  emit(Result.failure\u0026lt;String\u0026gt;(error)) } val safeFlow2 = flow2.catch { error: Throwable -\u0026gt; // Registrar error y emitir valor por defecto  logger.error(\u0026#34;Flow 2 falló\u0026#34;, error) emit(defaultValue) }   2. Transformación de Errores en Flows Compuestos Transformar errores en resultados específicos del dominio:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  sealed class DataResult\u0026lt;T\u0026gt; { data class Success\u0026lt;T\u0026gt;(val data: T) : DataResult\u0026lt;T\u0026gt;() data class Error\u0026lt;T\u0026gt;(val error: Throwable) : DataResult\u0026lt;T\u0026gt;() } fun \u0026lt;T\u0026gt; Flow\u0026lt;T\u0026gt;.asResult(): Flow\u0026lt;DataResult\u0026lt;T\u0026gt;\u0026gt; = map { value: T -\u0026gt; DataResult.Success(value) }.catch { e: Throwable -\u0026gt; emit(DataResult.Error\u0026lt;T\u0026gt;(e)) } // Uso en composición val combinedFlow = combine( flow1.asResult(), flow2.asResult() ) { result1: DataResult\u0026lt;Data1\u0026gt;, result2: DataResult\u0026lt;Data2\u0026gt; -\u0026gt; when { result1 is DataResult.Error\u0026lt;Data1\u0026gt; -\u0026gt; result1 as DataResult\u0026lt;CombinedData\u0026gt; result2 is DataResult.Error\u0026lt;Data2\u0026gt; -\u0026gt; result2 as DataResult\u0026lt;CombinedData\u0026gt; else -\u0026gt; DataResult.Success( combineData( (result1 as DataResult.Success\u0026lt;Data1\u0026gt;).data, (result2 as DataResult.Success\u0026lt;Data2\u0026gt;).data ) ) } }   3. Usando el Tipo Result para Manejo de Errores Un patrón común utilizando el tipo Result de Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  fun combineDataSources(): Flow\u0026lt;Result\u0026lt;CombinedData\u0026gt;\u0026gt; = combine( source1.catch { emit(Result.failure(it)) }, source2.catch { emit(Result.failure(it)) } ) { result1: Result\u0026lt;Data1\u0026gt;, result2: Result\u0026lt;Data2\u0026gt; -\u0026gt; when { result1.isFailure -\u0026gt; result1 as Result\u0026lt;CombinedData\u0026gt; result2.isFailure -\u0026gt; result2 as Result\u0026lt;CombinedData\u0026gt; else -\u0026gt; Result.success( CombinedData( result1.getOrNull()!!, result2.getOrNull()!! ) ) } }   4. Estrategias de Reintento Implementar lógica de reintento para fallos transitorios:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  fun \u0026lt;T\u0026gt; Flow\u0026lt;T\u0026gt;.retryWithBackoff( maxAttempts: Int = 3, initialDelay: Long = 100, maxDelay: Long = 1000, factor: Double = 2.0 ): Flow\u0026lt;T\u0026gt; = retry { cause: Throwable, attempt: Long -\u0026gt; if (attempt \u0026lt; maxAttempts) { delay( (initialDelay * factor.pow(attempt.toDouble())) .toLong().coerceAtMost(maxDelay) ) true } else false } // Uso en flows compuestos val resilientFlow = combine( flow1.retryWithBackoff(), flow2.retryWithBackoff() ) { value1: Data1, value2: Data2 -\u0026gt; // Procesar valores  CombinedData(value1, value2) }   Mejores Prácticas para el Manejo de Errores en Flows Compuestos:   Manejar Errores Cerca de la Fuente:\n Capturar errores en flows individuales antes de la composición Transformar errores en resultados específicos del dominio Proporcionar valores de respaldo cuando sea apropiado    Estrategias de Recuperación de Errores:\n Implementar lógica de reintento para fallos transitorios Usar estrategias de backoff para evitar sobrecargar los sistemas Considerar proporcionar valores por defecto o en caché    Propagación de Errores:\n Decidir si propagar o manejar errores localmente Usar tipos de error estructurados (sealed classes, tipo Result) Mantener el contexto del error a través de la cadena de flows    Monitoreo y Depuración:\n Registrar errores con el contexto apropiado Rastrear tasas y patrones de errores Implementar un reporte de errores adecuado    Consideraciones de Rendimiento Cuando combinamos Flows, considera estas técnicas de optimización de rendimiento:\n Gestión de Buffer:  1 2 3 4 5  val optimizedFlow = flow1 .buffer(Channel.BUFFERED) .combine(flow2.buffer(Channel.BUFFERED)) { value1: T1, value2: T2 -\u0026gt; // Process values  }   Conflación para Últimos Valores:  1 2 3 4 5  val conflatedFlow = flow1 .conflate() .combine(flow2.conflate()) { value1: T1, value2: T2 -\u0026gt; // Process only latest values  }   Conclusión La composición de Flows es una característica poderosa que te permite construir flujos reactivos complejos en Kotlin. Al comprender estos patrones y mejores prácticas, puedes combinar efectivamente múltiples Flows mientras mantienes un código limpio, mantenible y eficiente. Recuerda:\n Elegir el operador de composición adecuado para tu caso de uso Manejar errores apropiadamente en cada nivel Considerar las implicaciones de rendimiento Implementar un manejo adecuado de la cancelación  Estos patrones te ayudarán a construir aplicaciones robustas que puedan manejar flujos de datos complejos de manera efectiva.\n","description":"Aprende a combinar múltiples Kotlin Flows de manera efectiva utilizando varios patrones de composición y mejores prácticas para construir pipelines de flows complejos","id":25,"section":"posts","tags":["kotlin","coroutines","flows","patterns"],"title":"Patrones de Composición de Flows: Combinando Múltiples Flows de Manera Efectiva","uri":"https://carrion.dev/es/posts/flow-composition-patterns/"},{"content":"Entendiendo los Operadores de Flujo (Flow): Buffer, Conflate, Debounce y Sample Cuando trabajamos con flujos de Kotlin (Flows), especialmente en escenarios que involucran productores que emiten rápidamente y colectores lentos, es crucial entender cómo gestionar el flujo de datos de manera efectiva. Este post explora cuatro operadores esenciales de Flow que ayudan a manejar estos escenarios: buffer, conflate, debounce y sample.\nEl Problema: Colectores Lentos Antes de profundizar en los operadores, entendamos el problema que resuelven. Considera este escenario:\n1 2 3 4 5 6 7 8 9  flow { for (i in 1..100) { emit(i) delay(100) // Emit every 100ms  } }.collect { value: Int -\u0026gt; delay(300) // Process for 300ms  println(\u0026#34;Processed $value\u0026#34;) }   En este caso, el colector es más lento que el productor, lo que puede llevar a problemas de contrapresión. Cada operador que discutiremos proporciona una estrategia diferente para manejar esta situación.\nOperador Buffer El operador buffer crea un canal con capacidad específica para almacenar emisiones mientras el colector procesa los valores anteriores.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  flow { for (i in 1..5) { emit(i) println(\u0026#34;Emitting $i\u0026#34;) delay(100) } }.buffer(2) // Buffer capacity of 2  .collect { value: Int -\u0026gt; println(\u0026#34;Collecting $value\u0026#34;) delay(300) // Slow collector } // Output: // Emitting 1 // Emitting 2 // Emitting 3 // Collecting 1 (t=300ms) // Collecting 2 (t=600ms) // Emitting 4 // Emitting 5 // Collecting 3 (t=900ms) // Collecting 4 (t=1200ms) // Collecting 5 (t=1500ms)   Cuándo Usar Buffer  Cuando necesitas almacenar un número específico de emisiones Cuando necesitas procesar todos los valores pero quieres independizar las velocidades del productor y el colector Cuando es importante mantener el orden de procesamiento  Operador Conflate El operador conflate mantiene solo el último valor, descartando los valores intermedios si el colector no puede mantener el ritmo.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  flow { for (i in 1..5) { emit(i) println(\u0026#34;Emitting $i\u0026#34;) delay(100) } }.conflate() .collect { value: Int -\u0026gt; println(\u0026#34;Collecting $value\u0026#34;) delay(300) // Slow collector } // Output: // Emitting 1 // Emitting 2 // Collecting 1 (t=300ms) // Emitting 3 // Emitting 4 // Collecting 4 (t=600ms) // Emitting 5 // Collecting 5 (t=900ms)   Cuándo Usar Conflate  Cuando solo interesa el valor más reciente En escenarios de interfaz de usuario donde no es necesario mostrar estados intermedios Cuando no es crítico procesar cada valor individual  Operador Debounce El operador debounce emite un valor solo después de que ha pasado un tiempo específico sin nuevas emisiones.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  flow { emit(1) delay(90) emit(2) // Will be dropped  delay(90) emit(3) // Will be dropped  delay(150) // Longer than debounce timeout  emit(4) // Will be emitted }.debounce(100) .collect { value: Int -\u0026gt; println(\u0026#34;Collecting $value\u0026#34;) } // Output: // Collecting 1 (t=100ms) // Collecting 4 (t=430ms) // (Values 2 and 3 are dropped because new values arrived before debounce timeout)   Cuándo Usar Debounce  Para implementar búsqueda mientras se escribe Para manejar eventos rápidos de interfaz de usuario Cuando necesitas esperar \u0026ldquo;períodos de calma\u0026rdquo; antes de procesar  Operador Sample El operador sample toma periódicamente el valor más reciente del flujo en intervalos específicos.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  flow { var i = 0 while (i \u0026lt; 10) { emit(i++) delay(50) // Emit every 50ms  } }.sample(100) // Sample every 100ms  .collect { value: Int -\u0026gt; println(\u0026#34;Sampled value: $value\u0026#34;) } // Output: // Sampled value: 1 (t=100ms) // Sampled value: 3 (t=200ms) // Sampled value: 5 (t=300ms) // Sampled value: 7 (t=400ms) // Sampled value: 9 (t=500ms) // (Only captures the latest value every 100ms)   Cuándo Usar Sample  Cuando requieres actualizaciones regulares en intervalos fijos Para mostrar datos en tiempo real donde los valores intermedios no son relevantes Para limitar la tasa de procesamiento independientemente de la frecuencia de emisión  Comparación y Mejores Prácticas Aquí hay una comparación rápida de estos operadores:\n   Operador Comportamiento Caso de Uso     buffer Almacena emisiones Procesamiento completo manteniendo el orden   conflate Mantiene solo el último Actualizaciones de interfaz, último valor   debounce Espera período de calma Búsqueda en tiempo real, eventos rápidos   sample Muestreo periódico Actualizaciones regulares, control de frecuencia    Conclusión Comprender estos operadores de Flow es fundamental para construir aplicaciones reactivas eficientes:\n Utiliza buffer cuando necesites procesar todos los valores y controlar el uso de memoria Utiliza conflate cuando solo importe el último valor Utiliza debounce cuando manejes eventos rápidos que requieran \u0026ldquo;tiempo de asentamiento\u0026rdquo; Utiliza sample cuando necesites actualizaciones regulares en intervalos fijos  Selecciona el operador adecuado según tu caso de uso específico y los requisitos de completitud de datos, orden y frecuencia de procesamiento.\nRecuerda que estos operadores se pueden combinar para crear flujos de procesamiento de datos más sofisticados, pero evita sobre-complicar tus flujos. Considera siempre el equilibrio entre la completitud de datos, el uso de memoria y la eficiencia de procesamiento.\n","description":"Análisis profundo de los operadores de flujo en Kotlin (Flow): buffer, conflate, debounce y sample. Aprende cuándo y cómo usar cada operador con ejemplos prácticos.","id":26,"section":"posts","tags":["kotlin","flows","coroutines"],"title":"Entendiendo los Operadores de Flujo (Flow): Buffer, Conflate, Debounce y Sample","uri":"https://carrion.dev/es/posts/flow-operators-buffer-conflate/"},{"content":"Convirtiendo Callbacks a Coroutines y Flows en Kotlin Las APIs basadas en callbacks han sido un patrón común en la programación asíncrona durante muchos años. Sin embargo, con las corrutinas y flows de Kotlin, podemos transformar estos callbacks en código moderno y secuencial que es más fácil de leer y mantener. En este artículo, exploraremos cómo usar suspendCoroutine y callbackFlow para convertir APIs basadas en callbacks a corrutinas y flows.\nEntendiendo suspendCoroutine La función suspendCoroutine es una herramienta poderosa que nos permite envolver APIs basadas en callbacks en funciones suspend. Esta transformación hace que el código asíncrono sea más secuencial y fácil de manejar.\nUso Básico de suspendCoroutine Aquí hay un ejemplo simple de cómo convertir una función basada en callbacks a una función suspend:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // Traditional callback-based API interface LocationCallback { fun onLocationFound(location: Location) fun onError(error: Exception) } class LocationService { fun getCurrentLocation(callback: LocationCallback) { // Simulating async location fetch  // Implementation details...  } } // Converted to suspend function suspend fun LocationService.getLocationSuspend(): Location { return suspendCoroutine\u0026lt;Location\u0026gt; { continuation: Continuation\u0026lt;Location\u0026gt; -\u0026gt; getCurrentLocation(object : LocationCallback { override fun onLocationFound(location: Location) { continuation.resume(location) } override fun onError(error: Exception) { continuation.resumeWithException(error) } }) } } // Usage suspend fun fetchLocation() { try { val location = locationService.getLocationSuspend() println(\u0026#34;Ubicación recibida: $location\u0026#34;) } catch (e: Exception) { println(\u0026#34;Error al obtener la ubicación: ${e.message}\u0026#34;) } }   Manejo de Cancelación Cuando trabajamos con suspendCoroutine, es importante manejar la cancelación adecuadamente:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  suspend fun LocationService.getLocationSuspendWithCancellation(): Location { return suspendCancellableCoroutine\u0026lt;Location\u0026gt; { continuation: CancellableContinuation\u0026lt;Location\u0026gt; -\u0026gt; val callback = object : LocationCallback { override fun onLocationFound(location: Location) { continuation.resume(location) } override fun onError(error: Exception) { continuation.resumeWithException(error) } } getCurrentLocation(callback) continuation.invokeOnCancellation { // Cleanup resources, remove callbacks, etc.  removeLocationUpdates(callback) } } }   Convirtiendo a Flows con callbackFlow Mientras que suspendCoroutine es excelente para operaciones únicas, callbackFlow es perfecto para manejar flujos de datos o eventos. Nos permite convertir APIs basadas en callbacks que emiten múltiples valores en Kotlin Flows.\nEjemplo Básico de callbackFlow Aquí te mostramos cómo convertir una API de actualizaciones de ubicación a un Flow:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  interface LocationUpdatesCallback { fun onLocationUpdate(location: Location) fun onError(error: Exception) } class LocationService { fun startLocationUpdates(callback: LocationUpdatesCallback) { // Implementation details...  } fun stopLocationUpdates(callback: LocationUpdatesCallback) { // Implementation details...  } } fun LocationService.locationUpdatesFlow(): Flow\u0026lt;Location\u0026gt; = callbackFlow { val callback = object : LocationUpdatesCallback { override fun onLocationUpdate(location: Location) { trySend(location) } override fun onError(error: Exception) { close(error) } } startLocationUpdates(callback) // Clean up when the flow is cancelled  awaitClose { stopLocationUpdates(callback) } } // Usage suspend fun trackLocation() { locationService.locationUpdatesFlow() .catch { error: Throwable -\u0026gt; println(\u0026#34;Error en actualizaciones de ubicación: ${error.message}\u0026#34;) } .collect { location: Location -\u0026gt; println(\u0026#34;Nueva ubicación: $location\u0026#34;) } }   Manejo de Contrapresión (Backpressure) Cuando tratamos con actualizaciones frecuentes, es importante manejar la contrapresión adecuadamente:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  fun SensorService.sensorUpdatesFlow(): Flow\u0026lt;SensorData\u0026gt; = callbackFlow { val callback = object : SensorCallback { override fun onSensorUpdate(data: SensorData) { // Use trySend instead of send to handle backpressure  if (!trySend(data).isSuccess) { // Handle unsuccessful send  println(\u0026#34;Buffer full, dropping sensor update\u0026#34;) } } } registerSensorCallback(callback) awaitClose { unregisterSensorCallback(callback) } }.buffer(Channel.CONFLATED) // Keep only the latest value   Mejores Prácticas   Manejo de Errores\n Siempre manejar errores apropiadamente tanto en suspendCoroutine como en callbackFlow Usar bloques try-catch para suspendCoroutine Usar el operador catch para flows    Gestión de Recursos\n Limpiar recursos en awaitClose para callbackFlow Usar suspendCancellableCoroutine cuando se necesite manejar cancelación    Consideraciones de Contrapresión\n Elegir estrategias de buffer apropiadas para tu caso de uso Considerar usar canales conflated o buffered según tus necesidades    Pruebas\n Escribir pruebas tanto para escenarios de éxito como de error Probar el comportamiento de cancelación Verificar la limpieza de recursos    Patrones Comunes y Ejemplos Manejo de Timeout 1 2 3 4 5 6 7 8 9 10 11 12 13 14  suspend fun apiCallWithTimeout(): Result\u0026lt;String\u0026gt; = withTimeout(5000L) { suspendCoroutine\u0026lt;Result\u0026lt;String\u0026gt;\u0026gt; { continuation: Continuation\u0026lt;Result\u0026lt;String\u0026gt;\u0026gt; -\u0026gt; api.call(object : ApiCallback { override fun onSuccess(result: Result\u0026lt;String\u0026gt;) { continuation.resume(result) } override fun onError(error: Exception) { continuation.resumeWithException(error) } }) } }   Combinando Múltiples Callbacks 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  fun MultipleSourceService.combinedUpdatesFlow(): Flow\u0026lt;Update\u0026gt; = callbackFlow { val callback1 = object : SourceCallback { override fun onUpdate(data: Update) { trySend(data) } } val callback2 = object : SourceCallback { override fun onUpdate(data: Update) { trySend(data) } } registerCallbacks(callback1, callback2) awaitClose { unregisterCallbacks(callback1, callback2) } }.buffer(Channel.BUFFERED)   Conclusión La conversión de APIs basadas en callbacks a corrutinas y flows puede mejorar significativamente la legibilidad y mantenibilidad del código. Usando suspendCoroutine para operaciones únicas y callbackFlow para flujos de datos, puedes modernizar código legacy y aprovechar al máximo las potentes características de concurrencia de Kotlin.\nRecuerda siempre manejar los errores apropiadamente, gestionar los recursos correctamente y considerar la contrapresión cuando trates con actualizaciones de alta frecuencia. Con estas herramientas y patrones, puedes cerrar efectivamente la brecha entre las APIs basadas en callbacks y la concurrencia moderna de Kotlin.\n","description":"Aprende cómo transformar APIs basadas en callbacks a corrutinas y flows modernos de Kotlin usando suspendCoroutine y callbackFlow","id":27,"section":"posts","tags":["kotlin","coroutines","flows","callbacks"],"title":"Convirtiendo Callbacks a Corrutinas y Flows en Kotlin","uri":"https://carrion.dev/es/posts/callback-to-flow-conversion/"},{"content":"Entendiendo los Hot y Cold Flows en Kotlin Kotlin Flow es una potente característica para manejar flows reactivos de datos. Uno de los conceptos fundamentales para entender cuando trabajamos con flows es la distinción entre hot y cold flows. Este artículo explicará las diferencias y proporcionará ejemplos prácticos de ambos tipos.\nCold Flows: El Comportamiento por Defecto Los cold flows son el tipo predeterminado en Kotlin Flow. Comienzan a producir valores solo cuando un collector empieza a recolectar de ellos. Cada collector obtiene su propio flow independiente de valores desde el principio.\nCaracterísticas de los Cold Flows:  Comienzan a producir valores solo cuando son recolectados Cada collector recibe todos los valores desde el principio Los valores se producen independientemente para cada collector Los recursos no se comparten entre collectors  Aquí hay un ejemplo de un flujo cold:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  fun numbers(): Flow\u0026lt;Int\u0026gt; = flow { println(\u0026#34;Flow started\u0026#34;) for (i in 1..3) { delay(100) emit(i) } } suspend fun main() { val numbersFlow = numbers() // First collector  println(\u0026#34;First collector starting\u0026#34;) numbersFlow.collect { value: Int -\u0026gt; println(\u0026#34;Collector 1: $value\u0026#34;) } // Second collector  println(\u0026#34;Second collector starting\u0026#34;) numbersFlow.collect { value: Int -\u0026gt; println(\u0026#34;Collector 2: $value\u0026#34;) } }   Output:\nFirst collector starting Flow started Collector 1: 1 Collector 1: 2 Collector 1: 3 Second collector starting Flow started Collector 2: 1 Collector 2: 2 Collector 2: 3 Hot Flows: Estado Compartido y Eventos Los hot flows, por otro lado, pueden comenzar a producir valores independientemente de los collectors y pueden compartir el mismo flow de valores entre múltiples collectors. Son útiles para representar eventos en tiempo real o estado compartido.\nTipos de Hot Flows:  StateFlow: Para representar estado SharedFlow: Para representar eventos  Ejemplo de StateFlow: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class TemperatureSensor { private val _temperature = MutableStateFlow(20.0) // Initial temperature  val temperature: StateFlow\u0026lt;Double\u0026gt; = _temperature.asStateFlow() fun updateTemperature(newTemp: Double) { _temperature.update { newTemp } } } suspend fun main() { val sensor = TemperatureSensor() // First collector  launch { sensor.temperature.collect { temp: Double -\u0026gt; println(\u0026#34;Display 1: $temp°C\u0026#34;) } } delay(100) println(\u0026#34;Updating temperature to 22.5°C\u0026#34;) sensor.updateTemperature(22.5) delay(100) // Late collector - will only see the current value (22.5) and future updates  launch { println(\u0026#34;Display 2 starting collection...\u0026#34;) sensor.temperature.collect { temp: Double -\u0026gt; println(\u0026#34;Display 2: $temp°C\u0026#34;) } } delay(100) println(\u0026#34;Updating temperature to 23.0°C\u0026#34;) sensor.updateTemperature(23.0) }   Output:\nDisplay 1: 20.0°C Updating temperature to 22.5°C Display 1: 22.5°C Display 2 starting collection... Display 2: 22.5°C Updating temperature to 23.0°C Display 1: 23.0°C Display 2: 23.0°C Ejemplo de SharedFlow: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class EventBus { private val _events = MutableSharedFlow\u0026lt;String\u0026gt;() val events = _events.asSharedFlow() suspend fun emit(event: String) { _events.emit(event) } } suspend fun main() { val eventBus = EventBus() // First subscriber  launch { eventBus.events.collect { event: String -\u0026gt; println(\u0026#34;Subscriber 1: $event\u0026#34;) } } delay(100) println(\u0026#34;Emitting first event\u0026#34;) eventBus.emit(\u0026#34;User logged in\u0026#34;) delay(100) // Late subscriber - will miss the \u0026#34;User logged in\u0026#34; event  launch { println(\u0026#34;Subscriber 2 starting collection...\u0026#34;) eventBus.events.collect { event: String -\u0026gt; println(\u0026#34;Subscriber 2: $event\u0026#34;) } } delay(100) println(\u0026#34;Emitting second event\u0026#34;) eventBus.emit(\u0026#34;Data updated\u0026#34;) }   Output:\nSubscriber 1: User logged in Subscriber 2 starting collection... Emitting second event Subscriber 1: Data updated Subscriber 2: Data updated Diferencias Clave Entre Hot y Cold Flows   Tiempo de Ejecución\n Cold Flow: Se ejecuta por cada collector Hot Flow: Puede ejecutarse independientemente de los collectors    Compartición de Valores\n Cold Flow: Cada collector obtiene su propio flow Hot Flow: Múltiples collectors comparten el mismo flow    Uso de Recursos\n Cold Flow: Recursos asignados por collector Hot Flow: Recursos compartidos entre collectors    Casos de Uso\n Cold Flow: Transformaciones de datos, consultas a base de datos Hot Flow: Estados de UI, eventos en tiempo real, broadcasts    Cuándo Usar Cada Tipo Usa Cold Flows Cuando:  Cada collector necesita su propio flow independiente Estás realizando operaciones que consumen muchos recursos Necesitas reiniciar el flow desde el principio para cada collector  Usa Hot Flows Cuando:  Múltiples partes de tu app necesitan el mismo flow de datos Estás manejando estado de UI Necesitas transmitir eventos a múltiples suscriptores Quieres compartir recursos entre collectors  Mejores Prácticas   Cold Flows\n Úsalos para operaciones que deben ejecutarse independientemente Considera usar buffer() para optimización de rendimiento Limpia los recursos en onCompletion    Hot Flows\n Usa StateFlow para gestión de estado Usa SharedFlow para eventos Considera cuidadosamente los tamaños de replay y buffer Maneja la contrapresión adecuadamente    Al entender estas diferencias, puedes elegir el tipo correcto de flow para tu caso de uso específico y crear flows reactivos más eficientes y mantenibles en tus aplicaciones Kotlin.\n","description":"Una guía completa para entender las diferencias entre hot y cold flows en Kotlin, con ejemplos prácticos","id":28,"section":"posts","tags":["kotlin","coroutines","flows"],"title":"Entendiendo los Hot y Cold Flows en Kotlin","uri":"https://carrion.dev/es/posts/kotlin-flows-hot-cold/"},{"content":"Logrando Seguridad en Tiempo de Compilación con Koin: Una Guía Completa La inyección de dependencias es un patrón fundamental en el desarrollo moderno de Android, pero ¿cómo podemos asegurarnos de que nuestra configuración de DI sea correcta antes de ejecutar la aplicación? En esta publicación, exploraremos dos poderosos enfoques para lograr la seguridad en tiempo de compilación con Koin: usando la función verify() del DSL y aprovechando las Anotaciones de Koin con KSP.\nEl Problema: Validación en Tiempo de Ejecución vs. Tiempo de Compilación La inyección de dependencias tradicional a menudo revela problemas de configuración solo en tiempo de ejecución:\n Las dependencias faltantes causan fallos Las dependencias circulares no se detectan hasta el tiempo de ejecución Los desajustes de tipos se manifiestan cuando la aplicación está en ejecución El alcance (scoping) incorrecto lleva a comportamientos inesperados  Estos problemas pueden ser particularmente problemáticos en aplicaciones grandes donde los grafos de dependencias son complejos y no todos los caminos están cubiertos por tests.\nSolución 1: Koin DSL con verify() El primer enfoque utiliza la función incorporada verify() de Koin para verificar las configuraciones de módulos durante la fase de compilación.\nCómo Funciona 1 2 3 4 5 6 7 8 9 10 11 12  val appModule = module { single\u0026lt;Repository\u0026gt; { DefaultRepository() } factory { UseCase(get()) } viewModel { MainViewModel(get()) } } class ModuleCheck { @Test fun verifyKoinModules() { appModule.verify() } }   Al crear una test unitario que llama a verify() en tus módulos y hacerla parte de tu proceso de construcción, puedes detectar problemas comunes tempranamente.\nVentajas  Fácil de implementar No requiere dependencias adicionales Funciona con código existente de Koin DSL Se puede integrar en pipelines de CI/CD  Limitaciones  Requiere ejecución explícita de tests Menor soporte de IDE Sin errores directos de compilación No puede detectar todos los problemas potenciales  Solución 2: Anotaciones de Koin con KSP El segundo enfoque utiliza el Procesamiento de Símbolos de Kotlin (KSP) y el sistema de anotaciones de Koin para validar los grafos de dependencias durante la compilación.\nConfiguración 1 2 3 4 5 6 7 8 9 10 11 12 13  // build.gradle.kts plugins { id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;2.1.10-1.0.31\u0026#34; } dependencies { implementation(\u0026#34;io.insert-koin:koin-annotations:2.0.0-RC5\u0026#34;) ksp(\u0026#34;io.insert-koin:koin-ksp-compiler:2.0.0-RC5\u0026#34;) } ksp { arg(\u0026#34;KOIN_CONFIG_CHECK\u0026#34;, \u0026#34;true\u0026#34;) }   Cómo Funciona En lugar de usar el DSL, defines las dependencias usando anotaciones:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  @SingleOf(binds = [Repository::class]) class DefaultRepository : Repository { // Implementación } @Module class AppModule { @Factory fun provideUseCase(repository: Repository): UseCase { return UseCase(repository) } } @Module class ViewModelModule { @KoinViewModel fun provideMainViewModel( useCase: UseCase ): MainViewModel = MainViewModel(useCase) }   KSP procesa estas anotaciones durante la compilación y:\n Genera definiciones de dependencias con seguridad de tipos Valida el grafo de dependencias Asegura que todas las dependencias puedan resolverse Verifica dependencias circulares Verifica la consistencia del alcance  Ventajas  Validación real en tiempo de compilación Mejor soporte de IDE Declaraciones de dependencias más explícitas Detecta problemas durante la compilación Seguridad de tipos por diseño  Limitaciones  Requiere configuración adicional Más verboso que DSL Requiere migración desde código basado en DSL Aún en fase Release Candidate  Comparando los Enfoques    Característica DSL + verify() Anotaciones + KSP     Complejidad de Configuración Baja Media   Momento de Validación Tiempo de construcción (vía tests) Tiempo de compilación   Soporte de IDE Limitado Bueno   Esfuerzo de Migración Bajo Medio   Seguridad de Tipos Buena Excelente   Mensajes de Error Fallos en tests Errores de compilación   Curva de Aprendizaje Suave Moderada    ¿Qué Enfoque Deberías Elegir? Elige DSL + verify() si:  Tienes una base de código existente con Koin DSL Quieres una solución simple Prefieres una configuración más flexible Te sientes cómodo con la validación basada en tests  Elige Anotaciones + KSP si:  Estás comenzando un nuevo proyecto Quieres verdadera seguridad en tiempo de compilación Prefieres declaraciones de dependencias explícitas Valoras el soporte del IDE y la seguridad de tipos  Mejores Prácticas Independientemente del enfoque que elijas:\n  Haz que la validación sea parte de tu proceso de construcción\n Para DSL: Incluye test de verificación en tu construcción Para Anotaciones: Habilita la validación KSP    Documenta tu grafo de dependencias\n Mantén una estructura clara de módulos Documenta las decisiones de alcance Mantén una arquitectura limpia    Monitorea los tiempos de construcción\n Ambos enfoques pueden impactar los tiempos de construcción El procesamiento KSP agrega tiempo de compilación La ejecución de tests agrega tiempo de construcción    Considera una migración gradual\n Puedes mezclar ambos enfoques Migra gradualmente de DSL a anotaciones Comienza con nuevas características usando tu enfoque elegido    Conclusión Ambos enfoques ofrecen valiosas formas de lograr la seguridad en tiempo de compilación en tu inyección de dependencias con Koin. El DSL con verify() proporciona un enfoque más simple basado en tests, mientras que las anotaciones con KSP ofrecen garantías más fuertes en tiempo de compilación con mejor soporte de herramientas.\nElige el enfoque que mejor se adapte a las necesidades de tu proyecto, considerando factores como la base de código existente, la experiencia del equipo y el nivel deseado de seguridad de tipos. Recuerda que ambos enfoques son significativamente mejores que confiar únicamente en la validación en tiempo de ejecución.\nRecursos  Documentación de Koin Guía de Anotaciones de Koin Documentación de KSP Proyecto de Ejemplo  ","description":"La inyección de dependencias es un patrón fundamental en el desarrollo moderno de Android, pero ¿cómo podemos asegurarnos de que nuestra configuración de DI sea correcta antes de ejecutar la aplicación? En esta publicación, exploraremos dos poderosos enfoques para lograr la seguridad en tiempo de compilación con Koin: usando la función `verify()` del DSL y aprovechando las Anotaciones de Koin con KSP.","id":29,"section":"posts","tags":["kotlin","android","koin"],"title":"Logrando Seguridad en Tiempo de Compilación con Koin: Una Guía Completa","uri":"https://carrion.dev/es/posts/koin-compile-safety/"},{"content":"Gestión Confiable del Tiempo con la API TrustedTime en Android\nLa gestión precisa del tiempo es crucial para muchas funcionalidades de las aplicaciones, como la programación de tareas, el registro de transacciones y la seguridad. Sin embargo, depender del reloj del sistema de un dispositivo puede ser problemático, ya que los usuarios pueden modificar la configuración de la hora. Para abordar este problema, Google ha introducido la API TrustedTime, que proporciona una fuente de tiempo confiable y resistente a manipulaciones para las aplicaciones de Android.\nComprendiendo la API TrustedTime La API TrustedTime aprovecha la infraestructura segura de Google para ofrecer una marca de tiempo confiable, independiente de la configuración horaria local del dispositivo. Se sincroniza periódicamente con los servidores de tiempo precisos de Google, reduciendo la necesidad de solicitudes frecuentes a la red. La API también tiene en cuenta la deriva del reloj, alertando a los desarrolladores cuando la precisión del tiempo puede degradarse entre sincronizaciones.\nImportancia de la Gestión Precisa del Tiempo Depender únicamente del reloj de un dispositivo puede causar problemas como:\n Inconsistencia de Datos: Las aplicaciones que dependen del orden de los eventos pueden enfrentar corrupción de datos si los usuarios manipulan la hora del dispositivo. Riesgos de Seguridad: Las medidas de seguridad basadas en el tiempo, como OTP y controles de acceso, requieren un reloj preciso. Programaciones No Confiables: Los recordatorios y eventos programados pueden fallar si la hora del dispositivo es incorrecta. Deriva del Reloj: Los relojes internos pueden desviarse debido a factores como cambios de temperatura y niveles de batería. Problemas de Sincronización entre Dispositivos: Configuraciones horarias inconsistentes en diferentes dispositivos pueden interrumpir la sincronización de datos. Alto Consumo de Batería y Datos: Consultar constantemente servidores de tiempo en la red consume recursos, lo que TrustedTime ayuda a optimizar.  Aplicaciones Prácticas de TrustedTime La API TrustedTime mejora la seguridad y confiabilidad en varios escenarios:\n Aplicaciones Financieras: Garantiza marcas de tiempo precisas para transacciones. Juegos: Previene exploits basados en el tiempo. E-Commerce: Realiza un seguimiento preciso del procesamiento y entrega de pedidos. Ofertas por Tiempo Limitado: Garantiza que las promociones expiren correctamente. Dispositivos IoT: Sincroniza relojes en múltiples dispositivos. Aplicaciones de Productividad: Mantiene marcas de tiempo precisas en la edición de documentos en la nube.  Integrando TrustedTime en tu Aplicación Android 1. Agregar la Dependencia Incluye la API TrustedTime en tu archivo build.gradle:\n1  implementation \u0026#39;com.google.android.gms:play-services-time:16.0.1\u0026#39;   2. Inicializar TrustedTimeClient 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class MyApp : Application() { var trustedTimeClient: TrustedTimeClient? = null private set override fun onCreate() { super.onCreate() TrustedTime.createClient(this).addOnCompleteListener { task -\u0026gt; if (task.isSuccessful) { trustedTimeClient = task.result } else { // Manejar error  } } } }   3. Usando TrustedTime en una Actividad o Fragment Para recuperar la hora confiable dentro de una actividad o fragmento, podemos acceder al TrustedTimeClient desde la clase de aplicación:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class MainActivity : AppCompatActivity() { private val trustedTimeClient: TrustedTimeClient? get() = (application as MyApp).trustedTimeClient override fun onCreate(savedInstanceState: Bundle?) { super.onCreate() setContentView(R.layout.activity_main) getTrustedTime() } private fun getTrustedTime() { val currentTimeMillis = trustedTimeClient?.computeCurrentUnixEpochMillis() ?: System.currentTimeMillis() Log.d(\u0026#34;TrustedTime\u0026#34;, \u0026#34;Hora confiable actual: $currentTimeMillis\u0026#34;) } }   Al recuperar trustedTimeClient desde MyApp, evitamos inicializaciones redundantes y aseguramos una única fuente confiable de tiempo en toda la aplicación.\n4. Recuperar TrustedTime con un Mecanismo de Respaldo 1 2  val currentTimeMillis = trustedTimeClient?.computeCurrentUnixEpochMillis() ?: System.currentTimeMillis()   Esto garantiza un respaldo al reloj del sistema si TrustedTime no está disponible.\nConsideraciones y Limitaciones  Requiere Conexión a Internet: TrustedTime necesita acceso a Internet después del arranque del dispositivo para funcionar correctamente. Deriva del Reloj: Aunque la API proporciona una estimación del error, no puede prevenir completamente la deriva del reloj. Protección contra Manipulación: Reduce, pero no elimina por completo, los riesgos de manipulación del tiempo. Disponibilidad y Limitaciones de la API TrustedTime: La API TrustedTime está disponible en todos los dispositivos que ejecutan Google Play Services en Android 5 (Lollipop) y versiones superiores.  Al integrar la API TrustedTime, los desarrolladores pueden mejorar la precisión y seguridad de las funcionalidades dependientes del tiempo en sus aplicaciones, garantizando una experiencia consistente y confiable para los usuarios.\n","description":"La API TrustedTime aprovecha la infraestructura segura de Google para ofrecer una marca de tiempo confiable","id":30,"section":"posts","tags":["kotlin","android","google"],"title":"Gestión Confiable del Tiempo con la API TrustedTime en Android","uri":"https://carrion.dev/es/posts/trusted-time-api/"},{"content":"Mejores Prácticas de Arquitectura en Kotlin Multiplatform para Aplicaciones Móviles Kotlin Multiplatform (KMP) permite a los desarrolladores compartir la lógica de negocio entre Android y iOS mientras mantienen implementaciones específicas de cada plataforma cuando es necesario. Estructurar un proyecto KMP de manera eficiente es clave para mantener la escalabilidad, testabilidad y aplicar Clean Architecture. En esta guía, exploraremos las mejores prácticas para diseñar una aplicación móvil con Compose Multiplatform y Clean Architecture.\n1. Estructura del Proyecto Una estructura de proyecto bien organizada mejora el mantenimiento y la separación de responsabilidades. Un enfoque común es seguir una estructura multi-módulo, ya sea con un único módulo compartido o con múltiples módulos basados en feature:\nproject-root/ ├── core/ │ ├── network/ # Network shared logic │ │ ├── src/commonMain/ # Shared networking │ │ ├── src/androidMain/ # Android-specific implementations │ │ ├── src/iosMain/ # iOS-specific implementations ├── features/ # Feature-based modules │ ├── feature1/ # Example feature module │ │ ├── domain/ # Domain layer (Use cases, repositories interfaces) │ │ ├── data/ # Data layer (Implementations, APIs, Database) │ │ ├── presentation/ # UI and ViewModels for Compose Multiplatform ├── composeApp/ # Application module integrating all features │ ├── src/commonMain/ # Can contain shared UI and navigation logic │ ├── src/androidMain/ # Android-specific implementations if needed │ ├── src/iosMain/ # iOS-specific implementations if needed ├── androidApp/ # Android application module ├── iosApp/ # iOS application module  Feature Modules: En lugar de un único módulo compartido, se pueden tener módulos compartidos por feature para mejorar la modularidad y escalabilidad. Estos pueden dividirse aún más en domain, data y presentation para una mejor separación de responsabilidades. Core Modules: Contiene utilidades compartidas como networking, logging y lógica de dominio común. ComposeApp Module: Actúa como el módulo principal de la aplicación, integrando todos los módulos de features y manejando la navegación, similar a un módulo app en un proyecto estándar de Android.  En la mayoría de los proyectos de Compose Multiplatform, el módulo composeApp se usa para ensamblar todas las features, gestionar la navegación y manejar otras preocupaciones a nivel de aplicación, similar al módulo app en un proyecto estándar de Android.\n2. Aplicando Clean Architecture en KMP Seguir Clean Architecture ayuda a mantener la separación de responsabilidades y mejorar la testabilidad. La arquitectura puede estructurarse en las siguientes capas:\nCapa de Dominio (commonMain)  Contiene la lógica de negocio (Casos de uso, Interactors). Define las interfaces de repositorio para el acceso a datos. No depende de ninguna implementación específica de la plataforma.  1 2 3  interface UserRepository { suspend fun getUser(): User }   Capa de Datos (commonMain, específica por plataforma)  Implementa las interfaces de repositorio. Usa expect/actual para APIs específicas de plataforma como networking, bases de datos, etc. Obtiene y procesa datos antes de exponerlos a la capa de dominio.  Ejemplo de expect/actual para un cliente HTTP:\n1 2 3  expect class HttpClientProvider { fun getClient(): HttpClient }   Implementación específica para Android:\n1 2 3  actual class HttpClientProvider { actual fun getClient() = HttpClient(Android) {} }   Implementación específica para iOS:\n1 2 3  actual class HttpClientProvider { actual fun getClient() = HttpClient(Ios) {} }   Capa de Presentación (Compose Multiplatform) Con Compose Multiplatform, podemos compartir componentes de UI entre plataformas mientras aprovechamos la renderización nativa. El módulo composeApp integra todos los módulos de features y maneja la navegación y la lógica a nivel de aplicación.\n1 2 3 4 5 6 7  @Composable fun UserScreen(viewModel: UserViewModel) { val user by viewModel.userState.collectAsState() Column(modifier = Modifier.padding(16.dp)) { Text(\u0026#34;Hello, ${user?.name ?: \u0026#34;Guest\u0026#34;}\u0026#34;, style = MaterialTheme.typography.h6) } }   En Android, esto se renderiza con Jetpack Compose, y en iOS, con Compose para iOS.\n3. Gestión del Estado en KMP La gestión del estado en un proyecto KMP puede manejarse eficientemente con StateFlow.\n1 2 3 4 5 6 7 8 9 10  class UserViewModel(private val repository: UserRepository) { private val _userState = MutableStateFlow\u0026lt;User?\u0026gt;(null) val userState: StateFlow\u0026lt;User?\u0026gt; = _userState fun loadUser() { viewModelScope.launch { _userState.value = repository.getUser() } } }   Dado que Compose Multiplatform soporta collectAsState(), podemos observar y renderizar cambios de estado directamente en la UI.\n4. Testing en KMP  Unit Tests en commonTest usando kotlin.test. Pruebas específicas de plataforma en androidTest y iosTest.  Ejemplo de prueba unitaria compartida:\n1 2 3 4 5  @Test fun testUserRepository() = runTest { val repository = FakeUserRepository() assertNotNull(repository.getUser()) }   Conclusión Siguiendo estas mejores prácticas, puedes construir aplicaciones KMP escalables y mantenibles:\n Usa una estructura de proyecto modularizada con un módulo compartido o módulos por feature. Sigue Clean Architecture para mejorar la mantenibilidad. Aprovecha Compose Multiplatform para la UI, utilizando un módulo composeApp para integrar módulos de features y manejar la navegación. Los módulos de features pueden dividirse aún más en dominio, datos y presentación para mejorar la separación de responsabilidades. Gestiona el estado eficientemente con StateFlow. Escribe pruebas completas tanto en código compartido como en implementaciones específicas de plataforma.  KMP permite compartir código de manera eficiente mientras se preservan optimizaciones específicas de cada plataforma, lo que lo convierte en una opción poderosa para el desarrollo de aplicaciones móviles.\n¿Te gustaría un repositorio en GitHub con un ejemplo de esta configuración? 🚀\n","description":"Consejos de arquitectura para proyectos KMP usando Clean Architecture","id":31,"section":"posts","tags":["kotlin","compose","cmp","multiplatform","cleancode","architecture"],"title":"Mejores Prácticas de Arquitectura en Kotlin Multiplatform para Aplicaciones Móviles","uri":"https://carrion.dev/es/posts/kmp-architecture/"},{"content":"Mocks, Fakes y Más: Entendiendo los Test Doubles en Kotlin Al escribir tests en Kotlin, especialmente para el desarrollo de Android, a menudo necesitamos reemplazar dependencias reales con test doubles. Sin embargo, no todos los test doubles son iguales: términos como mocks, fakes, stubs, spies y dummies aparecen con frecuencia. En esta publicación, desglosaremos sus diferencias con ejemplos en Kotlin utilizando solo Kotlin puro (sin bibliotecas de terceros).\n1. Entendiendo los Test Doubles Los test doubles son objetos que sustituyen dependencias reales en las tests. Ayudan a aislar el sistema bajo prueba (SUT) y hacen que las tests sean más confiables. Aquí están los principales tipos:\n Dummy – Un objeto de relleno que se pasa como argumento pero no se utiliza en la ejecución del test. Stub – Proporciona respuestas predefinidas pero no contiene lógica. Fake – Una implementación liviana con lógica en memoria. Mock – Un test double que verifica interacciones. Spy – Envuelve un objeto real permitiendo la modificación selectiva de su comportamiento.  2. Objetos Dummy Un dummy es un objeto que solo existe para satisfacer la firma de un método, pero nunca se usa realmente.\nEjemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  interface EmailSender { fun sendEmail(email: String, message: String) } class UserService(private val emailSender: EmailSender) { fun registerUser(user: User) { // The user registers, but we don\u0026#39;t actually send an email  } } data class User(val name: String, val email: String) // Test fun testRegisterUser() { val dummyEmailSender = object : EmailSender { override fun sendEmail(email: String, message: String) { // This will never be called in the test  } } val userService = UserService(dummyEmailSender) userService.registerUser(User(\u0026#34;John Doe\u0026#34;, \u0026#34;john@example.com\u0026#34;)) }   3. Stubs Un stub devuelve respuestas predefinidas a las llamadas a métodos, pero no rastrea interacciones.\nEjemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  interface UserRepository { fun getUser(id: Int): User? } class StubUserRepository : UserRepository { override fun getUser(id: Int): User? { return if (id == 1) User(\u0026#34;John Doe\u0026#34;, \u0026#34;john@example.com\u0026#34;) else null } } // Test fun testGetUser() { val stubRepo = StubUserRepository() val user = stubRepo.getUser(1) assert(user?.name == \u0026#34;John Doe\u0026#34;) }   4. Fakes Un fake es una versión simplificada pero funcional de una clase real, a menudo utilizando almacenamiento en memoria.\nEjemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class FakeUserRepository : UserRepository { private val users = mutableMapOf\u0026lt;Int, User\u0026gt;() override fun getUser(id: Int): User? = users[id] fun addUser(id: Int, user: User) { users[id] = user } } // Test fun testFakeUserRepository() { val fakeRepo = FakeUserRepository() fakeRepo.addUser(1, User(\u0026#34;Jane Doe\u0026#34;, \u0026#34;jane@example.com\u0026#34;)) assert(fakeRepo.getUser(1)?.name == \u0026#34;Jane Doe\u0026#34;) }   5. Mocks Un mock es un test double que verifica interacciones. Sin un framework de mocking, debemos rastrear manualmente las llamadas.\nEjemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class MockEmailSender : EmailSender { var wasSendEmailCalled = false var sentTo: String? = null var sentMessage: String? = null override fun sendEmail(email: String, message: String) { wasSendEmailCalled = true sentTo = email sentMessage = message } } // Test fun testSendWelcomeEmail() { val mockEmailSender = MockEmailSender() val service = NotificationService(mockEmailSender) service.sendWelcomeEmail(User(\u0026#34;test@example.com\u0026#34;, \u0026#34;test@example.com\u0026#34;)) assert(mockEmailSender.wasSendEmailCalled) assert(mockEmailSender.sentTo == \u0026#34;test@example.com\u0026#34;) assert(mockEmailSender.sentMessage == \u0026#34;Welcome!\u0026#34;) } class NotificationService(private val emailSender: EmailSender) { fun sendWelcomeEmail(user: User) { emailSender.sendEmail(user.email, \u0026#34;Welcome!\u0026#34;) } }   6. Spies Un spy envuelve un objeto real mientras permite la modificación selectiva de su comportamiento. Sin una biblioteca, debemos extender la clase real y sobrescribir comportamientos específicos.\nEjemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  open class MathService { open fun add(a: Int, b: Int) = a + b } class SpyMathService : MathService() { var wasAddCalled = false var lastA: Int? = null var lastB: Int? = null override fun add(a: Int, b: Int): Int { wasAddCalled = true lastA = a lastB = b return super.add(a, b) // Calls the real implementation  } }   7. Uso de MockK para Mocks y Spies Si bien es posible crear mocks y spies manualmente, usar una biblioteca como MockK simplifica el proceso.\nEjemplo usando MockK: 1 2 3 4 5 6 7 8 9 10 11  import io.mockk.* fun testMockKExample() { val mockEmailSender = mockk\u0026lt;EmailSender\u0026gt;() every { mockEmailSender.sendEmail(any(), any()) } just Runs val service = NotificationService(mockEmailSender) service.sendWelcomeEmail(User(\u0026#34;test@example.com\u0026#34;, \u0026#34;test@example.com\u0026#34;)) verify { mockEmailSender.sendEmail(\u0026#34;test@example.com\u0026#34;, \u0026#34;Welcome!\u0026#34;) } }   MockK proporciona características avanzadas como spies automáticos, mocks relajados y captura de argumentos, lo que facilita la escritura de tests mantenibles.\nConclusión Comprender los test doubles te ayuda a escribir mejores tests al aislar dependencias. Usa:\n✅ Dummies cuando se requiere un argumento pero no se usa.\n✅ Stubs para devolver valores predefinidos.\n✅ Fakes para implementaciones livianas.\n✅ Mocks para verificar interacciones.\n✅ Spies cuando necesitas mockeo parcial.\n✅ MockK para un mockeo más fácil y potente.\nAl elegir el tipo correcto, puedes hacer que tus tests sean más confiables y mantenibles.\n","description":"Mocks, Fakes y Más: Entendiendo los Test Doubles en Kotlin","id":32,"section":"posts","tags":["kotlin","testing","mock","tdd"],"title":"Mocks, Fakes y Más","uri":"https://carrion.dev/es/posts/test-doubles/"},{"content":"Tests en Compose Multiplatform (CMP) desde Código Común Compose Multiplatform (CMP) permite construir UI para múltiples plataformas utilizando Jetpack Compose. Afortunadamente, CMP también admite escribir y ejecutar tests de UI en el código común, lo que hace que los test sean más eficientes en todas las plataformas. En esta publicación, exploraremos cómo probar aplicaciones CMP utilizando compose.uiTest y ejecutarlas en Android, Desktop e iOS.\n1. Configuración de Test de UI Comunes CMP proporciona compose.uiTest, lo que permite escribir test de UI en el módulo compartido sin depender de plataformas específicas. Esto significa que puedes escribir una vez y probar en todas partes.\nActualización de la Configuración del Proyecto Para habilitar los tests, actualiza tu archivo build.gradle.kts en el módulo compartido:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  kotlin { androidTarget { instrumentedTestVariant.sourceSetTree.set(KotlinSourceSetTree.test) } sourceSets { val commonTest by getting { dependencies { implementation(kotlin(\u0026#34;test\u0026#34;)) @OptIn(org.jetbrains.compose.ExperimentalComposeLibrary::class) implementation(compose.uiTest) } } val desktopTest by getting { dependencies { implementation(compose.desktop.currentOs) } } } }   Declaración de Dependencias para Tests de UI en Android En el nivel raíz de tu archivo build.gradle.kts, agrega las dependencias necesarias para los tests en Android:\n1 2 3 4  dependencies { androidTestImplementation(\u0026#34;androidx.compose.ui:ui-test-junit4-android:1.5.4\u0026#34;) debugImplementation(\u0026#34;androidx.compose.ui:ui-test-manifest:1.5.4\u0026#34;) }   Configuración Específica para Tests en Android Para tests instrumentadas en Android, agrega lo siguiente a tu build.gradle.kts:\n1 2 3 4 5  android { defaultConfig { testInstrumentationRunner = \u0026#34;androidx.test.runner.AndroidJUnitRunner\u0026#34; } }   2. Implementación de una UI de Contador Simple Vamos a crear un CounterViewModel que será probado:\n1 2 3 4 5 6 7 8 9 10 11 12  import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.asStateFlow class CounterViewModel { private val _count = MutableStateFlow(0) val count: StateFlow\u0026lt;Int\u0026gt; = _count.asStateFlow() fun increment() { _count.value += 1 } }   Ahora, creemos la UI con Composables que interactúa con este ViewModel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  import androidx.compose.foundation.layout.* import androidx.compose.material.* import androidx.compose.runtime.* import androidx.compose.ui.Modifier import androidx.compose.ui.platform.testTag import androidx.compose.ui.unit.dp @Composable fun CounterScreen(viewModel: CounterViewModel) { val count by viewModel.count.collectAsState() Column( modifier = Modifier.padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally ) { Text(text = count.toString(), fontSize = 24.sp, modifier = Modifier.testTag(\u0026#34;counterText\u0026#34;)) Spacer(modifier = Modifier.height(8.dp)) Button(onClick = { viewModel.increment() }, modifier = Modifier.testTag(\u0026#34;incrementButton\u0026#34;)) { Text(\u0026#34;Increment\u0026#34;) } } }   3. Escribiendo un Test de UI Común en CMP Ahora, escribamos un test de UI en commonTest para validar que al hacer clic en el botón, el contador se incremente:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import androidx.compose.ui.test.* import kotlin.test.Test import kotlin.test.assertEquals class CounterScreenTest { @OptIn(ExperimentalTestApi::class) @Test fun testButtonIncrementsCounter() = runComposeUiTest { val viewModel = CounterViewModel() setContent { CounterScreen(viewModel = viewModel) } onNodeWithTag(\u0026#34;counterText\u0026#34;).assertTextEquals(\u0026#34;0\u0026#34;) onNodeWithTag(\u0026#34;incrementButton\u0026#34;).performClick() onNodeWithTag(\u0026#34;counterText\u0026#34;).assertTextEquals(\u0026#34;1\u0026#34;) } }   4. Ejecutando los Tests en Múltiples Plataformas Ahora que hemos escrito nuestr test en código común, ejecutémosla en Android, Desktop e iOS.\nEjecutar Tests en Android Para tests instrumentadas en Android, ejecuta:\n1  ./gradlew connectedAndroidTest   Ejecutar Tests en Desktop 1  ./gradlew desktopTest   Ejecutar Tests en iOS Para tests en el simulador de iOS, ejecuta:\n1  ./gradlew :composeApp:iosSimulatorArm64Test   5. ¿Por Qué Probar CMP desde Código Común? ✅ Escribe una vez, prueba en todas partes: No es necesario duplicar tests en cada plataforma.\n✅ Comportamiento consistente en todas las plataformas: Garantiza que los elementos de la UI funcionen de la misma manera.\n✅ Mantenimiento más fácil: Una única suite de tests cubriendo todos los objetivos.\nConclusión Con los tests de UI en Compose Multiplatform, podemos validar el comportamiento de la UI desde código compartido sin necesidad de implementaciones de test específicos por plataforma. La biblioteca compose.uiTest nos permite probar interacciones de UI como la verificación de texto y clics en botones, asegurando consistencia en Android, iOS y Desktop.\n","description":"Aprende como escribir y correr tests de UI en Compose Multiplatform (CMP) desde el código común, consiguiendo consistencia entre plataformas para Android, iOS y Desktop.","id":33,"section":"posts","tags":["kotlin","compose","cmp","multiplatform"],"title":"Tests en Compose Multiplatform (CMP) desde Código Común","uri":"https://carrion.dev/es/posts/cmp-ui-testing/"},{"content":"Explorando la Librería de Colecciones Inmutables de Kotlin Las colecciones estándar de Kotlin (List, Set, Map) son mutables por defecto, lo que puede provocar modificaciones no deseadas. Para garantizar la inmutabilidad a nivel de API, JetBrains introdujo la librería de Colecciones Inmutables de Kotlin. Esta librería proporciona un conjunto de tipos de colección verdaderamente inmutables que evitan modificaciones accidentales y mejoran la seguridad en entornos concurrentes o de múltiples hilos.\n¿Por qué usar colecciones inmutables? Aunque Kotlin ya ofrece listOf(), setOf() y mapOf() para colecciones de solo lectura, estas no son verdaderamente inmutables. La colección subyacente aún puede modificarse si se referencia en otro lugar. Ejemplo:\n1 2 3 4 5 6 7  val list = mutableListOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) val readOnlyList: List\u0026lt;String\u0026gt; = list list.add(\u0026#34;D\u0026#34;) // Modifies the original list println(readOnlyList) // Output: [A, B, C, D]  (readOnlyList as MutableList).add(\u0026#34;E\u0026#34;) println(readOnlyList) // Output: [A, B, C, D, E]   Para resolver esto, la librería de Colecciones Inmutables proporciona colecciones que garantizan la inmutabilidad en tiempo de ejecución.\nCaracterísticas clave  Verdaderamente inmutables – Una vez creadas, no pueden modificarse. Seguras para múltiples hilos – Evitan modificaciones no intencionadas en entornos concurrentes. Optimizadas para el rendimiento – Utilizan compartición estructural para evitar copias innecesarias.  ¿Cómo usar las Colecciones Inmutables de Kotlin? 1. Agregar la dependencia Primero, incluye la dependencia de Colecciones Inmutables en tu build.gradle.kts:\n1 2 3  dependencies { implementation(\u0026#34;org.jetbrains.kotlinx:kotlinx-collections-immutable:0.3.5\u0026#34;) }   2. Crear colecciones inmutables La librería proporciona persistentListOf(), persistentSetOf() y persistentMapOf() para crear colecciones inmutables:\n1 2 3 4 5  import kotlinx.collections.immutable.* val immutableList = persistentListOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) val immutableSet = persistentSetOf(1, 2, 3) val immutableMap = persistentMapOf(\u0026#34;key1\u0026#34; to 100, \u0026#34;key2\u0026#34; to 200)   3. Agregar y eliminar elementos Dado que estas colecciones son inmutables, las operaciones de modificación devuelven una nueva copia modificada en lugar de cambiar la colección original:\n1 2 3 4 5  val newList = immutableList.add(\u0026#34;D\u0026#34;) // Creates a new list println(newList) // Output: [A, B, C, D]  val newMap = immutableMap.put(\u0026#34;key3\u0026#34;, 300) println(newMap) // Output: {key1=100, key2=200, key3=300}   La immutableList y immutableMap originales permanecen sin cambios.\nConsideraciones de rendimiento A diferencia de las colecciones inmutables estándar (que requieren copias completas para modificaciones), las colecciones persistentes utilizan compartición estructural. Esto significa que las modificaciones crean una nueva colección reutilizando las partes no modificadas de la original, mejorando el rendimiento y la eficiencia de la memoria.\nPor ejemplo, agregar un elemento a una lista persistente no crea una copia completa, sino que reutiliza la mayor parte de la estructura existente:\nOriginal: [A, B, C] New List: [A, B, C, D] (Only \u0026quot;D\u0026quot; is newly allocated) Esto hace que las colecciones inmutables sean eficientes incluso para grandes conjuntos de datos.\nBeneficios en Jetpack Compose Las colecciones inmutables son especialmente útiles en Jetpack Compose, ya que optimizan la gestión del estado y las recomposiciones. A continuación, se explica por qué son importantes en las aplicaciones Compose:\n1. Evitan recomposiciones innecesarias  Compose rastrea los cambios de estado para decidir cuándo recomponer los elementos de la UI. Las listas, conjuntos o mapas mutables pueden provocar recomposiciones innecesarias incluso cuando los datos no han cambiado. Las colecciones inmutables garantizan que el estado permanezca estable, evitando recomposiciones redundantes.  Ejemplo:\n1 2 3 4 5 6 7 8  @Composable fun MyListScreen(items: List\u0026lt;String\u0026gt;) { LazyColumn { items(items) { item -\u0026gt; Text(text = item) } } }   Si items es una lista mutable, incluso reasignando los mismos valores se activa una recomposición. Usar una colección inmutable como PersistentList garantiza que Compose reconozca cuando los datos no han cambiado:\n1 2  val items = remember { persistentListOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) } MyListScreen(items)   2. Estabilidad del estado para mejorar el rendimiento  Compose optimiza el renderizado omitiendo recomposiciones cuando los objetos de estado son estables. Las colecciones inmutables usan compartición estructural, lo que significa que las modificaciones solo afectan la parte cambiada mientras reutilizan el resto. Esto mejora el rendimiento en listas grandes o jerarquías de UI complejas.  3. Comportamiento predecible de la UI  Dado que las colecciones inmutables no pueden modificarse después de la creación, evitan mutaciones accidentales que podrían generar actualizaciones impredecibles en la UI. Esto es especialmente útil en arquitecturas dirigidas por estado (MVI, Redux, etc.), asegurando que la UI se actualice solo cuando sea necesario.  4. Seguridad en múltiples hilos  En aplicaciones Compose que usan corrutinas (Flows, LiveData, etc.), las colecciones inmutables previenen condiciones de carrera cuando múltiples hilos actualizan el estado. Garantizan un flujo de datos seguro entre ViewModels, repositorios y componentes de UI.  ¿Cuándo usar colecciones inmutables? ✅ Programación funcional – Fomenta la inmutabilidad para transformaciones de datos más seguras.\n✅ Seguridad en múltiples hilos – Evita modificaciones no intencionadas en entornos concurrentes.\n✅ Prevención de errores – Reduce efectos secundarios inesperados debido a mutaciones accidentales.\n✅ Gestión del estado en Compose – Ayuda a optimizar recomposiciones y mejora el rendimiento de la UI.\nConclusión La librería de Colecciones Inmutables de Kotlin proporciona colecciones verdaderamente inmutables, eficientes y seguras, lo que las convierte en una excelente opción para la programación funcional, aplicaciones concurrentes y desarrollo con Jetpack Compose. Al aprovechar colecciones persistentes, puedes escribir código Kotlin más seguro y predecible.\n🚀 ¿Usarías colecciones inmutables en tus proyectos?\n","description":"Explorando la Librería de Colecciones Inmutables de Kotlin, usala en Compose para mejorar el rendimiento.","id":34,"section":"posts","tags":["kotlin","collections","compose"],"title":"Explorando la Librería de Colecciones Inmutables de Kotlin","uri":"https://carrion.dev/es/posts/immutable-collections/"},{"content":"Mejorando el Rendimiento de las Aplicaciones Android con Baseline Profiles Introducción En el mundo móvil actual, los usuarios esperan que las aplicaciones se inicien al instante y funcionen sin problemas. La optimización del rendimiento es crucial, especialmente en lo que respecta al tiempo de inicio y la ejecución en tiempo de ejecución.\nLos Baseline Profiles de Android ofrecen una forma eficaz de acelerar el inicio de la aplicación y mejorar el rendimiento en tiempo de ejecución al precompilar rutas de código críticas. Google Play incluso recomienda el uso de Baseline Profiles para mejorar la experiencia del usuario, especialmente en aplicaciones con una renderización de UI compleja o dependencias pesadas.\nEn esta guía, exploraremos qué son los Baseline Profiles, cómo funcionan y cómo integrarlos en tu aplicación Android utilizando un módulo dedicado de Baseline Profile para lograr tiempos de inicio más rápidos y un mejor rendimiento en tiempo de ejecución.\n¿Qué son los Baseline Profiles? Las aplicaciones de Android utilizan el Android Runtime (ART) para ejecutar código, empleando Just-In-Time (JIT) y Ahead-Of-Time (AOT) compilation.\nSin embargo, la compilación JIT puede introducir retrasos durante el inicio de la aplicación, ya que el código no está completamente optimizado inicialmente. Baseline Profiles resuelven este problema al permitir que los desarrolladores especifiquen rutas de código críticas que deben precompilarse antes de ejecutar la aplicación.\n¿Cómo funcionan los Baseline Profiles?  Precompilación: Contienen definiciones de métodos y clases que se precompilan y optimizan antes de la ejecución. Instalación: Estos perfiles se instalan en el dispositivo del usuario en el primer inicio de la aplicación. Optimización: ART los utiliza para mejorar la velocidad de ejecución, especialmente durante los inicios en frío.  ¿Cuándo deberías usar Baseline Profiles? Los Baseline Profiles son especialmente beneficiosos en los siguientes escenarios:\n✅ Optimización del Inicio de la Aplicación – Reducción del tiempo de inicio en frío mediante la precompilación de secuencias de lanzamiento.\n✅ Mejora del Rendimiento del Desplazamiento – Garantiza una renderización de UI más fluida.\n✅ Optimización de Funcionalidades Frecuentemente Usadas – Precompilación de la lógica con la que los usuarios interactúan con frecuencia.\nConfiguración de Baseline Profiles en un Módulo Separado Paso 1: Crear el Módulo de Baseline Profile   Abrir Android Studio:\n Navegar a File → New → New Module. Seleccionar la plantilla Baseline Profile Generator.    Configurar el Módulo:\n Aplicación Objetivo: Elegir el módulo de la aplicación para el cual se generará el Baseline Profile. Nombre del Módulo: Asignar un nombre, por ejemplo, baselineprofile. Nombre del Paquete: Definir el nombre del paquete para el módulo. Lenguaje: Seleccionar Kotlin o Java. Lenguaje de Configuración de Build: Elegir entre Kotlin Script (KTS) o Groovy.    Finalizar: Hacer clic en Finish para crear el módulo.\n  Este proceso configura un nuevo módulo que contiene las configuraciones y el código necesarios para generar y evaluar Baseline Profiles.\nPaso 2: Definir el Generador de Baseline Profile Generador de Baseline Profile Basado en Jetpack Compose 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  @RunWith(AndroidJUnit4::class) @LargeTest class BaselineProfileGenerator { @get:Rule val baselineProfileRule = BaselineProfileRule() @get:Rule val composeTestRule = createAndroidComposeRule\u0026lt;MainActivity\u0026gt;() @Test fun baselineProfile() = baselineProfileRule.collect( packageName = \u0026#34;com.example.app\u0026#34;, includeInStartupProfile = true, profileBlock = { // 1. **Inicio en Frío de la Aplicación**  startActivityAndWait() // 2. **Navegar a la Pantalla Principal**  composeTestRule.onNodeWithText(\u0026#34;Get Started\u0026#34;) .performClick() composeTestRule.waitForIdle() // 3. **Desplazarse a través de una Lista LazyColumn**  composeTestRule.onNodeWithTag(\u0026#34;itemList\u0026#34;) .performScrollToIndex(10) composeTestRule.waitForIdle() // 4. **Abrir una Pantalla de Detalle**  composeTestRule.onNodeWithTag(\u0026#34;item_0\u0026#34;) .performClick() composeTestRule.waitForIdle() // 5. **Realizar una Búsqueda**  composeTestRule.onNodeWithTag(\u0026#34;searchInput\u0026#34;) .performTextInput(\u0026#34;Kotlin\u0026#34;) composeTestRule.waitForIdle() // 6. **Navegación hacia atrás**  composeTestRule.onNodeWithContentDescription(\u0026#34;Back\u0026#34;) .performClick() composeTestRule.waitForIdle() } ) }   Paso 3: Generar e Integrar el Baseline Profile   Generar el Baseline Profile:\n  Ejecutar la configuración Generate Baseline Profile creada por la plantilla.\n  Alternativamente, ejecutar la siguiente tarea de Gradle:\n1  ./gradlew :app:generateBaselineProfile     Esto genera el Baseline Profile y lo copia en el directorio apropiado dentro del módulo de la aplicación.\n  Integrar el Baseline Profile:\n  El perfil generado se incluye automáticamente en los assets del módulo de la aplicación.\n  Asegurar que el archivo build.gradle del módulo de la aplicación incluya las dependencias necesarias:\n1 2 3 4  dependencies { implementation(\u0026#34;androidx.profileinstaller:profileinstaller:1.3.0\u0026#34;) baselineProfile(project(\u0026#34;:baselineprofile\u0026#34;)) }     La biblioteca profileinstaller instala el Baseline Profile en los dispositivos de los usuarios, y la dependencia baselineProfile vincula el perfil generado a la aplicación.\n  Conclusión Los Baseline Profiles son una herramienta poderosa para mejorar el tiempo de inicio y el rendimiento en tiempo de ejecución sin aumentar el tamaño del APK. Al precompilar rutas de código críticas, tu aplicación se iniciará más rápido, brindando una experiencia más fluida y receptiva a los usuarios.\nAl integrar Baseline Profiles mediante un módulo dedicado, garantizas un enfoque modular, mantenible y escalable para la optimización del rendimiento.\nSi aún no lo has hecho, comienza a usar Baseline Profiles hoy mismo y mide su impacto en el rendimiento de tu aplicación.\n","description":"Mejorando el Rendimiento de las Aplicaciones Android con Baseline Profiles con un ejemplo real","id":35,"section":"posts","tags":["kotlin","architecture"],"title":"Mejorando el Rendimiento de las Aplicaciones Android con Baseline Profiles","uri":"https://carrion.dev/es/posts/baseline-profiles/"},{"content":"Modularización en Proyectos Gradle con Kotlin: Una Guía Completa Introducción A medida que los proyectos crecen en complejidad, mantener una base de código monolítica se vuelve un desafío. La modularización es una técnica de diseño de software que divide una aplicación en módulos más pequeños e independientes, haciendo que el proyecto sea más escalable, mantenible y eficiente.\nEn esta guía, exploraremos por qué la modularización es esencial, los diferentes tipos de módulos y las mejores prácticas para configurar un proyecto modular en Gradle usando Kotlin.\n¿Por qué Modularizar? Antes de implementar la modularización, es importante comprender sus principales beneficios:\n Tiempos de compilación más rápidos – Gradle compila módulos independientes en paralelo, reduciendo los tiempos de compilación. Escalabilidad – Facilita la gestión y expansión de proyectos grandes. Encapsulación – Cada módulo tiene una responsabilidad bien definida, mejorando la separación de preocupaciones. Colaboración en equipo – Diferentes equipos pueden trabajar de forma independiente en módulos distintos, reduciendo conflictos de integración. Reutilización – Se pueden extraer funcionalidades comunes en módulos reutilizables.  Escenario de Ejemplo Imagina una app de Android donde todas las características y dependencias residen en un solo módulo app. Esta configuración conduce a tiempos de compilación largos, código fuertemente acoplado y dificultades en las pruebas. Con la modularización, las funcionalidades y componentes compartidos pueden aislarse en módulos separados, mejorando la eficiencia.\nTipos de Módulos en un Proyecto Gradle ✅ Módulos de Funcionalidad (Feature Modules) Contienen características independientes de la aplicación, como:\n feature-auth (Pantallas de autenticación) feature-dashboard (Pantalla principal, datos del usuario) Pueden cargarse dinámicamente usando Dynamic Feature Modules en Android.  ✅ Módulos de Biblioteca (Library Modules) Componentes reutilizables compartidos en toda la aplicación, como:\n ui-components (Botones personalizados, toolbars) networking (Llamadas a API, configuración de Retrofit) analytics (Registro de eventos, Firebase)  ✅ Módulos Core Contienen utilidades compartidas, como:\n core-utils (Funciones comunes, extensiones)  Configuración de Gradle para Modularización Después de definir los tipos de módulos, es crucial configurar correctamente las dependencias.\nUso de api, implementation y compileOnly  implementation – La dependencia solo es visible dentro del módulo. api – La dependencia se expone a otros módulos. compileOnly – Se usa para dependencias solo en tiempo de compilación.  Ejemplo:\n1 2 3 4 5  // En feature-auth/build.gradle.kts dependencies { implementation(project(\u0026#34;:core-utils\u0026#34;)) // Solo visible en este módulo  compileOnly(\u0026#34;androidx.annotation:annotation:1.3.0\u0026#34;) }   Gestión de Dependencias en Gradle Administrar dependencias en múltiples módulos puede simplificarse utilizando Version Catalogs, que es el enfoque recomendado en proyectos Gradle modernos.\n✅ Uso de Version Catalogs (libs.versions.toml) (Recomendado) Los Version Catalogs de Gradle permiten definir dependencias en un archivo .toml, garantizando consistencia y facilitando las actualizaciones en todos los módulos. Este método es ahora el preferido para gestionar dependencias en Gradle.\nPaso 1: Definir dependencias en libs.versions.toml Crea o actualiza el archivo gradle/libs.versions.toml:\n1 2 3 4 5 6 7  [versions] retrofit = \u0026#34;2.9.0\u0026#34; coroutines = \u0026#34;1.6.4\u0026#34; [libraries] retrofit = { module = \u0026#34;com.squareup.retrofit2:retrofit\u0026#34;, version.ref = \u0026#34;retrofit\u0026#34; } coroutines = { module = \u0026#34;org.jetbrains.kotlinx:kotlinx-coroutines-core\u0026#34;, version.ref = \u0026#34;coroutines\u0026#34; }   Paso 2: Usar Version Catalog en build.gradle.kts 1 2 3 4  dependencies { implementation(libs.retrofit) implementation(libs.coroutines) }   Este enfoque proporciona:\n Gestión centralizada de dependencias – Todas las versiones se almacenan en un solo lugar. Actualizaciones seguras – Permite actualizaciones en bloque y verificación de compatibilidad. Mejor mantenibilidad – Reduce la duplicación en múltiples archivos build.gradle.kts.  Si tu proyecto aún usa buildSrc, considera migrar a Version Catalogs, ya que Gradle recomienda activamente este enfoque.\nEjemplo de Arquitectura Modular en Kotlin Estructura de Carpetas de un Proyecto Modular my-app/ │── app/ # Módulo principal de la aplicación │── core/ │ ├── core-utils/ # Utilidades comunes │── features/ │ ├── feature-auth/ # Inicio de sesión, registro │ ├── feature-dashboard/ # Panel de usuario, pantalla principal │── libraries/ │ ├── ui-components/ # Elementos de UI reutilizables │ ├── networking/ # Configuración de Retrofit, cliente API Flujo de Dependencias  feature-auth → depende de core-utils y networking app → depende de todos los módulos de funcionalidad (feature-auth, feature-dashboard)  Mejores Prácticas para Modularización ✅ Evitar Dependencias Cíclicas\n Los módulos de funcionalidad no deben depender directamente entre sí. Usa comunicación basada en eventos (por ejemplo, LiveData, Flow).  ✅ Usar Inyección de Dependencias (DI)\n Bibliotecas como Koin ayudan a gestionar dependencias.  ✅ Optimizar la Velocidad de Compilación en Gradle\n Habilitar la caché de configuración de Gradle:  org.gradle.parallel=true org.gradle.caching=true Conclusión Al implementar la modularización en proyectos Gradle, se logra:\n✔️ Tiempos de compilación más rápidos\n✔️ Mejor mantenibilidad\n✔️ Escalabilidad para equipos grandes\n✔️ Componentes reutilizables\n¿Te gustaría explorar un proyecto de Kotlin de ejemplo que muestre la modularización? 🚀\n","description":"Modularización en Proyectos Gradle con Kotlin: Una Guía Completa","id":36,"section":"posts","tags":["kotlin","architecture"],"title":"Modularización en Proyectos Gradle con Kotlin","uri":"https://carrion.dev/es/posts/gradle-modularization/"},{"content":"Test-Driven Development (TDD) en Kotlin para Android El Test-Driven Development (TDD) es una práctica de desarrollo de software que enfatiza escribir pruebas antes de implementar la funcionalidad. Sigue un ciclo Rojo-Verde-Refactorización: primero, escribes una prueba que falla (Rojo), luego implementas el código mínimo para que pase (Verde), y finalmente, refactorizas el código manteniendo la prueba en verde (Refactorización). En esta publicación, exploraremos cómo aplicar TDD en Kotlin para el desarrollo de Android usando JUnit, MockK y Coroutines, con un ejemplo del mundo real.\n¿Por qué usar Test-Driven Development en el desarrollo de Android?  Mejor calidad del código: Escribir pruebas primero garantiza mejores decisiones de diseño y mantenibilidad. Depuración más rápida: Los errores se detectan temprano antes de volverse complejos. Confianza al refactorizar: Las pruebas actúan como una red de seguridad al modificar código. Mayor productividad: Aunque escribir pruebas primero puede parecer más lento al principio, acelera el desarrollo a largo plazo.  Configuración del entorno de prueba Antes de comenzar, agreguemos las dependencias necesarias a nuestro archivo Gradle:\n1 2 3 4  // Pruebas unitarias testImplementation(\u0026#34;junit:junit:4.13.2\u0026#34;) testImplementation(\u0026#34;org.jetbrains.kotlinx:kotlinx-coroutines-test:1.10.1\u0026#34;) testImplementation(\u0026#34;io.mockk:mockk:1.13.16\u0026#34;)   Ahora, crearemos un ejemplo del mundo real para demostrar Test-Driven Development.\nEjemplo del mundo real: Obtener datos en un UseCase Implementaremos un UseCase que obtiene datos de un Repositorio y los ejecuta en el Dispatcher IO. Seguiremos el enfoque Test-Driven Development.\nPaso 1: Escribir una prueba que falle (Rojo) Primero, definamos una prueba para nuestro FetchUserUseCase. Este caso de uso obtiene los detalles de un usuario desde un repositorio.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  import io.mockk.* import kotlinx.coroutines.CoroutineDispatcher import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.ExperimentalCoroutinesApi import kotlinx.coroutines.test.* import kotlinx.coroutines.runBlocking import org.junit.Before import org.junit.Test import kotlin.test.assertEquals @ExperimentalCoroutinesApi class FetchUserUseCaseTest { private val repository: UserRepository = mockk() private lateinit var useCase: FetchUserUseCase private val testDispatcher = StandardTestDispatcher() @Before fun setup() { useCase = FetchUserUseCase(repository, testDispatcher) // Inyectar dispatcher de prueba  } @Test fun `fetch user returns expected user`() = runTest { // Given  val expectedUser = User(id = 1, name = \u0026#34;John Doe\u0026#34;) coEvery { repository.getUser(1) } returns expectedUser // When  val result = useCase(1) // Then  assertEquals(expectedUser, result) coVerify { repository.getUser(1) } } }   Entendiendo Given-When-Then   Given (Dado) – Configurar las condiciones o dependencias necesarias para la prueba.\n1 2  val expectedUser = User(id = 1, name = \u0026#34;John Doe\u0026#34;) coEvery { repository.getUser(1) } returns expectedUser    Esto prepara una respuesta simulada para repository.getUser(1), de modo que devuelva expectedUser.    When (Cuando) – Ejecutar la función o caso de uso que se está probando.\n1  val result = useCase(1)    Esto llama a FetchUserUseCase con un ID de usuario 1, activando el comportamiento que queremos probar.    Then (Entonces) – Verificar que el resultado esperado coincida con el resultado real.\n1 2  assertEquals(expectedUser, result) coVerify { repository.getUser(1) }    Esto comprueba que la función devolvió el usuario esperado y que el método getUser del repositorio fue llamado.    Paso 2: Implementar el código mínimo para que pase la prueba (Verde) Ahora, implementemos la clase FetchUserUseCase.\n1 2 3 4 5 6 7 8 9 10 11 12 13  import kotlinx.coroutines.CoroutineDispatcher import kotlinx.coroutines.withContext class FetchUserUseCase( private val repository: UserRepository, private val dispatcher: CoroutineDispatcher = Dispatchers.IO // Dispatcher inyectado ) { suspend operator fun invoke(userId: Int): User { return withContext(dispatcher) { repository.getUser(userId) } } }   Paso 3: Refactorizar Dado que nuestra prueba está pasando, podemos limpiar o mejorar nuestra implementación si es necesario. Aquí, la implementación ya es clara, por lo que no se requieren grandes refactorizaciones.\nEntendiendo las partes clave 1. Simulación con MockK Usamos MockK para simular nuestro repositorio:\n1  coEvery { repository.getUser(1) } returns expectedUser   Esto simula una llamada a una función que devuelve un valor predefinido.\n2. Uso de Coroutines con Test Dispatchers Reemplazamos Dispatchers.IO con un Test Dispatcher para controlar la ejecución de las corrutinas.\n3. Verificación de llamadas a funciones Nos aseguramos de que la función del repositorio haya sido llamada:\n1  coVerify { repository.getUser(1) }   Esto confirma que nuestro código se comporta como se espera.\nMejores prácticas para Test-Driven Development en Kotlin  Escribir pruebas pequeñas y enfocadas: Cada prueba debe verificar una sola cosa. Usar mocks con prudencia: Evita el exceso de mocks; solo simula dependencias reales. Preferir pruebas deterministas: Evita pruebas inestables o dependientes del tiempo. Aprovechar las utilidades de prueba de Coroutines: Usa StandardTestDispatcher y runTest. Mantener pruebas rápidas: Las pruebas unitarias deben ejecutarse en milisegundos.  Conclusión Test-Driven Development mejora la calidad del código y la eficiencia en el desarrollo. Al escribir pruebas primero, garantizamos código confiable y mantenible. En esta publicación, construimos un UseCase que obtiene datos de un repositorio ejecutándolo en el Dispatcher IO, siguiendo los principios de Test-Driven Development. Con MockK y Coroutines, creamos una configuración de pruebas robusta.\n¡Comienza a aplicar Test-Driven Development en tus proyectos de Kotlin hoy mismo y experimenta los beneficios de primera mano!\n🚀 ¿Qué sigue? ¿Te gustaría que ampliemos este contenido con pruebas de ViewModel o pruebas de UI con Jetpack Compose? ¡Déjamelo saber en los comentarios!\n","description":"Test-Driven Development (TDD) en Kotlin para Android con ejemplos reales usando JUnit, MockK y Coroutines","id":37,"section":"posts","tags":["kotlin","architecture","TDD","testing"],"title":"Test-Driven Development (TDD) en Kotlin para Android","uri":"https://carrion.dev/es/posts/tdd-kotlin/"},{"content":"Clean Architecture en Kotlin \u0026amp; Android Introducción Al desarrollar aplicaciones Android, mantener la escalabilidad y la legibilidad es crucial. Sin un enfoque arquitectónico claro, los proyectos pueden volverse difíciles de mantener a medida que crecen. Aquí es donde Clean Architecture, introducida por Uncle Bob (Robert C. Martin), se vuelve invaluable. Esta arquitectura enfatiza la separación de responsabilidades, haciendo que el código sea más modular, testeable y mantenible.\nEntendiendo Clean Architecture Clean Architecture está estructurada en tres capas principales, cada una con un rol específico:\n Capa de Presentación: Maneja la UI y las interacciones del usuario. Capa de Dominio: Contiene la lógica de negocio, casos de uso e interfaces de repositorio. Capa de Datos: Implementa los repositorios, maneja llamadas a APIs y operaciones de base de datos.  El principio central de Clean Architecture es la dirección de las dependencias: cada capa solo debe depender de las capas más cercanas al núcleo (dominio). Esto garantiza flexibilidad y escalabilidad.\nEstructura del Proyecto Un proyecto con Clean Architecture en Kotlin típicamente sigue esta estructura:\ncom.example.app │── presentation (ViewModels, UI, Estado) │── domain (Casos de Uso, Interfaces de Repositorio, Modelos) │── data (Implementaciones de Repositorio, Fuentes de Datos, APIs, DB) Cada capa debe estar en un módulo o paquete separado, asegurando una correcta separación de responsabilidades.\nModularización Para mejorar aún más el mantenimiento y la escalabilidad, considera estructurar tu proyecto en módulos de Gradle. Esto garantiza una clara separación entre capas y promueve la reutilización.\nUn proyecto modularizado con Clean Architecture podría seguir esta estructura:\ncom.example.app │── app (Módulo principal de la aplicación) │── feature-user │ │── domain (Casos de Uso, Interfaces de Repositorio, Modelos) │ │── data (Implementaciones de Repositorio, Fuentes de Datos, APIs, DB) │ │── presentation (UI y ViewModels para funcionalidades de usuario) │── core (Utilidades comunes, networking, helpers de base de datos) Beneficios de la modularización:\n Tiempos de compilación más rápidos debido a la compilación aislada de módulos. Mejor encapsulación del código y separación de responsabilidades. Desarrollo y mantenimiento de funcionalidades más sencillo. Mayor facilidad para realizar pruebas unitarias en módulos independientes.  Implementando Clean Architecture con Kotlin 1. Capa de Dominio (Lógica de Negocio Central) La capa de dominio define la lógica de negocio y los casos de uso. No debe depender de ningún framework o librería externa, lo que la convierte en la parte más estable de la aplicación.\nEjemplo: Definir una Interfaz de Repositorio 1 2 3  interface UserRepository { suspend fun getUserById(id: String): User }   Ejemplo: Caso de Uso 1 2 3 4 5  class GetUserByIdUseCase(private val userRepository: UserRepository) { suspend operator fun invoke(id: String): User { return userRepository.getUserById(id) } }   2. Capa de Datos (Implementación de Repositorios y Fuentes de Datos) La capa de datos proporciona implementaciones concretas de las interfaces de repositorio. Interactúa con APIs, bases de datos o almacenamiento local.\nEjemplo: Fuente de Datos 1 2 3 4 5 6 7 8 9  interface UserRemoteDataSource { suspend fun fetchUserById(id: String): User } class UserRemoteDataSourceImpl(private val api: UserApi) : UserRemoteDataSource { override suspend fun fetchUserById(id: String): User { return api.fetchUserById(id) } }   Ejemplo: Implementación del Repositorio 1 2 3 4 5  class UserRepositoryImpl(private val remoteDataSource: UserRemoteDataSource) : UserRepository { override suspend fun getUserById(id: String): User { return remoteDataSource.fetchUserById(id) } }   3. Capa de Presentación (UI \u0026amp; ViewModel) La capa de presentación es responsable de la lógica de UI y la gestión de estados. Depende de la capa de dominio, pero no interactúa directamente con la capa de datos.\nEjemplo: ViewModel 1 2 3 4 5 6 7 8 9 10 11  class UserViewModel(private val getUserByIdUseCase: GetUserByIdUseCase) : ViewModel() { private val _user = MutableStateFlow\u0026lt;User?\u0026gt;(null) val user: StateFlow\u0026lt;User?\u0026gt; get() = _user.asStateFlow() fun loadUser(id: String) { viewModelScope.launch { _user.value = getUserByIdUseCase(id) } } }   Mejores Prácticas  Mantén la Capa de Dominio Pura: No debe depender de frameworks de Android. Usa Inyección de Dependencias: Koin ayuda a gestionar las dependencias de manera limpia. Sigue la Regla de las Dependencias: Las capas internas no deben depender de las externas. Separa Interfaces e Implementaciones de Repositorios: Las interfaces van en la capa de dominio, las implementaciones en la capa de datos. Usa Fuentes de Datos: Encapsula llamadas a APIs y bases de datos en clases dedicadas. Modulariza tu Código: Usa módulos de Gradle para separar responsabilidades y mejorar los tiempos de compilación.  Conclusión Clean Architecture proporciona una forma robusta de estructurar aplicaciones Android. Al separar responsabilidades y aplicar dependencias claras, el código se vuelve más testeable y escalable. Usar Koin para la inyección de dependencias mejora aún más la mantenibilidad. Adoptar esta arquitectura, junto con modularización, resultará en una base de código más modular y resistente para tus proyectos en Kotlin.\n","description":"Clean Architecture en Kotlin \u0026 Android con ejemplos prácticos","id":38,"section":"posts","tags":["kotlin","architecture"],"title":"Clean Architecture en Kotlin \u0026 Android","uri":"https://carrion.dev/es/posts/clean-architecture/"},{"content":"Explorando Arquitecturas de Apps en Kotlin: MVC, MVP, MVVM y MVI Introducción En el desarrollo moderno de aplicaciones, elegir la arquitectura adecuada es esencial para crear aplicaciones mantenibles y escalables. Las arquitecturas definen cómo se organiza tu base de código y cómo interactúan los diferentes componentes. En este artículo, exploraremos cuatro arquitecturas populares: Model-View-Controller (MVC), Model-View-Presenter (MVP), Model-View-ViewModel (MVVM) y Model-View-Intent (MVI). Analizaremos su estructura, ventajas, desventajas y ejemplos prácticos en Kotlin.\n1. Model-View-Controller (MVC) Definición:\nMVC divide una aplicación en tres componentes:\n Model: Gestiona los datos y la lógica de negocio. View: Muestra los datos al usuario, accediendo directamente al Model para actualizaciones. Controller: Maneja la entrada del usuario y actualiza el Model.  Ventajas:\n Simple de implementar y entender. Eficaz para aplicaciones pequeñas o prototipos.  Desventajas:\n Acoplamiento estrecho entre la View y el Model. Separación limitada de preocupaciones; escalar puede ser desafiante.  Ejemplo en Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // Model data class User(var name: String, var age: Int) // View class UserView { fun displayUser(user: User) { println(\u0026#34;Name: ${user.name}, Age: ${user.age}\u0026#34;) } } // Controller class UserController(private val model: User, private val view: UserView) { fun handleUserInput() { println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; model.name = newName // Directly updates the model  view.displayUser(model) } } fun main() { val user = User(\u0026#34;Alice\u0026#34;, 30) val view = UserView() val controller = UserController(user, view) view.displayUser(user) controller.handleUserInput() }   2. Model-View-Presenter (MVP) Definición:\nEn MVP, el Presenter actúa como mediador entre el Model y la View. A diferencia de MVC, la View es pasiva y delega toda la lógica de interacción al Presenter, quien obtiene datos del Model y actualiza la View.\nVentajas:\n Mejor separación de preocupaciones en comparación con MVC. Más fácil de probar, ya que el Presenter maneja toda la lógica.  Desventajas:\n Las clases de Presenter pueden volverse grandes (\u0026ldquo;clases Dios\u0026rdquo;). Manejar eventos del ciclo de vida puede ser desafiante.  Ejemplo en Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // Model data class User(val name: String, val age: Int) // View Interface interface UserView { fun displayUser(name: String, age: Int) } // Presenter class UserPresenter(private val view: UserView) { private var user = User(\u0026#34;Bob\u0026#34;, 25) fun loadUser() { view.displayUser(user.name, user.age) } fun updateUser() { println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; user = user.copy(name = newName) view.displayUser(user.name, user.age) } } // View Implementation class ConsoleUserView : UserView { override fun displayUser(name: String, age: Int) { println(\u0026#34;Name: $name, Age: $age\u0026#34;) } } fun main() { val view = ConsoleUserView() val presenter = UserPresenter(view) presenter.loadUser() presenter.updateUser() }   3. Model-View-ViewModel (MVVM) Definición:\nMVVM promueve un enfoque reactivo. El ViewModel proporciona datos a la View y reacciona a los cambios en el Model. A menudo utiliza LiveData o StateFlow de Kotlin.\nVentajas:\n Fomenta una clara separación de preocupaciones. Excelente para programación reactiva utilizando corutinas o flujos.  Desventajas:\n Requiere familiaridad con paradigmas reactivos. El enlace de datos o la gestión de estados puede agregar complejidad.  Ejemplo en Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // Model data class User(val name: String, val age: Int) // ViewModel class UserViewModel { private val _user = MutableStateFlow(User(\u0026#34;Charlie\u0026#34;, 28)) val user = _user.asStateFlow() fun updateUser(name: String) { _user.value = _user.value.copy(name = name) } } // View class UserView(private val viewModel: UserViewModel) { fun render() { viewModel.user.collect { user -\u0026gt; println(\u0026#34;Name: ${user.name}, Age: ${user.age}\u0026#34;) } } fun getUserInput(): String { println(\u0026#34;Enter new name for the user:\u0026#34;) return readLine() ?: \u0026#34;\u0026#34; } fun updateUserName() { val newName = getUserInput() viewModel.updateUser(newName) } } fun main() = runBlocking { val viewModel = UserViewModel() val view = UserView(viewModel) view.render() view.updateUserName() }   4. Model-View-Intent (MVI) Definición:\nMVI utiliza un flujo de datos unidireccional. La View envía intenciones del usuario, el Model las procesa, y el estado se actualiza y es renderizado por la View.\nVentajas:\n Gestión de estado predecible. Fomenta la inmutabilidad y un flujo de datos claro.  Desventajas:\n Curva de aprendizaje pronunciada. Sobrecarga para aplicaciones simples.  Ejemplo en Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  // Model data class UserState(val name: String = \u0026#34;\u0026#34;, val age: Int = 0) // Intent sealed class UserIntent { object LoadUser : UserIntent() data class UpdateUser(val name: String) : UserIntent() } // Reducer fun userReducer(currentState: UserState, intent: UserIntent): UserState { return when (intent) { is UserIntent.LoadUser -\u0026gt; UserState(name = \u0026#34;Dave\u0026#34;, age = 40) is UserIntent.UpdateUser -\u0026gt; currentState.copy(name = intent.name) } } // ViewModel class UserViewModel { private val _state = MutableStateFlow(UserState()) val state: StateFlow\u0026lt;UserState\u0026gt; = _state fun processIntent(intent: UserIntent) { _state.update { currentState -\u0026gt; userReducer(currentState, intent) } } } // View class UserView(private val viewModel: UserViewModel) { fun render() { viewModel.state.collect { state -\u0026gt; println(\u0026#34;Name: ${state.name}, Age: ${state.age}\u0026#34;) } } fun sendIntent(intent: UserIntent) { viewModel.processIntent(intent) } } fun main() = runBlocking { val viewModel = UserViewModel() val view = UserView(viewModel) view.sendIntent(UserIntent.LoadUser) view.render() println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; view.sendIntent(UserIntent.UpdateUser(newName)) }   Conclusión Cada arquitectura tiene sus fortalezas y compromisos:\n MVC: Mejor para aplicaciones pequeñas y simples. MVP: Equilibra estructura y simplicidad. MVVM: Ideal para programación reactiva. MVI: Excelente para la gestión de estado predecible y escalable.  Considera la complejidad y los requisitos de tu proyecto al elegir una arquitectura. ¿Cuál prefieres tú?\n","description":"Explorando Arquitecturas de Apps en Kotlin: MVC, MVP, MVVM y MVI","id":39,"section":"posts","tags":["kotlin","architecture"],"title":"Explorando Arquitecturas de Apps en Kotlin","uri":"https://carrion.dev/es/posts/app-architecture/"},{"content":"Explorando Más Patrones de Diseño en Kotlin: Parte 3  Part 1 Part 2 Part 3  En esta tercera entrega, cubriremos los patrones Memento, Command, Visitor, Chain of Responsibility y Mediator. Estos patrones abordan desafíos de construcción, comportamiento y estructura, mostrando la sintaxis expresiva y las características modernas de Kotlin.\n1. Patrón Memento El Patrón Memento captura y restaura el estado de un objeto sin exponer sus detalles internos.\nCuándo Usar  Para implementar funcionalidad de deshacer/rehacer.  Implementación en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  class Editor { var content: String = \u0026#34;\u0026#34; fun createMemento(): Memento = Memento(content) fun restore(memento: Memento) { content = memento.state } data class Memento(val state: String) } class History { private val mementos = mutableListOf\u0026lt;Editor.Memento\u0026gt;() fun save(memento: Editor.Memento) { mementos.add(memento) } fun pop(): Editor.Memento? { if (mementos.isNotEmpty()) { return mementos.removeAt(mementos.lastIndex) } return null } } fun main() { val editor = Editor() val history = History() editor.content = \u0026#34;First Version\u0026#34; history.save(editor.createMemento()) editor.content = \u0026#34;Second Version\u0026#34; history.save(editor.createMemento()) editor.content = \u0026#34;Third Version\u0026#34; println(\u0026#34;Current Content: ${editor.content}\u0026#34;) editor.restore(history.pop()!!) println(\u0026#34;Restored Content: ${editor.content}\u0026#34;) editor.restore(history.pop()!!) println(\u0026#34;Restored Content: ${editor.content}\u0026#34;) }   Por Qué Kotlin? La sintaxis concisa de Kotlin facilita la captura y restauración de estados.\n2. Patrón Command El Patrón Command encapsula una solicitud como un objeto, permitiendo la parametrización y el encolado.\nCuándo Usar  Para implementar operaciones deshacibles o colas de comandos.  Implementación en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  interface Command { fun execute() } class Light { fun on() = println(\u0026#34;Light is ON\u0026#34;) fun off() = println(\u0026#34;Light is OFF\u0026#34;) } class LightOnCommand(private val light: Light) : Command { override fun execute() = light.on() } class LightOffCommand(private val light: Light) : Command { override fun execute() = light.off() } fun main() { val light = Light() val commands = listOf(LightOnCommand(light), LightOffCommand(light)) commands.forEach { it.execute() } }   Por Qué Kotlin? El enfoque funcional de Kotlin puede simplificar aún más la ejecución de comandos.\n3. Patrón Visitor El Patrón Visitor separa un algoritmo de la estructura de objetos sobre la que opera, moviendo el algoritmo a un objeto visitante.\nCuándo Usar  Cuando necesitas realizar operaciones en un conjunto de objetos con tipos variados.  Implementación en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  interface Shape { fun accept(visitor: ShapeVisitor) } class Circle(val radius: Double) : Shape { override fun accept(visitor: ShapeVisitor) { visitor.visit(this) } } class Rectangle(val width: Double, val height: Double) : Shape { override fun accept(visitor: ShapeVisitor) { visitor.visit(this) } } fun interface ShapeVisitor { fun visit(shape: Shape) } fun main() { val shapes: List\u0026lt;Shape\u0026gt; = listOf(Circle(5.0), Rectangle(4.0, 6.0)) val visitor = ShapeVisitor { shape -\u0026gt; when (shape) { is Circle -\u0026gt; println(\u0026#34;Circle with radius ${shape.radius}\u0026#34;) is Rectangle -\u0026gt; println(\u0026#34;Rectangle with width ${shape.width}and height ${shape.height}\u0026#34;) } } shapes.forEach { it.accept(visitor) } }   Por Qué Kotlin? Las fun interface y las clases selladas de Kotlin simplifican la implementación del visitante.\n4. Patrón Chain of Responsibility El Patrón Chain of Responsibility pasa una solicitud a lo largo de una cadena de manejadores hasta que uno la procesa.\nCuándo Usar  Cuando múltiples objetos pueden manejar una solicitud y el handler se determina en tiempo de ejecución.  Implementación en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  interface Handler { fun handle(request: String): Boolean } class AuthHandler(private val next: Handler?) : Handler { override fun handle(request: String): Boolean { println(\u0026#34;AuthHandler processing...\u0026#34;) return next?.handle(request) ?: true } } class LoggingHandler(private val next: Handler?) : Handler { override fun handle(request: String): Boolean { println(\u0026#34;LoggingHandler processing...\u0026#34;) return next?.handle(request) ?: true } } fun main() { val chain = AuthHandler(LoggingHandler(null)) chain.handle(\u0026#34;Request\u0026#34;) }   Por Qué Kotlin? Los tipos nulos de Kotlin y su delegación concisa simplifican el encadenamiento de handlers.\n5. Patrón Mediator El Patrón Mediator centraliza la comunicación compleja entre múltiples objetos haciendo que se comuniquen a través de un mediador.\nCuándo Usar  Cuando los objetos interactúan de manera compleja, lo que lleva a dependencias enredadas.  Implementación en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class Mediator { private val colleagues = mutableListOf\u0026lt;Colleague\u0026gt;() fun addColleague(colleague: Colleague) { colleagues.add(colleague) } fun broadcast(sender: Colleague, message: String) { colleagues.filter { it != sender } .forEach { it.receive(message) } } } interface Colleague { fun send(message: String) fun receive(message: String) } class ConcreteColleague(private val mediator: Mediator) : Colleague { override fun send(message: String) { println(\u0026#34;Sending message: $message\u0026#34;) mediator.broadcast(this, message) } override fun receive(message: String) { println(\u0026#34;Received message: $message\u0026#34;) } } fun main() { val mediator = Mediator() val colleague1 = ConcreteColleague(mediator) val colleague2 = ConcreteColleague(mediator) mediator.addColleague(colleague1) mediator.addColleague(colleague2) colleague1.send(\u0026#34;Hello from Colleague 1\u0026#34;) }   Por Qué Kotlin? Las funciones de primera clase y las colecciones de Kotlin simplifican la difusión y la interacción.\nConclusión Estos patrones—Memento, Command, Visitor, Chain of Responsibility y Mediator—demuestran la capacidad de Kotlin para mejorar patrones de diseño clásicos con características modernas.\n¿Cuál de estos patrones encuentras más interesante? ¡Házmelo saber! 🚀\n","description":"Kotlin Design Patterns - Part 3","id":40,"section":"posts","tags":["kotlin","design-patterns","architecture"],"title":"Kotlin Design Patterns - Part 3","uri":"https://carrion.dev/es/posts/design-patterns-3/"},{"content":"Entendiendo los principios SOLID con ejemplos en Kotlin Los principios SOLID son un conjunto de principios de diseño que hacen que los diseños de software sean más comprensibles, flexibles y mantenibles. Introducidos por Robert C. Martin, estos principios son una piedra angular de la programación orientada a objetos y son especialmente relevantes al construir sistemas complejos. En este blog, exploraremos cada principio con ejemplos escritos en Kotlin, un lenguaje que ofrece una sintaxis moderna y características poderosas.\n1. Principio de Responsabilidad Única (SRP) Una clase debe tener una, y solo una, razón para cambiar.\nEste principio asegura que una clase tenga una única responsabilidad, lo que la hace más fácil de mantener y menos propensa a errores.\nRompiendo SRP:\n1 2 3 4 5 6 7 8 9 10 11  class ReportManager { fun generateReport(data: String): String { // Lógica para generar reporte  return \u0026#34;Report: $data\u0026#34; } fun saveReport(report: String) { // Lógica para guardar reporte  println(\u0026#34;Report saved: $report\u0026#34;) } }   En este ejemplo, la clase ReportManager viola el SRP porque tiene dos responsabilidades: generar y guardar reportes. Cualquier cambio en la lógica de generación o de guardado requeriría modificar la misma clase.\nCorrigiendo SRP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class ReportGenerator { fun generateReport(data: String): String { // Lógica para generar reporte  return \u0026#34;Report: $data\u0026#34; } } class ReportSaver { fun saveReport(report: String) { // Lógica para guardar reporte  println(\u0026#34;Report saved: $report\u0026#34;) } } fun main() { val generator = ReportGenerator() val saver = ReportSaver() val report = generator.generateReport(\u0026#34;Sales Data\u0026#34;) saver.saveReport(report) }   Separando responsabilidades, hacemos que cada clase esté enfocada y sea más fácil de probar de manera independiente.\n2. Principio Abierto/Cerrado (OCP) Las entidades de software deben estar abiertas para extensión, pero cerradas para modificación.\nPuedes añadir nueva funcionalidad extendiendo clases sin cambiar el código existente.\nRompiendo OCP:\n1 2 3 4 5 6 7 8 9  class Discount { fun calculate(price: Double, type: String): Double { return when (type) { \u0026#34;none\u0026#34; -\u0026gt; price \u0026#34;percentage\u0026#34; -\u0026gt; price * 0.9 else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unknown discount type\u0026#34;) } } }   Aquí, añadir un nuevo tipo de descuento requiere modificar el método calculate, lo que viola el OCP.\nCorrigiendo OCP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  interface DiscountStrategy { fun calculate(price: Double): Double } class NoDiscount : DiscountStrategy { override fun calculate(price: Double): Double = price } class PercentageDiscount(private val percentage: Double) : DiscountStrategy { override fun calculate(price: Double): Double = price * (1 - percentage / 100) } class DiscountCalculator(private val strategy: DiscountStrategy) { fun calculate(price: Double): Double = strategy.calculate(price) } fun main() { val noDiscount = DiscountCalculator(NoDiscount()) println(\u0026#34;Price after no discount: ${noDiscount.calculate(100.0)}\u0026#34;) val percentageDiscount = DiscountCalculator(PercentageDiscount(10.0)) println(\u0026#34;Price after 10% discount: ${percentageDiscount.calculate(100.0)}\u0026#34;) }   Usando interfaces y composición, logramos un diseño que está abierto a la extensión (nuevas estrategias de descuento) y cerrado a la modificación (sin cambios en las clases existentes).\n3. Principio de Sustitución de Liskov (LSP) Los objetos de una superclase deben poder ser reemplazados con objetos de una subclase sin afectar la corrección del programa.\nEste principio asegura que las clases derivadas respeten las expectativas establecidas por su clase base.\nRompiendo LSP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  open class Bird { open fun fly() { println(\u0026#34;Flying\u0026#34;) } } class Sparrow : Bird() class Penguin : Bird() { override fun fly() { throw UnsupportedOperationException(\u0026#34;Penguins can\u0026#39;t fly\u0026#34;) } } fun main() { val birds: List\u0026lt;Bird\u0026gt; = listOf(Sparrow(), Penguin()) for (bird in birds) { bird.fly() // Esto fallará para Penguin  } }   En este ejemplo, Penguin viola LSP porque no puede cumplir el contrato de Bird. Una mejor aproximación es refactorizar el diseño:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  interface Flyable { fun fly() } class Sparrow : Flyable { override fun fly() { println(\u0026#34;Flying\u0026#34;) } } class Penguin { fun swim() { println(\u0026#34;Swimming\u0026#34;) } }   Ahora, los comportamientos están segregados, y se respeta el LSP.\n4. Principio de Segregación de Interfaces (ISP) Los clientes no deberían estar obligados a depender de métodos que no utilizan.\nEste principio promueve la creación de interfaces específicas en lugar de una única interfaz inflada.\nRompiendo ISP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Machine { fun print() fun scan() fun fax() } class OldPrinter : Machine { override fun print() { println(\u0026#34;Printing\u0026#34;) } override fun scan() { throw UnsupportedOperationException(\u0026#34;Scan not supported\u0026#34;) } override fun fax() { throw UnsupportedOperationException(\u0026#34;Fax not supported\u0026#34;) } }   Esta implementación fuerza a OldPrinter a implementar métodos que no soporta, violando ISP.\nCorrigiendo ISP:\n1 2 3 4 5 6 7 8 9 10 11 12 13  interface Printer { fun print() } interface Scanner { fun scan() } class SimplePrinter : Printer { override fun print() { println(\u0026#34;Printing\u0026#34;) } }   Dividiendo las funcionalidades en interfaces separadas, permitimos que los dispositivos implementen solo lo que necesitan.\n5. Principio de Inversión de Dependencias (DIP) Los módulos de alto nivel no deben depender de módulos de bajo nivel. Ambos deben depender de abstracciones.\nEste principio reduce el acoplamiento entre los módulos de alto y bajo nivel al introducir abstracciones.\nRompiendo DIP:\n1 2 3 4 5 6 7 8 9 10 11 12 13  class EmailService { fun sendEmail(message: String) { println(\u0026#34;Sending Email: $message\u0026#34;) } } class NotificationSender { private val emailService = EmailService() fun notifyUser(message: String) { emailService.sendEmail(message) } }   Aquí, NotificationSender está fuertemente acoplado a EmailService, lo que dificulta cambiar a un servicio de notificación diferente.\nCorrigiendo DIP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  interface NotificationService { fun sendNotification(message: String) } class EmailService : NotificationService { override fun sendNotification(message: String) { println(\u0026#34;Sending Email: $message\u0026#34;) } } class SMSService : NotificationService { override fun sendNotification(message: String) { println(\u0026#34;Sending SMS: $message\u0026#34;) } } class NotificationSender(private val service: NotificationService) { fun notifyUser(message: String) { service.sendNotification(message) } } fun main() { val emailSender = NotificationSender(EmailService()) emailSender.notifyUser(\u0026#34;Hello via Email\u0026#34;) val smsSender = NotificationSender(SMSService()) smsSender.notifyUser(\u0026#34;Hello via SMS\u0026#34;) }   Aquí, NotificationSender depende de la abstracción NotificationService, haciéndolo flexible para trabajar con cualquier tipo de notificación.\nConclusión Los principios SOLID forman la base para construir software robusto y escalable. Kotlin, con su sintaxis expresiva y características modernas, permite a los desarrolladores implementar estos principios de manera elegante. Al adherirse a estos principios, puedes crear código que sea más fácil de mantener, extender y adaptar a los cambios en los requisitos.\n","description":"Principios SOLID explicados con ejemplos de Kotlin.","id":41,"section":"posts","tags":["kotlin","solid","architecture"],"title":"Entendiendo los principios SOLID con ejemplos en Kotlin","uri":"https://carrion.dev/es/posts/solid-kotlin/"},{"content":"Explorando patrones de diseño en Kotlin: Parte2 Design Patterns Series  Part 1 Part 2 Part 3  Después de la gran acogida del primer artículo Patrones de diseño en Kotlin, volvemos con más! En esta segunda parte, revisaremos los patrones de Prototype, Composite, Proxy, Observer, y Strategy. Estos patrones resuelven una variedad de desafios de diseño y demuestran las capacidades expresivas de Kotlin.\n1. Patrón Prototype El Patrón Prototype es usado para crear nuevos objeto copiando una objeto existente, asegurando la creación eficaz de objetos.\nCuando usarlo  Cuando crear una nueva instancia es complejo o costoso. Para evitar crear instancias de subclases de forma repetida.  Implementación en Kotlin Usar las clases data de Kotlin y su función copy simplifica este patrón.\n1 2 3 4 5 6 7 8 9  data class Document(var title: String, var content: String, var author: String) fun main() { val original = Document(\u0026#34;Design Patterns\u0026#34;, \u0026#34;Content about patterns\u0026#34;, \u0026#34;John Doe\u0026#34;) val copy = original.copy(title = \u0026#34;Prototype Pattern\u0026#34;) println(\u0026#34;Original: $original\u0026#34;) println(\u0026#34;Copy: $copy\u0026#34;) }   Por qué Kotlin? Las clases data de Kotlin soportan de forma nativa copiar los objetos con código mínimo, haciendo que aplicar el patrón Prototype sea muy sencillo.\n2. Patrón Composite El Patrón Composite es usado para tratar objetos individuales y grupos de forma uniforme.\nCuando usarlo  Cuando tienes una estructura en árbol y quieres manipularlo de una forma consistente.  Implementación en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  interface Logger { fun log(message: String) } class ConsoleLogger : Logger { override fun log(message: String) { println(message) } } class FileLogger(private val filePath: String) : Logger { override fun log(message: String) { // Implementation for writing logs to a file  } } class RootLogger(private val loggers: List\u0026lt;Logger\u0026gt;) : Logger { override fun log(message: String) { loggers.forEach { it.log(message) } } } fun main() { val consoleLogger = ConsoleLogger() val fileLogger = FileLogger(\u0026#34;/path/to/log.txt\u0026#34;) val rootLogger = RootLogger(listOf(consoleLogger, fileLogger)) rootLogger.log(\u0026#34;Composite Pattern Example\u0026#34;) }   3. Patrón Proxy El Patrón Proxy sirve de puerta de entrada para controlar el acceso a otro objeto.\nCuando utilizarlo  Para controlar el acceso a otro recurso. Para añadir funcionalidad sin modificar el objeto existente.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Service { fun fetchData(): String } class RealService : Service { override fun fetchData() = \u0026#34;Data from Real Service\u0026#34; } class ProxyService(private val realService: RealService) : Service { override fun fetchData(): String { println(\u0026#34;Proxy: Checking access before delegating.\u0026#34;) return realService.fetchData() } } fun main() { val proxy = ProxyService(RealService()) println(proxy.fetchData()) }   4. Patrón Observer El Patrón Observer define una dependencia de uno-a-muchos, por lo que cuando un objeto cambia su estado, todos los que dependen de el son notificados.\nCuando utilizarlo  Para sistemas dirigidos por eventos. Cuando múltiples componentes necesitan reaccionar a cambios de estado.  Implementación en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  fun interface StateChangeListener { fun onStateChanged(oldState: String, newState: String) } class Subject { private val listeners = mutableListOf\u0026lt;StateChangeListener\u0026gt;() var state: String by Delegates.observable(\u0026#34;Initial State\u0026#34;) { _, old, new -\u0026gt; listeners.forEach { it.onStateChanged(old, new) } } fun addListener(listener: StateChangeListener) { listeners.add(listener) } } fun main() { val subject = Subject() subject.addListener { oldState, newState -\u0026gt; println(\u0026#34;Listener 1: State changed from \u0026#39;$oldState\u0026#39; to \u0026#39;$newState\u0026#39;\u0026#34;) } subject.addListener { oldState, newState -\u0026gt; println(\u0026#34;Listener 2: State changed from \u0026#39;$oldState\u0026#39; to \u0026#39;$newState\u0026#39;\u0026#34;) } subject.state = \u0026#34;State 1\u0026#34; subject.state = \u0026#34;State 2\u0026#34; }   Por qué Kotlin? Usar fun interface simplifica la implementación de interfaces con un sólo método. De forma adicional, los Delegates.observable de Kotlin hace que observar cambios de estado sea más directo, facilitando la implementación del patrón Observer.\n5. Patrón Strategy El Patrón Strategy define una seria de algoritmos, encapsula cada uno de ellos, y luego los hace intercambiables.\nCuando utilizar  Cuando necesitas vaerios algoritmos para una tarea en concreto.  Implementación en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  interface PaymentStrategy { fun pay(amount: Double) } class CreditCardPayment : PaymentStrategy { override fun pay(amount: Double) = println(\u0026#34;Paid $$amountusing Credit Card.\u0026#34;) } class PayPalPayment : PaymentStrategy { override fun pay(amount: Double) = println(\u0026#34;Paid $$amountusing PayPal.\u0026#34;) } class PaymentContext(private var strategy: PaymentStrategy) { fun setStrategy(strategy: PaymentStrategy) { this.strategy = strategy } fun executePayment(amount: Double) = strategy.pay(amount) } fun main() { val context = PaymentContext(CreditCardPayment()) context.executePayment(100.0) context.setStrategy(PayPalPayment()) context.executePayment(200.0) }   Conclusión Con Kotlin, los patrones de diseño como Prototype, Composite, Proxy, Observer, y Strategy se vuelven más intuitivos. Estos patrones no son solo herramientas, son los fundamentos para un código más claro y mantenible.\n","description":"Kotlin Patrones de diseño - Parte 2","id":42,"section":"posts","tags":["kotlin","design-patterns","architecture"],"title":"Patrones de diseño en Kotlin - Parte 2","uri":"https://carrion.dev/es/posts/design-patterns-2/"},{"content":"Usando Koin en Compose Multiplatform La inyección de dependencias es algo imprescindible para crear aplicaciones escalables, y Koin hace que sea muy sencillo, incluso en proyectos con Compose Multiplatform. Con la nueva función composable KoinApplication, puedes inicializar Koin directamente desde el código común, reduciendo la cantidad de código necesario mientras se mantiene la flexibilidad de configurar cada plataforma por separado. Vamos a ver un ejemplo.\nProject Setup Empieza creando un proyecto de Compose Multiplatform usando el KMP Wizard, seleccionando Android, iOS, Desktop y Web como plataformas. Para este ejemplo no vamos a incluir Server como plataforma.\nAñadiendo las dependencias Usa el version catalog de Gradle para incluir las dependencias necesarias de Koin en libs.versions.toml:\n1 2 3 4 5 6 7 8 9  [versions] koin-bom = \u0026#34;4.1.0-Beta1\u0026#34; [libraries] koin-bom = { module = \u0026#34;io.insert-koin:koin-bom\u0026#34;, version.ref = \u0026#34;koin-bom\u0026#34; } koin-core = { module = \u0026#34;io.insert-koin:koin-core\u0026#34; } koin-android = { module = \u0026#34;io.insert-koin:koin-android\u0026#34; } koin-compose = { module = \u0026#34;io.insert-koin:koin-compose\u0026#34; } koin-compose-viewModel = { module = \u0026#34;io.insert-koin:koin-compose-viewmodel\u0026#34; }   Definiendo los módulos de Koin Vamos a crear dos módulos de Koin: appModule y platformModule. El platformModule define las dependencias específicas de cada plataforma.\nMódulos compartidos 1 2 3 4 5 6 7 8 9 10 11 12  val appModule = module { viewModelOf(::MainViewModel) factoryOf(::GetJokeUseCase) singleOf(::DefaultJokeRepository) bind JokeRepository::class singleOf(::JokeJsonDataSource) bind JokeDataSource::class single { Json { ignoreUnknownKeys = true } } } val Module.localPreferencesDefinition get() = singleOf(::InMemoryLocalPreferences) bind LocalPreferences::class expect val platformModule: Module   Módulos específicos de cada plataforma Para Android vamos a usar una implementación de la interfaz de LocalPreferences que depende del contexto de Android por lo que necesitamos un módulo distinto al resto de plataformas:\n1 2 3 4  actual val platformModule: Module get() = module { singleOf(::AndroidPreferences) bind LocalPreferences::class }   Para iOS, Desktop y Web, reutilizaremos la localPreferencesDefinition que se puede ver más arriba:\n1 2 3 4  actual val platformModule: Module get() = module { localPreferencesDefinition }   Configurando la App En el archivo App.kt, podemos usar la función composable KoinApplication. Añadiendo el parámetro KoinAppDeclaration como opcional y con valor por defecto a null.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Composable @Preview fun App(koinAppDeclaration: KoinAppDeclaration? = null) { KoinApplication( application = { koinAppDeclaration?.invoke(this) modules(appModule, platformModule) } ) { MaterialTheme { MainScreen() } } }   En Android, usamos la lambda para proveer el contexto y activar el logging:\n1 2 3 4 5 6 7 8 9 10 11  class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { App { androidLogger(Level.DEBUG) androidContext(this@MainActivity) } } } }   Esta flexibilidad nos asegura configuraciones específicas por plataforma, como inyectar el contexto de Android, sin afectar al resto de plataformas.\nCorriendo la App Compila la aplicación en cada plataforma. Podrás probar que todo está funcionando y cada plataforma recibe la configuración que necesita para funcionar.\nConclusión La nueva función composable KoinApplication simplifica la inyección de dependencias en Compose Multiplatform permitiendo inizializar Koin de forma compartida manteniendo la posibilidad de configurar cada plataforma por separado si fuera necesario. Esta forma de proceder reduce el código necesario y promueve la reusabilidad del código entre plataformas.\nPuedes descargar el código completo para este ejemplo en GitHub.\nTambién si necesitas más información acerca de las diferentes opciones para declarar dependencias en Koin puedes visitar un post que publiqué en LinkedIn: Koin DSL\n","description":"Usando Koin en Compose Multiplatform desde el código común con posibilidad de configurar cada una de las plataformas.","id":43,"section":"posts","tags":["kotlin","multiplatform","cmp","compose","koin"],"title":"Usando Koin en Compose Multiplatform","uri":"https://carrion.dev/es/posts/koin-cmp/"},{"content":"Explorando patrones de diseño en Kotlin - Parte 1 Serie Patrones de diseño Design Patterns Series  Part 1 Part 2 Part 3  Los patrones de diseño son soluciones probadas a problemas comunes en el diseño de software. Con la sintaxis y funcionalidades modernas de Kotlin, implementar estos patrones normalmente resulta más limpio y conciso. En este post, exploraremos los patrones de Singleton, Factory Method, Builder, Adapter and Decorator, profundizando en su propósito, casos de uso y implementaciones en Kotlin.\n1. Patrón Singleton El Patrón Singleton asegura que una clase tiene solo una instancia y provee un punto de acceso global a ella.\nCuando utilizar  Al manejar recursos compartidos como conexiones a bases de datos.  Implementación en Kotlin La palabra reservada de Kotlin object provee una forma rápida de crear un Singleton.\n1 2 3 4 5  object DatabaseConnection { fun connect() { println(\u0026#34;Connecting to database...\u0026#34;) } }   Uso 1 2 3  fun main() { DatabaseConnection.connect() }   Ventajas en Kotlin  Por defecto es Thread-safe. Requiere un código mínimo comparado con implementaciones tradicionales en otros lenguajes.  2. Patrón Factory Method El Patrón Factory Method delega la creación de objectos a clases o funciones, lo que provee de flexibilidad a la hora de instanciar los objetos.\nCuando utilizarlo  Cuando crear los objetos requiere de lógica o tiene complejidad. Para desacoplar la creación del objeto del código del cliente.  Implementación en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Shape { fun draw() } class Circle : Shape { override fun draw() = println(\u0026#34;Drawing a Circle\u0026#34;) } class Rectangle : Shape { override fun draw() = println(\u0026#34;Drawing a Rectangle\u0026#34;) } object ShapeFactory { fun createShape(type: String): Shape = when (type) { \u0026#34;Circle\u0026#34; -\u0026gt; Circle() \u0026#34;Rectangle\u0026#34; -\u0026gt; Rectangle() else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unknown shape type\u0026#34;) } }   Uso 1 2 3 4  fun main() { val shape = ShapeFactory.createShape(\u0026#34;Circle\u0026#34;) shape.draw() }   3. Patrón Builder El Patrón Builder es usado para construir objetos complejos paso a paso. Es especialmente útil cuando un objeto tiene muchos parámetros opcionales o configuraciones distintas.\nCuando utilizar  Para evitar constructores con demasiados parámetros. Cuando el proceso de contrucción del objeto es complejo o incluye multiples pasos.  Implementación en Kotlin En Kotlin el uso de apply o las capacidades de DSL simplifican el patrón Builder.\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Car(val make: String, val model: String, val year: Int) { class Builder { private var make = \u0026#34;\u0026#34; private var model = \u0026#34;\u0026#34; private var year = 0 fun make(make: String) = apply { this.make = make } fun model(model: String) = apply { this.model = model } fun year(year: Int) = apply { this.year = year } fun build() = Car(make, model, year) } }   Uso 1 2 3 4 5 6 7 8 9  fun main() { val car = Car.Builder() .make(\u0026#34;Toyota\u0026#34;) .model(\u0026#34;Corolla\u0026#34;) .year(2022) .build() println(\u0026#34;${car.make}${car.model}, ${car.year}\u0026#34;) }   ** Por qué en Kotlin?** Enlazar métodos con apply permite una sintaxis más concisa y expresiva cuando se construye objetos.\n4. Patrón Adapter El Patrón Adapter es usado para hacer de puente entre interfaces que no son compatibles traduciendo una interfaz a la otra.\nCuando utilizar  Cuando se integra nuevo código con código antiguo o librerías externas. Cuando dos sistemas o componentes necesitan trabajar en conjunto pero tienen interfaces incompatibles.  Implementación en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // Existing integer provider interface interface OldProvider { fun provide(): Int } class RandomIntProvider : OldProvider { override fun provide(): Int = (1..100).random() } // Target string provider interface interface NewProvider { fun provide(): String } // Adapter class class OldToNewProviderAdapter(private val intProvider: OldProvider) : NewProvider { override fun provide(): String = \u0026#34;Provided number: ${intProvider.provide()}\u0026#34; }   Uso 1 2 3 4 5 6  fun main() { val intProvider = RandomIntProvider() val stringProvider: NewProvider = OldToNewProviderAdapter(intProvider) println(stringProvider.provideString()) }   Por qué en Kotlin? Los constructores primaries de Kotlin y la sintaxis concisa simplifican la implementación de clases de tipo wrapper.\n5. Patrón Decorator El Patrón Decorator añade dinámicamente comportamientos a los objetos sin alterar su estructura.\nCuando usarlo  Para extender la funcionalidad de una clase en tiempo de ejecución. Cuando heredar llevaría a una jerarquía sobrecargada.  Implementación en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14  interface Coffee { fun cost(): Double fun description(): String } class SimpleCoffee : Coffee { override fun cost() = 5.0 override fun description() = \u0026#34;Simple Coffee\u0026#34; } class MilkDecorator(private val coffee: Coffee) : Coffee { override fun cost() = coffee.cost() + 1.5 override fun description() = coffee.description() + \u0026#34;, Milk\u0026#34; }   Uso 1 2 3 4 5 6  fun main() { val coffee = SimpleCoffee() val coffeeWithMilk = MilkDecorator(coffee) println(\u0026#34;${coffeeWithMilk.description()}costs \\$${coffeeWithMilk.cost()}\u0026#34;) }   Conclusión Las funcionalidades modernas de Kotlin como object, when y apply hacen que implementar los patrones de diseño tradicionales sea más fácil y expresivo. Estos patrones no solo resuelven desafíos comunes de diseño si no que demuestran como Kotlin mejora su implementación.\nHay otros patrones de diseño que te gustaria que cubriera en futuros posts?\n","description":"Kotlin Patrones de diseño - Parte 1","id":44,"section":"posts","tags":["kotlin","design-patterns","architecture"],"title":"Patrones de diseño en Kotlin - Parte 1","uri":"https://carrion.dev/es/posts/design-patterns-1/"},{"content":"Explorando Kotlin Symbol Processing (KSP) con ejemplos prácticos Kotlin Symbol Processing (KSP) es una herramienta muy potente usada para simplificar el procesamiento de anotaciones en Kotlin. Comparado con kapt (Kotlin Annotation Processing Tool), KSP es más rápido, ofrece mejor integración con Kotlin y reduce los tiempos de compilación de forma significativa. En este post, exploraremos los fundamentos de KSP, discutiremos cómo funciona y mostraremos como su uso en librerías populares como Koin y Room.\nQué es KSP? KSP es una API ligera y eficiente para procesar código Kotlin. Permite crear procesadores de anotaciones que funcionan directamente con la sintaxis de Kotlin en lugar de depender de herramientas basadas en Java. Esto lo convierte en una opción ideal para proyectos orientados a Kotlin.\nBeneficios de KSP:  Velocidad: Procesa código Kotlin más rápido que kapt. Diseño centrado en Kotlin: Funciona directamente con los constructos del lenguaje Kotlin, evitando abstracciones basadas en Java. Ligero: Reduce el código repetitivo y se integra perfectamente con Gradle. Compatibilidad: Muchas bibliotecas populares ahora son compatibles con KSP de manera nativa.  Setting Up KSP in Your Project Agrega el plugin de KSP a tu proyecto\nConfiguración de Gradle 1 2 3 4 5 6 7 8 9 10 11 12 13  plugins { kotlin(\u0026#34;jvm\u0026#34;) version \u0026#34;\u0026lt;latest-kotlin-version\u0026gt;\u0026#34; id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;\u0026lt;latest-ksp-version\u0026gt;\u0026#34; } repositories { mavenCentral() } dependencies { implementation(kotlin(\u0026#34;stdlib\u0026#34;)) ksp(\u0026#34;\u0026lt;ksp-processor-library\u0026gt;\u0026#34;) }   Reemplaza \u0026lt;ksp-processor-library\u0026gt; con la dependencia del procesador específico de la biblioteca, como se muestra en los ejemplos a continuación.\nEjemplo 1: KSP con las anotaciones de Koin Koin desde la versión 3.4.0, permite definir dependencias a través de anotaciones, que luego son procesadas usando KSP para generar los módulos de Koin.\nConfiguración de Koin con KSP Añade las siguientes dependencias:\n1 2 3 4 5  dependencies { implementation(\u0026#34;io.insert-koin:koin-core:\u0026lt;version\u0026gt;\u0026#34;) implementation(\u0026#34;io.insert-koin:koin-annotations:\u0026lt;version\u0026gt;\u0026#34;) ksp(\u0026#34;io.insert-koin:koin-ksp-compiler:\u0026lt;version\u0026gt;\u0026#34;) }   Anota las clases Usa las anotaciones de Koin para definir tu grafo de dependencias:\n1 2 3 4 5 6 7 8 9  @Module @ComponentScan class AppModule @Single class UserRepository @Factory class UserUseCase(private val userRepository: UserRepository)   Módulo generado El procesador de KSP genera automáticamente un módulo de Koin. Puedes incluirlo en la configuración de tu aplicación:\n1 2 3 4 5  fun main() { startKoin { modules(AppModuleModule().module) } }   Esto elimina la necesidad de escribir manualmente el módulo de Koin, ahorrando tiempo y reduciendo el código repetitivo.\nExample 2: KSP con base de datos Room Room es un ORM ampliamente utilizado para Android. Con KSP, Room procesa anotaciones más rápidamente, reduciendo significativamente los tiempos de compilación\nConfiguración de Room con KSP Agrega las siguientes dependencias:\n1 2 3 4  dependencies { implementation(\u0026#34;androidx.room:room-runtime:\u0026lt;version\u0026gt;\u0026#34;) ksp(\u0026#34;androidx.room:room-compiler:\u0026lt;version\u0026gt;\u0026#34;) }   Anota las entidades 1 2 3 4 5  @Entity data class User( @PrimaryKey val id: Int, val name: String )   Generar DAO y Base de Datos 1 2 3 4 5 6 7 8 9 10  @Dao interface UserDao { @Query(\u0026#34;SELECT * FROM User\u0026#34;) fun getAllUsers(): List\u0026lt;User\u0026gt; } @Database(entities = [User::class], version = 1) abstract class AppDatabase : RoomDatabase() { abstract fun userDao(): UserDao }   Usando KSP, Room genera el código necesario de forma automática, reduciendo el código repetitivo.\nComo crear un procesador KSP personalizado Construyamos un procesador KSP personalizado que genere una clase Builder para clases de datos anotadas con @GenerateBuilder.\nCrear el módulo Primero, debes crear un módulo con la API para KSP.\n1 2 3  dependencies { implementation(\u0026#34;com.google.devtools.ksp:symbol-processing-api:\u0026lt;version\u0026gt;\u0026#34;) }   Definir la anotación 1 2 3  @Target(AnnotationTarget.CLASS) @Retention(AnnotationRetention.SOURCE) annotation class GenerateBuilder   Lógica del procesador KSP El procesador puede generar dinámicamente una clase Builder basada en las propiedades de la data class con la anotación. Necesitas crear una clase que extienda SymbolProcessor donde todo el trabajo se realizará en la función process, y una clase extendiendo SymbolProcessorProvider, que proveerá de la implementación del SymbolProcessor.\nAquí la implementación de SymbolProcessor:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  class KspBuilderProcessor( private val codeGenerator: CodeGenerator ) : SymbolProcessor { override fun process(resolver: Resolver): List\u0026lt;KSAnnotated\u0026gt; { val symbols = resolver.getSymbolsWithAnnotation(GenerateBuilder::class.qualifiedName.toString()) .filterIsInstance\u0026lt;KSClassDeclaration\u0026gt;() symbols.forEach { symbol -\u0026gt; val className = symbol.simpleName.asString() val packageName = symbol.packageName.asString() val generatedClassName = \u0026#34;${className}Builder\u0026#34; val file = codeGenerator.createNewFile( dependencies = Dependencies(false, symbol.containingFile!!), packageName = packageName, fileName = generatedClassName ) val properties = symbol.getAllProperties() val builderProperties = mutableListOf\u0026lt;String\u0026gt;() val setters = mutableListOf\u0026lt;String\u0026gt;() val buildMethodParams = mutableListOf\u0026lt;String\u0026gt;() properties.forEach { property -\u0026gt; val propName = property.simpleName.asString() val propType = property.type.resolve().declaration.simpleName.asString() .let { if (property.type.resolve().isMarkedNullable) \u0026#34;$it?\u0026#34; else it } val defaultValue = getDefaultValueFromProperty(property) builderProperties.add(\u0026#34; private var $propName: $propType= $defaultValue\u0026#34;) setters.add(\u0026#34; fun set${propName.replaceFirstChar { it.uppercase() }}($propName: $propType) = apply { this.$propName= $propName}\u0026#34;) buildMethodParams.add(\u0026#34; $propName= this.$propName\u0026#34;) } val builderClass = buildString { appendLine(\u0026#34;package $packageName\u0026#34;) appendLine() appendLine(\u0026#34;class $generatedClassName{\u0026#34;) builderProperties.forEach { property -\u0026gt; appendLine(property) } appendLine() setters.forEach { setter -\u0026gt; appendLine(setter) } appendLine() appendLine(\u0026#34; fun build(): $className{\u0026#34;) appendLine(\u0026#34; return $className(\u0026#34;) buildMethodParams.forEach { methodParam -\u0026gt; appendLine(methodParam) } appendLine(\u0026#34; )\u0026#34;) appendLine(\u0026#34; }\u0026#34;) appendLine(\u0026#34;}\u0026#34;) appendLine() appendLine(\u0026#34;fun ${generatedClassName.replaceFirstChar { it.lowercase() }}(block: $generatedClassName.() -\u0026gt; Unit): $className{\u0026#34;) appendLine(\u0026#34; return $generatedClassName().apply(block).build()\u0026#34;) appendLine(\u0026#34;}\u0026#34;) } file.write(builderClass.toByteArray()) file.close() } return symbols.filterNot { it.validate() }.toList() } private fun getDefaultValueFromProperty(property: KSPropertyDeclaration): String { val propType = property.type.resolve().declaration.qualifiedName?.asString() ?: \u0026#34;Any\u0026#34; val isNullable = property.type.resolve().isMarkedNullable return if (isNullable) \u0026#34;null\u0026#34; else when (propType) { \u0026#34;kotlin.String\u0026#34; -\u0026gt; \u0026#34;\\\u0026#34;\\\u0026#34;\u0026#34; \u0026#34;kotlin.Int\u0026#34;, \u0026#34;kotlin.Long\u0026#34;, \u0026#34;kotlin.Short\u0026#34;, \u0026#34;kotlin.Byte\u0026#34; -\u0026gt; \u0026#34;0\u0026#34; \u0026#34;kotlin.Double\u0026#34;, \u0026#34;kotlin.Float\u0026#34; -\u0026gt; \u0026#34;0.0\u0026#34; \u0026#34;kotlin.Boolean\u0026#34; -\u0026gt; \u0026#34;false\u0026#34; else -\u0026gt; throw IllegalArgumentException(\u0026#34;Non-nullable type $propTyperequires a default value\u0026#34;) } } }   Y aquí la clase que extiende de SymbolProcessorProvider:\n1 2 3 4 5  class KspBuilderProvider : SymbolProcessorProvider { override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor { return KspBuilderProcessor(environment.codeGenerator) } }   Con estas dos clases ya solo falta crear un fichero con ruta src/main/resources/META-INF/services y nombre com.google.devtools.ksp.processing.SymbolProcessorProvider. Su contenido será el nombre completo de la clase que extiende de SymbolProcessorProvider que acabas de crear. En este caso quedaría así:\ncom.example.kspbuilder.KspBuilderProvider Usando el procesador KSP personalizado Agregar el procesador personalizado Añade el plugin KSP al fichero build.gradle.kts en el módulo donde quieres utilizar la anotación:\n1 2 3 4 5 6 7 8  plugins { id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;\u0026lt;version\u0026gt;\u0026#34; } dependencies { implementation(project(\u0026#34;:KspBuilder\u0026#34;)) ksp(project(\u0026#34;:KspBuilder\u0026#34;)) }   Anotar la clase Crea una data class con la anotación:\n1 2 3 4 5  @GenerateBuilder class Person(val id: Int, val name: String, val age: Int, val address: Address?) @GenerateBuilder class Address(val id: Int, val name: String, val country: String)   Código generado Después de compilar el proyecto, el código generado con KSP se localiza en el directorio build/generated/ksp.\nPara la data class Person, la clase builder generada se ve así:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class PersonBuilder { private var id: Int = 0 private var name: String = \u0026#34;\u0026#34; private var age: Int = 0 private var address: Address? = null fun setId(id: Int) = apply { this.id = id } fun setName(name: String) = apply { this.name = name } fun setAge(age: Int) = apply { this.age = age } fun setAddress(address: Address?) = apply { this.address = address } fun build(): Person { return Person( id = this.id, name = this.name, age = this.age, address = this.address ) } } fun personBuilder(block: PersonBuilder.() -\u0026gt; Unit): Person { return PersonBuilder().apply(block).build() }   Para la data class Address, la clase builder generada sería así:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class AddressBuilder { private var id: Int = 0 private var name: String = \u0026#34;\u0026#34; private var country: String = \u0026#34;\u0026#34; fun setId(id: Int) = apply { this.id = id } fun setName(name: String) = apply { this.name = name } fun setCountry(country: String) = apply { this.country = country } fun build(): Address { return Address( id = this.id, name = this.name, country = this.country ) } } fun addressBuilder(block: AddressBuilder.() -\u0026gt; Unit): Address { return AddressBuilder().apply(block).build() }   Ejemplo de uso 1 2 3 4 5 6 7 8 9 10 11 12  val person = personBuilder { setId(10) setName(\u0026#34;Test\u0026#34;) setAge(100) setAddress( addressBuilder { setId(10) setName(\u0026#34;AddressTest\u0026#34;) setCountry(\u0026#34;Spain\u0026#34;) } ) }   Conclusión KSp es una herramienta muy importante para los desarrolladores Kotlin. Su diseño ligero y centrado en Kotlin hace que sea un reemplazo perfecto de kapt, su habilidad para generar código dinámicamente abre un gran abanico de posibilidades. Tanto si usas KSP con librerías como Koin y Room o creas tu propio procesador para tu caso de uso, KSP brinda las herramientas necesarias para elevar tu desarrollo al siguiente nivel.\nIntenta integrar KSP en tu próximo proyecto y observa los beneficios de primera mano!\nAquí dejo el repositorio con el código utilizado para crear el procesador KSP personalizado Github Repo\n","description":"Kotlin Avanzado - Kotlin Symbol Processing (KSP)","id":45,"section":"posts","tags":["kotlin","android","advanced"],"title":"Explorando Kotlin KSP","uri":"https://carrion.dev/es/posts/kotlin-ksp/"},{"content":"Explorando las funciones Infix en Kotlin Kotlin, es un lenguaje de programación moderno con funcionalidades que permiten escribir un código más expresivo y conciso. Una de estas funcionalidades son las infix functions, que permiten escribir código más limpio y legible. En este post, exploraremos que son las funciones infix, como usarlas y algunos ejemplo prácticos.\nQué son las funciones Infix? Las funciones infix en Kotlin son un tipo especial de función que pueden ser llamadas sin el uso de paréntesis o el punto. Esto puede hacer que ciertos patrones de código se lean de forma más natural, asemejándose a la sintaxis tradicional relacionada con matemáticas o DSL.\nEste sería un ejemplo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Point(val x: Int, val y: Int) { infix fun moveBy(offset: Point): Point { return Point(this.x + offset.x, this.y + offset.y) } } fun main() { val point1 = Point(2, 3) val offset = Point(1, 1) // Using the infix notation  val newPoint = point1 moveBy offset println(\u0026#34;New Point: (\\${newPoint.x}, \\${newPoint.y})\u0026#34;) }   En este ejemplo, la función moveBy se llama usando la notación infix, mejorando la legibilidad.\nReglas y sintaxis Aquí estan unos puntos clave acerca de las funciones infix:\n Solo un parámetro: La función debe recibir exáctamente un parámetro. Miembros de clase o funciones de extensión: Debe estar definida como una función de clase o una función de extensión. No Varargs or argumentos por defecto: El parámetro no puede tener valores por defecto o ser un vararg.  Ejemplo con una función de extensión:\n1 2 3 4 5 6 7 8  infix fun String.concatWith(other: String): String { return this + other } fun main() { val result = \u0026#34;Hello\u0026#34; concatWith \u0026#34; World\u0026#34; println(result) // Outputs: Hello World }   Casos de uso prácticos Las funciones infix son comunmente utilizadas en Kotlin para hacer el código más conciso y legible. Brillan en escenarios donde las operaciones intuitivas son necesarias, como cuando se trabaja con colecciones, rangos o expresiones de frameworks de testing o de inyección de dependencias. Abajo de estas líneas hay algunos ejemplos de como las funciones infix pueden simplificar el código que escribimos diariamente:\n  Mapeando claves con valores: La función to en la librería estandar de Kotlin es una función infix que ayuda a crear pares, normalmente se usan en los mapas.\n1 2 3 4  fun main() { val map = mapOf(\u0026#34;key1\u0026#34; to \u0026#34;value1\u0026#34;, \u0026#34;key2\u0026#34; to 42) println(map) // Outputs: {key1=value1, key2=42} }     Definiendo rangos: La función until es una función infix que se usa para definir rangos donde se excluye el límite superior.\n1 2 3 4 5  fun main() { for (i in 1 until 5) { println(i) // Outputs: 1, 2, 3, 4  } }     Definiendo el comportamiento de mocks: Librerías tales como MockK usan funciones infix para crear configuraciones de test más expresivas y legibles.\n1 2 3 4 5 6 7 8 9 10  class Calculator { fun add(a: Int, b: Int): Int = a + b } fun test() { val calculator = mockk\u0026lt;Calculator\u0026gt;() every { calculator.add(1, 2) } returns 3 println(calculator.add(1, 2)) // Outputs: 3 }     Inyección de dependencias con Koin: Koin, un framework de inyección de dependencias para Kotlin, usa la función infix bind para definir las relaciones entre clases e interfaces de una manera más legible y limpia.\n1 2 3 4 5 6  interface MyInterface class MyImplementation : MyInterface val appModule = module { single { MyImplementation() } bind MyInterface::class }   La función infix bind mejora la legibilidad cuando declaras que implementación específica debe usarse para inyectar una interfaz.\n  Cuando usar funciones Infix Mientras las funciones infix pueden hacer el código más limpio, deben usarse con cuidado:\n La operación es intuitiva y fácilmente entendible. Cuando mejoran la legibilidad y el flujo. Encajan naturalmente dentro del DSL.  Evitar las funciones infix en los siguientes casos:\n Puede llevar a una sintaxis ambigua y confusa. El propósito de la función no está claro con el nombre o uso.  Conclusión Las funciones infix de Kotlin son una herramienta poderosa para crear código más expresivo y legible. Definiendo un DSL, simplificando operaciones matemáticas, o mejorando expresiones lógicas, las funciones infix pueden hacer tu código más eleganto. De todas formas, al igual que con cualquier otra funcionalidad, debe ser usadas con cuidado para mantener la claridad del código y evitar sobrecomplicaciones.\nIntenta incorporar funciones infix en tu próximo proyecto de Kotlin y fíjate como transforma tu código! ¿Cuales son tus funciones infix favoritas o que formas creativas tienes de usarlas?\n","description":"Kotlin avanzado - Funciones Infix","id":46,"section":"posts","tags":["kotlin","android","advanced"],"title":"Funciones Infix en Kotlin","uri":"https://carrion.dev/es/posts/kotlin-infix/"},{"content":"✨ Entendiendo los Kotlin Delegates: La magia detrás de código más limpio ✨ Los Kotlin delegates son una funcionalidad muy útil que te permite delegar el comportamiento de una propiedad o incluso una implementación de una interfaz a otro objecto. En lugar de escribir lógica repetitiva o manejar el estado directamente, puedes delegar esta responsabilidad a clases especializadas y reusables.\nComo funcionan los Delegates Delegates en Kotlin funcionan usando la palabra reservada by, que redirecciona el comportamiento de una propiedad o interfaz al objeto delegado. Para propiedades, el objeto delegado provee una implementación personalizada de los métodos get y o set. Para la delegación de interfaces, la implementación de esa interfaz es delegada al objecto.\nEsto es un ejemplo de una propiedad delegada:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class StringDelegate { private var value: String = \u0026#34;\u0026#34; operator fun getValue(thisRef: Any?, property: kotlin.reflect.KProperty\u0026lt;*\u0026gt;): String { println(\u0026#34;Getting value for \\${property.name}\u0026#34;) return value } operator fun setValue(thisRef: Any?, property: kotlin.reflect.KProperty\u0026lt;*\u0026gt;, newValue: String) { println(\u0026#34;Setting value for \\${property.name} to \\$newValue\u0026#34;) value = newValue } } class Example { var text: String by StringDelegate() } fun main() { val example = Example() example.text = \u0026#34;Hello, Kotlin!\u0026#34; println(example.text) }   Output Setting value for text to Hello, Kotlin! Getting value for text Hello, Kotlin! En este ejemplo:\n La clase StringDelegate define un comportamiento personalizado del acceso a la propiedad usando los operadores getValuey setValue. La propiedad text en la clase Exampledelega su comportamiento a la instancia de StringDelegate.  Aplicaciones reales de Kotlin Delegates 1️⃣ Inyección de dependencias con Koin En #Koin, puedes usar el delegado by inject() para inyectar dependencias directamente en tus clases. Esto elimina la necesidad de instanciar manualmente:\n1 2 3 4 5 6 7 8 9 10  class DelegatesFragment : Fragment() { private val tracker: AnalyticsTracker by inject() } inline fun \u0026lt;reified T : Any\u0026gt; KoinComponent.inject( qualifier: Qualifier? = null, mode: LazyThreadSafetyMode = KoinPlatformTools.defaultLazyMode(), noinline parameters: ParametersDefinition? = null, ): Lazy\u0026lt;T\u0026gt; = lazy(mode) { get\u0026lt;T\u0026gt;(qualifier, parameters) }   El delegado by inject() automáticamente resuelve la dependencia usando el contenedor de Koin. Esto abstrae la lógica, resultando en código más limpio y testeable.\n2️⃣ Manejo de estados en Jetpack Compose En Jetpack Compose, la función remember junto con mutableStateOf es un gran ejemplo de delegación. Esto ayuda a manejar el estado de forma eficiente dentro de los composables:\n1 2 3 4 5 6 7 8 9 10 11  @Composable fun Counter() { var count by remember { mutableStateOf(0) } Column { Text(\u0026#34;Count: $count\u0026#34;) Button(onClick = { count++ }) { Text(\u0026#34;Increment\u0026#34;) } } }   3️⃣ Inicialización Lazy El delegado lazy es perfecto para propiedades que necesitan ser inicializadas solo cuando se acceden por primera vez:\n1 2 3 4 5 6 7 8 9  val greeting: String by lazy { println(\u0026#34;Initializing...\u0026#34;) \u0026#34;Hello, Kotlin!\u0026#34; } fun main() { println(greeting) // Initializes here  println(greeting) // Uses cached value }   Output Initializing... Hello, Kotlin! Hello, Kotlin! 4️⃣ Delegación de interfaces Kotlin permite delegar la implementación de una interfaz a otro objeto.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  interface Logger { fun log(message: String) } class ConsoleLogger : Logger { override fun log(message: String) { println(\u0026#34;Log: $message\u0026#34;) } } class FileLogger : Logger { override fun log(message: String) { println(\u0026#34;Writing log to file: $message\u0026#34;) } } class Application(logger: Logger) : Logger by logger fun main() { val consoleApp = Application(ConsoleLogger()) consoleApp.log(\u0026#34;Starting console application\u0026#34;) val fileApp = Application(FileLogger()) fileApp.log(\u0026#34;Starting file application\u0026#34;) }   Output Log: Starting console application Writing log to file: Starting file application Esto es lo que está pasando:\n La clase Application no tiene que implementar los métodos Logger de forma directa. En su lugar, delega la implementación de Logger al objeto pasado por constructor usando by. Esto hace más sencillo cambiar las implementaciones sin necesidad de cambiar la clase Application.  Por qué usar Kotlin Delegates? Los Delegates encapsulan la lógica que de otra manera cargarían y desordenarían tus clases. Ayudan a:\n Simplificar el código al reutilizar lógica, por ejemplo con la inicialización lazy. Abstraen patrones repetitivos, por ejemplo con la inyección de dependencias con #koin. Mejoran el manejo de los estados con la función mutableStateOf de Compose. Provee implementaciones modulares y reutilizables de interfaces.  Conclusion El mecanismo de los delegados en Kotlin es un ejemplo de como este lenguaje combina simplicidad con funcionalidad. Los delegados están en todas partes en el desarrollo de Kotlin. En qué otros casos los utilizas en tus proyectos?\n","description":"Kotlin avanzado - Delegates","id":47,"section":"posts","tags":["kotlin","android","advanced"],"title":"Kotlin Delegates","uri":"https://carrion.dev/es/posts/kotlin-delegates/"},{"content":"Kotlin Avanzado - Contracts: Cómo volver al compilador de Kotlin más inteligente Kotlin nunca deja de impresionarme con sus funcionalidades. Una función avanzada pero poco utilizada en el arsenal de Kotlin son los Contracts. Los contratos te permiten guiar al compilador de Kotlin para que tome mejores decisiones acerca de tu código, resultando en mejor seguridad ante nulos, mejor rendimiento o incluso menores errores en tiempo de ejecución.\nQué son los contratos de Kotlin? Los contratos de Kotlin te permiten definir reglas acerca de como se comporta tu código, ayudando al compilador a hacer un análisis estático más avanzado. Los contratos habilitan funcionalidades como smart-casts y comprobaciones teniendo en cuenta el contexto, superando las capacidades básicas de Kotlin.\nPor qué usar contratos?  Mejora la seguridad ante nulos: Elimina las comprobaciones de nulos redundantes ayudando al compilador a saber cuando algo está garantizado que no sea nulo. Smart-casts optimizados: Hace que el compilador conozca el tipo de las variables en casos específicos. Reduce la repeticón de código: Escribe código más limpio e intuitivo delegando las comprobaciones repetitivas al compilador.  Ejemplos de contratos en Kotlin 1. Simplificar las comprobaciones de nuloss Vamos a crear una función para validar valores no nulos:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @OptIn(ExperimentalContracts::class) inline fun \u0026lt;T\u0026gt; requireNotNull(value: T?, message: String): T { contract { returns() implies (value != null) } if (value == null) { throw IllegalArgumentException(message) } return value } fun processName(name: String?) { val nonNullName = requireNotNull(name, \u0026#34;Name cannot be null\u0026#34;) // No need for additional null checks; compiler knows \u0026#39;nonNullName\u0026#39; is not null!  println(\u0026#34;Processing name: $nonNullName\u0026#34;) } fun main() { processName(\u0026#34;John\u0026#34;) // Works fine  // processName(null) // Throws an IllegalArgumentException }   Cómo los contratos nos ayudan aquí?  La parte del contrato returns() implies (value != null) le dice al compilador:  Si la función retorna de forma satisfactoria, entonces value está garantizado que no es nulo.\n  Esto habilita smart-casts, de manera que no tienes que volver a comprobar si es nulo manualmente una vez llamada esta función.  Algo muy similar se hace en las funciones require y requireNotNull de la librería estandar de Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  /** * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false. * * @sample samples.misc.Preconditions.failRequireWithLazyMessage */ @kotlin.internal.InlineOnly public inline fun require(value: Boolean, lazyMessage: () -\u0026gt; Any): Unit { contract { returns() implies value } if (!value) { val message = lazyMessage() throw IllegalArgumentException(message.toString()) } } /** * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise * returns the not null value. * * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage */ @kotlin.internal.InlineOnly public inline fun \u0026lt;T : Any\u0026gt; requireNotNull(value: T?, lazyMessage: () -\u0026gt; Any): T { contract { returns() implies (value != null) } if (value == null) { val message = lazyMessage() throw IllegalArgumentException(message.toString()) } else { return value } }   2. Afirmaciones personalizadas Aquí se ve como los contratos pueden ser usados para definir afirmaciones personalizadas:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @OptIn(ExperimentalContracts::class) fun assertValidState(condition: Boolean, message: String) { contract { returns() implies condition } if (!condition) { throw IllegalStateException(message) } } fun performOperation(state: Boolean) { val state: Any? = \u0026#34;Hello\u0026#34; assertValidState(state is String, \u0026#34;Is String\u0026#34;) // Here the compiler knows that the state val is of type String so no need to other cast checks  println(\u0026#34;String length: ${assertion.length}\u0026#34;) } fun main() { performOperation(true) // Prints success  // performOperation(false) // Throws IllegalStateException }   3. Smart-Casts con condiciones personalizadas Vamos a crear una funcionalidad custom que comprueba si una valor coincide con un tipo específico. Esto demostrará como los contratos pueden ayudar a mejorar las comprobaciones:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  @OptIn(ExperimentalContracts::class) inline fun \u0026lt;reified T\u0026gt; isOfType(value: Any?): Boolean { contract { returns(true) implies (value is T) } return value is T } fun main() { val input: Any? = \u0026#34;Hello, Kotlin!\u0026#34; if (isOfType\u0026lt;String\u0026gt;(input)) { println(\u0026#34;String length: ${input.length}\u0026#34;) } val inputInt: Any? = 10 if (isOfType\u0026lt;Int\u0026gt;(inputInt)) { println(\u0026#34;The value is an integer ${input.toUInt()}\u0026#34;) } }   Con esta implementación, el compilador sabe que dentro del bloque if, input es un String, gracias al contrato definido en isOfType. The la misma manera, el compilador sabe que inputInt es de tipo Int y no hace falta comprobar el tipo de nuevo.\n4. Optimizando el control del flujo Los contratos pueden simplificar el control del flujo habilitando al compilador para entender las invariantes o condiciones. Por ejemplo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  inline fun isNotEmpty(list: List\u0026lt;*\u0026gt;?): Boolean { contract { returns(true) implies (list != null \u0026amp;\u0026amp; list.isNotEmpty()) } return list != null \u0026amp;\u0026amp; list.isNotEmpty() } fun processItems(items: List\u0026lt;String\u0026gt;?) { if (isNotEmpty(items)) { // Compiler knows items is non-null and not empty  println(\u0026#34;Processing ${items.size}items\u0026#34;) } else { println(\u0026#34;No items to process\u0026#34;) } } fun main() { processItems(listOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;)) processItems(null) processItems(emptyList()) }   Salida Processing 3 items No items to process No items to process Cuando usar contratos Los contratos son ideales para:\n Desarrollo de librerías: Proteger APIs públicas forzando condiciones pre existentes. DSLs y Frameworks: Simplificando la comprobación de tipos y validación de estados en DSLs de Kotlin. Optimizaciones en tiempo de ejecución: Reduce las comprobaciones en tiempo de ejecución al permitir al compilador inferir las condiciones en tiempo de compilación.  Conclusion Los contratos de Kotlin son una gema oculta que pueden perfeccionar tu código mejorando la seguridad, reduciendo la repetición de código, y permitiendo un análisis por parte del compilador más inteligente. Tanto si estás creando librerías, escribiendo complejos DSLs, o simplemente optimizando código del día a día, los contratos proveen una herramienta muy poderosa para guiar al compilador de Kotlin y asegurando un código correcto.\nTener en cuenta que los contratos están anotados como funcionalidad experimental pero están implementados en Kotlin desde la versión 1.3 y se usan extensamente en la librería estandar de Kotlin así que son lo suficiente estables como para utilizarlos.\n","description":"Kotlin avanzado - Contracts","id":48,"section":"posts","tags":["kotlin","android","advanced"],"title":"Kotlin contracts","uri":"https://carrion.dev/es/posts/kotlin-contracts/"},{"content":"Exportar a Swift en KMP Empezando con la versión 2.1.0 podemos empezar a probar a exportar a Swift en Kotlin. Esta funcionalidad te permite exportar los módulos compartidos de Kotlin a Swift sin usar Objective-C. Esto mejorará la experiancia de los desarrolladores de iOS cuando usen módulos de KMP.\nActualmente el soporte básico incluye:\n Exportar múltiples módulos de Gradle a swift. Definir los nombres de los módulos swift. Simplificar la estructura de paquetes.  Activar la funcionalidad Para empezar a probar esta funcionalidad debes activarla en el fichero gradle.properties:\nkotlin.experimental.swift-export.enabled=true Configuración Después de añadir la línea mostrada arriba necesitas añadir esta configuración al fichero build.gradle.kts:\n1 2 3 4 5 6 7 8 9 10 11  kotlin { iosX64() iosArm64() iosSimulatorArm64() @OptIn(ExperimentalSwiftExportDsl::class) swiftExport { moduleName = \u0026#34;shared\u0026#34; flattenPackage = \u0026#34;dev.carrion.kmpswiftexport\u0026#34; } }   El siguiente paso es configurar xcode para lanzar la nueva tarea embedSwiftExportForXcode en lugar de embedAndSignAppleFrameworkForXcode. Puedes realizar este cambio desde la configuración de Build phases de la iosApp desde xcode o bien desde Android Studio modificando el fichero project.pbxproj.\nDebes cambiar esta línea:\nshellScript = \u0026quot;cd \\\u0026quot;$SRCROOT/..\\\u0026quot;\\n./gradlew :shared:embedAndSignAppleFrameworkForXcode\\n\u0026quot;; Por esta otra:\nshellScript = \u0026quot;cd \\\u0026quot;$SRCROOT/..\\\u0026quot;\\n./gradlew :shared:embedSwiftExportForXcode\\n\u0026quot;; Después de aplicar estos cambios deberías ser capaz de lanzar la aplicación de iOS desde Android Studio o desde xcode sin ningún problema.\nAntes de activar la funcionalidad Si intentas navegar a la definición de una función de Kotlin desde xcode en un archivo swift, se mostrará el código Objective-C que se exporta del módulo compartido de Kotlin. Este fichero generado es enorme teniendo en cuenta la complejidad del projecto usado para este ejemplo.\nTe voy a mostrar a continuación una pequeña pieza del archivo de 175 líneas generado desde el código de Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;Greeting\u0026#34;))) @interface SharedGreeting : SharedBase - (instancetype)init __attribute__((swift_name(\u0026#34;init()\u0026#34;))) __attribute__((objc_designated_initializer)); + (instancetype)new __attribute__((availability(swift, unavailable, message=\u0026#34;use object initializers instead\u0026#34;))); - (NSString *)greet __attribute__((swift_name(\u0026#34;greet()\u0026#34;))); @end __attribute__((swift_name(\u0026#34;Platform\u0026#34;))) @protocol SharedPlatform @required @property (readonly) NSString *name __attribute__((swift_name(\u0026#34;name\u0026#34;))); @end __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;IOSPlatform\u0026#34;))) @interface SharedIOSPlatform : SharedBase \u0026lt;SharedPlatform\u0026gt; - (instancetype)init __attribute__((swift_name(\u0026#34;init()\u0026#34;))) __attribute__((objc_designated_initializer)); + (instancetype)new __attribute__((availability(swift, unavailable, message=\u0026#34;use object initializers instead\u0026#34;))); @property (readonly) NSString *name __attribute__((swift_name(\u0026#34;name\u0026#34;))); @end __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;Platform_iosKt\u0026#34;))) @interface SharedPlatform_iosKt : SharedBase + (id\u0026lt;SharedPlatform\u0026gt;)getPlatform __attribute__((swift_name(\u0026#34;getPlatform()\u0026#34;))); @end #pragma pop_macro(\u0026#34;_Nullable_result\u0026#34;) #pragma clang diagnostic pop NS_ASSUME_NONNULL_END   After enabling the feature Cuando activas al funcionalidad de exportar a Swift y compilas el proyecto, al intentar navegar a la definición de una función del código compartido de Kotlin, xcode te mostrará el código exportado de Swift.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  @_exported import ExportedKotlinPackages @_implementationOnly import SharedBridge_shared import KotlinRuntime public typealias Greeting = ExportedKotlinPackages.dev.carrion.kmpswiftexport.Greeting public func getPlatform() -\u0026gt; Swift.Never { ExportedKotlinPackages.dev.carrion.kmpswiftexport.getPlatform() } public extension ExportedKotlinPackages.dev.carrion.kmpswiftexport { public final class Greeting : KotlinRuntime.KotlinBase { public override init() { let __kt = dev_carrion_kmpswiftexport_Greeting_init_allocate() super.init(__externalRCRef: __kt) dev_carrion_kmpswiftexport_Greeting_init_initialize__TypesOfArguments__Swift_UInt__(__kt) } public override init( __externalRCRef: Swift.UInt ) { super.init(__externalRCRef: __externalRCRef) } public func greet() -\u0026gt; Swift.String { return dev_carrion_kmpswiftexport_Greeting_greet(self.__externalRCRef()) } } public static func getPlatform() -\u0026gt; Swift.Never { fatalError() } }   El código mostrado arriba es el fichero completo con 28 líneas, una gran diferencia con las 175 líneas del código exportado en Objective-C. También es importante mencionar la menor complejidad y mayor legibilidad del código swift.\nConclusion Después de probar esta nueva funcionalidad, estoy realmente impresionado con la mejora que supone para el desarrollo de iOS en los proyectos KMP. También me sorprende la diferencia en el código exportado en Objective-C y swift. Estoy seguro que esta funcionalidad mejorará en las siguientes versiones y acercará la experiencia entre el desarrollo nativo y el desarrollo multiplataforma.\nPuedes encontrar el repositorio con el código usado en este ejemplo en SwiftExport, con dos ramas, main, con la configuración del típico iOS framework conf, y la rama swift-export con la nueva funcionalidad habilitada.\n","description":"Nueva funcionalidad en Kotlin 2.1.0, exportar directamente a swift desde Kotlin","id":49,"section":"posts","tags":["kotlin","android","kmp"],"title":"Exportar a Swift en KMP","uri":"https://carrion.dev/es/posts/swift-export/"},{"content":"Condiciones en las expresiones when en Kotlin 2.1.0 Una de las nuevas funcionalidades de Kotlin 2.1.0 es las condiciones en las expresiones when, lo que tendría varias ventajas entre las que se incluye:\n Reducir anidaciones Evita código repetido Mejorar legibilidad  Activar la funcionalidad en Kotlin 2.1.0 Esta funcionalidad se encuentra en preview lo que es necesario activarla explícitamente para poder usarla en Kotlin 2.1.0. En el fichero build.gradle.kts añadiremos el siguiente código dentro del bloque de kotlin {}:\n1 2 3 4 5  kotlin { compilerOptions { freeCompilerArgs.add(\u0026#34;-Xwhen-guards\u0026#34;) } }   Uso de condicionales dentro de las ramas de la expresiones when Para este ejemplo usaremos una sealed interface para manejar respuestas de un servicio remoto:\n1 2 3 4 5  sealed interface Response\u0026lt;out T\u0026gt; { data object Loading : Response\u0026lt;Nothing\u0026gt; data class Content \u0026lt;out T\u0026gt; (val data: T?) : Response\u0026lt;T\u0026gt; data class Error(val error: Exception) : Response\u0026lt;Nothing\u0026gt; }   Esta interfaz la implementan Loading, Content y Error para gestionar los distintos estados de una respuesta.\nAntes de la nueva funcionalidad 1 2 3 4 5 6 7 8 9 10 11 12 13  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handleOld() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content -\u0026gt; if (data != null) { println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } is Response.Error -\u0026gt; if (error is IllegalStateException) { println(\u0026#34;Handled error\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } }   Como se puede ver en este caso se repite el código que muestra por pantalla Unknown error además de añadir anidaciones que dificultan la lectura del código.\nUsando los nuevos condicionales Se debe añadir el if justo después de la condición primaria de la rama, por ejemplo:\n1 2 3 4 5 6  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled error\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   De esta manera no se repite el código que mostraba por pantalla el texto de Unknown error y además eliminamos las anidaciones facilitando la lectura del código.\nEn caso de necesitar comprobar varias condiciones en la rama else se podría añadir una rama else if que controle el flujo de los casos que no cumplen las condiciones anteriores.\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) else if this is Response.Error \u0026amp;\u0026amp; this.error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   Esto último se puede simplificar usando dos ramas con la misma primera condición de is Response.Error que a mi parecer queda más simple:\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) is Response.Error if error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   Conclusión Con esta nueva funcionalidad se podrá añadir nuevas condiciones sin tener que repetir código y permitirá que las expresiones when sean más concisas. En la versión 2.1.0 de Kotlin está en modo preview pero se espera que pronto esta nueva funcionalidad sea estable.\nAquí el enlace a la documentación con las novedades de Kotlin 2.1.0 donde se explica la funcionalidad de condicionales en las expresiones when kotlinlang\n","description":"Nueva funcionalidad en Kotlin 2.1.0, condiciones en las expresiones when","id":50,"section":"posts","tags":["kotlin","android","kmp"],"title":"Condiciones en las expresiones when para Kotlin 2.1.0.","uri":"https://carrion.dev/es/posts/kotlin-guard-conditions-in-when/"},{"content":"Inyección de valores en tiempo de ejecución con Dagger-Hilt Desde que apareció Hilt para facilitar la inyección de dependencias en aplicaciones Android, no era posible la inyección de dependencias en tiempo de ejecución sin utilizar librerías ajenas a Dagger o Hilt. Desde la versión 2.31 se incorpora en Dagger la anotación @AssistedInject. Con esta anotación vamos a ser capaces de indicar a Dagger-Hilt que dependencias se tienen que resolver en tiempo de ejecución y retrasar la inyección de esos parámetros hasta tener los valores.\nEsto era necesario para poder inyectar valores en los constructores de los ViewModel y poder ejecutar alguna operación en el método init del mismo. Como puede ser una petición a una API externa o bien una consulta en la base de datos local.\nEn este artículo veremos como implementar el @AssistedInject de Dagger para la inyección de valores en tiempo de ejecución en ViewModels con Hilt.\nInstalación En el fichero build.gradle raíz del proyecto, incluiremos el siguiente classpath:\n1  classpath \u0026#39;com.google.dagger:hilt-android-gradle-plugin:2.31.2-alpha\u0026#39;   Una vez añadido el classpath añadiremos el plugin de Hilt en el fichero build.gradle del módulo app.\n1  apply plugin: \u0026#39;dagger.hilt.android.plugin\u0026#39;   Y también las siguientes líneas a nuestras dependencias:\n1 2  implementation \u0026#39;com.google.dagger:hilt-android:2.31.2-alpha\u0026#39; kapt \u0026#39;com.google.dagger:hilt-android-compiler:2.31.2-alpha\u0026#39;   También hay que tener en cuenta tener añadido en nuestro build.gradle el plugin de kapt. Para ello añadiremos lo siguiente a nuestro archivo de build.gradle del módulo app junto al resto de plugins:\n1  apply plugin: \u0026#39;kotlin-kapt\u0026#39;   Esa son las dependencias necesarias para implementar Hilt en nuestro proyecto. A lo largo de este post se usan distintas librerías como que no se definen en este artículo.\nEn este enlace puedes ver un ejemplo de un archivo build.gradle completo: app/build.gradle\nImplementación Para este ejemplo usaremos una clase repositorio encargada de recibir el nombre de usuario y devolver un mensaje de bienvenida. Para ello crearemos la siguiente interfaz:\n1 2 3  interface UserRepository { fun getMessage(name: String): String }   Y su implementación:\n1 2 3 4 5  class UserRepositoryImpl @Inject constructor() : UserRepository { override fun getMessage(name: String): String { return \u0026#34;Hi $name\u0026#34; } }   Anotamos el constructor con @Inject para posteriormente poder declarar un @Binds en el módulo de Hilt e inyectar la implementación cada vez que se pida una interfaz del tipo UserRepository.\nVamos a crear el siguiente ViewModel que será el encargado de recibir el nombre del usuario desde el Activity o Fragment y llamar al repositorio para recibir el mensaje de bienvenida:\n1 2 3 4 5 6 7 8 9  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { ... }   En este ViewModel podemos ver como se anota el constructor con @AssistedInject para indicar a Dagger-Hilt que esta clase contiene dependencias que se deben inyectar en tiempo de ejecución. Esas dependencias están anotadas con @Assisted.\nPara poder crear el ViewModel con la extensión by viewModels() de la librería de AndroidX debemos crear la Factory que más tarde pasaremos a la extensión:\n1 2 3 4 5 6 7 8  class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } }   Como puedes ver necesitamos la interfaz UserViewModelAssistedFactory que es la encargada de proveer los parámetros en tiempo de ejecución. Esta interfaz la implementamos de la siguiente forma:\n1 2 3 4 5 6  @AssistedFactory interface UserViewModelAssistedFactory { fun create(name: String): UserViewModel }   Se trata de una interfaz con una función create que recibe los parámetros a inyectar en tiempo de ejecución. En nuestro caso solo necesitamos el name, pero en caso de necesitar inyectar más parámetros en tiempo de ejecución, se pasarían como parámetro a esta función.\nCon esto ya podemos completar nuestro ViewModel con la lógica necesaria para pedir la respuesta al repositorio y exponer al Fragment o Activity a través de un StateFlow.\nEl ViewModel completo quedaría:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } } private val _message: MutableStateFlow\u0026lt;String\u0026gt; = MutableStateFlow(\u0026#34;\u0026#34;) val message: StateFlow\u0026lt;String\u0026gt; get() = _message init { viewModelScope.launch(dispatcher) { _message.emit(repository.getMessage(name)) } } }   Relativo a Hilt solo nos faltaría declarar el módulo indicando como proveer las dependencias. Para este ejemplo usaremos el siguiente módulo:\n1 2 3 4 5 6 7 8 9 10 11 12 13  @Module @InstallIn(ActivityComponent::class) abstract class MainModule { companion object { @Provides @Named(\u0026#34;UserDispatcher\u0026#34;) fun provideUserDispatcher(): CoroutineDispatcher = Dispatchers.IO } @Binds abstract fun provideUserRepository(repositoryImpl: UserRepositoryImpl): UserRepository }   En este módulo declaramos un Dispatcher para que sea más sencillo testear este ViewModel en un futuro. Y hacemos @Binds de nuestra interfaz UserRepository con su implementación UserRepositoryImpl.\nAhora podemos inyectar nuestro repositorio en una Activity o Fragment de la siguiente forma:\n1 2 3 4 5 6 7 8  private val navArgs: UserFragmentArgs by navArgs() @Inject lateinit var assistedFactory: UserViewModelAssistedFactory private val userViewModel: UserViewModel by viewModels { UserViewModel.Factory(assistedFactory, navArgs.name) }   Simplemente nos faltaría observar los cambios en el StateFlow del ViewModel para poder actualizar nuestra UI. Eso se haría de la siguiente manera en un Fragment aunque sería muy similar en un Activity\n1 2 3 4 5 6 7 8  override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycleScope.launchWhenStarted { userViewModel.message.collect { binding.name.text = it } } }    Recordar que es necesario anotar una clase que extienda de Application con @HiltAndroidApp y cada uno de las Activities o Fragments que usen inyección con Hilt con la anotación @AndroidEntryPoint.\n Conclusión Como hemos podido observar con @AssistedInject de Dagger podemos inyectar valores en tiempo de ejecución de una forma sencilla y podemos seguir utilizando los navArgs de AndroidX.\nEn el siguiente repositorio teneis el ejemplo completo: HiltAssistedInject\n","description":"Como inyectar valores en tiempo de ejecución a los ViewModel en Android.","id":51,"section":"posts","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Hilt: Inyectar valores al ViewModel en tiempo de ejecución.","uri":"https://carrion.dev/es/posts/hilt-inject-parameters-runtime/"},{"content":"Bienvenido a Carrion.dev Saludos Androide!!\nBienvenido a mi nuevo blog de Kotlin y programación Android. Me llamo Ignacio Carrión y soy dessarrollador Android. Me encanta el lenguaje Kotlin por las facilidades que me aporta al programar para Android y las infinitas posibilidades que ofrece en otros ámbitos (backend, web, nativo, multiplataforma).\nEn este blog espero poder publicar cosas interesantes acerca del lenguaje Kotlin y el ecosistema Android al menos cada dos semanas. Si quieres mantenerte al día no dudes en apuntarte a nuestra newsletter.\nSi tienes alguna duda, idea acerca de la que podemos hablar en un post o simplemente quieres contactar estoy disponible a través del correo: ignacio@carrion.dev.\nEspero que aprendamos mucho todos juntos!!\n","description":"Primer post en mi nuevo blog de Kotlin y Android.","id":52,"section":"posts","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Bienvenido a mi nuevo blog sobre Kotlin y desarrollo Android","uri":"https://carrion.dev/es/posts/welcome-to-my-new-kotlin-and-android-development-blog/"},{"content":"Sobre mi. Me llamo Ignacio Carrión, vivo en Valencia (España) y el que aparece en la foto es mi perro Wilfred. Me gusta cualquier cosa relacionada con la informática y los videojuegos. Actualmente trabajo como Senior Android Engineer para Tkww. Anteriormente he trabajado en otras empresas como desarrollador Android y también he impartido clases de programación. A raiz de mi trabajo como profesor me dí cuenta de que realmente me encanta aprender y que la gente aprenda conmigo. De esa motivación surge la idea de crear este blog, Carrion.dev.\nEspero poder ir publicando de forma asídua cosas interesantes acerca del lenguaje Kotlin y el ecosistema Android. Cualquier crítica constructiva e ideas acerca de posibles temas para artículos serán bien recibidas. Abajo aparecen los enlaces a las redes sociales en las que podrás encontrarme y contactar conmigo.\nContactar Portfolio\nGithub\n","description":"Ignacio Carrión, Desarrollador Android","id":56,"section":"","tags":null,"title":"Sobre mi","uri":"https://carrion.dev/es/about/"}]