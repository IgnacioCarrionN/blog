<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>design-patterns on Carrion.dev</title><link>https://carrion.dev/es/tags/design-patterns/</link><description>Recent content in design-patterns on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>es</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Fri, 25 Apr 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/es/tags/design-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Construyendo DSLs Tipados con Kotlin: De lo Básico a Patrones Avanzados</title><link>https://carrion.dev/es/posts/building-type-safe-dsls/</link><pubDate>Fri, 25 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 25 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/building-type-safe-dsls/</guid><description>Construyendo DSLs Tipados con Kotlin: De lo Básico a Patrones Avanzados Los Lenguajes de Dominio Específico (DSLs) en Kotlin te permiten crear APIs expresivas, legibles y tipadas. Este artículo explora cómo construir DSLs efectivos usando las potentes características de Kotlin, centrándose en el control de ámbito con @DslMarker para prevenir errores comunes en DSLs anidados.
Al final de este artículo, entenderás:
Cómo diseñar APIs de DSL limpias e intuitivas Cuándo y cómo usar @DslMarker para un mejor control de ámbito Mejores prácticas para mantener el tipado seguro en tu DSL Errores comunes y cómo evitarlos Conceptos Básicos de DSL Exploremos los conceptos fundamentales de los DSLs en Kotlin construyendo un simple constructor de HTML:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/type-safe-dsls.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>dsl</category><category>type-safety</category><category>design-patterns</category></item><item><title>Kotlin Design Patterns - Part 3</title><link>https://carrion.dev/es/posts/design-patterns-3/</link><pubDate>Mon, 13 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 13 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/design-patterns-3/</guid><description>Explorando Más Patrones de Diseño en Kotlin: Parte 3 Part 1 Part 2 Part 3 En esta tercera entrega, cubriremos los patrones Memento, Command, Visitor, Chain of Responsibility y Mediator. Estos patrones abordan desafíos de construcción, comportamiento y estructura, mostrando la sintaxis expresiva y las características modernas de Kotlin.
1. Patrón Memento El Patrón Memento captura y restaura el estado de un objeto sin exponer sus detalles internos.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/memento-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item><item><title>Patrones de diseño en Kotlin - Parte 2</title><link>https://carrion.dev/es/posts/design-patterns-2/</link><pubDate>Mon, 06 Jan 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 06 Jan 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/design-patterns-2/</guid><description>Explorando patrones de diseño en Kotlin: Parte2 Design Patterns Series Part 1 Part 2 Part 3 Después de la gran acogida del primer artículo Patrones de diseño en Kotlin, volvemos con más! En esta segunda parte, revisaremos los patrones de Prototype, Composite, Proxy, Observer, y Strategy. Estos patrones resuelven una variedad de desafios de diseño y demuestran las capacidades expresivas de Kotlin.
1. Patrón Prototype El Patrón Prototype es usado para crear nuevos objeto copiando una objeto existente, asegurando la creación eficaz de objetos.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/proxy-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item><item><title>Patrones de diseño en Kotlin - Parte 1</title><link>https://carrion.dev/es/posts/design-patterns-1/</link><pubDate>Mon, 30 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 30 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/design-patterns-1/</guid><description>Explorando patrones de diseño en Kotlin - Parte 1 Serie Patrones de diseño Design Patterns Series Part 1 Part 2 Part 3 Los patrones de diseño son soluciones probadas a problemas comunes en el diseño de software. Con la sintaxis y funcionalidades modernas de Kotlin, implementar estos patrones normalmente resulta más limpio y conciso. En este post, exploraremos los patrones de Singleton, Factory Method, Builder, Adapter and Decorator, profundizando en su propósito, casos de uso y implementaciones en Kotlin.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/singleton-pattern.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>design-patterns</category><category>architecture</category></item></channel></rss>