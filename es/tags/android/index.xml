<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>android on Carrion.dev</title><link>https://carrion.dev/es/tags/android/</link><description>Recent content in android on Carrion.dev</description><generator>Hugo -- gohugo.io</generator><language>es</language><managingEditor>ignacio@carrion.dev (Ignacio Carrión)</managingEditor><webMaster>ignacio@carrion.dev (Ignacio Carrión)</webMaster><copyright>&amp;copy;{year}, All Rights Reserved</copyright><lastBuildDate>Tue, 08 Apr 2025 08:00:00 +0100</lastBuildDate><atom:link href="https://carrion.dev/es/tags/android/index.xml" rel="self" type="application/rss+xml"/><item><title>Optimización de Rendimiento en Jetpack Compose</title><link>https://carrion.dev/es/posts/performance-optimization-compose/</link><pubDate>Tue, 08 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 08 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/performance-optimization-compose/</guid><description>Optimización de Rendimiento en Jetpack Compose La optimización del rendimiento es crucial para ofrecer una experiencia de usuario fluida en aplicaciones con Jetpack Compose. Este artículo explora técnicas clave y mejores prácticas para asegurar que tus funciones composables sean eficientes y tengan un buen rendimiento.
Entendiendo la Composición y Recomposición Uno de los aspectos fundamentales del rendimiento en Compose es entender cómo funcionan la composición y recomposición:
Recomposición Inteligente Compose utiliza recomposición inteligente para actualizar solo las partes de la UI que necesitan cambiar.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/remember-optimization.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>performance</category><category>optimization</category></item><item><title>Animaciones y Transiciones Personalizadas en Jetpack Compose</title><link>https://carrion.dev/es/posts/custom-animations-transitions-compose/</link><pubDate>Fri, 04 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 04 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/custom-animations-transitions-compose/</guid><description>Animaciones y Transiciones Personalizadas en Jetpack Compose Crear animaciones fluidas y significativas es crucial para ofrecer una experiencia de usuario pulida. Este artículo explora cómo crear animaciones y transiciones personalizadas en Jetpack Compose, desde animaciones básicas hasta implementaciones personalizadas complejas.
Creando Animaciones Personalizadas Las animaciones personalizadas permiten efectos visuales más complejos y únicos:
Especificaciones de Animación Personalizadas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Composable fun CustomAnimatedButton( onClick: () -&amp;gt; Unit, content: @Composable () -&amp;gt; Unit ) { var isPressed by remember { mutableStateOf(false) } val scope = rememberCoroutineScope() val scale by animateFloatAsState( targetValue = if (isPressed) 0.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/pulsating-dot.gif" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>animation</category><category>transitions</category></item><item><title>Gestión Avanzada de Estado en Compose: Effects y Flows</title><link>https://carrion.dev/es/posts/advanced-state-management-compose/</link><pubDate>Tue, 01 Apr 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 01 Apr 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/advanced-state-management-compose/</guid><description>Gestión Avanzada de Estado en Compose: Effects y Flows Este artículo explora patrones avanzados de gestión de estado en Jetpack Compose, centrándose en Effects e integración de Flows. Para conceptos fundamentales como mutableStateOf y state hoisting, consulta nuestro artículo complementario Gestión Básica de Estado en Jetpack Compose.
Entendiendo los Effects en Compose Los Effects en Compose son herramientas para manejar efectos secundarios y eventos del ciclo de vida de manera compatible con los composables.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/state-management-compose-advanced.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>state</category><category>flows</category><category>effects</category></item><item><title>Patrones de Gestión de Estado en Jetpack Compose</title><link>https://carrion.dev/es/posts/state-management-patterns-compose/</link><pubDate>Fri, 28 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 28 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/state-management-patterns-compose/</guid><description>Patrones de Gestión de Estado en Jetpack Compose La gestión del estado es un aspecto crucial en el desarrollo de aplicaciones robustas y mantenibles con Jetpack Compose. Este artículo explora patrones esenciales y mejores prácticas para gestionar el estado de manera efectiva en tu UI con Compose, incluyendo estado inmutable, actualizaciones basadas en eventos y estrategias de pruebas.
Entendiendo los Patrones de Gestión de Estado La gestión efectiva del estado en Compose requiere entender cómo estructurar y manejar los cambios de estado de una manera mantenible, testeable y escalable.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/state-management-compose.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>android</category><category>compose</category><category>patrones</category><category>estado</category><category>pruebas</category></item><item><title>Logrando Seguridad en Tiempo de Compilación con Koin: Una Guía Completa</title><link>https://carrion.dev/es/posts/koin-compile-safety/</link><pubDate>Tue, 04 Mar 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 04 Mar 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/koin-compile-safety/</guid><description>Logrando Seguridad en Tiempo de Compilación con Koin: Una Guía Completa La inyección de dependencias es un patrón fundamental en el desarrollo moderno de Android, pero ¿cómo podemos asegurarnos de que nuestra configuración de DI sea correcta antes de ejecutar la aplicación? En esta publicación, exploraremos dos poderosos enfoques para lograr la seguridad en tiempo de compilación con Koin: usando la función verify() del DSL y aprovechando las Anotaciones de Koin con KSP.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-ksp-config.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>koin</category></item><item><title>Gestión Confiable del Tiempo con la API TrustedTime en Android</title><link>https://carrion.dev/es/posts/trusted-time-api/</link><pubDate>Wed, 19 Feb 2025 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 19 Feb 2025 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/trusted-time-api/</guid><description>Gestión Confiable del Tiempo con la API TrustedTime en Android
La gestión precisa del tiempo es crucial para muchas funcionalidades de las aplicaciones, como la programación de tareas, el registro de transacciones y la seguridad. Sin embargo, depender del reloj del sistema de un dispositivo puede ser problemático, ya que los usuarios pueden modificar la configuración de la hora. Para abordar este problema, Google ha introducido la API TrustedTime, que proporciona una fuente de tiempo confiable y resistente a manipulaciones para las aplicaciones de Android.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/trusted-time-api.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>google</category></item><item><title>Explorando Kotlin KSP</title><link>https://carrion.dev/es/posts/kotlin-ksp/</link><pubDate>Fri, 27 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 27 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/kotlin-ksp/</guid><description>Explorando Kotlin Symbol Processing (KSP) con ejemplos prácticos Kotlin Symbol Processing (KSP) es una herramienta muy potente usada para simplificar el procesamiento de anotaciones en Kotlin. Comparado con kapt (Kotlin Annotation Processing Tool), KSP es más rápido, ofrece mejor integración con Kotlin y reduce los tiempos de compilación de forma significativa. En este post, exploraremos los fundamentos de KSP, discutiremos cómo funciona y mostraremos como su uso en librerías populares como Koin y Room.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-annotations.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Funciones Infix en Kotlin</title><link>https://carrion.dev/es/posts/kotlin-infix/</link><pubDate>Thu, 26 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Thu, 26 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/kotlin-infix/</guid><description>Explorando las funciones Infix en Kotlin Kotlin, es un lenguaje de programación moderno con funcionalidades que permiten escribir un código más expresivo y conciso. Una de estas funcionalidades son las infix functions, que permiten escribir código más limpio y legible. En este post, exploraremos que son las funciones infix, como usarlas y algunos ejemplo prácticos.
Qué son las funciones Infix? Las funciones infix en Kotlin son un tipo especial de función que pueden ser llamadas sin el uso de paréntesis o el punto.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-infix.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Kotlin Delegates</title><link>https://carrion.dev/es/posts/kotlin-delegates/</link><pubDate>Mon, 23 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Mon, 23 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/kotlin-delegates/</guid><description>✨ Entendiendo los Kotlin Delegates: La magia detrás de código más limpio ✨ Los Kotlin delegates son una funcionalidad muy útil que te permite delegar el comportamiento de una propiedad o incluso una implementación de una interfaz a otro objecto. En lugar de escribir lógica repetitiva o manejar el estado directamente, puedes delegar esta responsabilidad a clases especializadas y reusables.
Como funcionan los Delegates Delegates en Kotlin funcionan usando la palabra reservada by, que redirecciona el comportamiento de una propiedad o interfaz al objeto delegado.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/koin-delegate.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Kotlin contracts</title><link>https://carrion.dev/es/posts/kotlin-contracts/</link><pubDate>Fri, 20 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Fri, 20 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/kotlin-contracts/</guid><description>Kotlin Avanzado - Contracts: Cómo volver al compilador de Kotlin más inteligente Kotlin nunca deja de impresionarme con sus funcionalidades. Una función avanzada pero poco utilizada en el arsenal de Kotlin son los Contracts. Los contratos te permiten guiar al compilador de Kotlin para que tome mejores decisiones acerca de tu código, resultando en mejor seguridad ante nulos, mejor rendimiento o incluso menores errores en tiempo de ejecución.
Qué son los contratos de Kotlin?</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/kotlin-contract.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>advanced</category></item><item><title>Exportar a Swift en KMP</title><link>https://carrion.dev/es/posts/swift-export/</link><pubDate>Wed, 18 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 18 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/swift-export/</guid><description>Exportar a Swift en KMP Empezando con la versión 2.1.0 podemos empezar a probar a exportar a Swift en Kotlin. Esta funcionalidad te permite exportar los módulos compartidos de Kotlin a Swift sin usar Objective-C. Esto mejorará la experiancia de los desarrolladores de iOS cuando usen módulos de KMP.
Actualmente el soporte básico incluye:
Exportar múltiples módulos de Gradle a swift. Definir los nombres de los módulos swift. Simplificar la estructura de paquetes.</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/swift-export.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>kmp</category></item><item><title>Condiciones en las expresiones when para Kotlin 2.1.0.</title><link>https://carrion.dev/es/posts/kotlin-guard-conditions-in-when/</link><pubDate>Tue, 17 Dec 2024 08:00:00 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 17 Dec 2024 08:00:00 +0100</atom:modified><guid>https://carrion.dev/es/posts/kotlin-guard-conditions-in-when/</guid><description>Condiciones en las expresiones when en Kotlin 2.1.0 Una de las nuevas funcionalidades de Kotlin 2.1.0 es las condiciones en las expresiones when, lo que tendría varias ventajas entre las que se incluye:
Reducir anidaciones Evita código repetido Mejorar legibilidad Activar la funcionalidad en Kotlin 2.1.0 Esta funcionalidad se encuentra en preview lo que es necesario activarla explícitamente para poder usarla en Kotlin 2.1.0. En el fichero build.gradle.kts añadiremos el siguiente código dentro del bloque de kotlin {}:</description><dc:creator>Ignacio Carrión</dc:creator><media:content url="https://carrion.dev/images/kotlin/guard-when-new.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>kmp</category></item><item><title>Hilt: Inyectar valores al ViewModel en tiempo de ejecución.</title><link>https://carrion.dev/es/posts/hilt-inject-parameters-runtime/</link><pubDate>Wed, 24 Feb 2021 07:00:06 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Wed, 24 Feb 2021 07:00:06 +0100</atom:modified><guid>https://carrion.dev/es/posts/hilt-inject-parameters-runtime/</guid><description>Inyección de valores en tiempo de ejecución con Dagger-Hilt Desde que apareció Hilt para facilitar la inyección de dependencias en aplicaciones Android, no era posible la inyección de dependencias en tiempo de ejecución sin utilizar librerías ajenas a Dagger o Hilt. Desde la versión 2.31 se incorpora en Dagger la anotación @AssistedInject. Con esta anotación vamos a ser capaces de indicar a Dagger-Hilt que dependencias se tienen que resolver en tiempo de ejecución y retrasar la inyección de esos parámetros hasta tener los valores.</description><dc:creator>Ignacio</dc:creator><media:content url="https://carrion.dev/images/kotlin/kotlin-logo.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>jetpack</category><category>coroutines</category><category>androidx</category></item><item><title>Bienvenido a mi nuevo blog sobre Kotlin y desarrollo Android</title><link>https://carrion.dev/es/posts/welcome-to-my-new-kotlin-and-android-development-blog/</link><pubDate>Tue, 23 Feb 2021 10:00:06 +0100</pubDate><author>ignacio@carrion.dev (Ignacio Carrión)</author><atom:modified>Tue, 23 Feb 2021 10:00:06 +0100</atom:modified><guid>https://carrion.dev/es/posts/welcome-to-my-new-kotlin-and-android-development-blog/</guid><description>Bienvenido a Carrion.dev Saludos Androide!!
Bienvenido a mi nuevo blog de Kotlin y programación Android. Me llamo Ignacio Carrión y soy dessarrollador Android. Me encanta el lenguaje Kotlin por las facilidades que me aporta al programar para Android y las infinitas posibilidades que ofrece en otros ámbitos (backend, web, nativo, multiplataforma).
En este blog espero poder publicar cosas interesantes acerca del lenguaje Kotlin y el ecosistema Android al menos cada dos semanas.</description><dc:creator>Ignacio</dc:creator><media:content url="https://carrion.dev/images/kotlin/kotlin-logo.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>kotlin</category><category>android</category><category>jetpack</category><category>coroutines</category><category>androidx</category></item></channel></rss>