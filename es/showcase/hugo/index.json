[{"content":"Test-Driven Development (TDD) en Kotlin para Android El Test-Driven Development (TDD) es una pr√°ctica de desarrollo de software que enfatiza escribir pruebas antes de implementar la funcionalidad. Sigue un ciclo Rojo-Verde-Refactorizaci√≥n: primero, escribes una prueba que falla (Rojo), luego implementas el c√≥digo m√≠nimo para que pase (Verde), y finalmente, refactorizas el c√≥digo manteniendo la prueba en verde (Refactorizaci√≥n). En esta publicaci√≥n, exploraremos c√≥mo aplicar TDD en Kotlin para el desarrollo de Android usando JUnit, MockK y Coroutines, con un ejemplo del mundo real.\n¬øPor qu√© usar Test-Driven Development en el desarrollo de Android?  Mejor calidad del c√≥digo: Escribir pruebas primero garantiza mejores decisiones de dise√±o y mantenibilidad. Depuraci√≥n m√°s r√°pida: Los errores se detectan temprano antes de volverse complejos. Confianza al refactorizar: Las pruebas act√∫an como una red de seguridad al modificar c√≥digo. Mayor productividad: Aunque escribir pruebas primero puede parecer m√°s lento al principio, acelera el desarrollo a largo plazo.  Configuraci√≥n del entorno de prueba Antes de comenzar, agreguemos las dependencias necesarias a nuestro archivo Gradle:\n1 2 3 4  // Pruebas unitarias testImplementation(\u0026#34;junit:junit:4.13.2\u0026#34;) testImplementation(\u0026#34;org.jetbrains.kotlinx:kotlinx-coroutines-test:1.10.1\u0026#34;) testImplementation(\u0026#34;io.mockk:mockk:1.13.16\u0026#34;)   Ahora, crearemos un ejemplo del mundo real para demostrar Test-Driven Development.\nEjemplo del mundo real: Obtener datos en un UseCase Implementaremos un UseCase que obtiene datos de un Repositorio y los ejecuta en el Dispatcher IO. Seguiremos el enfoque Test-Driven Development.\nPaso 1: Escribir una prueba que falle (Rojo) Primero, definamos una prueba para nuestro FetchUserUseCase. Este caso de uso obtiene los detalles de un usuario desde un repositorio.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  import io.mockk.* import kotlinx.coroutines.CoroutineDispatcher import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.ExperimentalCoroutinesApi import kotlinx.coroutines.test.* import kotlinx.coroutines.runBlocking import org.junit.Before import org.junit.Test import kotlin.test.assertEquals @ExperimentalCoroutinesApi class FetchUserUseCaseTest { private val repository: UserRepository = mockk() private lateinit var useCase: FetchUserUseCase private val testDispatcher = StandardTestDispatcher() @Before fun setup() { useCase = FetchUserUseCase(repository, testDispatcher) // Inyectar dispatcher de prueba  } @Test fun `fetch user returns expected user`() = runTest { // Given  val expectedUser = User(id = 1, name = \u0026#34;John Doe\u0026#34;) coEvery { repository.getUser(1) } returns expectedUser // When  val result = useCase(1) // Then  assertEquals(expectedUser, result) coVerify { repository.getUser(1) } } }   Entendiendo Given-When-Then   Given (Dado) ‚Äì Configurar las condiciones o dependencias necesarias para la prueba.\n1 2  val expectedUser = User(id = 1, name = \u0026#34;John Doe\u0026#34;) coEvery { repository.getUser(1) } returns expectedUser    Esto prepara una respuesta simulada para repository.getUser(1), de modo que devuelva expectedUser.    When (Cuando) ‚Äì Ejecutar la funci√≥n o caso de uso que se est√° probando.\n1  val result = useCase(1)    Esto llama a FetchUserUseCase con un ID de usuario 1, activando el comportamiento que queremos probar.    Then (Entonces) ‚Äì Verificar que el resultado esperado coincida con el resultado real.\n1 2  assertEquals(expectedUser, result) coVerify { repository.getUser(1) }    Esto comprueba que la funci√≥n devolvi√≥ el usuario esperado y que el m√©todo getUser del repositorio fue llamado.    Paso 2: Implementar el c√≥digo m√≠nimo para que pase la prueba (Verde) Ahora, implementemos la clase FetchUserUseCase.\n1 2 3 4 5 6 7 8 9 10 11 12 13  import kotlinx.coroutines.CoroutineDispatcher import kotlinx.coroutines.withContext class FetchUserUseCase( private val repository: UserRepository, private val dispatcher: CoroutineDispatcher = Dispatchers.IO // Dispatcher inyectado ) { suspend operator fun invoke(userId: Int): User { return withContext(dispatcher) { repository.getUser(userId) } } }   Paso 3: Refactorizar Dado que nuestra prueba est√° pasando, podemos limpiar o mejorar nuestra implementaci√≥n si es necesario. Aqu√≠, la implementaci√≥n ya es clara, por lo que no se requieren grandes refactorizaciones.\nEntendiendo las partes clave 1. Simulaci√≥n con MockK Usamos MockK para simular nuestro repositorio:\n1  coEvery { repository.getUser(1) } returns expectedUser   Esto simula una llamada a una funci√≥n que devuelve un valor predefinido.\n2. Uso de Coroutines con Test Dispatchers Reemplazamos Dispatchers.IO con un Test Dispatcher para controlar la ejecuci√≥n de las corrutinas.\n3. Verificaci√≥n de llamadas a funciones Nos aseguramos de que la funci√≥n del repositorio haya sido llamada:\n1  coVerify { repository.getUser(1) }   Esto confirma que nuestro c√≥digo se comporta como se espera.\nMejores pr√°cticas para Test-Driven Development en Kotlin  Escribir pruebas peque√±as y enfocadas: Cada prueba debe verificar una sola cosa. Usar mocks con prudencia: Evita el exceso de mocks; solo simula dependencias reales. Preferir pruebas deterministas: Evita pruebas inestables o dependientes del tiempo. Aprovechar las utilidades de prueba de Coroutines: Usa StandardTestDispatcher y runTest. Mantener pruebas r√°pidas: Las pruebas unitarias deben ejecutarse en milisegundos.  Conclusi√≥n Test-Driven Development mejora la calidad del c√≥digo y la eficiencia en el desarrollo. Al escribir pruebas primero, garantizamos c√≥digo confiable y mantenible. En esta publicaci√≥n, construimos un UseCase que obtiene datos de un repositorio ejecut√°ndolo en el Dispatcher IO, siguiendo los principios de Test-Driven Development. Con MockK y Coroutines, creamos una configuraci√≥n de pruebas robusta.\n¬°Comienza a aplicar Test-Driven Development en tus proyectos de Kotlin hoy mismo y experimenta los beneficios de primera mano!\nüöÄ ¬øQu√© sigue? ¬øTe gustar√≠a que ampliemos este contenido con pruebas de ViewModel o pruebas de UI con Jetpack Compose? ¬°D√©jamelo saber en los comentarios!\n","description":"Test-Driven Development (TDD) en Kotlin para Android con ejemplos reales usando JUnit, MockK y Coroutines","id":2,"section":"posts","tags":["kotlin","architecture","TDD","testing"],"title":"Test-Driven Development (TDD) en Kotlin para Android","uri":"https://carrion.dev/es/posts/tdd-kotlin/"},{"content":"Clean Architecture en Kotlin \u0026amp; Android Introducci√≥n Al desarrollar aplicaciones Android, mantener la escalabilidad y la legibilidad es crucial. Sin un enfoque arquitect√≥nico claro, los proyectos pueden volverse dif√≠ciles de mantener a medida que crecen. Aqu√≠ es donde Clean Architecture, introducida por Uncle Bob (Robert C. Martin), se vuelve invaluable. Esta arquitectura enfatiza la separaci√≥n de responsabilidades, haciendo que el c√≥digo sea m√°s modular, testeable y mantenible.\nEntendiendo Clean Architecture Clean Architecture est√° estructurada en tres capas principales, cada una con un rol espec√≠fico:\n Capa de Presentaci√≥n: Maneja la UI y las interacciones del usuario. Capa de Dominio: Contiene la l√≥gica de negocio, casos de uso e interfaces de repositorio. Capa de Datos: Implementa los repositorios, maneja llamadas a APIs y operaciones de base de datos.  El principio central de Clean Architecture es la direcci√≥n de las dependencias: cada capa solo debe depender de las capas m√°s cercanas al n√∫cleo (dominio). Esto garantiza flexibilidad y escalabilidad.\nEstructura del Proyecto Un proyecto con Clean Architecture en Kotlin t√≠picamente sigue esta estructura:\ncom.example.app ‚îÇ‚îÄ‚îÄ presentation (ViewModels, UI, Estado) ‚îÇ‚îÄ‚îÄ domain (Casos de Uso, Interfaces de Repositorio, Modelos) ‚îÇ‚îÄ‚îÄ data (Implementaciones de Repositorio, Fuentes de Datos, APIs, DB) Cada capa debe estar en un m√≥dulo o paquete separado, asegurando una correcta separaci√≥n de responsabilidades.\nModularizaci√≥n Para mejorar a√∫n m√°s el mantenimiento y la escalabilidad, considera estructurar tu proyecto en m√≥dulos de Gradle. Esto garantiza una clara separaci√≥n entre capas y promueve la reutilizaci√≥n.\nUn proyecto modularizado con Clean Architecture podr√≠a seguir esta estructura:\ncom.example.app ‚îÇ‚îÄ‚îÄ app (M√≥dulo principal de la aplicaci√≥n) ‚îÇ‚îÄ‚îÄ feature-user ‚îÇ ‚îÇ‚îÄ‚îÄ domain (Casos de Uso, Interfaces de Repositorio, Modelos) ‚îÇ ‚îÇ‚îÄ‚îÄ data (Implementaciones de Repositorio, Fuentes de Datos, APIs, DB) ‚îÇ ‚îÇ‚îÄ‚îÄ presentation (UI y ViewModels para funcionalidades de usuario) ‚îÇ‚îÄ‚îÄ core (Utilidades comunes, networking, helpers de base de datos) Beneficios de la modularizaci√≥n:\n Tiempos de compilaci√≥n m√°s r√°pidos debido a la compilaci√≥n aislada de m√≥dulos. Mejor encapsulaci√≥n del c√≥digo y separaci√≥n de responsabilidades. Desarrollo y mantenimiento de funcionalidades m√°s sencillo. Mayor facilidad para realizar pruebas unitarias en m√≥dulos independientes.  Implementando Clean Architecture con Kotlin 1. Capa de Dominio (L√≥gica de Negocio Central) La capa de dominio define la l√≥gica de negocio y los casos de uso. No debe depender de ning√∫n framework o librer√≠a externa, lo que la convierte en la parte m√°s estable de la aplicaci√≥n.\nEjemplo: Definir una Interfaz de Repositorio 1 2 3  interface UserRepository { suspend fun getUserById(id: String): User }   Ejemplo: Caso de Uso 1 2 3 4 5  class GetUserByIdUseCase(private val userRepository: UserRepository) { suspend operator fun invoke(id: String): User { return userRepository.getUserById(id) } }   2. Capa de Datos (Implementaci√≥n de Repositorios y Fuentes de Datos) La capa de datos proporciona implementaciones concretas de las interfaces de repositorio. Interact√∫a con APIs, bases de datos o almacenamiento local.\nEjemplo: Fuente de Datos 1 2 3 4 5 6 7 8 9  interface UserRemoteDataSource { suspend fun fetchUserById(id: String): User } class UserRemoteDataSourceImpl(private val api: UserApi) : UserRemoteDataSource { override suspend fun fetchUserById(id: String): User { return api.fetchUserById(id) } }   Ejemplo: Implementaci√≥n del Repositorio 1 2 3 4 5  class UserRepositoryImpl(private val remoteDataSource: UserRemoteDataSource) : UserRepository { override suspend fun getUserById(id: String): User { return remoteDataSource.fetchUserById(id) } }   3. Capa de Presentaci√≥n (UI \u0026amp; ViewModel) La capa de presentaci√≥n es responsable de la l√≥gica de UI y la gesti√≥n de estados. Depende de la capa de dominio, pero no interact√∫a directamente con la capa de datos.\nEjemplo: ViewModel 1 2 3 4 5 6 7 8 9 10 11  class UserViewModel(private val getUserByIdUseCase: GetUserByIdUseCase) : ViewModel() { private val _user = MutableStateFlow\u0026lt;User?\u0026gt;(null) val user: StateFlow\u0026lt;User?\u0026gt; get() = _user.asStateFlow() fun loadUser(id: String) { viewModelScope.launch { _user.value = getUserByIdUseCase(id) } } }   Mejores Pr√°cticas  Mant√©n la Capa de Dominio Pura: No debe depender de frameworks de Android. Usa Inyecci√≥n de Dependencias: Koin ayuda a gestionar las dependencias de manera limpia. Sigue la Regla de las Dependencias: Las capas internas no deben depender de las externas. Separa Interfaces e Implementaciones de Repositorios: Las interfaces van en la capa de dominio, las implementaciones en la capa de datos. Usa Fuentes de Datos: Encapsula llamadas a APIs y bases de datos en clases dedicadas. Modulariza tu C√≥digo: Usa m√≥dulos de Gradle para separar responsabilidades y mejorar los tiempos de compilaci√≥n.  Conclusi√≥n Clean Architecture proporciona una forma robusta de estructurar aplicaciones Android. Al separar responsabilidades y aplicar dependencias claras, el c√≥digo se vuelve m√°s testeable y escalable. Usar Koin para la inyecci√≥n de dependencias mejora a√∫n m√°s la mantenibilidad. Adoptar esta arquitectura, junto con modularizaci√≥n, resultar√° en una base de c√≥digo m√°s modular y resistente para tus proyectos en Kotlin.\n","description":"Clean Architecture en Kotlin \u0026 Android con ejemplos pr√°cticos","id":3,"section":"posts","tags":["kotlin","architecture"],"title":"Clean Architecture en Kotlin \u0026 Android","uri":"https://carrion.dev/es/posts/clean-architecture/"},{"content":"Explorando Arquitecturas de Apps en Kotlin: MVC, MVP, MVVM y MVI Introducci√≥n En el desarrollo moderno de aplicaciones, elegir la arquitectura adecuada es esencial para crear aplicaciones mantenibles y escalables. Las arquitecturas definen c√≥mo se organiza tu base de c√≥digo y c√≥mo interact√∫an los diferentes componentes. En este art√≠culo, exploraremos cuatro arquitecturas populares: Model-View-Controller (MVC), Model-View-Presenter (MVP), Model-View-ViewModel (MVVM) y Model-View-Intent (MVI). Analizaremos su estructura, ventajas, desventajas y ejemplos pr√°cticos en Kotlin.\n1. Model-View-Controller (MVC) Definici√≥n:\nMVC divide una aplicaci√≥n en tres componentes:\n Model: Gestiona los datos y la l√≥gica de negocio. View: Muestra los datos al usuario, accediendo directamente al Model para actualizaciones. Controller: Maneja la entrada del usuario y actualiza el Model.  Ventajas:\n Simple de implementar y entender. Eficaz para aplicaciones peque√±as o prototipos.  Desventajas:\n Acoplamiento estrecho entre la View y el Model. Separaci√≥n limitada de preocupaciones; escalar puede ser desafiante.  Ejemplo en Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // Model data class User(var name: String, var age: Int) // View class UserView { fun displayUser(user: User) { println(\u0026#34;Name: ${user.name}, Age: ${user.age}\u0026#34;) } } // Controller class UserController(private val model: User, private val view: UserView) { fun handleUserInput() { println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; model.name = newName // Directly updates the model  view.displayUser(model) } } fun main() { val user = User(\u0026#34;Alice\u0026#34;, 30) val view = UserView() val controller = UserController(user, view) view.displayUser(user) controller.handleUserInput() }   2. Model-View-Presenter (MVP) Definici√≥n:\nEn MVP, el Presenter act√∫a como mediador entre el Model y la View. A diferencia de MVC, la View es pasiva y delega toda la l√≥gica de interacci√≥n al Presenter, quien obtiene datos del Model y actualiza la View.\nVentajas:\n Mejor separaci√≥n de preocupaciones en comparaci√≥n con MVC. M√°s f√°cil de probar, ya que el Presenter maneja toda la l√≥gica.  Desventajas:\n Las clases de Presenter pueden volverse grandes (\u0026ldquo;clases Dios\u0026rdquo;). Manejar eventos del ciclo de vida puede ser desafiante.  Ejemplo en Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // Model data class User(val name: String, val age: Int) // View Interface interface UserView { fun displayUser(name: String, age: Int) } // Presenter class UserPresenter(private val view: UserView) { private var user = User(\u0026#34;Bob\u0026#34;, 25) fun loadUser() { view.displayUser(user.name, user.age) } fun updateUser() { println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; user = user.copy(name = newName) view.displayUser(user.name, user.age) } } // View Implementation class ConsoleUserView : UserView { override fun displayUser(name: String, age: Int) { println(\u0026#34;Name: $name, Age: $age\u0026#34;) } } fun main() { val view = ConsoleUserView() val presenter = UserPresenter(view) presenter.loadUser() presenter.updateUser() }   3. Model-View-ViewModel (MVVM) Definici√≥n:\nMVVM promueve un enfoque reactivo. El ViewModel proporciona datos a la View y reacciona a los cambios en el Model. A menudo utiliza LiveData o StateFlow de Kotlin.\nVentajas:\n Fomenta una clara separaci√≥n de preocupaciones. Excelente para programaci√≥n reactiva utilizando corutinas o flujos.  Desventajas:\n Requiere familiaridad con paradigmas reactivos. El enlace de datos o la gesti√≥n de estados puede agregar complejidad.  Ejemplo en Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // Model data class User(val name: String, val age: Int) // ViewModel class UserViewModel { private val _user = MutableStateFlow(User(\u0026#34;Charlie\u0026#34;, 28)) val user = _user.asStateFlow() fun updateUser(name: String) { _user.value = _user.value.copy(name = name) } } // View class UserView(private val viewModel: UserViewModel) { fun render() { viewModel.user.collect { user -\u0026gt; println(\u0026#34;Name: ${user.name}, Age: ${user.age}\u0026#34;) } } fun getUserInput(): String { println(\u0026#34;Enter new name for the user:\u0026#34;) return readLine() ?: \u0026#34;\u0026#34; } fun updateUserName() { val newName = getUserInput() viewModel.updateUser(newName) } } fun main() = runBlocking { val viewModel = UserViewModel() val view = UserView(viewModel) view.render() view.updateUserName() }   4. Model-View-Intent (MVI) Definici√≥n:\nMVI utiliza un flujo de datos unidireccional. La View env√≠a intenciones del usuario, el Model las procesa, y el estado se actualiza y es renderizado por la View.\nVentajas:\n Gesti√≥n de estado predecible. Fomenta la inmutabilidad y un flujo de datos claro.  Desventajas:\n Curva de aprendizaje pronunciada. Sobrecarga para aplicaciones simples.  Ejemplo en Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  // Model data class UserState(val name: String = \u0026#34;\u0026#34;, val age: Int = 0) // Intent sealed class UserIntent { object LoadUser : UserIntent() data class UpdateUser(val name: String) : UserIntent() } // Reducer fun userReducer(currentState: UserState, intent: UserIntent): UserState { return when (intent) { is UserIntent.LoadUser -\u0026gt; UserState(name = \u0026#34;Dave\u0026#34;, age = 40) is UserIntent.UpdateUser -\u0026gt; currentState.copy(name = intent.name) } } // ViewModel class UserViewModel { private val _state = MutableStateFlow(UserState()) val state: StateFlow\u0026lt;UserState\u0026gt; = _state fun processIntent(intent: UserIntent) { _state.update { currentState -\u0026gt; userReducer(currentState, intent) } } } // View class UserView(private val viewModel: UserViewModel) { fun render() { viewModel.state.collect { state -\u0026gt; println(\u0026#34;Name: ${state.name}, Age: ${state.age}\u0026#34;) } } fun sendIntent(intent: UserIntent) { viewModel.processIntent(intent) } } fun main() = runBlocking { val viewModel = UserViewModel() val view = UserView(viewModel) view.sendIntent(UserIntent.LoadUser) view.render() println(\u0026#34;Enter new name for the user:\u0026#34;) val newName = readLine() ?: \u0026#34;\u0026#34; view.sendIntent(UserIntent.UpdateUser(newName)) }   Conclusi√≥n Cada arquitectura tiene sus fortalezas y compromisos:\n MVC: Mejor para aplicaciones peque√±as y simples. MVP: Equilibra estructura y simplicidad. MVVM: Ideal para programaci√≥n reactiva. MVI: Excelente para la gesti√≥n de estado predecible y escalable.  Considera la complejidad y los requisitos de tu proyecto al elegir una arquitectura. ¬øCu√°l prefieres t√∫?\n","description":"Explorando Arquitecturas de Apps en Kotlin: MVC, MVP, MVVM y MVI","id":4,"section":"posts","tags":["kotlin","architecture"],"title":"Explorando Arquitecturas de Apps en Kotlin","uri":"https://carrion.dev/es/posts/app-architecture/"},{"content":"Explorando M√°s Patrones de Dise√±o en Kotlin: Parte 3  Part 1 Part 2 Part 3  En esta tercera entrega, cubriremos los patrones Memento, Command, Visitor, Chain of Responsibility y Mediator. Estos patrones abordan desaf√≠os de construcci√≥n, comportamiento y estructura, mostrando la sintaxis expresiva y las caracter√≠sticas modernas de Kotlin.\n1. Patr√≥n Memento El Patr√≥n Memento captura y restaura el estado de un objeto sin exponer sus detalles internos.\nCu√°ndo Usar  Para implementar funcionalidad de deshacer/rehacer.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  class Editor { var content: String = \u0026#34;\u0026#34; fun createMemento(): Memento = Memento(content) fun restore(memento: Memento) { content = memento.state } data class Memento(val state: String) } class History { private val mementos = mutableListOf\u0026lt;Editor.Memento\u0026gt;() fun save(memento: Editor.Memento) { mementos.add(memento) } fun pop(): Editor.Memento? { if (mementos.isNotEmpty()) { return mementos.removeAt(mementos.lastIndex) } return null } } fun main() { val editor = Editor() val history = History() editor.content = \u0026#34;First Version\u0026#34; history.save(editor.createMemento()) editor.content = \u0026#34;Second Version\u0026#34; history.save(editor.createMemento()) editor.content = \u0026#34;Third Version\u0026#34; println(\u0026#34;Current Content: ${editor.content}\u0026#34;) editor.restore(history.pop()!!) println(\u0026#34;Restored Content: ${editor.content}\u0026#34;) editor.restore(history.pop()!!) println(\u0026#34;Restored Content: ${editor.content}\u0026#34;) }   Por Qu√© Kotlin? La sintaxis concisa de Kotlin facilita la captura y restauraci√≥n de estados.\n2. Patr√≥n Command El Patr√≥n Command encapsula una solicitud como un objeto, permitiendo la parametrizaci√≥n y el encolado.\nCu√°ndo Usar  Para implementar operaciones deshacibles o colas de comandos.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  interface Command { fun execute() } class Light { fun on() = println(\u0026#34;Light is ON\u0026#34;) fun off() = println(\u0026#34;Light is OFF\u0026#34;) } class LightOnCommand(private val light: Light) : Command { override fun execute() = light.on() } class LightOffCommand(private val light: Light) : Command { override fun execute() = light.off() } fun main() { val light = Light() val commands = listOf(LightOnCommand(light), LightOffCommand(light)) commands.forEach { it.execute() } }   Por Qu√© Kotlin? El enfoque funcional de Kotlin puede simplificar a√∫n m√°s la ejecuci√≥n de comandos.\n3. Patr√≥n Visitor El Patr√≥n Visitor separa un algoritmo de la estructura de objetos sobre la que opera, moviendo el algoritmo a un objeto visitante.\nCu√°ndo Usar  Cuando necesitas realizar operaciones en un conjunto de objetos con tipos variados.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  interface Shape { fun accept(visitor: ShapeVisitor) } class Circle(val radius: Double) : Shape { override fun accept(visitor: ShapeVisitor) { visitor.visit(this) } } class Rectangle(val width: Double, val height: Double) : Shape { override fun accept(visitor: ShapeVisitor) { visitor.visit(this) } } fun interface ShapeVisitor { fun visit(shape: Shape) } fun main() { val shapes: List\u0026lt;Shape\u0026gt; = listOf(Circle(5.0), Rectangle(4.0, 6.0)) val visitor = ShapeVisitor { shape -\u0026gt; when (shape) { is Circle -\u0026gt; println(\u0026#34;Circle with radius ${shape.radius}\u0026#34;) is Rectangle -\u0026gt; println(\u0026#34;Rectangle with width ${shape.width}and height ${shape.height}\u0026#34;) } } shapes.forEach { it.accept(visitor) } }   Por Qu√© Kotlin? Las fun interface y las clases selladas de Kotlin simplifican la implementaci√≥n del visitante.\n4. Patr√≥n Chain of Responsibility El Patr√≥n Chain of Responsibility pasa una solicitud a lo largo de una cadena de manejadores hasta que uno la procesa.\nCu√°ndo Usar  Cuando m√∫ltiples objetos pueden manejar una solicitud y el handler se determina en tiempo de ejecuci√≥n.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  interface Handler { fun handle(request: String): Boolean } class AuthHandler(private val next: Handler?) : Handler { override fun handle(request: String): Boolean { println(\u0026#34;AuthHandler processing...\u0026#34;) return next?.handle(request) ?: true } } class LoggingHandler(private val next: Handler?) : Handler { override fun handle(request: String): Boolean { println(\u0026#34;LoggingHandler processing...\u0026#34;) return next?.handle(request) ?: true } } fun main() { val chain = AuthHandler(LoggingHandler(null)) chain.handle(\u0026#34;Request\u0026#34;) }   Por Qu√© Kotlin? Los tipos nulos de Kotlin y su delegaci√≥n concisa simplifican el encadenamiento de handlers.\n5. Patr√≥n Mediator El Patr√≥n Mediator centraliza la comunicaci√≥n compleja entre m√∫ltiples objetos haciendo que se comuniquen a trav√©s de un mediador.\nCu√°ndo Usar  Cuando los objetos interact√∫an de manera compleja, lo que lleva a dependencias enredadas.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class Mediator { private val colleagues = mutableListOf\u0026lt;Colleague\u0026gt;() fun addColleague(colleague: Colleague) { colleagues.add(colleague) } fun broadcast(sender: Colleague, message: String) { colleagues.filter { it != sender } .forEach { it.receive(message) } } } interface Colleague { fun send(message: String) fun receive(message: String) } class ConcreteColleague(private val mediator: Mediator) : Colleague { override fun send(message: String) { println(\u0026#34;Sending message: $message\u0026#34;) mediator.broadcast(this, message) } override fun receive(message: String) { println(\u0026#34;Received message: $message\u0026#34;) } } fun main() { val mediator = Mediator() val colleague1 = ConcreteColleague(mediator) val colleague2 = ConcreteColleague(mediator) mediator.addColleague(colleague1) mediator.addColleague(colleague2) colleague1.send(\u0026#34;Hello from Colleague 1\u0026#34;) }   Por Qu√© Kotlin? Las funciones de primera clase y las colecciones de Kotlin simplifican la difusi√≥n y la interacci√≥n.\nConclusi√≥n Estos patrones‚ÄîMemento, Command, Visitor, Chain of Responsibility y Mediator‚Äîdemuestran la capacidad de Kotlin para mejorar patrones de dise√±o cl√°sicos con caracter√≠sticas modernas.\n¬øCu√°l de estos patrones encuentras m√°s interesante? ¬°H√°zmelo saber! üöÄ\n","description":"Kotlin Design Patterns - Part 3","id":5,"section":"posts","tags":["kotlin","design-patterns","architecture"],"title":"Kotlin Design Patterns - Part 3","uri":"https://carrion.dev/es/posts/design-patterns-3/"},{"content":"Entendiendo los principios SOLID con ejemplos en Kotlin Los principios SOLID son un conjunto de principios de dise√±o que hacen que los dise√±os de software sean m√°s comprensibles, flexibles y mantenibles. Introducidos por Robert C. Martin, estos principios son una piedra angular de la programaci√≥n orientada a objetos y son especialmente relevantes al construir sistemas complejos. En este blog, exploraremos cada principio con ejemplos escritos en Kotlin, un lenguaje que ofrece una sintaxis moderna y caracter√≠sticas poderosas.\n1. Principio de Responsabilidad √önica (SRP) Una clase debe tener una, y solo una, raz√≥n para cambiar.\nEste principio asegura que una clase tenga una √∫nica responsabilidad, lo que la hace m√°s f√°cil de mantener y menos propensa a errores.\nRompiendo SRP:\n1 2 3 4 5 6 7 8 9 10 11  class ReportManager { fun generateReport(data: String): String { // L√≥gica para generar reporte  return \u0026#34;Report: $data\u0026#34; } fun saveReport(report: String) { // L√≥gica para guardar reporte  println(\u0026#34;Report saved: $report\u0026#34;) } }   En este ejemplo, la clase ReportManager viola el SRP porque tiene dos responsabilidades: generar y guardar reportes. Cualquier cambio en la l√≥gica de generaci√≥n o de guardado requerir√≠a modificar la misma clase.\nCorrigiendo SRP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class ReportGenerator { fun generateReport(data: String): String { // L√≥gica para generar reporte  return \u0026#34;Report: $data\u0026#34; } } class ReportSaver { fun saveReport(report: String) { // L√≥gica para guardar reporte  println(\u0026#34;Report saved: $report\u0026#34;) } } fun main() { val generator = ReportGenerator() val saver = ReportSaver() val report = generator.generateReport(\u0026#34;Sales Data\u0026#34;) saver.saveReport(report) }   Separando responsabilidades, hacemos que cada clase est√© enfocada y sea m√°s f√°cil de probar de manera independiente.\n2. Principio Abierto/Cerrado (OCP) Las entidades de software deben estar abiertas para extensi√≥n, pero cerradas para modificaci√≥n.\nPuedes a√±adir nueva funcionalidad extendiendo clases sin cambiar el c√≥digo existente.\nRompiendo OCP:\n1 2 3 4 5 6 7 8 9  class Discount { fun calculate(price: Double, type: String): Double { return when (type) { \u0026#34;none\u0026#34; -\u0026gt; price \u0026#34;percentage\u0026#34; -\u0026gt; price * 0.9 else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unknown discount type\u0026#34;) } } }   Aqu√≠, a√±adir un nuevo tipo de descuento requiere modificar el m√©todo calculate, lo que viola el OCP.\nCorrigiendo OCP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  interface DiscountStrategy { fun calculate(price: Double): Double } class NoDiscount : DiscountStrategy { override fun calculate(price: Double): Double = price } class PercentageDiscount(private val percentage: Double) : DiscountStrategy { override fun calculate(price: Double): Double = price * (1 - percentage / 100) } class DiscountCalculator(private val strategy: DiscountStrategy) { fun calculate(price: Double): Double = strategy.calculate(price) } fun main() { val noDiscount = DiscountCalculator(NoDiscount()) println(\u0026#34;Price after no discount: ${noDiscount.calculate(100.0)}\u0026#34;) val percentageDiscount = DiscountCalculator(PercentageDiscount(10.0)) println(\u0026#34;Price after 10% discount: ${percentageDiscount.calculate(100.0)}\u0026#34;) }   Usando interfaces y composici√≥n, logramos un dise√±o que est√° abierto a la extensi√≥n (nuevas estrategias de descuento) y cerrado a la modificaci√≥n (sin cambios en las clases existentes).\n3. Principio de Sustituci√≥n de Liskov (LSP) Los objetos de una superclase deben poder ser reemplazados con objetos de una subclase sin afectar la correcci√≥n del programa.\nEste principio asegura que las clases derivadas respeten las expectativas establecidas por su clase base.\nRompiendo LSP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  open class Bird { open fun fly() { println(\u0026#34;Flying\u0026#34;) } } class Sparrow : Bird() class Penguin : Bird() { override fun fly() { throw UnsupportedOperationException(\u0026#34;Penguins can\u0026#39;t fly\u0026#34;) } } fun main() { val birds: List\u0026lt;Bird\u0026gt; = listOf(Sparrow(), Penguin()) for (bird in birds) { bird.fly() // Esto fallar√° para Penguin  } }   En este ejemplo, Penguin viola LSP porque no puede cumplir el contrato de Bird. Una mejor aproximaci√≥n es refactorizar el dise√±o:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  interface Flyable { fun fly() } class Sparrow : Flyable { override fun fly() { println(\u0026#34;Flying\u0026#34;) } } class Penguin { fun swim() { println(\u0026#34;Swimming\u0026#34;) } }   Ahora, los comportamientos est√°n segregados, y se respeta el LSP.\n4. Principio de Segregaci√≥n de Interfaces (ISP) Los clientes no deber√≠an estar obligados a depender de m√©todos que no utilizan.\nEste principio promueve la creaci√≥n de interfaces espec√≠ficas en lugar de una √∫nica interfaz inflada.\nRompiendo ISP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Machine { fun print() fun scan() fun fax() } class OldPrinter : Machine { override fun print() { println(\u0026#34;Printing\u0026#34;) } override fun scan() { throw UnsupportedOperationException(\u0026#34;Scan not supported\u0026#34;) } override fun fax() { throw UnsupportedOperationException(\u0026#34;Fax not supported\u0026#34;) } }   Esta implementaci√≥n fuerza a OldPrinter a implementar m√©todos que no soporta, violando ISP.\nCorrigiendo ISP:\n1 2 3 4 5 6 7 8 9 10 11 12 13  interface Printer { fun print() } interface Scanner { fun scan() } class SimplePrinter : Printer { override fun print() { println(\u0026#34;Printing\u0026#34;) } }   Dividiendo las funcionalidades en interfaces separadas, permitimos que los dispositivos implementen solo lo que necesitan.\n5. Principio de Inversi√≥n de Dependencias (DIP) Los m√≥dulos de alto nivel no deben depender de m√≥dulos de bajo nivel. Ambos deben depender de abstracciones.\nEste principio reduce el acoplamiento entre los m√≥dulos de alto y bajo nivel al introducir abstracciones.\nRompiendo DIP:\n1 2 3 4 5 6 7 8 9 10 11 12 13  class EmailService { fun sendEmail(message: String) { println(\u0026#34;Sending Email: $message\u0026#34;) } } class NotificationSender { private val emailService = EmailService() fun notifyUser(message: String) { emailService.sendEmail(message) } }   Aqu√≠, NotificationSender est√° fuertemente acoplado a EmailService, lo que dificulta cambiar a un servicio de notificaci√≥n diferente.\nCorrigiendo DIP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  interface NotificationService { fun sendNotification(message: String) } class EmailService : NotificationService { override fun sendNotification(message: String) { println(\u0026#34;Sending Email: $message\u0026#34;) } } class SMSService : NotificationService { override fun sendNotification(message: String) { println(\u0026#34;Sending SMS: $message\u0026#34;) } } class NotificationSender(private val service: NotificationService) { fun notifyUser(message: String) { service.sendNotification(message) } } fun main() { val emailSender = NotificationSender(EmailService()) emailSender.notifyUser(\u0026#34;Hello via Email\u0026#34;) val smsSender = NotificationSender(SMSService()) smsSender.notifyUser(\u0026#34;Hello via SMS\u0026#34;) }   Aqu√≠, NotificationSender depende de la abstracci√≥n NotificationService, haci√©ndolo flexible para trabajar con cualquier tipo de notificaci√≥n.\nConclusi√≥n Los principios SOLID forman la base para construir software robusto y escalable. Kotlin, con su sintaxis expresiva y caracter√≠sticas modernas, permite a los desarrolladores implementar estos principios de manera elegante. Al adherirse a estos principios, puedes crear c√≥digo que sea m√°s f√°cil de mantener, extender y adaptar a los cambios en los requisitos.\n","description":"Principios SOLID explicados con ejemplos de Kotlin.","id":6,"section":"posts","tags":["kotlin","solid","architecture"],"title":"Entendiendo los principios SOLID con ejemplos en Kotlin","uri":"https://carrion.dev/es/posts/solid-kotlin/"},{"content":"Explorando patrones de dise√±o en Kotlin: Parte2 Design Patterns Series  Part 1 Part 2 Part 3  Despu√©s de la gran acogida del primer art√≠culo Patrones de dise√±o en Kotlin, volvemos con m√°s! En esta segunda parte, revisaremos los patrones de Prototype, Composite, Proxy, Observer, y Strategy. Estos patrones resuelven una variedad de desafios de dise√±o y demuestran las capacidades expresivas de Kotlin.\n1. Patr√≥n Prototype El Patr√≥n Prototype es usado para crear nuevos objeto copiando una objeto existente, asegurando la creaci√≥n eficaz de objetos.\nCuando usarlo  Cuando crear una nueva instancia es complejo o costoso. Para evitar crear instancias de subclases de forma repetida.  Implementaci√≥n en Kotlin Usar las clases data de Kotlin y su funci√≥n copy simplifica este patr√≥n.\n1 2 3 4 5 6 7 8 9  data class Document(var title: String, var content: String, var author: String) fun main() { val original = Document(\u0026#34;Design Patterns\u0026#34;, \u0026#34;Content about patterns\u0026#34;, \u0026#34;John Doe\u0026#34;) val copy = original.copy(title = \u0026#34;Prototype Pattern\u0026#34;) println(\u0026#34;Original: $original\u0026#34;) println(\u0026#34;Copy: $copy\u0026#34;) }   Por qu√© Kotlin? Las clases data de Kotlin soportan de forma nativa copiar los objetos con c√≥digo m√≠nimo, haciendo que aplicar el patr√≥n Prototype sea muy sencillo.\n2. Patr√≥n Composite El Patr√≥n Composite es usado para tratar objetos individuales y grupos de forma uniforme.\nCuando usarlo  Cuando tienes una estructura en √°rbol y quieres manipularlo de una forma consistente.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  interface Logger { fun log(message: String) } class ConsoleLogger : Logger { override fun log(message: String) { println(message) } } class FileLogger(private val filePath: String) : Logger { override fun log(message: String) { // Implementation for writing logs to a file  } } class RootLogger(private val loggers: List\u0026lt;Logger\u0026gt;) : Logger { override fun log(message: String) { loggers.forEach { it.log(message) } } } fun main() { val consoleLogger = ConsoleLogger() val fileLogger = FileLogger(\u0026#34;/path/to/log.txt\u0026#34;) val rootLogger = RootLogger(listOf(consoleLogger, fileLogger)) rootLogger.log(\u0026#34;Composite Pattern Example\u0026#34;) }   3. Patr√≥n Proxy El Patr√≥n Proxy sirve de puerta de entrada para controlar el acceso a otro objeto.\nCuando utilizarlo  Para controlar el acceso a otro recurso. Para a√±adir funcionalidad sin modificar el objeto existente.  Kotlin Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Service { fun fetchData(): String } class RealService : Service { override fun fetchData() = \u0026#34;Data from Real Service\u0026#34; } class ProxyService(private val realService: RealService) : Service { override fun fetchData(): String { println(\u0026#34;Proxy: Checking access before delegating.\u0026#34;) return realService.fetchData() } } fun main() { val proxy = ProxyService(RealService()) println(proxy.fetchData()) }   4. Patr√≥n Observer El Patr√≥n Observer define una dependencia de uno-a-muchos, por lo que cuando un objeto cambia su estado, todos los que dependen de el son notificados.\nCuando utilizarlo  Para sistemas dirigidos por eventos. Cuando m√∫ltiples componentes necesitan reaccionar a cambios de estado.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  fun interface StateChangeListener { fun onStateChanged(oldState: String, newState: String) } class Subject { private val listeners = mutableListOf\u0026lt;StateChangeListener\u0026gt;() var state: String by Delegates.observable(\u0026#34;Initial State\u0026#34;) { _, old, new -\u0026gt; listeners.forEach { it.onStateChanged(old, new) } } fun addListener(listener: StateChangeListener) { listeners.add(listener) } } fun main() { val subject = Subject() subject.addListener { oldState, newState -\u0026gt; println(\u0026#34;Listener 1: State changed from \u0026#39;$oldState\u0026#39; to \u0026#39;$newState\u0026#39;\u0026#34;) } subject.addListener { oldState, newState -\u0026gt; println(\u0026#34;Listener 2: State changed from \u0026#39;$oldState\u0026#39; to \u0026#39;$newState\u0026#39;\u0026#34;) } subject.state = \u0026#34;State 1\u0026#34; subject.state = \u0026#34;State 2\u0026#34; }   Por qu√© Kotlin? Usar fun interface simplifica la implementaci√≥n de interfaces con un s√≥lo m√©todo. De forma adicional, los Delegates.observable de Kotlin hace que observar cambios de estado sea m√°s directo, facilitando la implementaci√≥n del patr√≥n Observer.\n5. Patr√≥n Strategy El Patr√≥n Strategy define una seria de algoritmos, encapsula cada uno de ellos, y luego los hace intercambiables.\nCuando utilizar  Cuando necesitas vaerios algoritmos para una tarea en concreto.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  interface PaymentStrategy { fun pay(amount: Double) } class CreditCardPayment : PaymentStrategy { override fun pay(amount: Double) = println(\u0026#34;Paid $$amountusing Credit Card.\u0026#34;) } class PayPalPayment : PaymentStrategy { override fun pay(amount: Double) = println(\u0026#34;Paid $$amountusing PayPal.\u0026#34;) } class PaymentContext(private var strategy: PaymentStrategy) { fun setStrategy(strategy: PaymentStrategy) { this.strategy = strategy } fun executePayment(amount: Double) = strategy.pay(amount) } fun main() { val context = PaymentContext(CreditCardPayment()) context.executePayment(100.0) context.setStrategy(PayPalPayment()) context.executePayment(200.0) }   Conclusi√≥n Con Kotlin, los patrones de dise√±o como Prototype, Composite, Proxy, Observer, y Strategy se vuelven m√°s intuitivos. Estos patrones no son solo herramientas, son los fundamentos para un c√≥digo m√°s claro y mantenible.\n","description":"Kotlin Patrones de dise√±o - Parte 2","id":7,"section":"posts","tags":["kotlin","design-patterns","architecture"],"title":"Patrones de dise√±o en Kotlin - Parte 2","uri":"https://carrion.dev/es/posts/design-patterns-2/"},{"content":"Usando Koin en Compose Multiplatform La inyecci√≥n de dependencias es algo imprescindible para crear aplicaciones escalables, y Koin hace que sea muy sencillo, incluso en proyectos con Compose Multiplatform. Con la nueva funci√≥n composable KoinApplication, puedes inicializar Koin directamente desde el c√≥digo com√∫n, reduciendo la cantidad de c√≥digo necesario mientras se mantiene la flexibilidad de configurar cada plataforma por separado. Vamos a ver un ejemplo.\nProject Setup Empieza creando un proyecto de Compose Multiplatform usando el KMP Wizard, seleccionando Android, iOS, Desktop y Web como plataformas. Para este ejemplo no vamos a incluir Server como plataforma.\nA√±adiendo las dependencias Usa el version catalog de Gradle para incluir las dependencias necesarias de Koin en libs.versions.toml:\n1 2 3 4 5 6 7 8 9  [versions] koin-bom = \u0026#34;4.1.0-Beta1\u0026#34; [libraries] koin-bom = { module = \u0026#34;io.insert-koin:koin-bom\u0026#34;, version.ref = \u0026#34;koin-bom\u0026#34; } koin-core = { module = \u0026#34;io.insert-koin:koin-core\u0026#34; } koin-android = { module = \u0026#34;io.insert-koin:koin-android\u0026#34; } koin-compose = { module = \u0026#34;io.insert-koin:koin-compose\u0026#34; } koin-compose-viewModel = { module = \u0026#34;io.insert-koin:koin-compose-viewmodel\u0026#34; }   Definiendo los m√≥dulos de Koin Vamos a crear dos m√≥dulos de Koin: appModule y platformModule. El platformModule define las dependencias espec√≠ficas de cada plataforma.\nM√≥dulos compartidos 1 2 3 4 5 6 7 8 9 10 11 12  val appModule = module { viewModelOf(::MainViewModel) factoryOf(::GetJokeUseCase) singleOf(::DefaultJokeRepository) bind JokeRepository::class singleOf(::JokeJsonDataSource) bind JokeDataSource::class single { Json { ignoreUnknownKeys = true } } } val Module.localPreferencesDefinition get() = singleOf(::InMemoryLocalPreferences) bind LocalPreferences::class expect val platformModule: Module   M√≥dulos espec√≠ficos de cada plataforma Para Android vamos a usar una implementaci√≥n de la interfaz de LocalPreferences que depende del contexto de Android por lo que necesitamos un m√≥dulo distinto al resto de plataformas:\n1 2 3 4  actual val platformModule: Module get() = module { singleOf(::AndroidPreferences) bind LocalPreferences::class }   Para iOS, Desktop y Web, reutilizaremos la localPreferencesDefinition que se puede ver m√°s arriba:\n1 2 3 4  actual val platformModule: Module get() = module { localPreferencesDefinition }   Configurando la App En el archivo App.kt, podemos usar la funci√≥n composable KoinApplication. A√±adiendo el par√°metro KoinAppDeclaration como opcional y con valor por defecto a null.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Composable @Preview fun App(koinAppDeclaration: KoinAppDeclaration? = null) { KoinApplication( application = { koinAppDeclaration?.invoke(this) modules(appModule, platformModule) } ) { MaterialTheme { MainScreen() } } }   En Android, usamos la lambda para proveer el contexto y activar el logging:\n1 2 3 4 5 6 7 8 9 10 11  class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { App { androidLogger(Level.DEBUG) androidContext(this@MainActivity) } } } }   Esta flexibilidad nos asegura configuraciones espec√≠ficas por plataforma, como inyectar el contexto de Android, sin afectar al resto de plataformas.\nCorriendo la App Compila la aplicaci√≥n en cada plataforma. Podr√°s probar que todo est√° funcionando y cada plataforma recibe la configuraci√≥n que necesita para funcionar.\nConclusi√≥n La nueva funci√≥n composable KoinApplication simplifica la inyecci√≥n de dependencias en Compose Multiplatform permitiendo inizializar Koin de forma compartida manteniendo la posibilidad de configurar cada plataforma por separado si fuera necesario. Esta forma de proceder reduce el c√≥digo necesario y promueve la reusabilidad del c√≥digo entre plataformas.\nPuedes descargar el c√≥digo completo para este ejemplo en GitHub.\nTambi√©n si necesitas m√°s informaci√≥n acerca de las diferentes opciones para declarar dependencias en Koin puedes visitar un post que publiqu√© en LinkedIn: Koin DSL\n","description":"Usando Koin en Compose Multiplatform desde el c√≥digo com√∫n con posibilidad de configurar cada una de las plataformas.","id":8,"section":"posts","tags":["kotlin","multiplatform","cmp","compose","koin"],"title":"Usando Koin en Compose Multiplatform","uri":"https://carrion.dev/es/posts/koin-cmp/"},{"content":"Explorando patrones de dise√±o en Kotlin - Parte 1 Serie Patrones de dise√±o Design Patterns Series  Part 1 Part 2 Part 3  Los patrones de dise√±o son soluciones probadas a problemas comunes en el dise√±o de software. Con la sintaxis y funcionalidades modernas de Kotlin, implementar estos patrones normalmente resulta m√°s limpio y conciso. En este post, exploraremos los patrones de Singleton, Factory Method, Builder, Adapter and Decorator, profundizando en su prop√≥sito, casos de uso y implementaciones en Kotlin.\n1. Patr√≥n Singleton El Patr√≥n Singleton asegura que una clase tiene solo una instancia y provee un punto de acceso global a ella.\nCuando utilizar  Al manejar recursos compartidos como conexiones a bases de datos.  Implementaci√≥n en Kotlin La palabra reservada de Kotlin object provee una forma r√°pida de crear un Singleton.\n1 2 3 4 5  object DatabaseConnection { fun connect() { println(\u0026#34;Connecting to database...\u0026#34;) } }   Uso 1 2 3  fun main() { DatabaseConnection.connect() }   Ventajas en Kotlin  Por defecto es Thread-safe. Requiere un c√≥digo m√≠nimo comparado con implementaciones tradicionales en otros lenguajes.  2. Patr√≥n Factory Method El Patr√≥n Factory Method delega la creaci√≥n de objectos a clases o funciones, lo que provee de flexibilidad a la hora de instanciar los objetos.\nCuando utilizarlo  Cuando crear los objetos requiere de l√≥gica o tiene complejidad. Para desacoplar la creaci√≥n del objeto del c√≥digo del cliente.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  interface Shape { fun draw() } class Circle : Shape { override fun draw() = println(\u0026#34;Drawing a Circle\u0026#34;) } class Rectangle : Shape { override fun draw() = println(\u0026#34;Drawing a Rectangle\u0026#34;) } object ShapeFactory { fun createShape(type: String): Shape = when (type) { \u0026#34;Circle\u0026#34; -\u0026gt; Circle() \u0026#34;Rectangle\u0026#34; -\u0026gt; Rectangle() else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unknown shape type\u0026#34;) } }   Uso 1 2 3 4  fun main() { val shape = ShapeFactory.createShape(\u0026#34;Circle\u0026#34;) shape.draw() }   3. Patr√≥n Builder El Patr√≥n Builder es usado para construir objetos complejos paso a paso. Es especialmente √∫til cuando un objeto tiene muchos par√°metros opcionales o configuraciones distintas.\nCuando utilizar  Para evitar constructores con demasiados par√°metros. Cuando el proceso de contrucci√≥n del objeto es complejo o incluye multiples pasos.  Implementaci√≥n en Kotlin En Kotlin el uso de apply o las capacidades de DSL simplifican el patr√≥n Builder.\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Car(val make: String, val model: String, val year: Int) { class Builder { private var make = \u0026#34;\u0026#34; private var model = \u0026#34;\u0026#34; private var year = 0 fun make(make: String) = apply { this.make = make } fun model(model: String) = apply { this.model = model } fun year(year: Int) = apply { this.year = year } fun build() = Car(make, model, year) } }   Uso 1 2 3 4 5 6 7 8 9  fun main() { val car = Car.Builder() .make(\u0026#34;Toyota\u0026#34;) .model(\u0026#34;Corolla\u0026#34;) .year(2022) .build() println(\u0026#34;${car.make}${car.model}, ${car.year}\u0026#34;) }   ** Por qu√© en Kotlin?** Enlazar m√©todos con apply permite una sintaxis m√°s concisa y expresiva cuando se construye objetos.\n4. Patr√≥n Adapter El Patr√≥n Adapter es usado para hacer de puente entre interfaces que no son compatibles traduciendo una interfaz a la otra.\nCuando utilizar  Cuando se integra nuevo c√≥digo con c√≥digo antiguo o librer√≠as externas. Cuando dos sistemas o componentes necesitan trabajar en conjunto pero tienen interfaces incompatibles.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // Existing integer provider interface interface OldProvider { fun provide(): Int } class RandomIntProvider : OldProvider { override fun provide(): Int = (1..100).random() } // Target string provider interface interface NewProvider { fun provide(): String } // Adapter class class OldToNewProviderAdapter(private val intProvider: OldProvider) : NewProvider { override fun provide(): String = \u0026#34;Provided number: ${intProvider.provide()}\u0026#34; }   Uso 1 2 3 4 5 6  fun main() { val intProvider = RandomIntProvider() val stringProvider: NewProvider = OldToNewProviderAdapter(intProvider) println(stringProvider.provideString()) }   Por qu√© en Kotlin? Los constructores primaries de Kotlin y la sintaxis concisa simplifican la implementaci√≥n de clases de tipo wrapper.\n5. Patr√≥n Decorator El Patr√≥n Decorator a√±ade din√°micamente comportamientos a los objetos sin alterar su estructura.\nCuando usarlo  Para extender la funcionalidad de una clase en tiempo de ejecuci√≥n. Cuando heredar llevar√≠a a una jerarqu√≠a sobrecargada.  Implementaci√≥n en Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14  interface Coffee { fun cost(): Double fun description(): String } class SimpleCoffee : Coffee { override fun cost() = 5.0 override fun description() = \u0026#34;Simple Coffee\u0026#34; } class MilkDecorator(private val coffee: Coffee) : Coffee { override fun cost() = coffee.cost() + 1.5 override fun description() = coffee.description() + \u0026#34;, Milk\u0026#34; }   Uso 1 2 3 4 5 6  fun main() { val coffee = SimpleCoffee() val coffeeWithMilk = MilkDecorator(coffee) println(\u0026#34;${coffeeWithMilk.description()}costs \\$${coffeeWithMilk.cost()}\u0026#34;) }   Conclusi√≥n Las funcionalidades modernas de Kotlin como object, when y apply hacen que implementar los patrones de dise√±o tradicionales sea m√°s f√°cil y expresivo. Estos patrones no solo resuelven desaf√≠os comunes de dise√±o si no que demuestran como Kotlin mejora su implementaci√≥n.\nHay otros patrones de dise√±o que te gustaria que cubriera en futuros posts?\n","description":"Kotlin Patrones de dise√±o - Parte 1","id":9,"section":"posts","tags":["kotlin","design-patterns","architecture"],"title":"Patrones de dise√±o en Kotlin - Parte 1","uri":"https://carrion.dev/es/posts/design-patterns-1/"},{"content":"Explorando Kotlin Symbol Processing (KSP) con ejemplos pr√°cticos Kotlin Symbol Processing (KSP) es una herramienta muy potente usada para simplificar el procesamiento de anotaciones en Kotlin. Comparado con kapt (Kotlin Annotation Processing Tool), KSP es m√°s r√°pido, ofrece mejor integraci√≥n con Kotlin y reduce los tiempos de compilaci√≥n de forma significativa. En este post, exploraremos los fundamentos de KSP, discutiremos c√≥mo funciona y mostraremos como su uso en librer√≠as populares como Koin y Room.\nQu√© es KSP? KSP es una API ligera y eficiente para procesar c√≥digo Kotlin. Permite crear procesadores de anotaciones que funcionan directamente con la sintaxis de Kotlin en lugar de depender de herramientas basadas en Java. Esto lo convierte en una opci√≥n ideal para proyectos orientados a Kotlin.\nBeneficios de KSP:  Velocidad: Procesa c√≥digo Kotlin m√°s r√°pido que kapt. Dise√±o centrado en Kotlin: Funciona directamente con los constructos del lenguaje Kotlin, evitando abstracciones basadas en Java. Ligero: Reduce el c√≥digo repetitivo y se integra perfectamente con Gradle. Compatibilidad: Muchas bibliotecas populares ahora son compatibles con KSP de manera nativa.  Setting Up KSP in Your Project Agrega el plugin de KSP a tu proyecto\nConfiguraci√≥n de Gradle 1 2 3 4 5 6 7 8 9 10 11 12 13  plugins { kotlin(\u0026#34;jvm\u0026#34;) version \u0026#34;\u0026lt;latest-kotlin-version\u0026gt;\u0026#34; id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;\u0026lt;latest-ksp-version\u0026gt;\u0026#34; } repositories { mavenCentral() } dependencies { implementation(kotlin(\u0026#34;stdlib\u0026#34;)) ksp(\u0026#34;\u0026lt;ksp-processor-library\u0026gt;\u0026#34;) }   Reemplaza \u0026lt;ksp-processor-library\u0026gt; con la dependencia del procesador espec√≠fico de la biblioteca, como se muestra en los ejemplos a continuaci√≥n.\nEjemplo 1: KSP con las anotaciones de Koin Koin desde la versi√≥n 3.4.0, permite definir dependencias a trav√©s de anotaciones, que luego son procesadas usando KSP para generar los m√≥dulos de Koin.\nConfiguraci√≥n de Koin con KSP A√±ade las siguientes dependencias:\n1 2 3 4 5  dependencies { implementation(\u0026#34;io.insert-koin:koin-core:\u0026lt;version\u0026gt;\u0026#34;) implementation(\u0026#34;io.insert-koin:koin-annotations:\u0026lt;version\u0026gt;\u0026#34;) ksp(\u0026#34;io.insert-koin:koin-ksp-compiler:\u0026lt;version\u0026gt;\u0026#34;) }   Anota las clases Usa las anotaciones de Koin para definir tu grafo de dependencias:\n1 2 3 4 5 6 7 8 9  @Module @ComponentScan class AppModule @Single class UserRepository @Factory class UserUseCase(private val userRepository: UserRepository)   M√≥dulo generado El procesador de KSP genera autom√°ticamente un m√≥dulo de Koin. Puedes incluirlo en la configuraci√≥n de tu aplicaci√≥n:\n1 2 3 4 5  fun main() { startKoin { modules(AppModuleModule().module) } }   Esto elimina la necesidad de escribir manualmente el m√≥dulo de Koin, ahorrando tiempo y reduciendo el c√≥digo repetitivo.\nExample 2: KSP con base de datos Room Room es un ORM ampliamente utilizado para Android. Con KSP, Room procesa anotaciones m√°s r√°pidamente, reduciendo significativamente los tiempos de compilaci√≥n\nConfiguraci√≥n de Room con KSP Agrega las siguientes dependencias:\n1 2 3 4  dependencies { implementation(\u0026#34;androidx.room:room-runtime:\u0026lt;version\u0026gt;\u0026#34;) ksp(\u0026#34;androidx.room:room-compiler:\u0026lt;version\u0026gt;\u0026#34;) }   Anota las entidades 1 2 3 4 5  @Entity data class User( @PrimaryKey val id: Int, val name: String )   Generar DAO y Base de Datos 1 2 3 4 5 6 7 8 9 10  @Dao interface UserDao { @Query(\u0026#34;SELECT * FROM User\u0026#34;) fun getAllUsers(): List\u0026lt;User\u0026gt; } @Database(entities = [User::class], version = 1) abstract class AppDatabase : RoomDatabase() { abstract fun userDao(): UserDao }   Usando KSP, Room genera el c√≥digo necesario de forma autom√°tica, reduciendo el c√≥digo repetitivo.\nComo crear un procesador KSP personalizado Construyamos un procesador KSP personalizado que genere una clase Builder para clases de datos anotadas con @GenerateBuilder.\nCrear el m√≥dulo Primero, debes crear un m√≥dulo con la API para KSP.\n1 2 3  dependencies { implementation(\u0026#34;com.google.devtools.ksp:symbol-processing-api:\u0026lt;version\u0026gt;\u0026#34;) }   Definir la anotaci√≥n 1 2 3  @Target(AnnotationTarget.CLASS) @Retention(AnnotationRetention.SOURCE) annotation class GenerateBuilder   L√≥gica del procesador KSP El procesador puede generar din√°micamente una clase Builder basada en las propiedades de la data class con la anotaci√≥n. Necesitas crear una clase que extienda SymbolProcessor donde todo el trabajo se realizar√° en la funci√≥n process, y una clase extendiendo SymbolProcessorProvider, que proveer√° de la implementaci√≥n del SymbolProcessor.\nAqu√≠ la implementaci√≥n de SymbolProcessor:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  class KspBuilderProcessor( private val codeGenerator: CodeGenerator ) : SymbolProcessor { override fun process(resolver: Resolver): List\u0026lt;KSAnnotated\u0026gt; { val symbols = resolver.getSymbolsWithAnnotation(GenerateBuilder::class.qualifiedName.toString()) .filterIsInstance\u0026lt;KSClassDeclaration\u0026gt;() symbols.forEach { symbol -\u0026gt; val className = symbol.simpleName.asString() val packageName = symbol.packageName.asString() val generatedClassName = \u0026#34;${className}Builder\u0026#34; val file = codeGenerator.createNewFile( dependencies = Dependencies(false, symbol.containingFile!!), packageName = packageName, fileName = generatedClassName ) val properties = symbol.getAllProperties() val builderProperties = mutableListOf\u0026lt;String\u0026gt;() val setters = mutableListOf\u0026lt;String\u0026gt;() val buildMethodParams = mutableListOf\u0026lt;String\u0026gt;() properties.forEach { property -\u0026gt; val propName = property.simpleName.asString() val propType = property.type.resolve().declaration.simpleName.asString() .let { if (property.type.resolve().isMarkedNullable) \u0026#34;$it?\u0026#34; else it } val defaultValue = getDefaultValueFromProperty(property) builderProperties.add(\u0026#34; private var $propName: $propType= $defaultValue\u0026#34;) setters.add(\u0026#34; fun set${propName.replaceFirstChar { it.uppercase() }}($propName: $propType) = apply { this.$propName= $propName}\u0026#34;) buildMethodParams.add(\u0026#34; $propName= this.$propName\u0026#34;) } val builderClass = buildString { appendLine(\u0026#34;package $packageName\u0026#34;) appendLine() appendLine(\u0026#34;class $generatedClassName{\u0026#34;) builderProperties.forEach { property -\u0026gt; appendLine(property) } appendLine() setters.forEach { setter -\u0026gt; appendLine(setter) } appendLine() appendLine(\u0026#34; fun build(): $className{\u0026#34;) appendLine(\u0026#34; return $className(\u0026#34;) buildMethodParams.forEach { methodParam -\u0026gt; appendLine(methodParam) } appendLine(\u0026#34; )\u0026#34;) appendLine(\u0026#34; }\u0026#34;) appendLine(\u0026#34;}\u0026#34;) appendLine() appendLine(\u0026#34;fun ${generatedClassName.replaceFirstChar { it.lowercase() }}(block: $generatedClassName.() -\u0026gt; Unit): $className{\u0026#34;) appendLine(\u0026#34; return $generatedClassName().apply(block).build()\u0026#34;) appendLine(\u0026#34;}\u0026#34;) } file.write(builderClass.toByteArray()) file.close() } return symbols.filterNot { it.validate() }.toList() } private fun getDefaultValueFromProperty(property: KSPropertyDeclaration): String { val propType = property.type.resolve().declaration.qualifiedName?.asString() ?: \u0026#34;Any\u0026#34; val isNullable = property.type.resolve().isMarkedNullable return if (isNullable) \u0026#34;null\u0026#34; else when (propType) { \u0026#34;kotlin.String\u0026#34; -\u0026gt; \u0026#34;\\\u0026#34;\\\u0026#34;\u0026#34; \u0026#34;kotlin.Int\u0026#34;, \u0026#34;kotlin.Long\u0026#34;, \u0026#34;kotlin.Short\u0026#34;, \u0026#34;kotlin.Byte\u0026#34; -\u0026gt; \u0026#34;0\u0026#34; \u0026#34;kotlin.Double\u0026#34;, \u0026#34;kotlin.Float\u0026#34; -\u0026gt; \u0026#34;0.0\u0026#34; \u0026#34;kotlin.Boolean\u0026#34; -\u0026gt; \u0026#34;false\u0026#34; else -\u0026gt; throw IllegalArgumentException(\u0026#34;Non-nullable type $propTyperequires a default value\u0026#34;) } } }   Y aqu√≠ la clase que extiende de SymbolProcessorProvider:\n1 2 3 4 5  class KspBuilderProvider : SymbolProcessorProvider { override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor { return KspBuilderProcessor(environment.codeGenerator) } }   Con estas dos clases ya solo falta crear un fichero con ruta src/main/resources/META-INF/services y nombre com.google.devtools.ksp.processing.SymbolProcessorProvider. Su contenido ser√° el nombre completo de la clase que extiende de SymbolProcessorProvider que acabas de crear. En este caso quedar√≠a as√≠:\ncom.example.kspbuilder.KspBuilderProvider Usando el procesador KSP personalizado Agregar el procesador personalizado A√±ade el plugin KSP al fichero build.gradle.kts en el m√≥dulo donde quieres utilizar la anotaci√≥n:\n1 2 3 4 5 6 7 8  plugins { id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;\u0026lt;version\u0026gt;\u0026#34; } dependencies { implementation(project(\u0026#34;:KspBuilder\u0026#34;)) ksp(project(\u0026#34;:KspBuilder\u0026#34;)) }   Anotar la clase Crea una data class con la anotaci√≥n:\n1 2 3 4 5  @GenerateBuilder class Person(val id: Int, val name: String, val age: Int, val address: Address?) @GenerateBuilder class Address(val id: Int, val name: String, val country: String)   C√≥digo generado Despu√©s de compilar el proyecto, el c√≥digo generado con KSP se localiza en el directorio build/generated/ksp.\nPara la data class Person, la clase builder generada se ve as√≠:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class PersonBuilder { private var id: Int = 0 private var name: String = \u0026#34;\u0026#34; private var age: Int = 0 private var address: Address? = null fun setId(id: Int) = apply { this.id = id } fun setName(name: String) = apply { this.name = name } fun setAge(age: Int) = apply { this.age = age } fun setAddress(address: Address?) = apply { this.address = address } fun build(): Person { return Person( id = this.id, name = this.name, age = this.age, address = this.address ) } } fun personBuilder(block: PersonBuilder.() -\u0026gt; Unit): Person { return PersonBuilder().apply(block).build() }   Para la data class Address, la clase builder generada ser√≠a as√≠:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class AddressBuilder { private var id: Int = 0 private var name: String = \u0026#34;\u0026#34; private var country: String = \u0026#34;\u0026#34; fun setId(id: Int) = apply { this.id = id } fun setName(name: String) = apply { this.name = name } fun setCountry(country: String) = apply { this.country = country } fun build(): Address { return Address( id = this.id, name = this.name, country = this.country ) } } fun addressBuilder(block: AddressBuilder.() -\u0026gt; Unit): Address { return AddressBuilder().apply(block).build() }   Ejemplo de uso 1 2 3 4 5 6 7 8 9 10 11 12  val person = personBuilder { setId(10) setName(\u0026#34;Test\u0026#34;) setAge(100) setAddress( addressBuilder { setId(10) setName(\u0026#34;AddressTest\u0026#34;) setCountry(\u0026#34;Spain\u0026#34;) } ) }   Conclusi√≥n KSp es una herramienta muy importante para los desarrolladores Kotlin. Su dise√±o ligero y centrado en Kotlin hace que sea un reemplazo perfecto de kapt, su habilidad para generar c√≥digo din√°micamente abre un gran abanico de posibilidades. Tanto si usas KSP con librer√≠as como Koin y Room o creas tu propio procesador para tu caso de uso, KSP brinda las herramientas necesarias para elevar tu desarrollo al siguiente nivel.\nIntenta integrar KSP en tu pr√≥ximo proyecto y observa los beneficios de primera mano!\nAqu√≠ dejo el repositorio con el c√≥digo utilizado para crear el procesador KSP personalizado Github Repo\n","description":"Kotlin Avanzado - Kotlin Symbol Processing (KSP)","id":10,"section":"posts","tags":["kotlin","android","advanced"],"title":"Explorando Kotlin KSP","uri":"https://carrion.dev/es/posts/kotlin-ksp/"},{"content":"Explorando las funciones Infix en Kotlin Kotlin, es un lenguaje de programaci√≥n moderno con funcionalidades que permiten escribir un c√≥digo m√°s expresivo y conciso. Una de estas funcionalidades son las infix functions, que permiten escribir c√≥digo m√°s limpio y legible. En este post, exploraremos que son las funciones infix, como usarlas y algunos ejemplo pr√°cticos.\nQu√© son las funciones Infix? Las funciones infix en Kotlin son un tipo especial de funci√≥n que pueden ser llamadas sin el uso de par√©ntesis o el punto. Esto puede hacer que ciertos patrones de c√≥digo se lean de forma m√°s natural, asemej√°ndose a la sintaxis tradicional relacionada con matem√°ticas o DSL.\nEste ser√≠a un ejemplo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Point(val x: Int, val y: Int) { infix fun moveBy(offset: Point): Point { return Point(this.x + offset.x, this.y + offset.y) } } fun main() { val point1 = Point(2, 3) val offset = Point(1, 1) // Using the infix notation  val newPoint = point1 moveBy offset println(\u0026#34;New Point: (\\${newPoint.x}, \\${newPoint.y})\u0026#34;) }   En este ejemplo, la funci√≥n moveBy se llama usando la notaci√≥n infix, mejorando la legibilidad.\nReglas y sintaxis Aqu√≠ estan unos puntos clave acerca de las funciones infix:\n Solo un par√°metro: La funci√≥n debe recibir ex√°ctamente un par√°metro. Miembros de clase o funciones de extensi√≥n: Debe estar definida como una funci√≥n de clase o una funci√≥n de extensi√≥n. No Varargs or argumentos por defecto: El par√°metro no puede tener valores por defecto o ser un vararg.  Ejemplo con una funci√≥n de extensi√≥n:\n1 2 3 4 5 6 7 8  infix fun String.concatWith(other: String): String { return this + other } fun main() { val result = \u0026#34;Hello\u0026#34; concatWith \u0026#34; World\u0026#34; println(result) // Outputs: Hello World }   Casos de uso pr√°cticos Las funciones infix son comunmente utilizadas en Kotlin para hacer el c√≥digo m√°s conciso y legible. Brillan en escenarios donde las operaciones intuitivas son necesarias, como cuando se trabaja con colecciones, rangos o expresiones de frameworks de testing o de inyecci√≥n de dependencias. Abajo de estas l√≠neas hay algunos ejemplos de como las funciones infix pueden simplificar el c√≥digo que escribimos diariamente:\n  Mapeando claves con valores: La funci√≥n to en la librer√≠a estandar de Kotlin es una funci√≥n infix que ayuda a crear pares, normalmente se usan en los mapas.\n1 2 3 4  fun main() { val map = mapOf(\u0026#34;key1\u0026#34; to \u0026#34;value1\u0026#34;, \u0026#34;key2\u0026#34; to 42) println(map) // Outputs: {key1=value1, key2=42} }     Definiendo rangos: La funci√≥n until es una funci√≥n infix que se usa para definir rangos donde se excluye el l√≠mite superior.\n1 2 3 4 5  fun main() { for (i in 1 until 5) { println(i) // Outputs: 1, 2, 3, 4  } }     Definiendo el comportamiento de mocks: Librer√≠as tales como MockK usan funciones infix para crear configuraciones de test m√°s expresivas y legibles.\n1 2 3 4 5 6 7 8 9 10  class Calculator { fun add(a: Int, b: Int): Int = a + b } fun test() { val calculator = mockk\u0026lt;Calculator\u0026gt;() every { calculator.add(1, 2) } returns 3 println(calculator.add(1, 2)) // Outputs: 3 }     Inyecci√≥n de dependencias con Koin: Koin, un framework de inyecci√≥n de dependencias para Kotlin, usa la funci√≥n infix bind para definir las relaciones entre clases e interfaces de una manera m√°s legible y limpia.\n1 2 3 4 5 6  interface MyInterface class MyImplementation : MyInterface val appModule = module { single { MyImplementation() } bind MyInterface::class }   La funci√≥n infix bind mejora la legibilidad cuando declaras que implementaci√≥n espec√≠fica debe usarse para inyectar una interfaz.\n  Cuando usar funciones Infix Mientras las funciones infix pueden hacer el c√≥digo m√°s limpio, deben usarse con cuidado:\n La operaci√≥n es intuitiva y f√°cilmente entendible. Cuando mejoran la legibilidad y el flujo. Encajan naturalmente dentro del DSL.  Evitar las funciones infix en los siguientes casos:\n Puede llevar a una sintaxis ambigua y confusa. El prop√≥sito de la funci√≥n no est√° claro con el nombre o uso.  Conclusi√≥n Las funciones infix de Kotlin son una herramienta poderosa para crear c√≥digo m√°s expresivo y legible. Definiendo un DSL, simplificando operaciones matem√°ticas, o mejorando expresiones l√≥gicas, las funciones infix pueden hacer tu c√≥digo m√°s eleganto. De todas formas, al igual que con cualquier otra funcionalidad, debe ser usadas con cuidado para mantener la claridad del c√≥digo y evitar sobrecomplicaciones.\nIntenta incorporar funciones infix en tu pr√≥ximo proyecto de Kotlin y f√≠jate como transforma tu c√≥digo! ¬øCuales son tus funciones infix favoritas o que formas creativas tienes de usarlas?\n","description":"Kotlin avanzado - Funciones Infix","id":11,"section":"posts","tags":["kotlin","android","advanced"],"title":"Funciones Infix en Kotlin","uri":"https://carrion.dev/es/posts/kotlin-infix/"},{"content":"‚ú® Entendiendo los Kotlin Delegates: La magia detr√°s de c√≥digo m√°s limpio ‚ú® Los Kotlin delegates son una funcionalidad muy √∫til que te permite delegar el comportamiento de una propiedad o incluso una implementaci√≥n de una interfaz a otro objecto. En lugar de escribir l√≥gica repetitiva o manejar el estado directamente, puedes delegar esta responsabilidad a clases especializadas y reusables.\nComo funcionan los Delegates Delegates en Kotlin funcionan usando la palabra reservada by, que redirecciona el comportamiento de una propiedad o interfaz al objeto delegado. Para propiedades, el objeto delegado provee una implementaci√≥n personalizada de los m√©todos get y o set. Para la delegaci√≥n de interfaces, la implementaci√≥n de esa interfaz es delegada al objecto.\nEsto es un ejemplo de una propiedad delegada:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class StringDelegate { private var value: String = \u0026#34;\u0026#34; operator fun getValue(thisRef: Any?, property: kotlin.reflect.KProperty\u0026lt;*\u0026gt;): String { println(\u0026#34;Getting value for \\${property.name}\u0026#34;) return value } operator fun setValue(thisRef: Any?, property: kotlin.reflect.KProperty\u0026lt;*\u0026gt;, newValue: String) { println(\u0026#34;Setting value for \\${property.name} to \\$newValue\u0026#34;) value = newValue } } class Example { var text: String by StringDelegate() } fun main() { val example = Example() example.text = \u0026#34;Hello, Kotlin!\u0026#34; println(example.text) }   Output Setting value for text to Hello, Kotlin! Getting value for text Hello, Kotlin! En este ejemplo:\n La clase StringDelegate define un comportamiento personalizado del acceso a la propiedad usando los operadores getValuey setValue. La propiedad text en la clase Exampledelega su comportamiento a la instancia de StringDelegate.  Aplicaciones reales de Kotlin Delegates 1Ô∏è‚É£ Inyecci√≥n de dependencias con Koin En #Koin, puedes usar el delegado by inject() para inyectar dependencias directamente en tus clases. Esto elimina la necesidad de instanciar manualmente:\n1 2 3 4 5 6 7 8 9 10  class DelegatesFragment : Fragment() { private val tracker: AnalyticsTracker by inject() } inline fun \u0026lt;reified T : Any\u0026gt; KoinComponent.inject( qualifier: Qualifier? = null, mode: LazyThreadSafetyMode = KoinPlatformTools.defaultLazyMode(), noinline parameters: ParametersDefinition? = null, ): Lazy\u0026lt;T\u0026gt; = lazy(mode) { get\u0026lt;T\u0026gt;(qualifier, parameters) }   El delegado by inject() autom√°ticamente resuelve la dependencia usando el contenedor de Koin. Esto abstrae la l√≥gica, resultando en c√≥digo m√°s limpio y testeable.\n2Ô∏è‚É£ Manejo de estados en Jetpack Compose En Jetpack Compose, la funci√≥n remember junto con mutableStateOf es un gran ejemplo de delegaci√≥n. Esto ayuda a manejar el estado de forma eficiente dentro de los composables:\n1 2 3 4 5 6 7 8 9 10 11  @Composable fun Counter() { var count by remember { mutableStateOf(0) } Column { Text(\u0026#34;Count: $count\u0026#34;) Button(onClick = { count++ }) { Text(\u0026#34;Increment\u0026#34;) } } }   3Ô∏è‚É£ Inicializaci√≥n Lazy El delegado lazy es perfecto para propiedades que necesitan ser inicializadas solo cuando se acceden por primera vez:\n1 2 3 4 5 6 7 8 9  val greeting: String by lazy { println(\u0026#34;Initializing...\u0026#34;) \u0026#34;Hello, Kotlin!\u0026#34; } fun main() { println(greeting) // Initializes here  println(greeting) // Uses cached value }   Output Initializing... Hello, Kotlin! Hello, Kotlin! 4Ô∏è‚É£ Delegaci√≥n de interfaces Kotlin permite delegar la implementaci√≥n de una interfaz a otro objeto.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  interface Logger { fun log(message: String) } class ConsoleLogger : Logger { override fun log(message: String) { println(\u0026#34;Log: $message\u0026#34;) } } class FileLogger : Logger { override fun log(message: String) { println(\u0026#34;Writing log to file: $message\u0026#34;) } } class Application(logger: Logger) : Logger by logger fun main() { val consoleApp = Application(ConsoleLogger()) consoleApp.log(\u0026#34;Starting console application\u0026#34;) val fileApp = Application(FileLogger()) fileApp.log(\u0026#34;Starting file application\u0026#34;) }   Output Log: Starting console application Writing log to file: Starting file application Esto es lo que est√° pasando:\n La clase Application no tiene que implementar los m√©todos Logger de forma directa. En su lugar, delega la implementaci√≥n de Logger al objeto pasado por constructor usando by. Esto hace m√°s sencillo cambiar las implementaciones sin necesidad de cambiar la clase Application.  Por qu√© usar Kotlin Delegates? Los Delegates encapsulan la l√≥gica que de otra manera cargar√≠an y desordenar√≠an tus clases. Ayudan a:\n Simplificar el c√≥digo al reutilizar l√≥gica, por ejemplo con la inicializaci√≥n lazy. Abstraen patrones repetitivos, por ejemplo con la inyecci√≥n de dependencias con #koin. Mejoran el manejo de los estados con la funci√≥n mutableStateOf de Compose. Provee implementaciones modulares y reutilizables de interfaces.  Conclusion El mecanismo de los delegados en Kotlin es un ejemplo de como este lenguaje combina simplicidad con funcionalidad. Los delegados est√°n en todas partes en el desarrollo de Kotlin. En qu√© otros casos los utilizas en tus proyectos?\n","description":"Kotlin avanzado - Delegates","id":12,"section":"posts","tags":["kotlin","android","advanced"],"title":"Kotlin Delegates","uri":"https://carrion.dev/es/posts/kotlin-delegates/"},{"content":"Kotlin Avanzado - Contracts: C√≥mo volver al compilador de Kotlin m√°s inteligente Kotlin nunca deja de impresionarme con sus funcionalidades. Una funci√≥n avanzada pero poco utilizada en el arsenal de Kotlin son los Contracts. Los contratos te permiten guiar al compilador de Kotlin para que tome mejores decisiones acerca de tu c√≥digo, resultando en mejor seguridad ante nulos, mejor rendimiento o incluso menores errores en tiempo de ejecuci√≥n.\nQu√© son los contratos de Kotlin? Los contratos de Kotlin te permiten definir reglas acerca de como se comporta tu c√≥digo, ayudando al compilador a hacer un an√°lisis est√°tico m√°s avanzado. Los contratos habilitan funcionalidades como smart-casts y comprobaciones teniendo en cuenta el contexto, superando las capacidades b√°sicas de Kotlin.\nPor qu√© usar contratos?  Mejora la seguridad ante nulos: Elimina las comprobaciones de nulos redundantes ayudando al compilador a saber cuando algo est√° garantizado que no sea nulo. Smart-casts optimizados: Hace que el compilador conozca el tipo de las variables en casos espec√≠ficos. Reduce la repetic√≥n de c√≥digo: Escribe c√≥digo m√°s limpio e intuitivo delegando las comprobaciones repetitivas al compilador.  Ejemplos de contratos en Kotlin 1. Simplificar las comprobaciones de nuloss Vamos a crear una funci√≥n para validar valores no nulos:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @OptIn(ExperimentalContracts::class) inline fun \u0026lt;T\u0026gt; requireNotNull(value: T?, message: String): T { contract { returns() implies (value != null) } if (value == null) { throw IllegalArgumentException(message) } return value } fun processName(name: String?) { val nonNullName = requireNotNull(name, \u0026#34;Name cannot be null\u0026#34;) // No need for additional null checks; compiler knows \u0026#39;nonNullName\u0026#39; is not null!  println(\u0026#34;Processing name: $nonNullName\u0026#34;) } fun main() { processName(\u0026#34;John\u0026#34;) // Works fine  // processName(null) // Throws an IllegalArgumentException }   C√≥mo los contratos nos ayudan aqu√≠?  La parte del contrato returns() implies (value != null) le dice al compilador:  Si la funci√≥n retorna de forma satisfactoria, entonces value est√° garantizado que no es nulo.\n  Esto habilita smart-casts, de manera que no tienes que volver a comprobar si es nulo manualmente una vez llamada esta funci√≥n.  Algo muy similar se hace en las funciones require y requireNotNull de la librer√≠a estandar de Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  /** * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false. * * @sample samples.misc.Preconditions.failRequireWithLazyMessage */ @kotlin.internal.InlineOnly public inline fun require(value: Boolean, lazyMessage: () -\u0026gt; Any): Unit { contract { returns() implies value } if (!value) { val message = lazyMessage() throw IllegalArgumentException(message.toString()) } } /** * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise * returns the not null value. * * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage */ @kotlin.internal.InlineOnly public inline fun \u0026lt;T : Any\u0026gt; requireNotNull(value: T?, lazyMessage: () -\u0026gt; Any): T { contract { returns() implies (value != null) } if (value == null) { val message = lazyMessage() throw IllegalArgumentException(message.toString()) } else { return value } }   2. Afirmaciones personalizadas Aqu√≠ se ve como los contratos pueden ser usados para definir afirmaciones personalizadas:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @OptIn(ExperimentalContracts::class) fun assertValidState(condition: Boolean, message: String) { contract { returns() implies condition } if (!condition) { throw IllegalStateException(message) } } fun performOperation(state: Boolean) { val state: Any? = \u0026#34;Hello\u0026#34; assertValidState(state is String, \u0026#34;Is String\u0026#34;) // Here the compiler knows that the state val is of type String so no need to other cast checks  println(\u0026#34;String length: ${assertion.length}\u0026#34;) } fun main() { performOperation(true) // Prints success  // performOperation(false) // Throws IllegalStateException }   3. Smart-Casts con condiciones personalizadas Vamos a crear una funcionalidad custom que comprueba si una valor coincide con un tipo espec√≠fico. Esto demostrar√° como los contratos pueden ayudar a mejorar las comprobaciones:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  @OptIn(ExperimentalContracts::class) inline fun \u0026lt;reified T\u0026gt; isOfType(value: Any?): Boolean { contract { returns(true) implies (value is T) } return value is T } fun main() { val input: Any? = \u0026#34;Hello, Kotlin!\u0026#34; if (isOfType\u0026lt;String\u0026gt;(input)) { println(\u0026#34;String length: ${input.length}\u0026#34;) } val inputInt: Any? = 10 if (isOfType\u0026lt;Int\u0026gt;(inputInt)) { println(\u0026#34;The value is an integer ${input.toUInt()}\u0026#34;) } }   Con esta implementaci√≥n, el compilador sabe que dentro del bloque if, input es un String, gracias al contrato definido en isOfType. The la misma manera, el compilador sabe que inputInt es de tipo Int y no hace falta comprobar el tipo de nuevo.\n4. Optimizando el control del flujo Los contratos pueden simplificar el control del flujo habilitando al compilador para entender las invariantes o condiciones. Por ejemplo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  inline fun isNotEmpty(list: List\u0026lt;*\u0026gt;?): Boolean { contract { returns(true) implies (list != null \u0026amp;\u0026amp; list.isNotEmpty()) } return list != null \u0026amp;\u0026amp; list.isNotEmpty() } fun processItems(items: List\u0026lt;String\u0026gt;?) { if (isNotEmpty(items)) { // Compiler knows items is non-null and not empty  println(\u0026#34;Processing ${items.size}items\u0026#34;) } else { println(\u0026#34;No items to process\u0026#34;) } } fun main() { processItems(listOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;)) processItems(null) processItems(emptyList()) }   Salida Processing 3 items No items to process No items to process Cuando usar contratos Los contratos son ideales para:\n Desarrollo de librer√≠as: Proteger APIs p√∫blicas forzando condiciones pre existentes. DSLs y Frameworks: Simplificando la comprobaci√≥n de tipos y validaci√≥n de estados en DSLs de Kotlin. Optimizaciones en tiempo de ejecuci√≥n: Reduce las comprobaciones en tiempo de ejecuci√≥n al permitir al compilador inferir las condiciones en tiempo de compilaci√≥n.  Conclusion Los contratos de Kotlin son una gema oculta que pueden perfeccionar tu c√≥digo mejorando la seguridad, reduciendo la repetici√≥n de c√≥digo, y permitiendo un an√°lisis por parte del compilador m√°s inteligente. Tanto si est√°s creando librer√≠as, escribiendo complejos DSLs, o simplemente optimizando c√≥digo del d√≠a a d√≠a, los contratos proveen una herramienta muy poderosa para guiar al compilador de Kotlin y asegurando un c√≥digo correcto.\nTener en cuenta que los contratos est√°n anotados como funcionalidad experimental pero est√°n implementados en Kotlin desde la versi√≥n 1.3 y se usan extensamente en la librer√≠a estandar de Kotlin as√≠ que son lo suficiente estables como para utilizarlos.\n","description":"Kotlin avanzado - Contracts","id":13,"section":"posts","tags":["kotlin","android","advanced"],"title":"Kotlin contracts","uri":"https://carrion.dev/es/posts/kotlin-contracts/"},{"content":"Exportar a Swift en KMP Empezando con la versi√≥n 2.1.0 podemos empezar a probar a exportar a Swift en Kotlin. Esta funcionalidad te permite exportar los m√≥dulos compartidos de Kotlin a Swift sin usar Objective-C. Esto mejorar√° la experiancia de los desarrolladores de iOS cuando usen m√≥dulos de KMP.\nActualmente el soporte b√°sico incluye:\n Exportar m√∫ltiples m√≥dulos de Gradle a swift. Definir los nombres de los m√≥dulos swift. Simplificar la estructura de paquetes.  Activar la funcionalidad Para empezar a probar esta funcionalidad debes activarla en el fichero gradle.properties:\nkotlin.experimental.swift-export.enabled=true Configuraci√≥n Despu√©s de a√±adir la l√≠nea mostrada arriba necesitas a√±adir esta configuraci√≥n al fichero build.gradle.kts:\n1 2 3 4 5 6 7 8 9 10 11  kotlin { iosX64() iosArm64() iosSimulatorArm64() @OptIn(ExperimentalSwiftExportDsl::class) swiftExport { moduleName = \u0026#34;shared\u0026#34; flattenPackage = \u0026#34;dev.carrion.kmpswiftexport\u0026#34; } }   El siguiente paso es configurar xcode para lanzar la nueva tarea embedSwiftExportForXcode en lugar de embedAndSignAppleFrameworkForXcode. Puedes realizar este cambio desde la configuraci√≥n de Build phases de la iosApp desde xcode o bien desde Android Studio modificando el fichero project.pbxproj.\nDebes cambiar esta l√≠nea:\nshellScript = \u0026quot;cd \\\u0026quot;$SRCROOT/..\\\u0026quot;\\n./gradlew :shared:embedAndSignAppleFrameworkForXcode\\n\u0026quot;; Por esta otra:\nshellScript = \u0026quot;cd \\\u0026quot;$SRCROOT/..\\\u0026quot;\\n./gradlew :shared:embedSwiftExportForXcode\\n\u0026quot;; Despu√©s de aplicar estos cambios deber√≠as ser capaz de lanzar la aplicaci√≥n de iOS desde Android Studio o desde xcode sin ning√∫n problema.\nAntes de activar la funcionalidad Si intentas navegar a la definici√≥n de una funci√≥n de Kotlin desde xcode en un archivo swift, se mostrar√° el c√≥digo Objective-C que se exporta del m√≥dulo compartido de Kotlin. Este fichero generado es enorme teniendo en cuenta la complejidad del projecto usado para este ejemplo.\nTe voy a mostrar a continuaci√≥n una peque√±a pieza del archivo de 175 l√≠neas generado desde el c√≥digo de Kotlin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;Greeting\u0026#34;))) @interface SharedGreeting : SharedBase - (instancetype)init __attribute__((swift_name(\u0026#34;init()\u0026#34;))) __attribute__((objc_designated_initializer)); + (instancetype)new __attribute__((availability(swift, unavailable, message=\u0026#34;use object initializers instead\u0026#34;))); - (NSString *)greet __attribute__((swift_name(\u0026#34;greet()\u0026#34;))); @end __attribute__((swift_name(\u0026#34;Platform\u0026#34;))) @protocol SharedPlatform @required @property (readonly) NSString *name __attribute__((swift_name(\u0026#34;name\u0026#34;))); @end __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;IOSPlatform\u0026#34;))) @interface SharedIOSPlatform : SharedBase \u0026lt;SharedPlatform\u0026gt; - (instancetype)init __attribute__((swift_name(\u0026#34;init()\u0026#34;))) __attribute__((objc_designated_initializer)); + (instancetype)new __attribute__((availability(swift, unavailable, message=\u0026#34;use object initializers instead\u0026#34;))); @property (readonly) NSString *name __attribute__((swift_name(\u0026#34;name\u0026#34;))); @end __attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\u0026#34;Platform_iosKt\u0026#34;))) @interface SharedPlatform_iosKt : SharedBase + (id\u0026lt;SharedPlatform\u0026gt;)getPlatform __attribute__((swift_name(\u0026#34;getPlatform()\u0026#34;))); @end #pragma pop_macro(\u0026#34;_Nullable_result\u0026#34;) #pragma clang diagnostic pop NS_ASSUME_NONNULL_END   After enabling the feature Cuando activas al funcionalidad de exportar a Swift y compilas el proyecto, al intentar navegar a la definici√≥n de una funci√≥n del c√≥digo compartido de Kotlin, xcode te mostrar√° el c√≥digo exportado de Swift.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  @_exported import ExportedKotlinPackages @_implementationOnly import SharedBridge_shared import KotlinRuntime public typealias Greeting = ExportedKotlinPackages.dev.carrion.kmpswiftexport.Greeting public func getPlatform() -\u0026gt; Swift.Never { ExportedKotlinPackages.dev.carrion.kmpswiftexport.getPlatform() } public extension ExportedKotlinPackages.dev.carrion.kmpswiftexport { public final class Greeting : KotlinRuntime.KotlinBase { public override init() { let __kt = dev_carrion_kmpswiftexport_Greeting_init_allocate() super.init(__externalRCRef: __kt) dev_carrion_kmpswiftexport_Greeting_init_initialize__TypesOfArguments__Swift_UInt__(__kt) } public override init( __externalRCRef: Swift.UInt ) { super.init(__externalRCRef: __externalRCRef) } public func greet() -\u0026gt; Swift.String { return dev_carrion_kmpswiftexport_Greeting_greet(self.__externalRCRef()) } } public static func getPlatform() -\u0026gt; Swift.Never { fatalError() } }   El c√≥digo mostrado arriba es el fichero completo con 28 l√≠neas, una gran diferencia con las 175 l√≠neas del c√≥digo exportado en Objective-C. Tambi√©n es importante mencionar la menor complejidad y mayor legibilidad del c√≥digo swift.\nConclusion Despu√©s de probar esta nueva funcionalidad, estoy realmente impresionado con la mejora que supone para el desarrollo de iOS en los proyectos KMP. Tambi√©n me sorprende la diferencia en el c√≥digo exportado en Objective-C y swift. Estoy seguro que esta funcionalidad mejorar√° en las siguientes versiones y acercar√° la experiencia entre el desarrollo nativo y el desarrollo multiplataforma.\nPuedes encontrar el repositorio con el c√≥digo usado en este ejemplo en SwiftExport, con dos ramas, main, con la configuraci√≥n del t√≠pico iOS framework conf, y la rama swift-export con la nueva funcionalidad habilitada.\n","description":"Nueva funcionalidad en Kotlin 2.1.0, exportar directamente a swift desde Kotlin","id":14,"section":"posts","tags":["kotlin","android","kmp"],"title":"Exportar a Swift en KMP","uri":"https://carrion.dev/es/posts/swift-export/"},{"content":"Condiciones en las expresiones when en Kotlin 2.1.0 Una de las nuevas funcionalidades de Kotlin 2.1.0 es las condiciones en las expresiones when, lo que tendr√≠a varias ventajas entre las que se incluye:\n Reducir anidaciones Evita c√≥digo repetido Mejorar legibilidad  Activar la funcionalidad en Kotlin 2.1.0 Esta funcionalidad se encuentra en preview lo que es necesario activarla expl√≠citamente para poder usarla en Kotlin 2.1.0. En el fichero build.gradle.kts a√±adiremos el siguiente c√≥digo dentro del bloque de kotlin {}:\n1 2 3 4 5  kotlin { compilerOptions { freeCompilerArgs.add(\u0026#34;-Xwhen-guards\u0026#34;) } }   Uso de condicionales dentro de las ramas de la expresiones when Para este ejemplo usaremos una sealed interface para manejar respuestas de un servicio remoto:\n1 2 3 4 5  sealed interface Response\u0026lt;out T\u0026gt; { data object Loading : Response\u0026lt;Nothing\u0026gt; data class Content \u0026lt;out T\u0026gt; (val data: T?) : Response\u0026lt;T\u0026gt; data class Error(val error: Exception) : Response\u0026lt;Nothing\u0026gt; }   Esta interfaz la implementan Loading, Content y Error para gestionar los distintos estados de una respuesta.\nAntes de la nueva funcionalidad 1 2 3 4 5 6 7 8 9 10 11 12 13  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handleOld() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content -\u0026gt; if (data != null) { println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } is Response.Error -\u0026gt; if (error is IllegalStateException) { println(\u0026#34;Handled error\u0026#34;) } else { println(\u0026#34;Unknown error\u0026#34;) } }   Como se puede ver en este caso se repite el c√≥digo que muestra por pantalla Unknown error adem√°s de a√±adir anidaciones que dificultan la lectura del c√≥digo.\nUsando los nuevos condicionales Se debe a√±adir el if justo despu√©s de la condici√≥n primaria de la rama, por ejemplo:\n1 2 3 4 5 6  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled error\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   De esta manera no se repite el c√≥digo que mostraba por pantalla el texto de Unknown error y adem√°s eliminamos las anidaciones facilitando la lectura del c√≥digo.\nEn caso de necesitar comprobar varias condiciones en la rama else se podr√≠a a√±adir una rama else if que controle el flujo de los casos que no cumplen las condiciones anteriores.\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) else if this is Response.Error \u0026amp;\u0026amp; this.error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   Esto √∫ltimo se puede simplificar usando dos ramas con la misma primera condici√≥n de is Response.Error que a mi parecer queda m√°s simple:\n1 2 3 4 5 6 7  fun \u0026lt;T\u0026gt; Response\u0026lt;T\u0026gt;.handle() = when (this) { is Response.Loading -\u0026gt; println(\u0026#34;Loading\u0026#34;) is Response.Content if data != null -\u0026gt; println(\u0026#34;Content ${data::class.simpleName}\u0026#34;) is Response.Error if error is IllegalStateException -\u0026gt; println(\u0026#34;Handled IllegalState\u0026#34;) is Response.Error if error is NoSuchElementException -\u0026gt; println(\u0026#34;Handle NoSuchElement\u0026#34;) else -\u0026gt; println(\u0026#34;Unknown error\u0026#34;) }   Conclusi√≥n Con esta nueva funcionalidad se podr√° a√±adir nuevas condiciones sin tener que repetir c√≥digo y permitir√° que las expresiones when sean m√°s concisas. En la versi√≥n 2.1.0 de Kotlin est√° en modo preview pero se espera que pronto esta nueva funcionalidad sea estable.\nAqu√≠ el enlace a la documentaci√≥n con las novedades de Kotlin 2.1.0 donde se explica la funcionalidad de condicionales en las expresiones when kotlinlang\n","description":"Nueva funcionalidad en Kotlin 2.1.0, condiciones en las expresiones when","id":15,"section":"posts","tags":["kotlin","android","kmp"],"title":"Condiciones en las expresiones when para Kotlin 2.1.0.","uri":"https://carrion.dev/es/posts/kotlin-guard-conditions-in-when/"},{"content":"Inyecci√≥n de valores en tiempo de ejecuci√≥n con Dagger-Hilt Desde que apareci√≥ Hilt para facilitar la inyecci√≥n de dependencias en aplicaciones Android, no era posible la inyecci√≥n de dependencias en tiempo de ejecuci√≥n sin utilizar librer√≠as ajenas a Dagger o Hilt. Desde la versi√≥n 2.31 se incorpora en Dagger la anotaci√≥n @AssistedInject. Con esta anotaci√≥n vamos a ser capaces de indicar a Dagger-Hilt que dependencias se tienen que resolver en tiempo de ejecuci√≥n y retrasar la inyecci√≥n de esos par√°metros hasta tener los valores.\nEsto era necesario para poder inyectar valores en los constructores de los ViewModel y poder ejecutar alguna operaci√≥n en el m√©todo init del mismo. Como puede ser una petici√≥n a una API externa o bien una consulta en la base de datos local.\nEn este art√≠culo veremos como implementar el @AssistedInject de Dagger para la inyecci√≥n de valores en tiempo de ejecuci√≥n en ViewModels con Hilt.\nInstalaci√≥n En el fichero build.gradle ra√≠z del proyecto, incluiremos el siguiente classpath:\n1  classpath \u0026#39;com.google.dagger:hilt-android-gradle-plugin:2.31.2-alpha\u0026#39;   Una vez a√±adido el classpath a√±adiremos el plugin de Hilt en el fichero build.gradle del m√≥dulo app.\n1  apply plugin: \u0026#39;dagger.hilt.android.plugin\u0026#39;   Y tambi√©n las siguientes l√≠neas a nuestras dependencias:\n1 2  implementation \u0026#39;com.google.dagger:hilt-android:2.31.2-alpha\u0026#39; kapt \u0026#39;com.google.dagger:hilt-android-compiler:2.31.2-alpha\u0026#39;   Tambi√©n hay que tener en cuenta tener a√±adido en nuestro build.gradle el plugin de kapt. Para ello a√±adiremos lo siguiente a nuestro archivo de build.gradle del m√≥dulo app junto al resto de plugins:\n1  apply plugin: \u0026#39;kotlin-kapt\u0026#39;   Esa son las dependencias necesarias para implementar Hilt en nuestro proyecto. A lo largo de este post se usan distintas librer√≠as como que no se definen en este art√≠culo.\nEn este enlace puedes ver un ejemplo de un archivo build.gradle completo: app/build.gradle\nImplementaci√≥n Para este ejemplo usaremos una clase repositorio encargada de recibir el nombre de usuario y devolver un mensaje de bienvenida. Para ello crearemos la siguiente interfaz:\n1 2 3  interface UserRepository { fun getMessage(name: String): String }   Y su implementaci√≥n:\n1 2 3 4 5  class UserRepositoryImpl @Inject constructor() : UserRepository { override fun getMessage(name: String): String { return \u0026#34;Hi $name\u0026#34; } }   Anotamos el constructor con @Inject para posteriormente poder declarar un @Binds en el m√≥dulo de Hilt e inyectar la implementaci√≥n cada vez que se pida una interfaz del tipo UserRepository.\nVamos a crear el siguiente ViewModel que ser√° el encargado de recibir el nombre del usuario desde el Activity o Fragment y llamar al repositorio para recibir el mensaje de bienvenida:\n1 2 3 4 5 6 7 8 9  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { ... }   En este ViewModel podemos ver como se anota el constructor con @AssistedInject para indicar a Dagger-Hilt que esta clase contiene dependencias que se deben inyectar en tiempo de ejecuci√≥n. Esas dependencias est√°n anotadas con @Assisted.\nPara poder crear el ViewModel con la extensi√≥n by viewModels() de la librer√≠a de AndroidX debemos crear la Factory que m√°s tarde pasaremos a la extensi√≥n:\n1 2 3 4 5 6 7 8  class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } }   Como puedes ver necesitamos la interfaz UserViewModelAssistedFactory que es la encargada de proveer los par√°metros en tiempo de ejecuci√≥n. Esta interfaz la implementamos de la siguiente forma:\n1 2 3 4 5 6  @AssistedFactory interface UserViewModelAssistedFactory { fun create(name: String): UserViewModel }   Se trata de una interfaz con una funci√≥n create que recibe los par√°metros a inyectar en tiempo de ejecuci√≥n. En nuestro caso solo necesitamos el name, pero en caso de necesitar inyectar m√°s par√°metros en tiempo de ejecuci√≥n, se pasar√≠an como par√°metro a esta funci√≥n.\nCon esto ya podemos completar nuestro ViewModel con la l√≥gica necesaria para pedir la respuesta al repositorio y exponer al Fragment o Activity a trav√©s de un StateFlow.\nEl ViewModel completo quedar√≠a:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class UserViewModel @AssistedInject constructor( private val repository: UserRepository, @Named(\u0026#34;UserDispatcher\u0026#34;) private val dispatcher: CoroutineDispatcher, @Assisted private val name: String ) : ViewModel() { class Factory( private val assistedFactory: UserViewModelAssistedFactory, private val name: String, ) : ViewModelProvider.Factory { override fun \u0026lt;T : ViewModel?\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T { return assistedFactory.create(name) as T } } private val _message: MutableStateFlow\u0026lt;String\u0026gt; = MutableStateFlow(\u0026#34;\u0026#34;) val message: StateFlow\u0026lt;String\u0026gt; get() = _message init { viewModelScope.launch(dispatcher) { _message.emit(repository.getMessage(name)) } } }   Relativo a Hilt solo nos faltar√≠a declarar el m√≥dulo indicando como proveer las dependencias. Para este ejemplo usaremos el siguiente m√≥dulo:\n1 2 3 4 5 6 7 8 9 10 11 12 13  @Module @InstallIn(ActivityComponent::class) abstract class MainModule { companion object { @Provides @Named(\u0026#34;UserDispatcher\u0026#34;) fun provideUserDispatcher(): CoroutineDispatcher = Dispatchers.IO } @Binds abstract fun provideUserRepository(repositoryImpl: UserRepositoryImpl): UserRepository }   En este m√≥dulo declaramos un Dispatcher para que sea m√°s sencillo testear este ViewModel en un futuro. Y hacemos @Binds de nuestra interfaz UserRepository con su implementaci√≥n UserRepositoryImpl.\nAhora podemos inyectar nuestro repositorio en una Activity o Fragment de la siguiente forma:\n1 2 3 4 5 6 7 8  private val navArgs: UserFragmentArgs by navArgs() @Inject lateinit var assistedFactory: UserViewModelAssistedFactory private val userViewModel: UserViewModel by viewModels { UserViewModel.Factory(assistedFactory, navArgs.name) }   Simplemente nos faltar√≠a observar los cambios en el StateFlow del ViewModel para poder actualizar nuestra UI. Eso se har√≠a de la siguiente manera en un Fragment aunque ser√≠a muy similar en un Activity\n1 2 3 4 5 6 7 8  override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycleScope.launchWhenStarted { userViewModel.message.collect { binding.name.text = it } } }    Recordar que es necesario anotar una clase que extienda de Application con @HiltAndroidApp y cada uno de las Activities o Fragments que usen inyecci√≥n con Hilt con la anotaci√≥n @AndroidEntryPoint.\n Conclusi√≥n Como hemos podido observar con @AssistedInject de Dagger podemos inyectar valores en tiempo de ejecuci√≥n de una forma sencilla y podemos seguir utilizando los navArgs de AndroidX.\nEn el siguiente repositorio teneis el ejemplo completo: HiltAssistedInject\n","description":"Como inyectar valores en tiempo de ejecuci√≥n a los ViewModel en Android.","id":16,"section":"posts","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Hilt: Inyectar valores al ViewModel en tiempo de ejecuci√≥n.","uri":"https://carrion.dev/es/posts/hilt-inject-parameters-runtime/"},{"content":"Bienvenido a Carrion.dev Saludos Androide!!\nBienvenido a mi nuevo blog de Kotlin y programaci√≥n Android. Me llamo Ignacio Carri√≥n y soy dessarrollador Android. Me encanta el lenguaje Kotlin por las facilidades que me aporta al programar para Android y las infinitas posibilidades que ofrece en otros √°mbitos (backend, web, nativo, multiplataforma).\nEn este blog espero poder publicar cosas interesantes acerca del lenguaje Kotlin y el ecosistema Android al menos cada dos semanas. Si quieres mantenerte al d√≠a no dudes en apuntarte a nuestra newsletter.\nSi tienes alguna duda, idea acerca de la que podemos hablar en un post o simplemente quieres contactar estoy disponible a trav√©s del correo: ignacio@carrion.dev.\nEspero que aprendamos mucho todos juntos!!\n","description":"Primer post en mi nuevo blog de Kotlin y Android.","id":17,"section":"posts","tags":["kotlin","android","jetpack","coroutines","androidx"],"title":"Bienvenido a mi nuevo blog sobre Kotlin y desarrollo Android","uri":"https://carrion.dev/es/posts/welcome-to-my-new-kotlin-and-android-development-blog/"},{"content":"Sobre mi. Me llamo Ignacio Carri√≥n, vivo en Valencia (Espa√±a) y el que aparece en la foto es mi perro Wilfred. Me gusta cualquier cosa relacionada con la inform√°tica y los videojuegos. Actualmente trabajo como Senior Android Engineer para Tkww. Anteriormente he trabajado en otras empresas como desarrollador Android y tambi√©n he impartido clases de programaci√≥n. A raiz de mi trabajo como profesor me d√≠ cuenta de que realmente me encanta aprender y que la gente aprenda conmigo. De esa motivaci√≥n surge la idea de crear este blog, Carrion.dev.\nEspero poder ir publicando de forma as√≠dua cosas interesantes acerca del lenguaje Kotlin y el ecosistema Android. Cualquier cr√≠tica constructiva e ideas acerca de posibles temas para art√≠culos ser√°n bien recibidas. Abajo aparecen los enlaces a las redes sociales en las que podr√°s encontrarme y contactar conmigo.\nContactar Portfolio\nGithub\n","description":"Ignacio Carri√≥n, Desarrollador Android","id":22,"section":"","tags":null,"title":"Sobre mi","uri":"https://carrion.dev/es/about/"}]